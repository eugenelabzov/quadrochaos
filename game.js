(function() {
    var VMathArrayConstructor = Array;
    if (typeof Float32Array !== "undefined" && Float32Array.prototype !== undefined && Float32Array.prototype.slice === undefined) {
        Float32Array.prototype.slice = function Float32ArraySlice(s, e) {
            var length = this.length;
            if (s === undefined) {
                s = 0
            } else if (s < 0) {
                s += length
            }
            if (e === undefined) {
                e = length
            } else if (e < 0) {
                e += length
            }
            length = e - s;
            if (0 < length) {
                var dst = new Float32Array(length);
                var n = 0;
                do {
                    dst[n] = this[s];
                    n += 1;
                    s += 1
                } while (s < e);
                return dst
            } else {
                return new Float32Array(0)
            }
        }
    }
    var VMath = {
        version: 1,
        precision: 1e-6,
        FLOAT_MAX: 3.402823466e38,
        select: function selectFn(m, a, b) {
            if (m) {
                return a
            } else {
                return b
            }
        },
        reciprocal: function reciprocalFn(a) {
            if (a !== 0) {
                return 1 / a
            } else {
                throw "Division by zero"
            }
        },
        truncate: function truncateFn(value) {
            return value | 0
        },
        v2BuildZero: function v2BuildZeroFn(dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(2)
            }
            dst[0] = 0;
            dst[1] = 0;
            return dst
        },
        v2BuildOne: function v2BuildOneFn(dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(2)
            }
            dst[0] = 1;
            dst[1] = 1;
            return dst
        },
        v2BuildXAxis: function v2BuildXAxisFn(dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(2)
            }
            dst[0] = 1;
            dst[1] = 0;
            return dst
        },
        v2BuildYAxis: function v2BuildYAxisFn(dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(2)
            }
            dst[0] = 0;
            dst[1] = 1;
            return dst
        },
        v2Build: function v2Fn(a, b, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(2)
            }
            dst[0] = a;
            dst[1] = b;
            return dst
        },
        v2Copy: function v2CopyFn(src, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(2)
            }
            dst[0] = src[0];
            dst[1] = src[1];
            return dst
        },
        v2Set: function v2SetFn(v, a) {
            v[0] = a[0];
            v[1] = a[1]
        },
        v2Neg: function v2NegFn(a, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(2)
            }
            dst[0] = -a[0];
            dst[1] = -a[1];
            return dst
        },
        v2Add: function v2AddFn(a, b, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(2)
            }
            dst[0] = a[0] + b[0];
            dst[1] = a[1] + b[1];
            return dst
        },
        v2Add3: function v2Add3Fn(a, b, c, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(2)
            }
            dst[0] = a[0] + b[0] + c[0];
            dst[1] = a[1] + b[1] + c[1];
            return dst
        },
        v2Add4: function v2Add4Fn(a, b, c, d, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(2)
            }
            dst[0] = a[0] + b[0] + c[0] + d[0];
            dst[1] = a[1] + b[1] + c[1] + d[1];
            return dst
        },
        v2Sub: function v2SubFn(a, b, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(2)
            }
            dst[0] = a[0] - b[0];
            dst[1] = a[1] - b[1];
            return dst
        },
        v2Mul: function v2MulFn(a, b, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(2)
            }
            dst[0] = a[0] * b[0];
            dst[1] = a[1] * b[1];
            return dst
        },
        v2MulAdd: function v2MulAddFn(a, b, c, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(2)
            }
            dst[0] = a[0] * b[0] + c[0];
            dst[1] = a[1] * b[1] + c[1];
            return dst
        },
        v2Dot: function v2DotFn(a, b) {
            return a[0] * b[0] + a[1] * b[1]
        },
        v2PerpDot: function v2PerpDot(a, b) {
            return a[0] * b[1] - a[1] * b[0]
        },
        v2LengthSq: function v2LengthSqFn(a) {
            var a0 = a[0];
            var a1 = a[1];
            return a0 * a0 + a1 * a1
        },
        v2Length: function v2LengthFn(a) {
            var a0 = a[0];
            var a1 = a[1];
            return Math.sqrt(a0 * a0 + a1 * a1)
        },
        v2Reciprocal: function v2ReciprocalFn(a, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(2)
            }
            var rcp = VMath.reciprocal;
            dst[0] = rcp(a[0]);
            dst[1] = rcp(a[1]);
            return dst
        },
        v2Normalize: function v2NormalizeFn(a, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(2)
            }
            var a0 = a[0];
            var a1 = a[1];
            var lsq = a0 * a0 + a1 * a1;
            if (lsq > 0) {
                var lr = 1 / Math.sqrt(lsq);
                dst[0] = a0 * lr;
                dst[1] = a1 * lr
            } else {
                dst[0] = 0;
                dst[1] = 0
            }
            return dst
        },
        v2Abs: function v2AbsFn(a, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(2)
            }
            var abs = Math.abs;
            dst[0] = abs(a[0]);
            dst[1] = abs(a[1]);
            return dst
        },
        v2Max: function v2MaxFn(a, b, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(2)
            }
            var max = Math.max;
            dst[0] = max(a[0], b[0]);
            dst[1] = max(a[1], b[1]);
            return dst
        },
        v2Min: function v2MinFn(a, b, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(2)
            }
            var min = Math.min;
            dst[0] = min(a[0], b[0]);
            dst[1] = min(a[1], b[1]);
            return dst
        },
        v2Equal: function v2EqualFn(a, b, precision) {
            var abs = Math.abs;
            if (precision === undefined) {
                precision = this.precision
            }
            return abs(a[0] - b[0]) <= precision && abs(a[1] - b[1]) <= precision
        },
        v2MaskEqual: function v2MaskEqualFn(a, b) {
            var abs = Math.abs;
            var precision = VMath.precision;
            return [abs(a[0] - b[0]) <= precision, abs(a[1] - b[1]) <= precision]
        },
        v2MaskLess: function v2MaskLessFn(a, b) {
            return [a[0] < b[0], a[1] < b[1]]
        },
        v2MaskGreater: function v2MaskGreaterFn(a, b) {
            return [a[0] > b[0], a[1] > b[1]]
        },
        v2MaskGreaterEq: function v2MaskGreaterEqFn(a, b) {
            return [a[0] >= b[0], a[1] >= b[1]]
        },
        v2MaskNot: function v2MaskNotFn(a) {
            return [!a[0], !a[1]]
        },
        v2MaskOr: function v2MaskOrFn(a, b) {
            return [a[0] || b[0], a[1] || b[1]]
        },
        v2MaskAnd: function v2MaskAndFn(a, b) {
            return [a[0] && b[0], a[1] && b[1]]
        },
        v2Select: function v2SelectFn(m, a, b, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(2)
            }
            dst[0] = m[0] ? a[0] : b[0];
            dst[1] = m[1] ? a[1] : b[1];
            return dst
        },
        v2ScalarBuild: function v2ScalarBuildFn(a, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(2)
            }
            dst[0] = a;
            dst[1] = a;
            return dst
        },
        v2ScalarMax: function v2ScalarMaxFn(a, b, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(2)
            }
            var max = Math.max;
            dst[0] = max(a[0], b);
            dst[1] = max(a[1], b);
            return dst
        },
        v2ScalarMin: function v2ScalarMinFn(a, b, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(2)
            }
            var min = Math.min;
            dst[0] = min(a[0], b);
            dst[1] = min(a[1], b);
            return dst
        },
        v2ScalarAdd: function v2ScalarAddFn(a, b, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(2)
            }
            dst[0] = a[0] + b;
            dst[1] = a[1] + b;
            return dst
        },
        v2ScalarSub: function v2ScalarSubFn(a, b, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(2)
            }
            dst[0] = a[0] - b;
            dst[1] = a[1] - b;
            return dst
        },
        v2ScalarMul: function v2ScalarMulFn(a, b, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(2)
            }
            if (b === 0) {
                dst[0] = 0;
                dst[1] = 0
            } else {
                dst[0] = a[0] * b;
                dst[1] = a[1] * b
            }
            return dst
        },
        v2AddScalarMul: function v2AddScalarMulFn(a, b, c, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(2)
            }
            dst[0] = a[0] + b[0] * c;
            dst[1] = a[1] + b[1] * c;
            return dst
        },
        v2EqualScalarMask: function v2EqualScalarMaskFn(a, b) {
            var abs = Math.abs;
            var precision = VMath.precision;
            return [abs(a[0] - b) <= precision, abs(a[1] - b) <= precision]
        },
        v2LessScalarMask: function v2LessScalarMaskFn(a, b) {
            return [a[0] < b, a[1] < b]
        },
        v2GreaterScalarMask: function v2GreaterScalarMaskFn(a, b) {
            return [a[0] > b, a[1] > b]
        },
        v2GreaterEqScalarMask: function v2GreaterEqScalarMaskFn(a, b) {
            return [a[0] >= b, a[1] >= b]
        },
        v2Lerp: function v2LerpFn(a, b, t, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(2)
            }
            dst[0] = a[0] + (b[0] - a[0]) * t;
            dst[1] = a[1] + (b[1] - a[1]) * t;
            return dst
        },
        v3BuildZero: function v3BuildZeroFn(dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(3)
            }
            res[0] = 0;
            res[1] = 0;
            res[2] = 0;
            return res
        },
        v3BuildOne: function v3BuildOneFn(dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(3)
            }
            res[0] = 1;
            res[1] = 1;
            res[2] = 1;
            return res
        },
        v3BuildXAxis: function v3BuildXAxisFn(dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(3)
            }
            res[0] = 1;
            res[1] = 0;
            res[2] = 0;
            return res
        },
        v3BuildYAxis: function v3BuildYAxisFn(dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(3)
            }
            res[0] = 0;
            res[1] = 1;
            res[2] = 0;
            return res
        },
        v3BuildZAxis: function v3BuildZAxisFn(dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(3)
            }
            res[0] = 0;
            res[1] = 0;
            res[2] = 1;
            return res
        },
        v3Build: function v3Fn(a, b, c, dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(3)
            }
            res[0] = a;
            res[1] = b;
            res[2] = c;
            return res
        },
        v3Copy: function v3CopyFn(src, dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(3)
            }
            res[0] = src[0];
            res[1] = src[1];
            res[2] = src[2];
            return res
        },
        v3Set: function v3SetFn(v, a) {
            v[0] = a[0];
            v[1] = a[1];
            v[2] = a[2]
        },
        v3Neg: function v3NegFn(a, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(3)
            }
            dst[0] = -a[0];
            dst[1] = -a[1];
            dst[2] = -a[2];
            return dst
        },
        v3Add: function v3AddFn(a, b, dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(3)
            }
            res[0] = a[0] + b[0];
            res[1] = a[1] + b[1];
            res[2] = a[2] + b[2];
            return res
        },
        v3Add3: function v3Add3Fn(a, b, c, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(3)
            }
            dst[0] = a[0] + b[0] + c[0];
            dst[1] = a[1] + b[1] + c[1];
            dst[2] = a[2] + b[2] + c[2];
            return dst
        },
        v3Add4: function v3Add4Fn(a, b, c, d, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(3)
            }
            dst[0] = a[0] + b[0] + c[0] + d[0];
            dst[1] = a[1] + b[1] + c[1] + d[1];
            dst[2] = a[2] + b[2] + c[2] + d[2];
            return dst
        },
        v3Sub: function v3SubFn(a, b, dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(3)
            }
            res[0] = a[0] - b[0];
            res[1] = a[1] - b[1];
            res[2] = a[2] - b[2];
            return res
        },
        v3Mul: function v3MulFn(a, b, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(3)
            }
            dst[0] = a[0] * b[0];
            dst[1] = a[1] * b[1];
            dst[2] = a[2] * b[2];
            return dst
        },
        v3MulAdd: function v3MulAddFn(a, b, c, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(3)
            }
            dst[0] = a[0] * b[0] + c[0];
            dst[1] = a[1] * b[1] + c[1];
            dst[2] = a[2] * b[2] + c[2];
            return dst
        },
        v3Dot: function v3DotFn(a, b) {
            return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]
        },
        v3Cross: function v3CrossFn(a, b, dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(3)
            }
            var a0 = a[0];
            var a1 = a[1];
            var a2 = a[2];
            var b0 = b[0];
            var b1 = b[1];
            var b2 = b[2];
            res[0] = a1 * b2 - a2 * b1;
            res[1] = a2 * b0 - a0 * b2;
            res[2] = a0 * b1 - a1 * b0;
            return res
        },
        v3LengthSq: function v3LengthSqFn(a) {
            var a0 = a[0];
            var a1 = a[1];
            var a2 = a[2];
            return a0 * a0 + a1 * a1 + a2 * a2
        },
        v3Length: function v3LengthFn(a) {
            var a0 = a[0];
            var a1 = a[1];
            var a2 = a[2];
            return Math.sqrt(a0 * a0 + a1 * a1 + a2 * a2)
        },
        v3Reciprocal: function v3ReciprocalFn(a, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(3)
            }
            var rcp = VMath.reciprocal;
            dst[0] = rcp(a[0]);
            dst[1] = rcp(a[1]);
            dst[2] = rcp(a[2]);
            return dst
        },
        v3Normalize: function v3NormalizeFn(a, dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(3)
            }
            var a0 = a[0];
            var a1 = a[1];
            var a2 = a[2];
            var lsq = a0 * a0 + a1 * a1 + a2 * a2;
            if (lsq > 0) {
                var lr = 1 / Math.sqrt(lsq);
                res[0] = a0 * lr;
                res[1] = a1 * lr;
                res[2] = a2 * lr
            } else {
                res[0] = 0;
                res[1] = 0;
                res[2] = 0
            }
            return res
        },
        v3Abs: function v3AbsFn(a, dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(3)
            }
            var abs = Math.abs;
            res[0] = abs(a[0]);
            res[1] = abs(a[1]);
            res[2] = abs(a[2]);
            return res
        },
        v3Max: function v3MaxFn(a, b, dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(3)
            }
            var max = Math.max;
            res[0] = max(a[0], b[0]);
            res[1] = max(a[1], b[1]);
            res[2] = max(a[2], b[2]);
            return res
        },
        v3Min: function v3MinFn(a, b, dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(3)
            }
            var min = Math.min;
            res[0] = min(a[0], b[0]);
            res[1] = min(a[1], b[1]);
            res[2] = min(a[2], b[2]);
            return res
        },
        v3Equal: function v3EqualFn(a, b, precision) {
            var abs = Math.abs;
            if (precision === undefined) {
                precision = this.precision
            }
            return abs(a[0] - b[0]) <= precision && abs(a[1] - b[1]) <= precision && abs(a[2] - b[2]) <= precision
        },
        v3MaskEqual: function v3MaskEqualFn(a, b) {
            var abs = Math.abs;
            var precision = VMath.precision;
            return [abs(a[0] - b[0]) <= precision, abs(a[1] - b[1]) <= precision, abs(a[2] - b[2]) <= precision]
        },
        v3MaskLess: function v3MaskLessFn(a, b) {
            return [a[0] < b[0], a[1] < b[1], a[2] < b[2]]
        },
        v3MaskGreater: function v3MaskGreaterFn(a, b) {
            return [a[0] > b[0], a[1] > b[1], a[2] > b[2]]
        },
        v3MaskGreaterEq: function v3MaskGreaterEqFn(a, b) {
            return [a[0] >= b[0], a[1] >= b[1], a[2] >= b[2]]
        },
        v3MaskNot: function v3MaskNotFn(a) {
            return [!a[0], !a[1], !a[2]]
        },
        v3MaskOr: function v3MaskOrFn(a, b) {
            return [a[0] || b[0], a[1] || b[1], a[2] || b[2]]
        },
        v3MaskAnd: function v3MaskAndFn(a, b) {
            return [a[0] && b[0], a[1] && b[1], a[2] && b[2]]
        },
        v3Select: function v3SelectFn(m, a, b, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(3)
            }
            dst[0] = m[0] ? a[0] : b[0];
            dst[1] = m[1] ? a[1] : b[1];
            dst[2] = m[2] ? a[2] : b[2];
            return dst
        },
        v3ScalarBuild: function v3ScalarBuildFn(a, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(3)
            }
            dst[0] = a;
            dst[1] = a;
            dst[2] = a;
            return dst
        },
        v3ScalarMax: function v3ScalarMaxFn(a, b, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(3)
            }
            var max = Math.max;
            dst[0] = max(a[0], b);
            dst[1] = max(a[1], b);
            dst[2] = max(a[2], b);
            return dst
        },
        v3ScalarMin: function v3ScalarMinFn(a, b, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(3)
            }
            var min = Math.min;
            dst[0] = min(a[0], b);
            dst[1] = min(a[1], b);
            dst[2] = min(a[2], b);
            return dst
        },
        v3ScalarAdd: function v3ScalarAddFn(a, b, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(3)
            }
            dst[0] = a[0] + b;
            dst[1] = a[1] + b;
            dst[2] = a[2] + b;
            return dst
        },
        v3ScalarSub: function v3ScalarSubFn(a, b, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(3)
            }
            dst[0] = a[0] - b;
            dst[1] = a[1] - b;
            dst[2] = a[2] - b;
            return dst
        },
        v3ScalarMul: function v3ScalarMulFn(a, b, dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(3)
            }
            if (b === 0) {
                res[0] = 0;
                res[1] = 0;
                res[2] = 0
            } else {
                res[0] = a[0] * b;
                res[1] = a[1] * b;
                res[2] = a[2] * b
            }
            return res
        },
        v3AddScalarMul: function v3AddScalarMulFn(a, b, c, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(3)
            }
            dst[0] = a[0] + b[0] * c;
            dst[1] = a[1] + b[1] * c;
            dst[2] = a[2] + b[2] * c;
            return dst
        },
        v3EqualScalarMask: function v3EqualScalarMaskFn(a, b) {
            var abs = Math.abs;
            var precision = VMath.precision;
            return [abs(a[0] - b) <= precision, abs(a[1] - b) <= precision, abs(a[2] - b) <= precision]
        },
        v3LessScalarMask: function v3LessScalarMaskFn(a, b) {
            return [a[0] < b, a[1] < b, a[2] < b]
        },
        v3GreaterScalarMask: function v3GreaterScalarMaskFn(a, b) {
            return [a[0] > b, a[1] > b, a[2] > b]
        },
        v3GreaterEqScalarMask: function v3GreaterEqScalarMaskFn(a, b) {
            return [a[0] >= b, a[1] >= b, a[2] >= b]
        },
        v3Lerp: function v3LerpFn(a, b, t, dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(3)
            }
            res[0] = a[0] + (b[0] - a[0]) * t;
            res[1] = a[1] + (b[1] - a[1]) * t;
            res[2] = a[2] + (b[2] - a[2]) * t;
            return res
        },
        v4BuildZero: function v4BuildZeroFn(dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(4)
            }
            res[0] = 0;
            res[1] = 0;
            res[2] = 0;
            res[3] = 0;
            return res
        },
        v4BuildOne: function v4BuildOneFn(dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(4)
            }
            res[0] = 1;
            res[1] = 1;
            res[2] = 1;
            res[3] = 1;
            return res
        },
        v4Build: function v4BuildFn(a, b, c, d, dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(4)
            }
            res[0] = a;
            res[1] = b;
            res[2] = c;
            res[3] = d;
            return res
        },
        v4Copy: function v4CopyFn(src, dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(4)
            }
            res[0] = src[0];
            res[1] = src[1];
            res[2] = src[2];
            res[3] = src[3];
            return res
        },
        v4Set: function v4SetFn(v, a) {
            v[0] = a[0];
            v[1] = a[1];
            v[2] = a[2];
            v[3] = a[3]
        },
        v4Neg: function v4NegFn(a, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(4)
            }
            dst[0] = -a[0];
            dst[1] = -a[1];
            dst[2] = -a[2];
            dst[3] = -a[3];
            return dst
        },
        v4Add: function v4AddFn(a, b, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(4)
            }
            dst[0] = a[0] + b[0];
            dst[1] = a[1] + b[1];
            dst[2] = a[2] + b[2];
            dst[3] = a[3] + b[3];
            return dst
        },
        v4Add3: function v4Add3Fn(a, b, c, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(4)
            }
            dst[0] = a[0] + b[0] + c[0];
            dst[1] = a[1] + b[1] + c[1];
            dst[2] = a[2] + b[2] + c[2];
            dst[3] = a[3] + b[3] + c[3];
            return dst
        },
        v4Add4: function v4Add4Fn(a, b, c, d, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(4)
            }
            dst[0] = a[0] + b[0] + c[0] + d[0];
            dst[1] = a[1] + b[1] + c[1] + d[1];
            dst[2] = a[2] + b[2] + c[2] + d[2];
            dst[3] = a[3] + b[3] + c[3] + d[3];
            return dst
        },
        v4Sub: function v4SubFn(a, b, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(4)
            }
            dst[0] = a[0] - b[0];
            dst[1] = a[1] - b[1];
            dst[2] = a[2] - b[2];
            dst[3] = a[3] - b[3];
            return dst
        },
        v4Mul: function v4MulFn(a, b, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(4)
            }
            dst[0] = a[0] * b[0];
            dst[1] = a[1] * b[1];
            dst[2] = a[2] * b[2];
            dst[3] = a[3] * b[3];
            return dst
        },
        v4MulAdd: function v4MulAddFn(a, b, c, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(4)
            }
            dst[0] = a[0] * b[0] + c[0];
            dst[1] = a[1] * b[1] + c[1];
            dst[2] = a[2] * b[2] + c[2];
            dst[3] = a[3] * b[3] + c[3];
            return dst
        },
        v4Dot: function v4DotFn(a, b) {
            return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3]
        },
        v4LengthSq: function v4LengthSqFn(a) {
            var a0 = a[0];
            var a1 = a[1];
            var a2 = a[2];
            var a3 = a[3];
            return a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3
        },
        v4Length: function v4LengthFn(a) {
            var a0 = a[0];
            var a1 = a[1];
            var a2 = a[2];
            var a3 = a[3];
            return Math.sqrt(a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3)
        },
        v4Reciprocal: function v4ReciprocalFn(a, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(4)
            }
            var rcp = VMath.reciprocal;
            dst[0] = rcp(a[0]);
            dst[1] = rcp(a[1]);
            dst[2] = rcp(a[2]);
            dst[3] = rcp(a[3]);
            return dst
        },
        v4Normalize: function v4NormalizeFn(a, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(4)
            }
            var a0 = a[0];
            var a1 = a[1];
            var a2 = a[2];
            var a3 = a[3];
            var lsq = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
            if (lsq > 0) {
                var lr = 1 / Math.sqrt(lsq);
                dst[0] = a0 * lr;
                dst[1] = a1 * lr;
                dst[2] = a2 * lr;
                dst[3] = a3 * lr
            } else {
                dst[0] = 0;
                dst[1] = 0;
                dst[2] = 0;
                dst[3] = 0
            }
            return dst
        },
        v4Abs: function v4AbsFn(a, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(4)
            }
            var abs = Math.abs;
            dst[0] = abs(a[0]);
            dst[1] = abs(a[1]);
            dst[2] = abs(a[2]);
            dst[3] = abs(a[3]);
            return dst
        },
        v4Max: function v4MaxFn(a, b, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(4)
            }
            var max = Math.max;
            dst[0] = max(a[0], b[0]);
            dst[1] = max(a[1], b[1]);
            dst[2] = max(a[2], b[2]);
            dst[3] = max(a[3], b[3]);
            return dst
        },
        v4Min: function v4MinFn(a, b, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(4)
            }
            var min = Math.min;
            dst[0] = min(a[0], b[0]);
            dst[1] = min(a[1], b[1]);
            dst[2] = min(a[2], b[2]);
            dst[3] = min(a[3], b[3]);
            return dst
        },
        v4Equal: function v4EqualFn(a, b, precision) {
            var abs = Math.abs;
            if (precision === undefined) {
                precision = this.precision
            }
            return abs(a[0] - b[0]) <= precision && abs(a[1] - b[1]) <= precision && abs(a[2] - b[2]) <= precision && abs(a[3] - b[3]) <= precision
        },
        v4MaskEqual: function v4MaskEqualFn(a, b) {
            var abs = Math.abs;
            var precision = VMath.precision;
            return [abs(a[0] - b[0]) <= precision, abs(a[1] - b[1]) <= precision, abs(a[2] - b[2]) <= precision, abs(a[3] - b[3]) <= precision]
        },
        v4MaskLess: function v4MaskLessFn(a, b) {
            return [a[0] < b[0], a[1] < b[1], a[2] < b[2], a[3] < b[3]]
        },
        v4MaskGreater: function v4MaskGreaterFn(a, b) {
            return [a[0] > b[0], a[1] > b[1], a[2] > b[2], a[3] > b[3]]
        },
        v4MaskGreaterEq: function v4MaskGreaterEqFn(a, b) {
            return [a[0] >= b[0], a[1] >= b[1], a[2] >= b[2], a[3] >= b[3]]
        },
        v4MaskNot: function v4MaskNotFn(a) {
            return [!a[0], !a[1], !a[2], !a[3]]
        },
        v4MaskOr: function v4MaskOrFn(a, b) {
            return [a[0] || b[0], a[1] || b[1], a[2] || b[2], a[3] || b[3]]
        },
        v4MaskAnd: function v4MaskAndFn(a, b) {
            return [a[0] && b[0], a[1] && b[1], a[2] && b[2], a[3] && b[3]]
        },
        v4Many: function v4ManyFn(m) {
            return m[0] || m[1] || m[2] || m[3]
        },
        v4MaskAll: function v4MaskAllFn(m) {
            return m[0] && m[1] && m[2] && m[3]
        },
        v4Select: function v4SelectFn(m, a, b, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(4)
            }
            dst[0] = m[0] ? a[0] : b[0];
            dst[1] = m[1] ? a[1] : b[1];
            dst[2] = m[2] ? a[2] : b[2];
            dst[3] = m[3] ? a[3] : b[3];
            return dst
        },
        v4ScalarBuild: function v4ScalarBuildFn(a, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(4)
            }
            dst[0] = a;
            dst[1] = a;
            dst[2] = a;
            dst[3] = a;
            return dst
        },
        v4ScalarMax: function v4ScalarMaxFn(a, b, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(4)
            }
            var max = Math.max;
            dst[0] = max(a[0], b);
            dst[1] = max(a[1], b);
            dst[2] = max(a[2], b);
            dst[3] = max(a[3], b);
            return dst
        },
        v4ScalarMin: function v4ScalarMinFn(a, b, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(4)
            }
            var min = Math.min;
            dst[0] = min(a[0], b);
            dst[1] = min(a[1], b);
            dst[2] = min(a[2], b);
            dst[3] = min(a[3], b);
            return dst
        },
        v4ScalarAdd: function v4ScalarAddFn(a, b, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(4)
            }
            dst[0] = a[0] + b;
            dst[1] = a[1] + b;
            dst[2] = a[2] + b;
            dst[3] = a[3] + b;
            return dst
        },
        v4ScalarSub: function v4ScalarSubFn(a, b, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(4)
            }
            dst[0] = a[0] - b;
            dst[1] = a[1] - b;
            dst[2] = a[2] - b;
            dst[3] = a[3] - b;
            return dst
        },
        v4ScalarMul: function v4ScalarMulFn(a, b, dst) {
            if (b === 0) {
                return VMath.v4BuildZero(dst)
            } else {
                if (dst === undefined) {
                    dst = new VMathArrayConstructor(4)
                }
                dst[0] = a[0] * b;
                dst[1] = a[1] * b;
                dst[2] = a[2] * b;
                dst[3] = a[3] * b;
                return dst
            }
        },
        v4AddScalarMul: function v4AddScalarMulFn(a, b, c, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(4)
            }
            dst[0] = a[0] + b[0] * c;
            dst[1] = a[1] + b[1] * c;
            dst[2] = a[2] + b[2] * c;
            dst[3] = a[3] + b[3] * c;
            return dst
        },
        v4ScalarEqual: function v4ScalarEqualFn(a, b) {
            var abs = Math.abs;
            var precision = VMath.precision;
            return abs(a[0] - b) <= precision && abs(a[1] - b) <= precision && abs(a[2] - b) <= precision && abs(a[3] - b) <= precision
        },
        v4EqualScalarMask: function v4EqualScalarMaskFn(a, b) {
            var abs = Math.abs;
            var precision = VMath.precision;
            return [abs(a[0] - b) <= precision, abs(a[1] - b) <= precision, abs(a[2] - b) <= precision, abs(a[3] - b) <= precision]
        },
        v4LessScalarMask: function v4LessScalarMaskFn(a, b) {
            return [a[0] < b, a[1] < b, a[2] < b, a[3] < b]
        },
        v4GreaterScalarMask: function v4GreaterScalarMaskFn(a, b) {
            return [a[0] > b, a[1] > b, a[2] > b, a[3] > b]
        },
        v4GreaterEqScalarMask: function v4GreaterEqScalarMaskFn(a, b) {
            return [a[0] >= b, a[1] >= b, a[2] >= b, a[3] >= b]
        },
        v4Lerp: function v4LerpFn(a, b, t, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(4)
            }
            dst[0] = a[0] + (b[0] - a[0]) * t;
            dst[1] = a[1] + (b[1] - a[1]) * t;
            dst[2] = a[2] + (b[2] - a[2]) * t;
            dst[3] = a[3] + (b[3] - a[3]) * t;
            return dst
        },
        aabbBuild: function aabbBuildFn(a0, a1, a2, a3, a4, a5, dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(6)
            }
            res[0] = a0;
            res[1] = a1;
            res[2] = a2;
            res[3] = a3;
            res[4] = a4;
            res[5] = a5;
            return res
        },
        aabbBuildEmpty: function aabbBuildEmptyFn(dst) {
            var float_max = this.FLOAT_MAX;
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(6)
            }
            res[0] = float_max;
            res[1] = float_max;
            res[2] = float_max;
            res[3] = -float_max;
            res[4] = -float_max;
            res[5] = -float_max;
            return res
        },
        aabbCopy: function aabbCopyFn(aabb, dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(6)
            }
            res[0] = aabb[0];
            res[1] = aabb[1];
            res[2] = aabb[2];
            res[3] = aabb[3];
            res[4] = aabb[4];
            res[5] = aabb[5];
            return res
        },
        aabbSet: function aabbSet(dst, src) {
            dst[0] = src[0];
            dst[1] = src[1];
            dst[2] = src[2];
            dst[3] = src[3];
            dst[4] = src[4];
            dst[5] = src[5]
        },
        aabbIsEmpty: function aabbIsEmptyFn(aabb) {
            return aabb[0] > aabb[3]
        },
        aabbMin: function aabbMinFn(aabb, dst) {
            if (dst === undefined) {
                return aabb.slice(0, 3)
            }
            dst[0] = aabb[0];
            dst[1] = aabb[1];
            dst[2] = aabb[2];
            return dst
        },
        aabbMax: function aabbMaxFn(aabb, dst) {
            if (dst === undefined) {
                return aabb.slice(3, 6)
            }
            dst[0] = aabb[3];
            dst[1] = aabb[4];
            dst[2] = aabb[5];
            return dst
        },
        aabbGetCenterAndHalf: function aabbGetCenterAndHalfFn(aabb, center, half) {
            var cX = (aabb[0] + aabb[3]) * .5;
            var cY = (aabb[1] + aabb[4]) * .5;
            var cZ = (aabb[2] + aabb[5]) * .5;
            center[0] = cX;
            center[1] = cY;
            center[2] = cZ;
            half[0] = aabb[3] - cX;
            half[1] = aabb[4] - cY;
            half[2] = aabb[5] - cZ
        },
        aabbIsInsidePlanes: function aabbIsInsidePlanesFn(aabb, planes) {
            var numPlanes = planes.length;
            var n = 0;
            do {
                var plane = planes[n];
                var d0 = plane[0];
                var d1 = plane[1];
                var d2 = plane[2];
                var distance = d0 * (d0 < 0 ? aabb[0] : aabb[3]) + d1 * (d1 < 0 ? aabb[1] : aabb[4]) + d2 * (d2 < 0 ? aabb[2] : aabb[5]);
                if (distance < plane[3]) {
                    return false
                }
                n += 1
            } while (n < numPlanes);
            return true
        },
        aabbIsFullyInsidePlanes: function aabbIsFullyInsidePlanesFn(aabb, planes) {
            var numPlanes = planes.length;
            var n = 0;
            do {
                var plane = planes[n];
                var d0 = plane[0];
                var d1 = plane[1];
                var d2 = plane[2];
                var distance = d0 * (d0 > 0 ? aabb[0] : aabb[3]) + d1 * (d1 > 0 ? aabb[1] : aabb[4]) + d2 * (d2 > 0 ? aabb[2] : aabb[5]);
                if (distance < plane[3]) {
                    return false
                }
                n += 1
            } while (n < numPlanes);
            return true
        },
        aabbUnion: function aabbUnionFn(a, b, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(6)
            }
            dst[0] = a[0] < b[0] ? a[0] : b[0];
            dst[1] = a[1] < b[1] ? a[1] : b[1];
            dst[2] = a[2] < b[2] ? a[2] : b[2];
            dst[3] = a[3] > b[3] ? a[3] : b[3];
            dst[4] = a[4] > b[4] ? a[4] : b[4];
            dst[5] = a[5] > b[5] ? a[5] : b[5];
            return dst
        },
        aabbUnionArray: function aabbUnionArrayFn(aabbArray, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(6)
            }
            VMath.aabbCopy(aabbArray[0], dst);
            var numAABBs = aabbArray.length;
            for (var i = 1; i < numAABBs; i += 1) {
                var aabb = aabbArray[i];
                dst[0] = dst[0] < aabb[0] ? dst[0] : aabb[0];
                dst[1] = dst[1] < aabb[1] ? dst[1] : aabb[1];
                dst[2] = dst[2] < aabb[2] ? dst[2] : aabb[2];
                dst[3] = dst[3] > aabb[3] ? dst[3] : aabb[3];
                dst[4] = dst[4] > aabb[4] ? dst[4] : aabb[4];
                dst[5] = dst[5] > aabb[5] ? dst[5] : aabb[5]
            }
            return dst
        },
        aabbAddPoints: function aabbAddPointFn(aabb, ps) {
            var i;
            var numPoints = ps.length;
            var r0 = aabb[0];
            var r1 = aabb[1];
            var r2 = aabb[2];
            var r3 = aabb[3];
            var r4 = aabb[4];
            var r5 = aabb[5];
            var p, p0, p1, p2;
            for (i = 0; i < numPoints; i += 1) {
                p = ps[i];
                p0 = p[0];
                p1 = p[1];
                p2 = p[2];
                r0 = r0 < p0 ? r0 : p0;
                r1 = r1 < p1 ? r1 : p1;
                r2 = r2 < p2 ? r2 : p2;
                r3 = r3 > p0 ? r3 : p0;
                r4 = r4 > p1 ? r4 : p1;
                r5 = r5 > p2 ? r5 : p2
            }
            aabb[0] = r0;
            aabb[1] = r1;
            aabb[2] = r2;
            aabb[3] = r3;
            aabb[4] = r4;
            aabb[5] = r5
        },
        aabbTransform: function aabbTransformFn(aabb, matrix, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(6)
            }
            var cX = (aabb[0] + aabb[3]) * .5;
            var cY = (aabb[1] + aabb[4]) * .5;
            var cZ = (aabb[2] + aabb[5]) * .5;
            var hX = aabb[3] - cX;
            var hY = aabb[4] - cY;
            var hZ = aabb[5] - cZ;
            var m0 = matrix[0];
            var m1 = matrix[1];
            var m2 = matrix[2];
            var m3 = matrix[3];
            var m4 = matrix[4];
            var m5 = matrix[5];
            var m6 = matrix[6];
            var m7 = matrix[7];
            var m8 = matrix[8];
            var ctX = matrix[9] + (m0 * cX + m3 * cY + m6 * cZ);
            var ctY = matrix[10] + (m1 * cX + m4 * cY + m7 * cZ);
            var ctZ = matrix[11] + (m2 * cX + m5 * cY + m8 * cZ);
            var abs = Math.abs;
            var htX = abs(m0) * hX + abs(m3) * hY + abs(m6) * hZ;
            var htY = abs(m1) * hX + abs(m4) * hY + abs(m7) * hZ;
            var htZ = abs(m2) * hX + abs(m5) * hY + abs(m8) * hZ;
            dst[0] = ctX - htX;
            dst[1] = ctY - htY;
            dst[2] = ctZ - htZ;
            dst[3] = ctX + htX;
            dst[4] = ctY + htY;
            dst[5] = ctZ + htZ;
            return dst
        },
        aabbIntercept: function aabbInterceptFn(a, b, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(6)
            }
            dst[0] = a[0] > b[0] ? a[0] : b[0];
            dst[1] = a[1] > b[1] ? a[1] : b[1];
            dst[2] = a[2] > b[2] ? a[2] : b[2];
            dst[3] = a[3] < b[3] ? a[3] : b[3];
            dst[4] = a[4] < b[4] ? a[4] : b[4];
            dst[5] = a[5] < b[5] ? a[5] : b[5];
            return dst
        },
        aabbOverlaps: function aabbOverlapsFn(a, b) {
            return a[0] <= b[3] && a[1] <= b[4] && a[2] <= b[5] && a[3] >= b[0] && a[4] >= b[1] && a[5] >= b[2]
        },
        aabbSphereOverlaps: function aabbSphereOverlapsFn(aabb, center, radius) {
            var centerX = center[0];
            var centerY = center[1];
            var centerZ = center[2];
            var radiusSquared = radius * radius;
            var minX = aabb[0];
            var minY = aabb[1];
            var minZ = aabb[2];
            var maxX = aabb[3];
            var maxY = aabb[4];
            var maxZ = aabb[5];
            var totalDistance = 0,
                sideDistance;
            if (centerX < minX) {
                sideDistance = minX - centerX;
                totalDistance += sideDistance * sideDistance
            } else if (centerX > maxX) {
                sideDistance = centerX - maxX;
                totalDistance += sideDistance * sideDistance
            }
            if (centerY < minY) {
                sideDistance = minY - centerY;
                totalDistance += sideDistance * sideDistance
            } else if (centerY > maxY) {
                sideDistance = centerY - maxY;
                totalDistance += sideDistance * sideDistance
            }
            if (centerZ < minZ) {
                sideDistance = minZ - centerZ;
                totalDistance += sideDistance * sideDistance
            } else if (centerZ > maxZ) {
                sideDistance = centerZ - maxZ;
                totalDistance += sideDistance * sideDistance
            }
            return totalDistance <= radiusSquared
        },
        aabbIsInside: function aabbIsInsideFn(a, b) {
            return a[0] >= b[0] && a[1] >= b[1] && a[2] >= b[2] && a[3] <= b[3] && a[4] <= b[4] && a[5] <= b[5]
        },
        aabbTestInside: function aabbTestInsideFn(a, b) {
            if (a[0] <= b[3] && a[1] <= b[4] && a[2] <= b[5] && a[3] >= b[0] && a[4] >= b[1] && a[5] >= b[2]) {
                if (a[0] >= b[0] && a[1] >= b[1] && a[2] >= b[2] && a[3] <= b[3] && a[4] <= b[4] && a[5] <= b[5]) {
                    return 2
                }
                return 1
            }
            return 0
        },
        m33BuildIdentity: function m33BuildIdentityFn(dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(9)
            }
            res[0] = 1;
            res[1] = 0;
            res[2] = 0;
            res[3] = 0;
            res[4] = 1;
            res[5] = 0;
            res[6] = 0;
            res[7] = 0;
            res[8] = 1;
            return res
        },
        m33Build: function m33BuildFn(r, u, a, dst) {
            var res;
            var length = arguments.length;
            if (length >= 9) {
                if (length > 9) {
                    res = arguments[9];
                    if (res === undefined) {
                        res = new VMathArrayConstructor(9)
                    }
                } else {
                    res = new VMathArrayConstructor(9)
                }
                res[0] = arguments[0];
                res[1] = arguments[1];
                res[2] = arguments[2];
                res[3] = arguments[3];
                res[4] = arguments[4];
                res[5] = arguments[5];
                res[6] = arguments[6];
                res[7] = arguments[7];
                res[8] = arguments[8]
            } else {
                res = dst;
                if (res === undefined) {
                    res = new VMathArrayConstructor(9)
                }
                res[0] = r[0];
                res[1] = r[1];
                res[2] = r[2];
                res[3] = u[0];
                res[4] = u[1];
                res[5] = u[2];
                res[6] = a[0];
                res[7] = a[1];
                res[8] = a[2]
            }
            return res
        },
        m33Copy: function m33CopyFn(m, dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(9)
            }
            res[0] = m[0];
            res[1] = m[1];
            res[2] = m[2];
            res[3] = m[3];
            res[4] = m[4];
            res[5] = m[5];
            res[6] = m[6];
            res[7] = m[7];
            res[8] = m[8];
            return res
        },
        m33FromAxisRotation: function m33FromAxisRotationFn(axis, angle, dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(9)
            }
            var s = Math.sin(angle);
            var c = Math.cos(angle);
            var t = 1 - c;
            var axisX = axis[0];
            var axisY = axis[1];
            var axisZ = axis[2];
            var tx = t * axisX;
            var ty = t * axisY;
            var tz = t * axisZ;
            var sx = s * axisX;
            var sy = s * axisY;
            var sz = s * axisZ;
            res[0] = tx * axisX + c;
            res[1] = tx * axisY - sz;
            res[2] = tx * axisZ + sy;
            res[3] = ty * axisX + sz;
            res[4] = ty * axisY + c;
            res[5] = ty * axisZ - sx;
            res[6] = tz * axisX - sy;
            res[7] = tz * axisY + sx;
            res[8] = tz * axisZ + c;
            return res
        },
        m33FromQuat: function m33FromQuatFn(q, dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(9)
            }
            var qx = q[0];
            var qy = q[1];
            var qz = q[2];
            var qw = q[3];
            var xx = 2 * qx * qx;
            var yy = 2 * qy * qy;
            var zz = 2 * qz * qz;
            var xy = 2 * qx * qy;
            var zw = 2 * qz * qw;
            var xz = 2 * qx * qz;
            var yw = 2 * qy * qw;
            var yz = 2 * qy * qz;
            var xw = 2 * qx * qw;
            res[0] = 1 - yy - zz;
            res[1] = xy - zw;
            res[2] = xz + yw;
            res[3] = xy + zw;
            res[4] = 1 - xx - zz;
            res[5] = yz - xw;
            res[6] = xz - yw;
            res[7] = yz + xw;
            res[8] = 1 - xx - yy;
            return res
        },
        m33Right: function m33RightFn(m, dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(3)
            }
            res[0] = m[0];
            res[1] = m[1];
            res[2] = m[2];
            return res
        },
        m33Up: function m33UpFn(m, dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(3)
            }
            res[0] = m[3];
            res[1] = m[4];
            res[2] = m[5];
            return res
        },
        m33At: function m33AtFn(m, dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(3)
            }
            res[0] = m[6];
            res[1] = m[7];
            res[2] = m[8];
            return res
        },
        m33SetRight: function m33SetRightFn(m, v) {
            m[0] = v[0];
            m[1] = v[1];
            m[2] = v[2]
        },
        m33SetUp: function m33SetUpFn(m, v) {
            m[3] = v[0];
            m[4] = v[1];
            m[5] = v[2]
        },
        m33SetAt: function m33SetAtFn(m, v) {
            m[6] = v[0];
            m[7] = v[1];
            m[8] = v[2]
        },
        m33Transpose: function m33TransposeFn(m, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(9)
            }
            var m0 = m[0];
            var m1 = m[1];
            var m2 = m[2];
            var m3 = m[3];
            var m4 = m[4];
            var m5 = m[5];
            var m6 = m[6];
            var m7 = m[7];
            var m8 = m[8];
            dst[0] = m0;
            dst[1] = m3;
            dst[2] = m6;
            dst[3] = m1;
            dst[4] = m4;
            dst[5] = m7;
            dst[6] = m2;
            dst[7] = m5;
            dst[8] = m8;
            return dst
        },
        m33Determinant: function m33DeterminantFn(m) {
            var m0 = m[0];
            var m1 = m[1];
            var m2 = m[2];
            var m3 = m[3];
            var m4 = m[4];
            var m5 = m[5];
            var m6 = m[6];
            var m7 = m[7];
            var m8 = m[8];
            return m0 * (m4 * m8 - m5 * m7) + m1 * (m5 * m6 - m3 * m8) + m2 * (m3 * m7 - m4 * m6)
        },
        m33Inverse: function m33InverseFn(m, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(9)
            }
            var m0 = m[0];
            var m1 = m[1];
            var m2 = m[2];
            var m3 = m[3];
            var m4 = m[4];
            var m5 = m[5];
            var m6 = m[6];
            var m7 = m[7];
            var m8 = m[8];
            var d4857 = m4 * m8 - m5 * m7;
            var d5638 = m5 * m6 - m3 * m8;
            var d3746 = m3 * m7 - m4 * m6;
            var det = m0 * d4857 + m1 * d5638 + m2 * d3746;
            if (det === 0) {
                dst[0] = dst[1] = dst[2] = 0;
                dst[3] = dst[4] = dst[5] = 0;
                dst[6] = dst[7] = dst[8] = 0
            } else {
                var detrecp = 1 / det;
                dst[0] = d4857 * detrecp;
                dst[1] = (m7 * m2 - m8 * m1) * detrecp;
                dst[2] = (m1 * m5 - m2 * m4) * detrecp;
                dst[3] = d5638 * detrecp;
                dst[4] = (m8 * m0 - m6 * m2) * detrecp;
                dst[5] = (m3 * m2 - m0 * m5) * detrecp;
                dst[6] = d3746 * detrecp;
                dst[7] = (m6 * m1 - m7 * m0) * detrecp;
                dst[8] = (m0 * m4 - m3 * m1) * detrecp
            }
            return dst
        },
        m33InverseTranspose: function m33InverseTransposeFn(m, dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(9)
            }
            var m0 = m[0];
            var m1 = m[1];
            var m2 = m[2];
            var m3 = m[3];
            var m4 = m[4];
            var m5 = m[5];
            var m6 = m[6];
            var m7 = m[7];
            var m8 = m[8];
            var d4857 = m4 * m8 - m5 * m7;
            var d5638 = m5 * m6 - m3 * m8;
            var d3746 = m3 * m7 - m4 * m6;
            var det = m0 * d4857 + m1 * d5638 + m2 * d3746;
            if (det === 0) {
                res[0] = res[1] = res[2] = 0;
                res[3] = res[4] = res[5] = 0;
                res[6] = res[7] = res[8] = 0
            } else {
                var detrecp = 1 / det;
                res[0] = d4857 * detrecp;
                res[3] = (m7 * m2 - m8 * m1) * detrecp;
                res[6] = (m1 * m5 - m2 * m4) * detrecp;
                res[1] = d5638 * detrecp;
                res[4] = (m8 * m0 - m6 * m2) * detrecp;
                res[7] = (m3 * m2 - m0 * m5) * detrecp;
                res[2] = d3746 * detrecp;
                res[5] = (m6 * m1 - m7 * m0) * detrecp;
                res[8] = (m0 * m4 - m3 * m1) * detrecp
            }
            return res
        },
        m33Mul: function m33MulFn(a, b, dst) {
            var a0 = a[0];
            var a1 = a[1];
            var a2 = a[2];
            var a3 = a[3];
            var a4 = a[4];
            var a5 = a[5];
            var a6 = a[6];
            var a7 = a[7];
            var a8 = a[8];
            var b0 = b[0];
            var b1 = b[1];
            var b2 = b[2];
            var b3 = b[3];
            var b4 = b[4];
            var b5 = b[5];
            var b6 = b[6];
            var b7 = b[7];
            var b8 = b[8];
            if (dst === undefined) {
                dst = new VMathArrayConstructor(9)
            }
            dst[0] = b0 * a0 + b3 * a1 + b6 * a2;
            dst[1] = b1 * a0 + b4 * a1 + b7 * a2;
            dst[2] = b2 * a0 + b5 * a1 + b8 * a2;
            dst[3] = b0 * a3 + b3 * a4 + b6 * a5;
            dst[4] = b1 * a3 + b4 * a4 + b7 * a5;
            dst[5] = b2 * a3 + b5 * a4 + b8 * a5;
            dst[6] = b0 * a6 + b3 * a7 + b6 * a8;
            dst[7] = b1 * a6 + b4 * a7 + b7 * a8;
            dst[8] = b2 * a6 + b5 * a7 + b8 * a8;
            return dst
        },
        m33Transform: function m33TransformFn(m, v, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(3)
            }
            var v0 = v[0];
            var v1 = v[1];
            var v2 = v[2];
            dst[0] = m[0] * v0 + m[3] * v1 + m[6] * v2;
            dst[1] = m[1] * v0 + m[4] * v1 + m[7] * v2;
            dst[2] = m[2] * v0 + m[5] * v1 + m[8] * v2;
            return dst
        },
        m33Equal: function m33EqualFn(a, b, precision) {
            var abs = Math.abs;
            if (precision === undefined) {
                precision = this.precision
            }
            return abs(a[0] - b[0]) <= precision && abs(a[1] - b[1]) <= precision && abs(a[2] - b[2]) <= precision && abs(a[3] - b[3]) <= precision && abs(a[4] - b[4]) <= precision && abs(a[5] - b[5]) <= precision && abs(a[6] - b[6]) <= precision && abs(a[7] - b[7]) <= precision && abs(a[8] - b[8]) <= precision
        },
        m33MulM43: function m33MulM43Fn(a, b, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(12)
            }
            var a0 = a[0];
            var a1 = a[1];
            var a2 = a[2];
            var a3 = a[3];
            var a4 = a[4];
            var a5 = a[5];
            var a6 = a[6];
            var a7 = a[7];
            var a8 = a[8];
            var b0 = b[0];
            var b1 = b[1];
            var b2 = b[2];
            var b3 = b[3];
            var b4 = b[4];
            var b5 = b[5];
            var b6 = b[6];
            var b7 = b[7];
            var b8 = b[8];
            dst[0] = b0 * a0 + b3 * a1 + b6 * a2;
            dst[1] = b1 * a0 + b4 * a1 + b7 * a2;
            dst[2] = b2 * a0 + b5 * a1 + b8 * a2;
            dst[3] = b0 * a3 + b3 * a4 + b6 * a5;
            dst[4] = b1 * a3 + b4 * a4 + b7 * a5;
            dst[5] = b2 * a3 + b5 * a4 + b8 * a5;
            dst[6] = b0 * a6 + b3 * a7 + b6 * a8;
            dst[7] = b1 * a6 + b4 * a7 + b7 * a8;
            dst[8] = b2 * a6 + b5 * a7 + b8 * a8;
            dst[9] = b[9];
            dst[10] = b[10];
            dst[11] = b[11];
            return dst
        },
        m33MulM44: function m33MulM44Fn(a, b, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(16)
            }
            var a0 = a[0];
            var a1 = a[1];
            var a2 = a[2];
            var a3 = a[3];
            var a4 = a[4];
            var a5 = a[5];
            var a6 = a[6];
            var a7 = a[7];
            var a8 = a[8];
            var b0 = b[0];
            var b1 = b[1];
            var b2 = b[2];
            var b3 = b[3];
            var b4 = b[4];
            var b5 = b[5];
            var b6 = b[6];
            var b7 = b[7];
            var b8 = b[8];
            var b9 = b[9];
            var b10 = b[10];
            var b11 = b[11];
            dst[0] = b0 * a0 + b4 * a1 + b8 * a2;
            dst[1] = b1 * a0 + b5 * a1 + b9 * a2;
            dst[2] = b2 * a0 + b6 * a1 + b10 * a2;
            dst[3] = b3 * a0 + b7 * a1 + b11 * a2;
            dst[4] = b0 * a3 + b4 * a4 + b8 * a5;
            dst[5] = b1 * a3 + b5 * a4 + b9 * a5;
            dst[6] = b2 * a3 + b6 * a4 + b10 * a5;
            dst[7] = b3 * a3 + b7 * a4 + b11 * a5;
            dst[8] = b0 * a6 + b4 * a7 + b8 * a8;
            dst[9] = b1 * a6 + b5 * a7 + b9 * a8;
            dst[10] = b2 * a6 + b6 * a7 + b10 * a8;
            dst[11] = b3 * a6 + b7 * a7 + b11 * a8;
            dst[12] = b[12];
            dst[13] = b[13];
            dst[14] = b[14];
            dst[15] = b[15];
            return dst
        },
        m33ScalarAdd: function m33ScalarAddFn(m, s, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(9)
            }
            for (var n = 0; n < 9; n += 1) {
                dst[n] = m[n] + s
            }
            return dst
        },
        m33ScalarSub: function m33ScalarSubFn(m, s, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(9)
            }
            for (var n = 0; n < 9; n += 1) {
                dst[n] = m[n] - s
            }
            return dst
        },
        m33ScalarMul: function m33ScalarMulFn(m, s, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(9)
            }
            for (var n = 0; n < 9; n += 1) {
                dst[n] = m[n] * s
            }
            return dst
        },
        m34BuildIdentity: function m34BuildIdentityFn(dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(12)
            }
            res[0] = 1;
            res[1] = 0;
            res[2] = 0;
            res[3] = 0;
            res[4] = 0;
            res[5] = 1;
            res[6] = 0;
            res[7] = 0;
            res[8] = 0;
            res[9] = 0;
            res[10] = 1;
            res[11] = 0;
            return res
        },
        m34Pos: function m34PosFn(m, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(3)
            }
            dst[0] = m[3];
            dst[1] = m[7];
            dst[2] = m[11];
            return dst
        },
        m34Scale: function m34ScaleFn(m, scale, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(12)
            }
            var sx = scale[0];
            var sy = scale[1];
            var sz = scale[2];
            dst[0] = m[0] * sx;
            dst[1] = m[1] * sx;
            dst[2] = m[2] * sx;
            dst[3] = m[3];
            dst[4] = m[4] * sy;
            dst[5] = m[5] * sy;
            dst[6] = m[6] * sy;
            dst[7] = m[7];
            dst[8] = m[8] * sz;
            dst[9] = m[9] * sz;
            dst[10] = m[10] * sz;
            dst[11] = m[11];
            return dst
        },
        m43BuildIdentity: function m43BuildIdentityFn(dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(12)
            }
            res[0] = 1;
            res[1] = 0;
            res[2] = 0;
            res[3] = 0;
            res[4] = 1;
            res[5] = 0;
            res[6] = 0;
            res[7] = 0;
            res[8] = 1;
            res[9] = 0;
            res[10] = 0;
            res[11] = 0;
            return res
        },
        m43Build: function m43BuildFn(r, u, a, p, dst, a21, a02, a12, a22, a03, a13, a23, _dst) {
            var res;
            var length = arguments.length;
            if (length >= 12) {
                if (length > 12) {
                    res = arguments[12];
                    if (res === undefined) {
                        res = new VMathArrayConstructor(12)
                    }
                } else {
                    res = new VMathArrayConstructor(12)
                }
                res[0] = arguments[0];
                res[1] = arguments[1];
                res[2] = arguments[2];
                res[3] = arguments[3];
                res[4] = arguments[4];
                res[5] = arguments[5];
                res[6] = arguments[6];
                res[7] = arguments[7];
                res[8] = arguments[8];
                res[9] = arguments[9];
                res[10] = arguments[10];
                res[11] = arguments[11]
            } else {
                res = dst;
                if (res === undefined) {
                    res = new VMathArrayConstructor(12)
                }
                res[0] = r[0];
                res[1] = r[1];
                res[2] = r[2];
                res[3] = u[0];
                res[4] = u[1];
                res[5] = u[2];
                res[6] = a[0];
                res[7] = a[1];
                res[8] = a[2];
                res[9] = p[0];
                res[10] = p[1];
                res[11] = p[2]
            }
            return res
        },
        m43BuildTranslation: function m43BuildTranslationFn(x, y, z, dst) {
            var res;
            if (3 <= arguments.length) {
                res = dst;
                if (res === undefined) {
                    res = new VMathArrayConstructor(12)
                }
                res[9] = x;
                res[10] = y;
                res[11] = z
            } else {
                res = y;
                if (res === undefined) {
                    res = new VMathArrayConstructor(12)
                }
                res[9] = x[0];
                res[10] = x[1];
                res[11] = x[2]
            }
            res[0] = 1;
            res[1] = 0;
            res[2] = 0;
            res[3] = 0;
            res[4] = 1;
            res[5] = 0;
            res[6] = 0;
            res[7] = 0;
            res[8] = 1;
            return res
        },
        m43Copy: function m43CopyFn(m, dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(12)
            }
            res[0] = m[0];
            res[1] = m[1];
            res[2] = m[2];
            res[3] = m[3];
            res[4] = m[4];
            res[5] = m[5];
            res[6] = m[6];
            res[7] = m[7];
            res[8] = m[8];
            res[9] = m[9];
            res[10] = m[10];
            res[11] = m[11];
            return res
        },
        m43FromM33V3: function m43FromM33V3Fn(m, v, dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(12)
            }
            res[0] = m[0];
            res[1] = m[1];
            res[2] = m[2];
            res[3] = m[3];
            res[4] = m[4];
            res[5] = m[5];
            res[6] = m[6];
            res[7] = m[7];
            res[8] = m[8];
            res[9] = v[0];
            res[10] = v[1];
            res[11] = v[2];
            return res
        },
        m43FromAxisRotation: function m43FromAxisRotationFn(axis, angle, dst) {
            var s = Math.sin(angle);
            var c = Math.cos(angle);
            var t = 1 - c;
            var axisX = axis[0];
            var axisY = axis[1];
            var axisZ = axis[2];
            var tx = t * axisX;
            var ty = t * axisY;
            var tz = t * axisZ;
            var sx = s * axisX;
            var sy = s * axisY;
            var sz = s * axisZ;
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(12)
            }
            res[0] = tx * axisX + c;
            res[1] = tx * axisY - sz;
            res[2] = tx * axisZ + sy;
            res[3] = ty * axisX + sz;
            res[4] = ty * axisY + c;
            res[5] = ty * axisZ - sx;
            res[6] = tz * axisX - sy;
            res[7] = tz * axisY + sx;
            res[8] = tz * axisZ + c;
            res[9] = 0;
            res[10] = 0;
            res[11] = 0;
            return res
        },
        m43FromQuatPos: function m43FromQuatPosFn(qp, dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(12)
            }
            var qx = qp[0];
            var qy = qp[1];
            var qz = qp[2];
            var qw = qp[3];
            var px = qp[4];
            var py = qp[5];
            var pz = qp[6];
            var xx = 2 * qx * qx;
            var yy = 2 * qy * qy;
            var zz = 2 * qz * qz;
            var xy = 2 * qx * qy;
            var zw = 2 * qz * qw;
            var xz = 2 * qx * qz;
            var yw = 2 * qy * qw;
            var yz = 2 * qy * qz;
            var xw = 2 * qx * qw;
            res[0] = 1 - yy - zz;
            res[1] = xy - zw;
            res[2] = xz + yw;
            res[3] = xy + zw;
            res[4] = 1 - xx - zz;
            res[5] = yz - xw;
            res[6] = xz - yw;
            res[7] = yz + xw;
            res[8] = 1 - xx - yy;
            res[9] = px;
            res[10] = py;
            res[11] = pz;
            return res
        },
        m43FromRTS: function m43FromRTSFn(quat, pos, scale, dst) {
            var qx = quat[0];
            var qy = quat[1];
            var qz = quat[2];
            var qw = quat[3];
            var xx = 2 * qx * qx;
            var yy = 2 * qy * qy;
            var zz = 2 * qz * qz;
            var xy = 2 * qx * qy;
            var zw = 2 * qz * qw;
            var xz = 2 * qx * qz;
            var yw = 2 * qy * qw;
            var yz = 2 * qy * qz;
            var xw = 2 * qx * qw;
            var sx = scale[0];
            var sy = scale[1];
            var sz = scale[2];
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(12)
            }
            res[0] = sx * (1 - yy - zz);
            res[1] = sx * (xy - zw);
            res[2] = sx * (xz + yw);
            res[3] = sy * (xy + zw);
            res[4] = sy * (1 - xx - zz);
            res[5] = sy * (yz - xw);
            res[6] = sz * (xz - yw);
            res[7] = sz * (yz + xw);
            res[8] = sz * (1 - xx - yy);
            res[9] = pos[0];
            res[10] = pos[1];
            res[11] = pos[2];
            return res
        },
        m43FromRT: function m43FromRTFn(quat, pos, dst) {
            var qx = quat[0];
            var qy = quat[1];
            var qz = quat[2];
            var qw = quat[3];
            var xx = 2 * qx * qx;
            var yy = 2 * qy * qy;
            var zz = 2 * qz * qz;
            var xy = 2 * qx * qy;
            var zw = 2 * qz * qw;
            var xz = 2 * qx * qz;
            var yw = 2 * qy * qw;
            var yz = 2 * qy * qz;
            var xw = 2 * qx * qw;
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(12)
            }
            res[0] = 1 - yy - zz;
            res[1] = xy - zw;
            res[2] = xz + yw;
            res[3] = xy + zw;
            res[4] = 1 - xx - zz;
            res[5] = yz - xw;
            res[6] = xz - yw;
            res[7] = yz + xw;
            res[8] = 1 - xx - yy;
            res[9] = pos[0];
            res[10] = pos[1];
            res[11] = pos[2];
            return res
        },
        m43Right: function m43RightFn(m, dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(3)
            }
            res[0] = m[0];
            res[1] = m[1];
            res[2] = m[2];
            return res
        },
        m43Up: function m43UpFn(m, dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(3)
            }
            res[0] = m[3];
            res[1] = m[4];
            res[2] = m[5];
            return res
        },
        m43At: function m43AtFn(m, dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(3)
            }
            res[0] = m[6];
            res[1] = m[7];
            res[2] = m[8];
            return res
        },
        m43Pos: function m43PosFn(m, dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(3)
            }
            res[0] = m[9];
            res[1] = m[10];
            res[2] = m[11];
            return res
        },
        m43SetRight: function m43SetRightFn(m, v) {
            m[0] = v[0];
            m[1] = v[1];
            m[2] = v[2]
        },
        m43SetUp: function m43SetUpFn(m, v) {
            m[3] = v[0];
            m[4] = v[1];
            m[5] = v[2]
        },
        m43SetAt: function m43SetAtFn(m, v) {
            m[6] = v[0];
            m[7] = v[1];
            m[8] = v[2]
        },
        m43SetPos: function m43SetPosFn(m, v) {
            m[9] = v[0];
            m[10] = v[1];
            m[11] = v[2]
        },
        m43SetAxisRotation: function m43SetAxisRotationFn(m, axis, angle) {
            var s = Math.sin(angle);
            var c = Math.cos(angle);
            var t = 1 - c;
            var axisX = axis[0];
            var axisY = axis[1];
            var axisZ = axis[2];
            var tx = t * axisX;
            var ty = t * axisY;
            var tz = t * axisZ;
            var sx = s * axisX;
            var sy = s * axisY;
            var sz = s * axisZ;
            m[0] = tx * axisX + c;
            m[1] = tx * axisY - sz;
            m[2] = tx * axisZ + sy;
            m[3] = ty * axisX + sz;
            m[4] = ty * axisY + c;
            m[5] = ty * axisZ - sx;
            m[6] = tz * axisX - sy;
            m[7] = tz * axisY + sx;
            m[8] = tz * axisZ + c
        },
        m43InverseOrthonormal: function m43InverseOrthonormalFn(m, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(12)
            }
            var m0 = m[0];
            var m1 = m[1];
            var m2 = m[2];
            var m3 = m[3];
            var m4 = m[4];
            var m5 = m[5];
            var m6 = m[6];
            var m7 = m[7];
            var m8 = m[8];
            var px = m[9];
            var py = m[10];
            var pz = m[11];
            dst[0] = m0;
            dst[1] = m3;
            dst[2] = m6;
            dst[3] = m1;
            dst[4] = m4;
            dst[5] = m7;
            dst[6] = m2;
            dst[7] = m5;
            dst[8] = m8;
            dst[9] = -(px * m0 + py * m1 + pz * m2);
            dst[10] = -(px * m3 + py * m4 + pz * m5);
            dst[11] = -(px * m6 + py * m7 + pz * m8);
            return dst
        },
        m43Orthonormalize: function m43OrthonormalizeFn(m, dst) {
            var normalize = VMath.v3Normalize;
            var length = VMath.v3Length;
            var dot = VMath.v3Dot;
            var cross = VMath.v3Cross;
            var abs = Math.abs;
            var right = VMath.m43Right(m);
            var up = VMath.m43Up(m);
            var at = VMath.m43At(m);
            var pos = VMath.m43Pos(m);
            var innerX = length(right);
            var innerY = length(up);
            var innerZ = length(at);
            normalize(right, right);
            normalize(up, up);
            normalize(at, at);
            var vpU, vpV, vpW;
            if (innerX > 0) {
                if (innerY > 0) {
                    if (innerZ > 0) {
                        var outerX = abs(dot(up, at));
                        var outerY = abs(dot(at, right));
                        var outerZ = abs(dot(right, up));
                        if (outerX < outerY) {
                            if (outerX < outerZ) {
                                vpU = up;
                                vpV = at;
                                vpW = right
                            } else {
                                vpU = right;
                                vpV = up;
                                vpW = at
                            }
                        } else {
                            if (outerY < outerZ) {
                                vpU = at;
                                vpV = right;
                                vpW = up
                            } else {
                                vpU = right;
                                vpV = up;
                                vpW = at
                            }
                        }
                    } else {
                        vpU = right;
                        vpV = up;
                        vpW = at
                    }
                } else {
                    vpU = at;
                    vpV = right;
                    vpW = up
                }
            } else {
                vpU = up;
                vpV = at;
                vpW = right
            }
            cross(vpU, vpV, vpW);
            normalize(vpW, vpW);
            cross(vpW, vpU, vpV);
            normalize(vpV, vpV);
            if (dst === undefined) {
                dst = new VMathArrayConstructor(12)
            }
            dst[0] = right[0];
            dst[1] = right[1];
            dst[2] = right[2];
            dst[3] = up[0];
            dst[4] = up[1];
            dst[5] = up[2];
            dst[6] = at[0];
            dst[7] = at[1];
            dst[8] = at[2];
            dst[9] = pos[0];
            dst[10] = pos[1];
            dst[11] = pos[2];
            return dst
        },
        m43Determinant: function m43DeterminantFn(m) {
            return m[0] * (m[4] * m[8] - m[5] * m[7]) + m[1] * (m[5] * m[6] - m[3] * m[8]) + m[2] * (m[3] * m[7] - m[4] * m[6])
        },
        m43Inverse: function m43InverseFn(m, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(12)
            }
            var m0 = m[0];
            var m1 = m[1];
            var m2 = m[2];
            var m3 = m[3];
            var m4 = m[4];
            var m5 = m[5];
            var m6 = m[6];
            var m7 = m[7];
            var m8 = m[8];
            var m9 = m[9];
            var m10 = m[10];
            var m11 = m[11];
            var d4857 = m4 * m8 - m5 * m7;
            var d5638 = m5 * m6 - m3 * m8;
            var d3746 = m3 * m7 - m4 * m6;
            var det = m0 * d4857 + m1 * d5638 + m2 * d3746;
            if (det === 0) {
                return dst
            } else {
                if (dst === undefined) {
                    dst = new VMathArrayConstructor(12)
                }
                var rdet = 1 / det;
                dst[0] = d4857 * rdet;
                dst[1] = (m7 * m2 - m8 * m1) * rdet;
                dst[2] = (m1 * m5 - m2 * m4) * rdet;
                dst[3] = d5638 * rdet;
                dst[4] = (m8 * m0 - m6 * m2) * rdet;
                dst[5] = (m3 * m2 - m0 * m5) * rdet;
                dst[6] = d3746 * rdet;
                dst[7] = (m6 * m1 - m7 * m0) * rdet;
                dst[8] = (m0 * m4 - m3 * m1) * rdet;
                dst[9] = (m3 * (m10 * m8 - m7 * m11) + m4 * (m6 * m11 - m9 * m8) + m5 * (m9 * m7 - m6 * m10)) * rdet;
                dst[10] = (m6 * (m2 * m10 - m1 * m11) + m7 * (m0 * m11 - m9 * m2) + m8 * (m9 * m1 - m0 * m10)) * rdet;
                dst[11] = (m9 * (m2 * m4 - m1 * m5) + m10 * (m0 * m5 - m3 * m2) + m11 * (m3 * m1 - m0 * m4)) * rdet;
                return dst
            }
        },
        m43Translate: function m43TranslateFn(matrix, pos) {
            matrix[9] += pos[0];
            matrix[10] += pos[1];
            matrix[11] += pos[2]
        },
        m43Scale: function m43ScaleFn(m, scale, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(12)
            }
            var sx = scale[0];
            var sy = scale[1];
            var sz = scale[2];
            dst[0] = m[0] * sx;
            dst[1] = m[1] * sx;
            dst[2] = m[2] * sx;
            dst[3] = m[3] * sy;
            dst[4] = m[4] * sy;
            dst[5] = m[5] * sy;
            dst[6] = m[6] * sz;
            dst[7] = m[7] * sz;
            dst[8] = m[8] * sz;
            dst[9] = m[9];
            dst[10] = m[10];
            dst[11] = m[11];
            return dst
        },
        m43TransformVector: function m43TransformVectorFn(m, v, dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(3)
            }
            var v0 = v[0];
            var v1 = v[1];
            var v2 = v[2];
            res[0] = m[0] * v0 + m[3] * v1 + m[6] * v2;
            res[1] = m[1] * v0 + m[4] * v1 + m[7] * v2;
            res[2] = m[2] * v0 + m[5] * v1 + m[8] * v2;
            return res
        },
        m43TransformPoint: function m43TransformPointFn(m, v, dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(3)
            }
            var v0 = v[0];
            var v1 = v[1];
            var v2 = v[2];
            res[0] = m[0] * v0 + m[3] * v1 + m[6] * v2 + m[9];
            res[1] = m[1] * v0 + m[4] * v1 + m[7] * v2 + m[10];
            res[2] = m[2] * v0 + m[5] * v1 + m[8] * v2 + m[11];
            return res
        },
        m43Mul: function m43MulFn(a, b, dst) {
            var a0 = a[0];
            var a1 = a[1];
            var a2 = a[2];
            var a3 = a[3];
            var a4 = a[4];
            var a5 = a[5];
            var a6 = a[6];
            var a7 = a[7];
            var a8 = a[8];
            var a9 = a[9];
            var a10 = a[10];
            var a11 = a[11];
            var b0 = b[0];
            var b1 = b[1];
            var b2 = b[2];
            var b3 = b[3];
            var b4 = b[4];
            var b5 = b[5];
            var b6 = b[6];
            var b7 = b[7];
            var b8 = b[8];
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(12)
            }
            res[0] = b0 * a0 + b3 * a1 + b6 * a2;
            res[1] = b1 * a0 + b4 * a1 + b7 * a2;
            res[2] = b2 * a0 + b5 * a1 + b8 * a2;
            res[3] = b0 * a3 + b3 * a4 + b6 * a5;
            res[4] = b1 * a3 + b4 * a4 + b7 * a5;
            res[5] = b2 * a3 + b5 * a4 + b8 * a5;
            res[6] = b0 * a6 + b3 * a7 + b6 * a8;
            res[7] = b1 * a6 + b4 * a7 + b7 * a8;
            res[8] = b2 * a6 + b5 * a7 + b8 * a8;
            res[9] = b0 * a9 + b3 * a10 + b6 * a11 + b[9];
            res[10] = b1 * a9 + b4 * a10 + b7 * a11 + b[10];
            res[11] = b2 * a9 + b5 * a10 + b8 * a11 + b[11];
            return res
        },
        m43MulM33: function m43MulM33Fn(a, b, dst) {
            var a0 = a[0];
            var a1 = a[1];
            var a2 = a[2];
            var a3 = a[3];
            var a4 = a[4];
            var a5 = a[5];
            var a6 = a[6];
            var a7 = a[7];
            var a8 = a[8];
            var a9 = a[9];
            var a10 = a[10];
            var a11 = a[11];
            var b0 = b[0];
            var b1 = b[1];
            var b2 = b[2];
            var b3 = b[3];
            var b4 = b[4];
            var b5 = b[5];
            var b6 = b[6];
            var b7 = b[7];
            var b8 = b[8];
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(12)
            }
            res[0] = b0 * a0 + b3 * a1 + b6 * a2;
            res[1] = b1 * a0 + b4 * a1 + b7 * a2;
            res[2] = b2 * a0 + b5 * a1 + b8 * a2;
            res[3] = b0 * a3 + b3 * a4 + b6 * a5;
            res[4] = b1 * a3 + b4 * a4 + b7 * a5;
            res[5] = b2 * a3 + b5 * a4 + b8 * a5;
            res[6] = b0 * a6 + b3 * a7 + b6 * a8;
            res[7] = b1 * a6 + b4 * a7 + b7 * a8;
            res[8] = b2 * a6 + b5 * a7 + b8 * a8;
            res[9] = b0 * a9 + b3 * a10 + b6 * a11;
            res[10] = b1 * a9 + b4 * a10 + b7 * a11;
            res[11] = b2 * a9 + b5 * a10 + b8 * a11;
            return res
        },
        m43MulM44: function m43MulM44Fn(a, b, dst) {
            var a0 = a[0];
            var a1 = a[1];
            var a2 = a[2];
            var a3 = a[3];
            var a4 = a[4];
            var a5 = a[5];
            var a6 = a[6];
            var a7 = a[7];
            var a8 = a[8];
            var a9 = a[9];
            var a10 = a[10];
            var a11 = a[11];
            var b0 = b[0];
            var b1 = b[1];
            var b2 = b[2];
            var b3 = b[3];
            var b4 = b[4];
            var b5 = b[5];
            var b6 = b[6];
            var b7 = b[7];
            var b8 = b[8];
            var b9 = b[9];
            var b10 = b[10];
            var b11 = b[11];
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(16)
            }
            res[0] = b0 * a0 + b4 * a1 + b8 * a2;
            res[1] = b1 * a0 + b5 * a1 + b9 * a2;
            res[2] = b2 * a0 + b6 * a1 + b10 * a2;
            res[3] = b3 * a0 + b7 * a1 + b11 * a2;
            res[4] = b0 * a3 + b4 * a4 + b8 * a5;
            res[5] = b1 * a3 + b5 * a4 + b9 * a5;
            res[6] = b2 * a3 + b6 * a4 + b10 * a5;
            res[7] = b3 * a3 + b7 * a4 + b11 * a5;
            res[8] = b0 * a6 + b4 * a7 + b8 * a8;
            res[9] = b1 * a6 + b5 * a7 + b9 * a8;
            res[10] = b2 * a6 + b6 * a7 + b10 * a8;
            res[11] = b3 * a6 + b7 * a7 + b11 * a8;
            res[12] = b0 * a9 + b4 * a10 + b8 * a11 + b[12];
            res[13] = b1 * a9 + b5 * a10 + b9 * a11 + b[13];
            res[14] = b2 * a9 + b6 * a10 + b10 * a11 + b[14];
            res[15] = b3 * a9 + b7 * a10 + b11 * a11 + b[15];
            return res
        },
        m43Transpose: function m43TransposeFn(m, dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(12)
            }
            var m0 = m[0];
            var m1 = m[1];
            var m2 = m[2];
            var m3 = m[3];
            var m4 = m[4];
            var m5 = m[5];
            var m6 = m[6];
            var m7 = m[7];
            var m8 = m[8];
            var m9 = m[9];
            var m10 = m[10];
            var m11 = m[11];
            res[0] = m0;
            res[1] = m3;
            res[2] = m6;
            res[3] = m9;
            res[4] = m1;
            res[5] = m4;
            res[6] = m7;
            res[7] = m10;
            res[8] = m2;
            res[9] = m5;
            res[10] = m8;
            res[11] = m11;
            return res
        },
        m43MulTranspose: function m43MulTransposeFn(a, b, dst) {
            var a0 = a[0];
            var a1 = a[1];
            var a2 = a[2];
            var a3 = a[3];
            var a4 = a[4];
            var a5 = a[5];
            var a6 = a[6];
            var a7 = a[7];
            var a8 = a[8];
            var a9 = a[9];
            var a10 = a[10];
            var a11 = a[11];
            var b0 = b[0];
            var b1 = b[1];
            var b2 = b[2];
            var b3 = b[3];
            var b4 = b[4];
            var b5 = b[5];
            var b6 = b[6];
            var b7 = b[7];
            var b8 = b[8];
            var b9 = b[9];
            var b10 = b[10];
            var b11 = b[11];
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(12)
            }
            res[0] = b0 * a0 + b3 * a1 + b6 * a2;
            res[1] = b0 * a3 + b3 * a4 + b6 * a5;
            res[2] = b0 * a6 + b3 * a7 + b6 * a8;
            res[3] = b0 * a9 + b3 * a10 + b6 * a11 + b9;
            res[4] = b1 * a0 + b4 * a1 + b7 * a2;
            res[5] = b1 * a3 + b4 * a4 + b7 * a5;
            res[6] = b1 * a6 + b4 * a7 + b7 * a8;
            res[7] = b1 * a9 + b4 * a10 + b7 * a11 + b10;
            res[8] = b2 * a0 + b5 * a1 + b8 * a2;
            res[9] = b2 * a3 + b5 * a4 + b8 * a5;
            res[10] = b2 * a6 + b5 * a7 + b8 * a8;
            res[11] = b2 * a9 + b5 * a10 + b8 * a11 + b11;
            return res
        },
        m43Offset: function m43OffsetFn(m, o, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(12)
            }
            var m0 = m[0];
            var m1 = m[1];
            var m2 = m[2];
            var m3 = m[3];
            var m4 = m[4];
            var m5 = m[5];
            var m6 = m[6];
            var m7 = m[7];
            var m8 = m[8];
            var m9 = m[9];
            var m10 = m[10];
            var m11 = m[11];
            var o0 = o[0];
            var o1 = o[1];
            var o2 = o[2];
            dst[0] = m0;
            dst[1] = m1;
            dst[2] = m2;
            dst[3] = m3;
            dst[4] = m4;
            dst[5] = m5;
            dst[6] = m6;
            dst[7] = m7;
            dst[8] = m8;
            dst[9] = m0 * o0 + m3 * o1 + m6 * o2 + m9;
            dst[10] = m1 * o0 + m4 * o1 + m7 * o2 + m10;
            dst[11] = m2 * o0 + m5 * o1 + m8 * o2 + m11;
            return dst
        },
        m43NegOffset: function m43NegOffsetFn(m, o, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(12)
            }
            var m0 = m[0];
            var m1 = m[1];
            var m2 = m[2];
            var m3 = m[3];
            var m4 = m[4];
            var m5 = m[5];
            var m6 = m[6];
            var m7 = m[7];
            var m8 = m[8];
            var m9 = m[9];
            var m10 = m[10];
            var m11 = m[11];
            var o0 = -o[0];
            var o1 = -o[1];
            var o2 = -o[2];
            dst[0] = m0;
            dst[1] = m1;
            dst[2] = m2;
            dst[3] = m3;
            dst[4] = m4;
            dst[5] = m5;
            dst[6] = m6;
            dst[7] = m7;
            dst[8] = m8;
            dst[9] = m0 * o0 + m3 * o1 + m6 * o2 + m9;
            dst[10] = m1 * o0 + m4 * o1 + m7 * o2 + m10;
            dst[11] = m2 * o0 + m5 * o1 + m8 * o2 + m11;
            return dst
        },
        m43InverseTransposeProjection: function m43InverseTransposeProjectionFn(m, s, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(12)
            }
            var xf = .5 / s[0];
            var yf = .5 / s[1];
            var zf = .5 / s[2];
            var m0 = m[0] * xf;
            var m1 = m[1] * xf;
            var m2 = m[2] * xf;
            var m3 = m[3] * yf;
            var m4 = m[4] * yf;
            var m5 = m[5] * yf;
            var m6 = m[6] * zf;
            var m7 = m[7] * zf;
            var m8 = m[8] * zf;
            var px = m[9];
            var py = m[10];
            var pz = m[11];
            dst[0] = m0;
            dst[1] = m1;
            dst[2] = m2;
            dst[3] = .5 - (px * m0 + py * m1 + pz * m2);
            dst[4] = m3;
            dst[5] = m4;
            dst[6] = m5;
            dst[7] = .5 - (px * m3 + py * m4 + pz * m5);
            dst[8] = m6;
            dst[9] = m7;
            dst[10] = m8;
            dst[11] = .5 - (px * m6 + py * m7 + pz * m8);
            return dst
        },
        m43ScalarAdd: function m43ScalarAddFn(m, s, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(12)
            }
            for (var n = 0; n < 12; n += 1) {
                dst[n] = m[n] + s
            }
            return dst
        },
        m43ScalarSub: function m43ScalarSubFn(m, s, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(12)
            }
            for (var n = 0; n < 12; n += 1) {
                dst[n] = m[n] - s
            }
            return dst
        },
        m43ScalarMul: function m43ScalarMulFn(m, s, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(12)
            }
            for (var n = 0; n < 12; n += 1) {
                dst[n] = m[n] * s
            }
            return dst
        },
        m44BuildIdentity: function m44BuildIdentityFn(dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(16)
            }
            res[0] = 1;
            res[1] = 0;
            res[2] = 0;
            res[3] = 0;
            res[4] = 0;
            res[5] = 1;
            res[6] = 0;
            res[7] = 0;
            res[8] = 0;
            res[9] = 0;
            res[10] = 1;
            res[11] = 0;
            res[12] = 0;
            res[13] = 0;
            res[14] = 0;
            res[15] = 1;
            return res
        },
        m44Build: function m44BuildFn(r, u, a, p, dst) {
            var res;
            var length = arguments.length;
            if (length >= 16) {
                if (length > 16) {
                    res = arguments[16];
                    if (res === undefined) {
                        res = new VMathArrayConstructor(16)
                    }
                } else {
                    res = new VMathArrayConstructor(16)
                }
                res[0] = arguments[0];
                res[1] = arguments[1];
                res[2] = arguments[2];
                res[3] = arguments[3];
                res[4] = arguments[4];
                res[5] = arguments[5];
                res[6] = arguments[6];
                res[7] = arguments[7];
                res[8] = arguments[8];
                res[9] = arguments[9];
                res[10] = arguments[10];
                res[11] = arguments[11];
                res[12] = arguments[12];
                res[13] = arguments[13];
                res[14] = arguments[14];
                res[15] = arguments[15]
            } else {
                res = dst;
                if (res === undefined) {
                    res = new VMathArrayConstructor(16)
                }
                res[0] = r[0];
                res[1] = r[1];
                res[2] = r[2];
                res[3] = r[3];
                res[4] = u[0];
                res[5] = u[1];
                res[6] = u[2];
                res[7] = u[3];
                res[8] = a[0];
                res[9] = a[1];
                res[10] = a[2];
                res[11] = a[3];
                res[12] = p[0];
                res[13] = p[1];
                res[14] = p[2];
                res[15] = p[3]
            }
            return res
        },
        m44Copy: function m44CopyFn(m, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(16)
            }
            dst[0] = m[0];
            dst[1] = m[1];
            dst[2] = m[2];
            dst[3] = m[3];
            dst[4] = m[4];
            dst[5] = m[5];
            dst[6] = m[6];
            dst[7] = m[7];
            dst[8] = m[8];
            dst[9] = m[9];
            dst[10] = m[10];
            dst[11] = m[11];
            dst[12] = m[12];
            dst[13] = m[13];
            dst[14] = m[14];
            dst[15] = m[15];
            return dst
        },
        m44Right: function m44RightFn(m, dst) {
            if (dst === undefined) {
                return m.slice(0, 4)
            }
            dst[0] = m[0];
            dst[1] = m[1];
            dst[2] = m[2];
            dst[3] = m[3];
            return dst
        },
        m44Up: function m44UpFn(m, dst) {
            if (dst === undefined) {
                return m.slice(4, 8)
            }
            dst[0] = m[4];
            dst[1] = m[5];
            dst[2] = m[6];
            dst[3] = m[7];
            return dst
        },
        m44At: function m44AtFn(m, dst) {
            if (dst === undefined) {
                return m.slice(8, 12)
            }
            dst[0] = m[8];
            dst[1] = m[9];
            dst[2] = m[10];
            dst[3] = m[11];
            return dst
        },
        m44Pos: function m44PosFn(m, dst) {
            if (dst === undefined) {
                return m.slice(12)
            }
            dst[0] = m[12];
            dst[1] = m[13];
            dst[2] = m[14];
            dst[3] = m[15];
            return dst
        },
        m44SetRight: function m44SetRightFn(m, v) {
            m[0] = v[0];
            m[1] = v[1];
            m[2] = v[2];
            m[3] = v[3]
        },
        m44SetUp: function m44SetUpFn(m, v) {
            m[4] = v[0];
            m[5] = v[1];
            m[6] = v[2];
            m[7] = v[3]
        },
        m44SetAt: function m44SetAtFn(m, v) {
            m[8] = v[0];
            m[9] = v[1];
            m[10] = v[2];
            m[11] = v[3]
        },
        m44SetPos: function m44SetPosFn(m, v) {
            m[12] = v[0];
            m[13] = v[1];
            m[14] = v[2];
            m[15] = v[3]
        },
        m44Translate: function m44TranslateFn(m, v) {
            m[12] += v[0];
            m[13] += v[1];
            m[14] += v[2];
            m[15] += v[3]
        },
        m44Scale: function m44ScaleFn(m, scale, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(16)
            }
            dst[0] = m[0] * scale[0];
            dst[1] = m[1] * scale[0];
            dst[2] = m[2] * scale[0];
            dst[3] = m[3];
            dst[4] = m[4] * scale[1];
            dst[5] = m[5] * scale[1];
            dst[6] = m[6] * scale[1];
            dst[7] = m[7];
            dst[8] = m[8] * scale[2];
            dst[9] = m[9] * scale[2];
            dst[10] = m[10] * scale[2];
            dst[11] = m[11];
            dst[12] = m[12];
            dst[13] = m[13];
            dst[14] = m[14];
            dst[15] = m[15];
            return dst
        },
        m44Transform: function m44TransformFn(m, v, dst) {
            var v0 = v[0];
            var v1 = v[1];
            var v2 = v[2];
            var v3 = v[3];
            if (dst === undefined) {
                dst = new VMathArrayConstructor(4)
            }
            if (v3 !== 1) {
                dst[0] = m[0] * v0 + m[4] * v1 + m[8] * v2 + m[12] * v3;
                dst[1] = m[1] * v0 + m[5] * v1 + m[9] * v2 + m[13] * v3;
                dst[2] = m[2] * v0 + m[6] * v1 + m[10] * v2 + m[14] * v3;
                dst[3] = m[3] * v0 + m[7] * v1 + m[11] * v2 + m[15] * v3
            } else {
                dst[0] = m[0] * v0 + m[4] * v1 + m[8] * v2 + m[12];
                dst[1] = m[1] * v0 + m[5] * v1 + m[9] * v2 + m[13];
                dst[2] = m[2] * v0 + m[6] * v1 + m[10] * v2 + m[14];
                dst[3] = m[3] * v0 + m[7] * v1 + m[11] * v2 + m[15]
            }
            return dst
        },
        m44Mul: function m44MulFn(a, b, dst) {
            var a0 = a[0];
            var a1 = a[1];
            var a2 = a[2];
            var a3 = a[3];
            var a4 = a[4];
            var a5 = a[5];
            var a6 = a[6];
            var a7 = a[7];
            var a8 = a[8];
            var a9 = a[9];
            var a10 = a[10];
            var a11 = a[11];
            var a12 = a[12];
            var a13 = a[13];
            var a14 = a[14];
            var a15 = a[15];
            var b0 = b[0];
            var b1 = b[1];
            var b2 = b[2];
            var b3 = b[3];
            var b4 = b[4];
            var b5 = b[5];
            var b6 = b[6];
            var b7 = b[7];
            var b8 = b[8];
            var b9 = b[9];
            var b10 = b[10];
            var b11 = b[11];
            var b12 = b[12];
            var b13 = b[13];
            var b14 = b[14];
            var b15 = b[15];
            if (dst === undefined) {
                dst = new VMathArrayConstructor(16)
            }
            dst[0] = b0 * a0 + b4 * a1 + b8 * a2 + b12 * a3;
            dst[1] = b1 * a0 + b5 * a1 + b9 * a2 + b13 * a3;
            dst[2] = b2 * a0 + b6 * a1 + b10 * a2 + b14 * a3;
            dst[3] = b3 * a0 + b7 * a1 + b11 * a2 + b15 * a3;
            dst[4] = b0 * a4 + b4 * a5 + b8 * a6 + b12 * a7;
            dst[5] = b1 * a4 + b5 * a5 + b9 * a6 + b13 * a7;
            dst[6] = b2 * a4 + b6 * a5 + b10 * a6 + b14 * a7;
            dst[7] = b3 * a4 + b7 * a5 + b11 * a6 + b15 * a7;
            dst[8] = b0 * a8 + b4 * a9 + b8 * a10 + b12 * a11;
            dst[9] = b1 * a8 + b5 * a9 + b9 * a10 + b13 * a11;
            dst[10] = b2 * a8 + b6 * a9 + b10 * a10 + b14 * a11;
            dst[11] = b3 * a8 + b7 * a9 + b11 * a10 + b15 * a11;
            dst[12] = b0 * a12 + b4 * a13 + b8 * a14 + b12 * a15;
            dst[13] = b1 * a12 + b5 * a13 + b9 * a14 + b13 * a15;
            dst[14] = b2 * a12 + b6 * a13 + b10 * a14 + b14 * a15;
            dst[15] = b3 * a12 + b7 * a13 + b11 * a14 + b15 * a15;
            return dst
        },
        m44Inverse: function m44InverseFn(m, dst) {
            var m0 = m[0];
            var m1 = m[1];
            var m2 = m[2];
            var m3 = m[3];
            var m4 = m[4];
            var m5 = m[5];
            var m6 = m[6];
            var m7 = m[7];
            var m8 = m[8];
            var m9 = m[9];
            var m10 = m[10];
            var m11 = m[11];
            var m12 = m[12];
            var m13 = m[13];
            var m14 = m[14];
            var m15 = m[15];
            if (dst === undefined) {
                dst = new VMathArrayConstructor(16)
            }
            var A0 = m0 * m5 - m1 * m4;
            var A1 = m0 * m6 - m2 * m4;
            var A2 = m0 * m7 - m3 * m4;
            var A3 = m1 * m6 - m2 * m5;
            var A4 = m1 * m7 - m3 * m5;
            var A5 = m2 * m7 - m3 * m6;
            var B0 = m8 * m13 - m9 * m12;
            var B1 = m8 * m14 - m10 * m12;
            var B2 = m8 * m15 - m11 * m12;
            var B3 = m9 * m14 - m10 * m13;
            var B4 = m9 * m15 - m11 * m13;
            var B5 = m10 * m15 - m11 * m14;
            var det = A0 * B5 - A1 * B4 + A2 * B3 + A3 * B2 - A4 * B1 + A5 * B0;
            if (det === 0) {
                dst[0] = 0;
                dst[1] = 0;
                dst[2] = 0;
                dst[3] = 0;
                dst[4] = 0;
                dst[5] = 0;
                dst[6] = 0;
                dst[7] = 0;
                dst[8] = 0;
                dst[9] = 0;
                dst[10] = 0;
                dst[11] = 0;
                dst[12] = 0;
                dst[13] = 0;
                dst[14] = 0;
                dst[15] = 0
            } else {
                var detrecp = 1 / det;
                dst[0] = (+(m5 * B5) - m6 * B4 + m7 * B3) * detrecp;
                dst[4] = (-(m4 * B5) + m6 * B2 - m7 * B1) * detrecp;
                dst[8] = (+(m4 * B4) - m5 * B2 + m7 * B0) * detrecp;
                dst[12] = (-(m4 * B3) + m5 * B1 - m6 * B0) * detrecp;
                dst[1] = (-(m1 * B5) + m2 * B4 - m3 * B3) * detrecp;
                dst[5] = (+(m0 * B5) - m2 * B2 + m3 * B1) * detrecp;
                dst[9] = (-(m0 * B4) + m1 * B2 - m3 * B0) * detrecp;
                dst[13] = (+(m0 * B3) - m1 * B1 + m2 * B0) * detrecp;
                dst[2] = (+(m13 * A5) - m14 * A4 + m15 * A3) * detrecp;
                dst[6] = (-(m12 * A5) + m14 * A2 - m15 * A1) * detrecp;
                dst[10] = (+(m12 * A4) - m13 * A2 + m15 * A0) * detrecp;
                dst[14] = (-(m12 * A3) + m13 * A1 - m14 * A0) * detrecp;
                dst[3] = (-(m9 * A5) + m10 * A4 - m11 * A3) * detrecp;
                dst[7] = (+(m8 * A5) - m10 * A2 + m11 * A1) * detrecp;
                dst[11] = (-(m8 * A4) + m9 * A2 - m11 * A0) * detrecp;
                dst[15] = (+(m8 * A3) - m9 * A1 + m10 * A0) * detrecp
            }
            return dst
        },
        m44Transpose: function m44TransposeFn(m, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(16)
            }
            dst[0] = m[0];
            dst[1] = m[4];
            dst[2] = m[8];
            dst[3] = m[12];
            dst[4] = m[1];
            dst[5] = m[5];
            dst[6] = m[9];
            dst[7] = m[13];
            dst[8] = m[2];
            dst[9] = m[6];
            dst[10] = m[10];
            dst[11] = m[14];
            dst[12] = m[3];
            dst[13] = m[7];
            dst[14] = m[11];
            dst[15] = m[15];
            return dst
        },
        m44ScalarAdd: function m44ScalarAddFn(m, s, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(16)
            }
            for (var n = 0; n < 16; n += 1) {
                dst[n] = m[n] + s
            }
            return dst
        },
        m44ScalarSub: function m44ScalarSubFn(m, s, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(16)
            }
            for (var n = 0; n < 16; n += 1) {
                dst[n] = m[n] - s
            }
            return dst
        },
        m44ScalarMul: function m44ScalarMulFn(m, s, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(16)
            }
            for (var n = 0; n < 16; n += 1) {
                dst[n] = m[n] * s
            }
            return dst
        },
        quatBuild: function quatBuildFn(x, y, z, w, dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(4)
            }
            res[0] = x;
            res[1] = y;
            res[2] = z;
            res[3] = w;
            return res
        },
        quatCopy: function quatCopyFn(src, dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(4)
            }
            res[0] = src[0];
            res[1] = src[1];
            res[2] = src[2];
            res[3] = src[3];
            return res
        },
        quatIsSimilar: function quatIsSimilarFn(q1, q2, precision) {
            if (precision === undefined) {
                precision = this.precision
            }
            var q1temp = q1;
            if (q1[3] * q2[3] < 0) {
                q1temp = VMath.v4Neg(q1)
            }
            var mag_sqrd = VMath.v4LengthSq(VMath.v4Sub(q1temp, q2));
            var epsilon_sqrd = precision * precision;
            return mag_sqrd < epsilon_sqrd
        },
        quatLength: function quatLengthFn(q) {
            return VMath.v4Length(q)
        },
        quatDot: function quatDotFn(q1, q2) {
            return VMath.v4Dot(q1, q2)
        },
        quatMul: function quatMulFn(q1, q2, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(4)
            }
            var q2x = q1[0];
            var q2y = q1[1];
            var q2z = q1[2];
            var q2w = q1[3];
            var q1x = q2[0];
            var q1y = q2[1];
            var q1z = q2[2];
            var q1w = q2[3];
            var cx = q1z * q2y - q1y * q2z;
            var cy = q1x * q2z - q1z * q2x;
            var cz = q1y * q2x - q1x * q2y;
            dst[0] = q2x * q1w + q1x * q2w + cx;
            dst[1] = q2y * q1w + q1y * q2w + cy;
            dst[2] = q2z * q1w + q1z * q2w + cz;
            dst[3] = q1w * q2w - (q1x * q2x + q1y * q2y + q1z * q2z);
            return dst
        },
        quatMulTranslate: function quatMulTranslateFn(qa, va, qb, vb, qr, vr) {
            var qax = qa[0];
            var qay = qa[1];
            var qaz = qa[2];
            var qaw = qa[3];
            var qbx = qb[0];
            var qby = qb[1];
            var qbz = qb[2];
            var qbw = qb[3];
            var cx = qaz * qby - qay * qbz;
            var cy = qax * qbz - qaz * qbx;
            var cz = qay * qbx - qax * qby;
            qr[0] = qbx * qaw + qax * qbw + cx;
            qr[1] = qby * qaw + qay * qbw + cy;
            qr[2] = qbz * qaw + qaz * qbw + cz;
            qr[3] = qaw * qbw - (qax * qbx + qay * qby + qaz * qbz);
            var vax = va[0];
            var vay = va[1];
            var vaz = va[2];
            var vbx = vb[0];
            var vby = vb[1];
            var vbz = vb[2];
            var s = qaw * qaw - (qax * qax + qay * qay + qaz * qaz);
            var rx = vbx * s;
            var ry = vby * s;
            var rz = vbz * s;
            s = qax * vbx + qay * vby + qaz * vbz;
            var twoS = s + s;
            rx += qax * twoS;
            ry += qay * twoS;
            rz += qaz * twoS;
            cx = qaz * vby - qay * vbz;
            cy = qax * vbz - qaz * vbx;
            cz = qay * vbx - qax * vby;
            var twoQw = qaw + qaw;
            rx += cx * twoQw;
            ry += cy * twoQw;
            rz += cz * twoQw;
            vr[0] = rx + vax;
            vr[1] = ry + vay;
            vr[2] = rz + vaz
        },
        quatNormalize: function quatNormalizeFn(q, dst) {
            var norme = VMath.quatDot(q, q);
            if (norme === 0) {
                return VMath.v4BuildZero(dst)
            } else {
                var recip = 1 / Math.sqrt(norme);
                return VMath.v4ScalarMul(q, recip, dst)
            }
        },
        quatConjugate: function quatConjugateFn(q, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(4)
            }
            dst[0] = -q[0];
            dst[1] = -q[1];
            dst[2] = -q[2];
            dst[3] = q[3];
            return dst
        },
        quatLerp: function quatLerpFn(q1, q2, t, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(4)
            }
            var q1x = q1[0];
            var q1y = q1[1];
            var q1z = q1[2];
            var q1w = q1[3];
            var q2x = q2[0];
            var q2y = q2[1];
            var q2z = q2[2];
            var q2w = q2[3];
            dst[0] = (q2x - q1x) * t + q1x;
            dst[1] = (q2y - q1y) * t + q1y;
            dst[2] = (q2z - q1z) * t + q1z;
            dst[3] = (q2w - q1w) * t + q1w;
            return dst
        },
        cosMinSlerpAngle: Math.cos(Math.PI / 40),
        quatSlerp: function quatSlerpFn(q1, q2, t, dst) {
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(4)
            }
            var q1x = q1[0];
            var q1y = q1[1];
            var q1z = q1[2];
            var q1w = q1[3];
            var q2x = q2[0];
            var q2y = q2[1];
            var q2z = q2[2];
            var q2w = q2[3];
            var dotq1q2 = q1x * q2x + q1y * q2y + q1z * q2z + q1w * q2w;
            var cosom = dotq1q2;
            if (cosom < 0) {
                q1x = -q1x;
                q1y = -q1y;
                q1z = -q1z;
                q1w = -q1w;
                cosom = -cosom
            }
            if (cosom > VMath.cosMinSlerpAngle) {
                if (cosom > 1 - 1e-6) {
                    res[0] = q1x;
                    res[1] = q1y;
                    res[2] = q1z;
                    res[3] = q1w;
                    return res
                }
                var delta = t;
                if (dotq1q2 <= 0) {
                    delta = -t
                }
                var qrx = (q2x - q1x) * delta + q1x;
                var qry = (q2y - q1y) * delta + q1y;
                var qrz = (q2z - q1z) * delta + q1z;
                var qrw = (q2w - q1w) * delta + q1w;
                var mag = Math.sqrt(qrx * qrx + qry * qry + qrz * qrz + qrw * qrw);
                var recip = 1 / mag;
                res[0] = qrx * recip;
                res[1] = qry * recip;
                res[2] = qrz * recip;
                res[3] = qrw * recip;
                return res
            }
            var sinFn = Math.sin;
            var omega = Math.acos(cosom);
            var inv_sin_omega = 1 / sinFn(omega);
            var scalar = sinFn((1 - t) * omega) * inv_sin_omega;
            q1x = q1x * scalar;
            q1y = q1y * scalar;
            q1z = q1z * scalar;
            q1w = q1w * scalar;
            scalar = sinFn(t * omega) * inv_sin_omega;
            q2x = q2x * scalar;
            q2y = q2y * scalar;
            q2z = q2z * scalar;
            q2w = q2w * scalar;
            res[0] = q1x + q2x;
            res[1] = q1y + q2y;
            res[2] = q1z + q2z;
            res[3] = q1w + q2w;
            return res
        },
        quatFromM43: function quatFromM43Fn(m, dst) {
            var m0 = m[0];
            var m1 = m[1];
            var m2 = m[2];
            var m3 = m[3];
            var m4 = m[4];
            var m5 = m[5];
            var m6 = m[6];
            var m7 = m[7];
            var m8 = m[8];
            var x, y, z, w, s;
            var trace = m0 + m4 + m8 + 1;
            if (trace > VMath.precision) {
                w = Math.sqrt(trace) / 2;
                x = (m5 - m7) / (4 * w);
                y = (m6 - m2) / (4 * w);
                z = (m1 - m3) / (4 * w)
            } else {
                if (m0 > m4 && m0 > m8) {
                    s = Math.sqrt(1 + m0 - m4 - m8) * 2;
                    w = (m5 - m7) / s;
                    x = .25 * s;
                    y = (m3 + m1) / s;
                    z = (m6 + m2) / s
                } else if (m4 > m8) {
                    s = Math.sqrt(1 + m4 - m0 - m8) * 2;
                    w = (m6 - m2) / s;
                    x = (m3 + m1) / s;
                    y = .25 * s;
                    z = (m7 + m5) / s
                } else {
                    s = Math.sqrt(1 + m8 - m0 - m4) * 2;
                    w = (m1 - m3) / s;
                    x = (m6 + m2) / s;
                    y = (m7 + m5) / s;
                    z = .25 * s
                }
            }
            var q = VMath.quatNormalize([x, y, z, w], dst);
            return VMath.quatConjugate(q, dst)
        },
        quatFromAxisRotation: function quatFromAxisRotationFn(axis, angle, dst) {
            var omega = .5 * angle;
            var s = Math.sin(omega);
            var c = Math.cos(omega);
            var res = dst;
            if (res === undefined) {
                res = new VMathArrayConstructor(4)
            }
            res[0] = axis[0] * s;
            res[1] = axis[1] * s;
            res[2] = axis[2] * s;
            res[3] = c;
            return VMath.quatNormalize(res, res)
        },
        quatToAxisRotation: function quatToAxisRotation(q, dst) {
            if (dst === undefined) {
                dst = new VMathArrayConstructor(4)
            }
            var q3 = q[3];
            var angle = Math.acos(q3) * 2;
            var sin_sqrd = 1 - q3 * q3;
            if (sin_sqrd < VMath.precision) {
                dst[0] = 1;
                dst[1] = 0;
                dst[2] = 0;
                dst[3] = angle
            } else {
                var scale = 1 / Math.sqrt(sin_sqrd);
                dst[0] = q[0] * scale;
                dst[1] = q[1] * scale;
                dst[2] = q[2] * scale;
                dst[3] = angle
            }
            return dst
        },
        quatTransformVector: function quatTransformVectorFn(q, v, dst) {
            var qx = q[0];
            var qy = q[1];
            var qz = q[2];
            var qw = q[3];
            var vx = v[0];
            var vy = v[1];
            var vz = v[2];
            var s = qw * qw - (qx * qx + qy * qy + qz * qz);
            var rx = vx * s;
            var ry = vy * s;
            var rz = vz * s;
            s = qx * vx + qy * vy + qz * vz;
            var twoS = s + s;
            rx += qx * twoS;
            ry += qy * twoS;
            rz += qz * twoS;
            var cx = qz * vy - qy * vz;
            var cy = qx * vz - qz * vx;
            var cz = qy * vx - qx * vy;
            var twoQw = qw + qw;
            rx += cx * twoQw;
            ry += cy * twoQw;
            rz += cz * twoQw;
            if (dst === undefined) {
                dst = new VMathArrayConstructor(3)
            }
            dst[0] = rx;
            dst[1] = ry;
            dst[2] = rz;
            return dst
        },
        quatEqual: function quatEqual(q1, q2, precision) {
            if (precision === undefined) {
                precision = this.precision
            }
            var abs = Math.abs;
            return abs(q1[0] - q2[0]) <= precision && abs(q1[1] - q2[1]) <= precision && abs(q1[2] - q2[2]) <= precision && abs(q1[3] - q2[3]) <= precision
        },
        quatPosBuild: function quatPosBuildFn(x, y, z, w, px, py, pz, dst) {
            var res;
            if (arguments.length < 7) {
                res = z;
                if (res === undefined) {
                    res = new VMathArrayConstructor(7)
                }
                res[0] = x[0];
                res[1] = x[1];
                res[2] = x[2];
                res[3] = x[3];
                res[4] = y[0];
                res[5] = y[1];
                res[6] = y[2]
            } else {
                res = dst;
                if (res === undefined) {
                    res = new VMathArrayConstructor(7)
                }
                res[0] = x;
                res[1] = y;
                res[2] = z;
                res[3] = w;
                res[4] = px;
                res[5] = py;
                res[6] = pz
            }
            return res
        },
        quatPosTransformVector: function quatPosTransformVectorFn(qp, n, dst) {
            return VMath.quatTransformVector(qp, n, dst)
        },
        quatPosTransformPoint: function quatPosTransformPointFn(qp, p) {
            var offset = qp.slice(4, 7);
            var rotatedp = VMath.quatTransformVector(qp, p);
            return VMath.v3Add(rotatedp, offset)
        },
        quatPosMul: function quatPosMulFn(qp1, qp2) {
            var v2 = qp2.slice(4, 7);
            var qr = VMath.quatMul(qp1, qp2);
            var pr = VMath.quatPosTransformPoint(qp1, v2);
            qr[4] = pr[0];
            qr[5] = pr[1];
            qr[6] = pr[2];
            return qr
        },
        isVisibleBox: function isVisibleBoxFn(center, halfDimensions, vpm) {
            var abs = Math.abs;
            var c0 = center[0];
            var c1 = center[1];
            var c2 = center[2];
            var h0 = halfDimensions[0];
            var h1 = halfDimensions[1];
            var h2 = halfDimensions[2];
            var m0 = vpm[0];
            var m1 = vpm[1];
            var m2 = vpm[2];
            var m3 = vpm[3];
            var m4 = vpm[4];
            var m5 = vpm[5];
            var m6 = vpm[6];
            var m7 = vpm[7];
            var m8 = vpm[8];
            var m9 = vpm[9];
            var m10 = vpm[10];
            var m11 = vpm[11];
            var I0 = m0 * h0;
            var I1 = m1 * h0;
            var I2 = m2 * h0;
            var I3 = m3 * h0;
            var J0 = m4 * h1;
            var J1 = m5 * h1;
            var J2 = m6 * h1;
            var J3 = m7 * h1;
            var K0 = m8 * h2;
            var K1 = m9 * h2;
            var K2 = m10 * h2;
            var K3 = m11 * h2;
            var T0 = m0 * c0 + m4 * c1 + m8 * c2 + vpm[12];
            var T1 = m1 * c0 + m5 * c1 + m9 * c2 + vpm[13];
            var T2 = m2 * c0 + m6 * c1 + m10 * c2 + vpm[14];
            var T3 = m3 * c0 + m7 * c1 + m11 * c2 + vpm[15];
            return !(T0 - T3 > abs(I0 - I3) + abs(J0 - J3) + abs(K0 - K3) || T0 + T3 < -(abs(I0 + I3) + abs(J0 + J3) + abs(K0 + K3)) || T1 - T3 > abs(I1 - I3) + abs(J1 - J3) + abs(K1 - K3) || T1 + T3 < -(abs(I1 + I3) + abs(J1 + J3) + abs(K1 + K3)) || T2 - T3 > abs(I2 - I3) + abs(J2 - J3) + abs(K2 - K3) || T2 + T3 < -(abs(I2 + I3) + abs(J2 + J3) + abs(K2 + K3)) || T3 + T3 < -(abs(I3 + I3) + abs(J3 + J3) + abs(K3 + K3)))
        },
        isVisibleBoxOrigin: function isVisibleBoxOriginFn(halfDimensions, vpm) {
            var abs = Math.abs;
            var h0 = halfDimensions[0];
            var h1 = halfDimensions[1];
            var h2 = halfDimensions[2];
            var I0 = vpm[0] * h0;
            var I1 = vpm[1] * h0;
            var I2 = vpm[2] * h0;
            var I3 = vpm[3] * h0;
            var J0 = vpm[4] * h1;
            var J1 = vpm[5] * h1;
            var J2 = vpm[6] * h1;
            var J3 = vpm[7] * h1;
            var K0 = vpm[8] * h2;
            var K1 = vpm[9] * h2;
            var K2 = vpm[10] * h2;
            var K3 = vpm[11] * h2;
            var T0 = vpm[12];
            var T1 = vpm[13];
            var T2 = vpm[14];
            var T3 = vpm[15];
            return !(T0 - T3 > abs(I0 - I3) + abs(J0 - J3) + abs(K0 - K3) || T0 + T3 < -(abs(I0 + I3) + abs(J0 + J3) + abs(K0 + K3)) || T1 - T3 > abs(I1 - I3) + abs(J1 - J3) + abs(K1 - K3) || T1 + T3 < -(abs(I1 + I3) + abs(J1 + J3) + abs(K1 + K3)) || T2 - T3 > abs(I2 - I3) + abs(J2 - J3) + abs(K2 - K3) || T2 + T3 < -(abs(I2 + I3) + abs(J2 + J3) + abs(K2 + K3)) || T3 + T3 < -(abs(I3 + I3) + abs(J3 + J3) + abs(K3 + K3)))
        },
        isVisibleSphere: function isVisibleSphereFn(center, radius, vpm) {
            var abs = Math.abs;
            var c0 = center[0];
            var c1 = center[1];
            var c2 = center[2];
            var m0 = vpm[0];
            var m1 = vpm[1];
            var m2 = vpm[2];
            var m3 = vpm[3];
            var m4 = vpm[4];
            var m5 = vpm[5];
            var m6 = vpm[6];
            var m7 = vpm[7];
            var m8 = vpm[8];
            var m9 = vpm[9];
            var m10 = vpm[10];
            var m11 = vpm[11];
            var I0 = m0;
            var I1 = m1;
            var I2 = m2;
            var I3 = m3;
            var J0 = m4;
            var J1 = m5;
            var J2 = m6;
            var J3 = m7;
            var K0 = m8;
            var K1 = m9;
            var K2 = m10;
            var K3 = m11;
            var T0 = m0 * c0 + m4 * c1 + m8 * c2 + vpm[12];
            var T1 = m1 * c0 + m5 * c1 + m9 * c2 + vpm[13];
            var T2 = m2 * c0 + m6 * c1 + m10 * c2 + vpm[14];
            var T3 = m3 * c0 + m7 * c1 + m11 * c2 + vpm[15];
            var nradius = -radius;
            return !(T0 - T3 > radius * (abs(I0 - I3) + abs(J0 - J3) + abs(K0 - K3)) || T0 + T3 < nradius * (abs(I0 + I3) + abs(J0 + J3) + abs(K0 + K3)) || T1 - T3 > radius * (abs(I1 - I3) + abs(J1 - J3) + abs(K1 - K3)) || T1 + T3 < nradius * (abs(I1 + I3) + abs(J1 + J3) + abs(K1 + K3)) || T2 - T3 > radius * (abs(I2 - I3) + abs(J2 - J3) + abs(K2 - K3)) || T2 + T3 < nradius * (abs(I2 + I3) + abs(J2 + J3) + abs(K2 + K3)) || T3 + T3 < nradius * (abs(I3 + I3) + abs(J3 + J3) + abs(K3 + K3)))
        },
        isVisibleSphereOrigin: function isVisibleSphereOriginFn(radius, vpm) {
            var abs = Math.abs;
            var I0 = vpm[0];
            var I1 = vpm[1];
            var I2 = vpm[2];
            var I3 = vpm[3];
            var J0 = vpm[4];
            var J1 = vpm[5];
            var J2 = vpm[6];
            var J3 = vpm[7];
            var K0 = vpm[8];
            var K1 = vpm[9];
            var K2 = vpm[10];
            var K3 = vpm[11];
            var T0 = vpm[12];
            var T1 = vpm[13];
            var T2 = vpm[14];
            var T3 = vpm[15];
            var nradius = -radius;
            return !(T0 - T3 > radius * (abs(I0 - I3) + abs(J0 - J3) + abs(K0 - K3)) || T0 + T3 < nradius * (abs(I0 + I3) + abs(J0 + J3) + abs(K0 + K3)) || T1 - T3 > radius * (abs(I1 - I3) + abs(J1 - J3) + abs(K1 - K3)) || T1 + T3 < nradius * (abs(I1 + I3) + abs(J1 + J3) + abs(K1 + K3)) || T2 - T3 > radius * (abs(I2 - I3) + abs(J2 - J3) + abs(K2 - K3)) || T2 + T3 < nradius * (abs(I2 + I3) + abs(J2 + J3) + abs(K2 + K3)) || T3 + T3 < nradius * (abs(I3 + I3) + abs(J3 + J3) + abs(K3 + K3)))
        },
        isVisibleSphereUnit: function isVisibleSphereUnitFn(vpm) {
            var abs = Math.abs;
            var I0 = vpm[0];
            var I1 = vpm[1];
            var I2 = vpm[2];
            var I3 = vpm[3];
            var J0 = vpm[4];
            var J1 = vpm[5];
            var J2 = vpm[6];
            var J3 = vpm[7];
            var K0 = vpm[8];
            var K1 = vpm[9];
            var K2 = vpm[10];
            var K3 = vpm[11];
            var T0 = vpm[12];
            var T1 = vpm[13];
            var T2 = vpm[14];
            var T3 = vpm[15];
            return !(T0 - T3 > abs(I0 - I3) + abs(J0 - J3) + abs(K0 - K3) || T0 + T3 < -(abs(I0 + I3) + abs(J0 + J3) + abs(K0 + K3)) || T1 - T3 > abs(I1 - I3) + abs(J1 - J3) + abs(K1 - K3) || T1 + T3 < -(abs(I1 + I3) + abs(J1 + J3) + abs(K1 + K3)) || T2 - T3 > abs(I2 - I3) + abs(J2 - J3) + abs(K2 - K3) || T2 + T3 < -(abs(I2 + I3) + abs(J2 + J3) + abs(K2 + K3)) || T3 + T3 < -(abs(I3 + I3) + abs(J3 + J3) + abs(K3 + K3)))
        },
        transformBox: function transformBoxFn(center, halfExtents, matrix) {
            var abs = Math.abs;
            var m0 = matrix[0];
            var m1 = matrix[1];
            var m2 = matrix[2];
            var m3 = matrix[3];
            var m4 = matrix[4];
            var m5 = matrix[5];
            var m6 = matrix[6];
            var m7 = matrix[7];
            var m8 = matrix[8];
            var c0 = center[0];
            var c1 = center[1];
            var c2 = center[2];
            var h0 = halfExtents[0];
            var h1 = halfExtents[1];
            var h2 = halfExtents[2];
            var out_center = new VMathArrayConstructor(3);
            out_center[0] = m0 * c0 + m3 * c1 + m6 * c2 + matrix[9];
            out_center[1] = m1 * c0 + m4 * c1 + m7 * c2 + matrix[10];
            out_center[2] = m2 * c0 + m5 * c1 + m8 * c2 + matrix[11];
            var out_halfext = new VMathArrayConstructor(3);
            out_halfext[0] = abs(m0) * h0 + abs(m3) * h1 + abs(m6) * h2;
            out_halfext[1] = abs(m1) * h0 + abs(m4) * h1 + abs(m7) * h2;
            out_halfext[2] = abs(m2) * h0 + abs(m5) * h1 + abs(m8) * h2;
            return {
                center: out_center,
                halfExtents: out_center
            }
        },
        planeNormalize: function planeNormalizeFn(plane, output) {
            if (output === undefined) {
                output = new VMathArrayConstructor(4)
            }
            var a = plane[0];
            var b = plane[1];
            var c = plane[2];
            var lsq = a * a + b * b + c * c;
            if (lsq > 0) {
                var lr = 1 / Math.sqrt(lsq);
                output[0] = a * lr;
                output[1] = b * lr;
                output[2] = c * lr;
                output[3] = plane[3] * lr
            } else {
                output[0] = 0;
                output[1] = 0;
                output[2] = 0;
                output[3] = 0
            }
            return output
        },
        extractFrustumPlanes: function extractFrustumPlanesFn(m, p) {
            var planeNormalize = VMath.planeNormalize;
            var m0 = m[0];
            var m1 = m[1];
            var m2 = m[2];
            var m3 = m[3];
            var m4 = m[4];
            var m5 = m[5];
            var m6 = m[6];
            var m7 = m[7];
            var m8 = m[8];
            var m9 = m[9];
            var m10 = m[10];
            var m11 = m[11];
            var m12 = m[12];
            var m13 = m[13];
            var m14 = m[14];
            var m15 = m[15];
            var planes = p || [];
            planes[0] = planeNormalize([m3 + m0, m7 + m4, m11 + m8, -(m15 + m12)], planes[0]);
            planes[1] = planeNormalize([m3 - m0, m7 - m4, m11 - m8, -(m15 - m12)], planes[1]);
            planes[2] = planeNormalize([m3 - m1, m7 - m5, m11 - m9, -(m15 - m13)], planes[2]);
            planes[3] = planeNormalize([m3 + m1, m7 + m5, m11 + m9, -(m15 + m13)], planes[3]);
            planes[4] = planeNormalize([m3 + m2, m7 + m6, m11 + m10, -(m15 + m14)], planes[4]);
            planes[5] = planeNormalize([m3 - m2, m7 - m6, m11 - m10, -(m15 - m14)], planes[5]);
            return planes
        },
        isInsidePlanesPoint: function isInsidePlanesPointFn(p, planes) {
            var p0 = p[0];
            var p1 = p[1];
            var p2 = p[2];
            var numPlanes = planes.length;
            var n = 0;
            do {
                var plane = planes[n];
                if (plane[0] * p0 + plane[1] * p1 + plane[2] * p2 < plane[3]) {
                    return false
                }
                n += 1
            } while (n < numPlanes);
            return true
        },
        isInsidePlanesSphere: function isInsidePlanesSphereFn(c, r, planes) {
            var c0 = c[0];
            var c1 = c[1];
            var c2 = c[2];
            var numPlanes = planes.length;
            var n = 0;
            do {
                var plane = planes[n];
                if (plane[0] * c0 + plane[1] * c1 + plane[2] * c2 < plane[3] - r) {
                    return false
                }
                n += 1
            } while (n < numPlanes);
            return true
        },
        isInsidePlanesBox: function isInsidePlanesBoxFn(c, h, planes) {
            var c0 = c[0];
            var c1 = c[1];
            var c2 = c[2];
            var h0 = h[0];
            var h1 = h[1];
            var h2 = h[2];
            var p0 = c0 + h0;
            var p1 = c1 + h1;
            var p2 = c2 + h2;
            var n0 = c0 - h0;
            var n1 = c1 - h1;
            var n2 = c2 - h2;
            var numPlanes = planes.length;
            var n = 0;
            do {
                var plane = planes[n];
                var d0 = plane[0];
                var d1 = plane[1];
                var d2 = plane[2];
                if (d0 * (d0 < 0 ? n0 : p0) + d1 * (d1 < 0 ? n1 : p1) + d2 * (d2 < 0 ? n2 : p2) < plane[3]) {
                    return false
                }
                n += 1
            } while (n < numPlanes);
            return true
        },
        extractIntersectingPlanes: function extractIntersectingPlanesFn(extents, planes) {
            var n0 = extents[0];
            var n1 = extents[1];
            var n2 = extents[2];
            var p0 = extents[3];
            var p1 = extents[4];
            var p2 = extents[5];
            var numPlanes = planes.length;
            var p = [];
            var np = 0;
            var n = 0;
            do {
                var plane = planes[n];
                var d0 = plane[0];
                var d1 = plane[1];
                var d2 = plane[2];
                if (d0 * (d0 > 0 ? n0 : p0) + d1 * (d1 > 0 ? n1 : p1) + d2 * (d2 > 0 ? n2 : p2) < plane[3]) {
                    p[np] = plane;
                    np += 1
                }
                n += 1
            } while (n < numPlanes);
            return p
        }
    };
    if (typeof Float32Array !== "undefined") {
        var testVector = new Float32Array([1, 2, 3]);
        testVector[0] = VMath.FLOAT_MAX;
        VMath.FLOAT_MAX = testVector[0];
        VMathArrayConstructor = Float32Array
    }
    VMath.arrayConstructor = VMathArrayConstructor;
    if (TurbulenzEngine.hasOwnProperty("VMath")) {
        TurbulenzEngine.VMath = VMath
    }
    var Utilities = {
        skipAsserts: false,
        assert: function assertFn(test, message) {
            if (!test) {
                if (!this.skipAsserts) {
                    this.breakInDebugger.doesNotExist()
                }
            }
        },
        beget: function begetFn(o) {
            var F = function() {};
            F.prototype = o;
            return new F
        },
        log: function logFn(a, b) {
            var console = window.console;
            if (console) {
                switch (arguments.length) {
                    case 1:
                        console.log(arguments[0]);
                        break;
                    case 2:
                        console.log(arguments[0], arguments[1]);
                        break;
                    case 3:
                        console.log(arguments[0], arguments[1], arguments[2]);
                        break;
                    case 4:
                        console.log(arguments[0], arguments[1], arguments[2], arguments[3]);
                        break;
                    default:
                        var args = [].splice.call(arguments, 0);
                        console.log(args.join(" "));
                        break
                }
            }
        },
        nearestLowerPow2: function UtilitiesNearestLowerPow2(num) {
            num = num | num >>> 1;
            num = num | num >>> 2;
            num = num | num >>> 4;
            num = num | num >>> 8;
            num = num | num >>> 16;
            return num - (num >>> 1)
        },
        nearestUpperPow2: function UtilitiesNearestUpperPow2(num) {
            num = num - 1;
            num = num | num >>> 1;
            num = num | num >>> 2;
            num = num | num >>> 4;
            num = num | num >>> 8;
            num = num | num >>> 16;
            return num + 1
        },
        ajax: function utilitiesAjaxFn(params) {
            var requestText = "";
            var method = params.method;
            var data = params.data || {};
            var encrypted = params.encrypt;
            var signature = null;
            var url = params.url;
            var requestHandler = params.requestHandler;
            var callbackFn = params.callback;
            var withCredentials = params.enableCORSCredentials;
            if (encrypted) {
                data.requestUrl = url;
                var str = JSON.stringify(data);
                if (method === "POST") {
                    str = TurbulenzEngine.encrypt(str)
                }
                requestText += "data=" + encodeURIComponent(str) + "&";
                requestText += "gameSessionId=" + encodeURIComponent(data.gameSessionId);
                signature = TurbulenzEngine.generateSignature(str)
            } else if (data) {
                var key;
                for (key in data) {
                    if (data.hasOwnProperty(key)) {
                        if (requestText.length !== 0) {
                            requestText += "&"
                        }
                        requestText += encodeURIComponent(key) + "=" + encodeURIComponent(data[key])
                    }
                }
            }
            var httpResponseCallback = function httpResponseCallbackFn(xhrResponseText, xhrStatus) {
                var xhr = this.xhr;
                this.xhr.onreadystatechange = null;
                this.xhr = null;
                
                    var response = JSON.parse(xhrResponseText);
                    if (encrypted) {
                        var sig = xhr.getResponseHeader("X-TZ-Signature");
                        var validSignature = TurbulenzEngine.verifySignature(xhrResponseText, sig);
                        xhrResponseText = null;
                        TurbulenzEngine.setTimeout(function() {
                            var receivedUrl = response.requestUrl;
                            if (validSignature) {
                                if (!TurbulenzEngine.encryptionEnabled || receivedUrl === url) {
                                    callbackFn(response, xhrStatus);
                                    callbackFn = null;
                                    return
                                }
                            }
                            if (xhrStatus === 400) {
                                callbackFn(response, xhrStatus, "Verification Failed")
                            } else {
                                callbackFn({
                                    msg: "Verification failed",
                                    ok: false
                                }, 400, "Verification Failed")
                            }
                            callbackFn = null
                        }, 0)
                    } else {
                        xhrResponseText = null;
                        TurbulenzEngine.setTimeout(function() {
                            callbackFn(response, xhrStatus);
                            callbackFn = null
                        }, 0)
                    }
                
            };
            var httpRequest = function httpRequestFn(url, onload, callContext) {
                var xhr;
                if (window.XMLHttpRequest) {
                    xhr = new window.XMLHttpRequest;
                    if (withCredentials && "withCredentials" in xhr) {
                        xhr.withCredentials = true
                    }
                } else if (window.ActiveXObject) {
                    xhr = new window.ActiveXObject("Microsoft.XMLHTTP")
                } else {
                    if (params.error) {
                        params.error("No XMLHTTPRequest object could be created")
                    }
                    return
                }
                callContext.xhr = xhr;
                var httpCallback = function httpCallbackFn() {
                    if (xhr.readyState === 4 && TurbulenzEngine && !TurbulenzEngine.isUnloading()) {
                        var xhrResponseText = xhr.responseText;
                        var xhrStatus = xhr.status;
                        var xhrStatusText = xhrStatus !== 0 && xhr.statusText || "No connection or cross domain request";
                        if (xhr.getAllResponseHeaders() === "" && xhrResponseText === "" && xhrStatus === 200 && xhrStatusText === "OK") {
                            onload("", 0);
                            return
                        }
                        onload.call(callContext, xhrResponseText, xhrStatus)
                    }
                };
                xhr.open(method, requestText && method !== "POST" ? url + "?" + requestText : url, true);
                if (callbackFn) {
                    xhr.onreadystatechange = httpCallback
                }
                if (signature) {
                    xhr.setRequestHeader("X-TZ-Signature", signature)
                }
                if (method === "POST") {
                    xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8");
                    xhr.send(requestText)
                } else {
                    xhr.send()
                }
            };
            if (requestHandler) {
                requestHandler.request({
                    src: url,
                    requestFn: httpRequest,
                    responseFilter: params.responseFilter,
                    onload: httpResponseCallback
                })
            } else {
                var callContext = {
                    src: url
                };
                httpRequest(url, httpResponseCallback, callContext)
            }
        },
        ajaxStatusCodes: {
            0: "No Connection, Timeout Or Cross Domain Request",
            100: "Continue",
            101: "Switching Protocols",
            200: "OK",
            201: "Created",
            202: "Accepted",
            203: "Non-Authoritative Information",
            204: "No Content",
            205: "Reset Content",
            206: "Partial Content",
            300: "Multiple Choices",
            301: "Moved Permanently",
            302: "Found",
            303: "See Other",
            304: "Not Modified",
            305: "Use Proxy",
            307: "Temporary Redirect",
            400: "Bad Request",
            401: "Unauthorized",
            402: "Payment Required",
            403: "Forbidden",
            404: "Not Found",
            405: "Method Not Allowed",
            406: "Not Acceptable",
            407: "Proxy Authentication Required",
            408: "Request Time-out",
            409: "Conflict",
            410: "Gone",
            411: "Length Required",
            412: "Precondition Failed",
            413: "Request Entity Too Large",
            414: "Request-URI Too Large",
            415: "Unsupported Media Type",
            416: "Requested range not satisfiable",
            417: "Expectation Failed",
            429: "Too Many Requests",
            480: "Temporarily Unavailable",
            500: "Internal Server Error",
            501: "Not Implemented",
            502: "Bad Gateway",
            503: "Service Unavailable",
            504: "Gateway Time-out",
            505: "HTTP Version not supported"
        }
    };
    var MathDeviceConvert = {
        v2ToArray: function v2ToJavaScriptArrayFn(v2) {
            return [v2[0], v2[1]]
        },
        arrayToV2: function arrayToV2Fn(mathDevice, v2Array, v2Dest) {
            return mathDevice.v2Build(v2Array[0], v2Array[1], v2Dest)
        },
        v3ToArray: function v3ToJavaScriptArrayFn(v3) {
            return [v3[0], v3[1], v3[2]]
        },
        arrayToV3: function arrayToV3Fn(mathDevice, v3Array, v3Dest) {
            return mathDevice.v3Build(v3Array[0], v3Array[1], v3Array[2], v3Dest)
        },
        v4ToArray: function v4ToJavaScriptArrayFn(v4) {
            return [v4[0], v4[1], v4[2], v4[3]]
        },
        arrayToV4: function arrayToV4Fn(mathDevice, v4Array, v4Dest) {
            return mathDevice.v4Build(v4Array[0], v4Array[1], v4Array[2], v4Array[3], v4Dest)
        },
        quatToArray: function quatToJavaScriptArrayFn(quat) {
            return [quat[0], quat[1], quat[2], quat[3]]
        },
        arrayToQuat: function arrayToQuatFn(mathDevice, quatArray, quatDest) {
            return mathDevice.quatBuild(quatArray[0], quatArray[1], quatArray[2], quatArray[3], quatDest)
        },
        aabbToArray: function aabbToJavaScriptArrayFn(aabb) {
            return [aabb[0], aabb[1], aabb[2], aabb[3], aabb[4], aabb[5]]
        },
        arrayToAABB: function arrayToQuatFn(mathDevice, aabbArray, aabbDest) {
            return mathDevice.aabbBuild(aabbArray[0], aabbArray[1], aabbArray[2], aabbArray[3], aabbArray[4], aabbArray[5], aabbDest)
        },
        quatPosToArray: function quatPosToJavaScriptArrayFn(quatPos) {
            return [quatPos[0], quatPos[1], quatPos[2], quatPos[3], quatPos[4], quatPos[5], quatPos[6]]
        },
        arrayToQuatPos: function arrayToQuatPosFn(mathDevice, quatPosArray, quatPosDest) {
            return mathDevice.quatPosBuild(quatPosArray[0], quatPosArray[1], quatPosArray[2], quatPosArray[3], quatPosArray[4], quatPosArray[5], quatPosArray[6], quatPosDest)
        },
        m33ToArray: function m33ToJavaScriptArrayFn(m33) {
            return [m33[0], m33[1], m33[2], m33[3], m33[4], m33[5], m33[6], m33[7], m33[8]]
        },
        arrayToM33: function arrayToM33Fn(mathDevice, m33Array, m33Dest) {
            return mathDevice.m33Build(m33Array[0], m33Array[1], m33Array[2], m33Array[3], m33Array[4], m33Array[5], m33Array[6], m33Array[7], m33Array[8], m33Dest)
        },
        m43ToArray: function m43ToJavaScriptArrayFn(m43) {
            return [m43[0], m43[1], m43[2], m43[3], m43[4], m43[5], m43[6], m43[7], m43[8], m43[9], m43[10], m43[11]]
        },
        arrayToM43: function arrayToM43Fn(mathDevice, m43Array, m43Dest) {
            return mathDevice.m43Build(m43Array[0], m43Array[1], m43Array[2], m43Array[3], m43Array[4], m43Array[5], m43Array[6], m43Array[7], m43Array[8], m43Array[9], m43Array[10], m43Array[11], m43Dest)
        },
        m34ToArray: function m34ToJavaScriptArrayFn(m34) {
            return [m34[0], m34[1], m34[2], m34[3], m34[4], m34[5], m34[6], m34[7], m34[8], m34[9], m34[10], m34[11]]
        },
        m44ToArray: function m44ToJavaScriptArrayFn(m44) {
            return [m44[0], m44[1], m44[2], m44[3], m44[4], m44[5], m44[6], m44[7], m44[8], m44[9], m44[10], m44[11], m44[12], m44[13], m44[14], m44[15]]
        },
        arrayToM44: function arrayToM44Fn(mathDevice, m44Array, m44Dest) {
            return mathDevice.m44Build(m44Array[0], m44Array[1], m44Array[2], m44Array[3], m44Array[4], m44Array[5], m44Array[6], m44Array[7], m44Array[8], m44Array[9], m44Array[10], m44Array[11], m44Array[12], m44Array[13], m44Array[14], m44Array[15], m44Dest)
        }
    };
    var Reference = function() {
        function Reference() {}
        Reference.prototype.add = function() {
            this.referenceCount += 1
        };
        Reference.prototype.remove = function() {
            this.referenceCount -= 1;
            if (this.referenceCount === 0) {
                if (this.destroyedObserver) {
                    this.destroyedObserver.notify(this.object)
                }
                this.object.destroy();
                this.object = null
            }
        };
        Reference.prototype.subscribeDestroyed = function(observerFunction) {
            if (!this.destroyedObserver) {
                this.destroyedObserver = Observer.create()
            }
            this.destroyedObserver.subscribe(observerFunction)
        };
        Reference.prototype.unsubscribeDestroyed = function(observerFunction) {
            this.destroyedObserver.unsubscribe(observerFunction)
        };
        Reference.create = function(object) {
            var result = new Reference;
            result.object = object;
            result.referenceCount = 0;
            return result
        };
        Reference.version = 1;
        return Reference
    }();
    var Profile = {
        profiles: {},
        sortMode: {
            alphabetical: 0,
            duration: 1,
            max: 2,
            min: 3,
            calls: 4
        },
        start: function profileStartFn(name) {
            var data = this.profiles[name];
            if (!data) {
                data = {
                    name: name,
                    calls: 0,
                    duration: 0,
                    min: Number.MAX_VALUE,
                    max: 0,
                    sumOfSquares: 0
                };
                this.profiles[name] = data
            }
            data.start = TurbulenzEngine.time
        },
        stop: function profileStopFn(name) {
            var end = TurbulenzEngine.time;
            var data = this.profiles[name];
            if (data) {
                var duration = end - data.start;
                data.duration += duration;
                data.calls += 1;
                data.sumOfSquares += duration * duration;
                if (duration > data.max) {
                    data.max = duration
                }
                if (duration < data.min) {
                    data.min = duration
                }
            }
        },
        reset: function profileResetFn() {
            this.profiles = {}
        },
        getReport: function profileGetReportFn(sortMode, format) {
            var dataArray = [];
            var data;
            var maxDuration = 0;
            var name;
            for (name in this.profiles) {
                if (this.profiles.hasOwnProperty(name)) {
                    data = this.profiles[name];
                    if (maxDuration < data.duration) {
                        maxDuration = data.duration
                    }
                    dataArray.push(data)
                }
            }
            var compareFunction;
            if (sortMode === Profile.sortMode.alphabetical) {
                compareFunction = function compareName(left, right) {
                    return left.name < right.name ? -1 : left.name > right.name ? 1 : 0
                }
            } else if (sortMode === Profile.sortMode.max) {
                compareFunction = function compareMax(left, right) {
                    return right.max - left.max
                }
            } else if (sortMode === Profile.sortMode.min) {
                compareFunction = function compareMin(left, right) {
                    return right.min - left.min
                }
            } else if (sortMode === Profile.sortMode.calls) {
                compareFunction = function compareCalls(left, right) {
                    return right.calls - left.calls
                }
            } else {
                compareFunction = function compareDuration(left, right) {
                    return right.duration - left.duration
                }
            }
            dataArray.sort(compareFunction);
            var line;
            var text = "";
            var precision = format ? format.precision : 8;
            var percentagePrecision = format ? format.percentagePrecision : 1;
            var seperator = format ? format.seperator : " ";
            var length = dataArray.length;
            var standardDeviation;
            var mean;
            var index;
            for (index = 0; index < length; index += 1) {
                data = dataArray[index];
                line = data.name;
                line += seperator + data.calls;
                line += seperator + data.duration.toFixed(precision);
                line += seperator + data.max.toFixed(precision);
                line += seperator + data.min.toFixed(precision);
                mean = data.duration / data.calls;
                line += seperator + mean.toFixed(precision);
                standardDeviation = Math.sqrt(data.sumOfSquares / data.calls - mean * mean);
                line += seperator + standardDeviation.toFixed(precision);
                line += seperator + (100 * data.duration / maxDuration).toFixed(percentagePrecision) + "%\n";
                text += line
            }
            return text
        }
    };
    var JSProfiling = {};
    JSProfiling.createArray = function JSProfilingCreateArrayFn(rootNode) {
        var map = {};
        var array = [];
        if (rootNode.head) {
            rootNode = rootNode.head
        }
        var processNode = function processNodeFn(node) {
            var urlObject = map[node.url];
            if (!urlObject) {
                urlObject = {};
                map[node.url] = urlObject
            }
            var functionName = node.functionName === "" ? "(anonymous)" : node.functionName;
            var functionObject = urlObject[functionName];
            if (!functionObject) {
                functionObject = {};
                urlObject[functionName] = functionObject
            }
            var existingNode = functionObject[node.lineNumber];
            if (!existingNode) {
                var newNode = {
                    functionName: functionName,
                    numberOfCalls: node.numberOfCalls,
                    totalTime: node.totalTime,
                    selfTime: node.selfTime,
                    url: node.url,
                    lineNumber: node.lineNumber
                };
                array[array.length] = newNode;
                functionObject[node.lineNumber] = newNode
            } else {
                existingNode.totalTime += node.totalTime;
                existingNode.selfTime += node.selfTime;
                existingNode.numberOfCalls += node.numberOfCalls
            }
            var children = typeof node.children === "function" ? node.children() : node.children;
            if (children) {
                var numberOfChildren = children.length;
                var childIndex;
                for (childIndex = 0; childIndex < numberOfChildren; childIndex += 1) {
                    processNode(children[childIndex])
                }
            }
        };
        processNode(rootNode);
        return array
    };
    JSProfiling.sort = function JSProfilingSortFn(array, propertyName, descending) {
        if (!propertyName) {
            propertyName = "totalTime"
        }
        var sorterAscending = function(left, right) {
            return left[propertyName] - right[propertyName]
        };
        var sorterDescending = function(left, right) {
            return right[propertyName] - left[propertyName]
        };
        if (descending === false) {
            array.sort(sorterAscending)
        } else {
            array.sort(sorterDescending)
        }
    };
    var AABBTreeNode = function() {
        function AABBTreeNode(extents, escapeNodeOffset, externalNode) {
            this.escapeNodeOffset = escapeNodeOffset;
            this.externalNode = externalNode;
            this.extents = extents;
            return this
        }
        AABBTreeNode.prototype.isLeaf = function() {
            return !!this.externalNode
        };
        AABBTreeNode.prototype.reset = function(minX, minY, minZ, maxX, maxY, maxZ, escapeNodeOffset, externalNode) {
            this.escapeNodeOffset = escapeNodeOffset;
            this.externalNode = externalNode;
            var oldExtents = this.extents;
            oldExtents[0] = minX;
            oldExtents[1] = minY;
            oldExtents[2] = minZ;
            oldExtents[3] = maxX;
            oldExtents[4] = maxY;
            oldExtents[5] = maxZ
        };
        AABBTreeNode.prototype.clear = function() {
            this.escapeNodeOffset = 1;
            this.externalNode = undefined;
            var oldExtents = this.extents;
            var maxNumber = Number.MAX_VALUE;
            oldExtents[0] = maxNumber;
            oldExtents[1] = maxNumber;
            oldExtents[2] = maxNumber;
            oldExtents[3] = -maxNumber;
            oldExtents[4] = -maxNumber;
            oldExtents[5] = -maxNumber
        };
        AABBTreeNode.create = function(extents, escapeNodeOffset, externalNode) {
            return new AABBTreeNode(extents, escapeNodeOffset, externalNode)
        };
        AABBTreeNode.version = 1;
        return AABBTreeNode
    }();
    var AABBTree = function() {
        function AABBTree(highQuality) {
            this.numNodesLeaf = 4;
            this.nodes = [];
            this.endNode = 0;
            this.needsRebuild = false;
            this.needsRebound = false;
            this.numAdds = 0;
            this.numUpdates = 0;
            this.numExternalNodes = 0;
            this.startUpdate = 2147483647;
            this.endUpdate = -2147483647;
            this.highQuality = highQuality;
            this.ignoreY = false;
            this.nodesStack = new Array(32)
        }
        AABBTree.allocateNode = function() {
            var nodesPool = this.nodesPool;
            if (!nodesPool.length) {
                var nodesPoolAllocationSize = this.nodesPoolAllocationSize;
                var useFloat32Array = this.useFloat32Array;
                var extentsArray, extentsArrayIndex;
                if (useFloat32Array) {
                    extentsArray = new Float32Array(nodesPoolAllocationSize * 6);
                    extentsArrayIndex = 0
                }
                var n, extents;
                for (n = 0; n < nodesPoolAllocationSize; n += 1) {
                    if (useFloat32Array) {
                        extents = extentsArray.subarray(extentsArrayIndex, extentsArrayIndex + 6);
                        extentsArrayIndex += 6
                    } else {
                        extents = [0, 0, 0, 0, 0, 0]
                    }
                    nodesPool[n] = AABBTreeNode.create(extents, 1, undefined)
                }
            }
            return nodesPool.pop()
        };
        AABBTree.releaseNode = function(node) {
            var nodesPool = this.nodesPool;
            if (nodesPool.length < this.nodesPoolAllocationSize) {
                node.clear();
                nodesPool.push(node)
            }
        };
        AABBTree.recycleNodes = function(nodes, start) {
            var numNodes = nodes.length;
            var n;
            for (n = start; n < numNodes; n += 1) {
                var node = nodes[n];
                if (node) {
                    this.releaseNode(node)
                }
            }
            nodes.length = start
        };
        AABBTree.prototype.add = function(externalNode, extents) {
            var endNode = this.endNode;
            externalNode.spatialIndex = endNode;
            var node = AABBTree.allocateNode();
            node.escapeNodeOffset = 1;
            node.externalNode = externalNode;
            var copyExtents = node.extents;
            copyExtents[0] = extents[0];
            copyExtents[1] = extents[1];
            copyExtents[2] = extents[2];
            copyExtents[3] = extents[3];
            copyExtents[4] = extents[4];
            copyExtents[5] = extents[5];
            this.nodes[endNode] = node;
            this.endNode = endNode + 1;
            this.needsRebuild = true;
            this.numAdds += 1;
            this.numExternalNodes += 1
        };
        AABBTree.prototype.remove = function(externalNode) {
            var index = externalNode.spatialIndex;
            if (index !== undefined) {
                if (this.numExternalNodes > 1) {
                    var nodes = this.nodes;
                    nodes[index].clear();
                    var endNode = this.endNode;
                    if (index + 1 >= endNode) {
                        while (!nodes[endNode - 1].externalNode) {
                            endNode -= 1
                        }
                        this.endNode = endNode
                    } else {
                        this.needsRebuild = true
                    }
                    this.numExternalNodes -= 1
                } else {
                    this.clear()
                }
                externalNode.spatialIndex = undefined
            }
        };
        AABBTree.prototype.findParent = function(nodeIndex) {
            var nodes = this.nodes;
            var parentIndex = nodeIndex;
            var nodeDist = 0;
            var parent;
            do {
                parentIndex -= 1;
                nodeDist += 1;
                parent = nodes[parentIndex]
            } while (parent.escapeNodeOffset <= nodeDist);
            return parent
        };
        AABBTree.prototype.update = function(externalNode, extents) {
            var index = externalNode.spatialIndex;
            if (index !== undefined) {
                var min0 = extents[0];
                var min1 = extents[1];
                var min2 = extents[2];
                var max0 = extents[3];
                var max1 = extents[4];
                var max2 = extents[5];
                var needsRebuild = this.needsRebuild;
                var needsRebound = this.needsRebound;
                var nodes = this.nodes;
                var node = nodes[index];
                var nodeExtents = node.extents;
                var doUpdate = needsRebuild || needsRebound || nodeExtents[0] > min0 || nodeExtents[1] > min1 || nodeExtents[2] > min2 || nodeExtents[3] < max0 || nodeExtents[4] < max1 || nodeExtents[5] < max2;
                nodeExtents[0] = min0;
                nodeExtents[1] = min1;
                nodeExtents[2] = min2;
                nodeExtents[3] = max0;
                nodeExtents[4] = max1;
                nodeExtents[5] = max2;
                if (doUpdate) {
                    if (!needsRebuild && 1 < nodes.length) {
                        this.numUpdates += 1;
                        if (this.startUpdate > index) {
                            this.startUpdate = index
                        }
                        if (this.endUpdate < index) {
                            this.endUpdate = index
                        }
                        if (!needsRebound) {
                            if (2 * this.numUpdates > this.numExternalNodes) {
                                this.needsRebound = true
                            } else {
                                var parent = this.findParent(index);
                                var parentExtents = parent.extents;
                                if (parentExtents[0] > min0 || parentExtents[1] > min1 || parentExtents[2] > min2 || parentExtents[3] < max0 || parentExtents[4] < max1 || parentExtents[5] < max2) {
                                    this.needsRebound = true
                                }
                            }
                        } else {
                            if (this.numUpdates > 3 * this.numExternalNodes) {
                                this.needsRebuild = true;
                                this.numAdds = this.numUpdates
                            }
                        }
                    }
                }
            } else {
                this.add(externalNode, extents)
            }
        };
        AABBTree.prototype.needsFinalize = function() {
            return this.needsRebuild || this.needsRebound
        };
        AABBTree.prototype.finalize = function() {
            if (this.needsRebuild) {
                this.rebuild()
            } else if (this.needsRebound) {
                this.rebound()
            }
        };
        AABBTree.prototype.rebound = function() {
            var nodes = this.nodes;
            if (nodes.length > 1) {
                var startUpdateNodeIndex = this.startUpdate;
                var endUpdateNodeIndex = this.endUpdate;
                var nodesStack = this.nodesStack;
                var numNodesStack = 0;
                var topNodeIndex = 0;
                for (;;) {
                    var topNode = nodes[topNodeIndex];
                    var currentNodeIndex = topNodeIndex;
                    var currentEscapeNodeIndex = topNodeIndex + topNode.escapeNodeOffset;
                    var nodeIndex = topNodeIndex + 1;
                    var node;
                    do {
                        node = nodes[nodeIndex];
                        var escapeNodeIndex = nodeIndex + node.escapeNodeOffset;
                        if (nodeIndex < endUpdateNodeIndex) {
                            if (!node.externalNode) {
                                if (escapeNodeIndex > startUpdateNodeIndex) {
                                    nodesStack[numNodesStack] = topNodeIndex;
                                    numNodesStack += 1;
                                    topNodeIndex = nodeIndex
                                }
                            }
                        } else {
                            break
                        }
                        nodeIndex = escapeNodeIndex
                    } while (nodeIndex < currentEscapeNodeIndex);
                    if (topNodeIndex === currentNodeIndex) {
                        nodeIndex = topNodeIndex + 1;
                        node = nodes[nodeIndex];
                        var extents = node.extents;
                        var minX = extents[0];
                        var minY = extents[1];
                        var minZ = extents[2];
                        var maxX = extents[3];
                        var maxY = extents[4];
                        var maxZ = extents[5];
                        nodeIndex = nodeIndex + node.escapeNodeOffset;
                        while (nodeIndex < currentEscapeNodeIndex) {
                            node = nodes[nodeIndex];
                            extents = node.extents;
                            if (minX > extents[0]) {
                                minX = extents[0]
                            }
                            if (minY > extents[1]) {
                                minY = extents[1]
                            }
                            if (minZ > extents[2]) {
                                minZ = extents[2]
                            }
                            if (maxX < extents[3]) {
                                maxX = extents[3]
                            }
                            if (maxY < extents[4]) {
                                maxY = extents[4]
                            }
                            if (maxZ < extents[5]) {
                                maxZ = extents[5]
                            }
                            nodeIndex = nodeIndex + node.escapeNodeOffset
                        }
                        extents = topNode.extents;
                        extents[0] = minX;
                        extents[1] = minY;
                        extents[2] = minZ;
                        extents[3] = maxX;
                        extents[4] = maxY;
                        extents[5] = maxZ;
                        endUpdateNodeIndex = topNodeIndex;
                        if (0 < numNodesStack) {
                            numNodesStack -= 1;
                            topNodeIndex = nodesStack[numNodesStack]
                        } else {
                            break
                        }
                    }
                }
            }
            this.needsRebuild = false;
            this.needsRebound = false;
            this.numAdds = 0;
            this.startUpdate = 2147483647;
            this.endUpdate = -2147483647
        };
        AABBTree.prototype.rebuild = function() {
            if (this.numExternalNodes > 0) {
                var nodes = this.nodes;
                var n, buildNodes, numBuildNodes, endNodeIndex;
                if (this.numExternalNodes === nodes.length) {
                    buildNodes = nodes;
                    numBuildNodes = nodes.length;
                    nodes = [];
                    this.nodes = nodes
                } else {
                    buildNodes = [];
                    buildNodes.length = this.numExternalNodes;
                    numBuildNodes = 0;
                    endNodeIndex = this.endNode;
                    for (n = 0; n < endNodeIndex; n += 1) {
                        var currentNode = nodes[n];
                        if (currentNode.externalNode) {
                            nodes[n] = undefined;
                            buildNodes[numBuildNodes] = currentNode;
                            numBuildNodes += 1
                        }
                    }
                    if (buildNodes.length > numBuildNodes) {
                        buildNodes.length = numBuildNodes
                    }
                }
                var rootNode;
                if (numBuildNodes > 1) {
                    if (numBuildNodes > this.numNodesLeaf && this.numAdds > 0) {
                        if (this.highQuality) {
                            this._sortNodesHighQuality(buildNodes)
                        } else if (this.ignoreY) {
                            this._sortNodesNoY(buildNodes)
                        } else {
                            this._sortNodes(buildNodes)
                        }
                    }
                    var predictedNumNodes = this._predictNumNodes(0, numBuildNodes, 0);
                    if (nodes.length > predictedNumNodes) {
                        AABBTree.recycleNodes(nodes, predictedNumNodes)
                    }
                    this._recursiveBuild(buildNodes, 0, numBuildNodes, 0);
                    endNodeIndex = nodes[0].escapeNodeOffset;
                    if (nodes.length > endNodeIndex) {
                        AABBTree.recycleNodes(nodes, endNodeIndex)
                    }
                    this.endNode = endNodeIndex;
                    rootNode = nodes[0];
                    var extents = rootNode.extents;
                    var deltaX = extents[3] - extents[0];
                    var deltaY = extents[4] - extents[1];
                    var deltaZ = extents[5] - extents[2];
                    this.ignoreY = 4 * deltaY < (deltaX <= deltaZ ? deltaX : deltaZ)
                } else {
                    rootNode = buildNodes[0];
                    rootNode.externalNode.spatialIndex = 0;
                    nodes.length = 1;
                    nodes[0] = rootNode;
                    this.endNode = 1
                }
                buildNodes = null
            }
            this.needsRebuild = false;
            this.needsRebound = false;
            this.numAdds = 0;
            this.numUpdates = 0;
            this.startUpdate = 2147483647;
            this.endUpdate = -2147483647
        };
        AABBTree.prototype._sortNodes = function(nodes) {
            var numNodesLeaf = this.numNodesLeaf;
            var numNodes = nodes.length;

            function getkeyXfn(node) {
                var extents = node.extents;
                return extents[0] + extents[3]
            }

            function getkeyYfn(node) {
                var extents = node.extents;
                return extents[1] + extents[4]
            }

            function getkeyZfn(node) {
                var extents = node.extents;
                return extents[2] + extents[5]
            }

            function getreversekeyXfn(node) {
                var extents = node.extents;
                return -(extents[0] + extents[3])
            }

            function getreversekeyYfn(node) {
                var extents = node.extents;
                return -(extents[1] + extents[4])
            }

            function getreversekeyZfn(node) {
                var extents = node.extents;
                return -(extents[2] + extents[5])
            }
            var nthElement = this._nthElement;
            var reverse = false;
            var axis = 0;

            function sortNodesRecursive(nodes, startIndex, endIndex) {
                var splitNodeIndex = startIndex + endIndex >> 1;
                if (axis === 0) {
                    if (reverse) {
                        nthElement(nodes, startIndex, splitNodeIndex, endIndex, getreversekeyXfn)
                    } else {
                        nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyXfn)
                    }
                } else if (axis === 2) {
                    if (reverse) {
                        nthElement(nodes, startIndex, splitNodeIndex, endIndex, getreversekeyZfn)
                    } else {
                        nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyZfn)
                    }
                } else {
                    if (reverse) {
                        nthElement(nodes, startIndex, splitNodeIndex, endIndex, getreversekeyYfn)
                    } else {
                        nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyYfn)
                    }
                }
                if (axis === 0) {
                    axis = 2
                } else if (axis === 2) {
                    axis = 1
                } else {
                    axis = 0
                }
                reverse = !reverse;
                if (startIndex + numNodesLeaf < splitNodeIndex) {
                    sortNodesRecursive(nodes, startIndex, splitNodeIndex)
                }
                if (splitNodeIndex + numNodesLeaf < endIndex) {
                    sortNodesRecursive(nodes, splitNodeIndex, endIndex)
                }
            }
            sortNodesRecursive(nodes, 0, numNodes)
        };
        AABBTree.prototype._sortNodesNoY = function(nodes) {
            var numNodesLeaf = this.numNodesLeaf;
            var numNodes = nodes.length;

            function getkeyXfn(node) {
                var extents = node.extents;
                return extents[0] + extents[3]
            }

            function getkeyZfn(node) {
                var extents = node.extents;
                return extents[2] + extents[5]
            }

            function getreversekeyXfn(node) {
                var extents = node.extents;
                return -(extents[0] + extents[3])
            }

            function getreversekeyZfn(node) {
                var extents = node.extents;
                return -(extents[2] + extents[5])
            }
            var nthElement = this._nthElement;
            var reverse = false;
            var axis = 0;

            function sortNodesNoYRecursive(nodes, startIndex, endIndex) {
                var splitNodeIndex = startIndex + endIndex >> 1;
                if (axis === 0) {
                    if (reverse) {
                        nthElement(nodes, startIndex, splitNodeIndex, endIndex, getreversekeyXfn)
                    } else {
                        nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyXfn)
                    }
                } else {
                    if (reverse) {
                        nthElement(nodes, startIndex, splitNodeIndex, endIndex, getreversekeyZfn)
                    } else {
                        nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyZfn)
                    }
                }
                if (axis === 0) {
                    axis = 2
                } else {
                    axis = 0
                }
                reverse = !reverse;
                if (startIndex + numNodesLeaf < splitNodeIndex) {
                    sortNodesNoYRecursive(nodes, startIndex, splitNodeIndex)
                }
                if (splitNodeIndex + numNodesLeaf < endIndex) {
                    sortNodesNoYRecursive(nodes, splitNodeIndex, endIndex)
                }
            }
            sortNodesNoYRecursive(nodes, 0, numNodes)
        };
        AABBTree.prototype._sortNodesHighQuality = function(nodes) {
            var numNodesLeaf = this.numNodesLeaf;
            var numNodes = nodes.length;

            function getkeyXfn(node) {
                var extents = node.extents;
                return extents[0] + extents[3]
            }

            function getkeyYfn(node) {
                var extents = node.extents;
                return extents[1] + extents[4]
            }

            function getkeyZfn(node) {
                var extents = node.extents;
                return extents[2] + extents[5]
            }

            function getkeyXZfn(node) {
                var extents = node.extents;
                return extents[0] + extents[2] + extents[3] + extents[5]
            }

            function getkeyZXfn(node) {
                var extents = node.extents;
                return extents[0] - extents[2] + extents[3] - extents[5]
            }

            function getreversekeyXfn(node) {
                var extents = node.extents;
                return -(extents[0] + extents[3])
            }

            function getreversekeyYfn(node) {
                var extents = node.extents;
                return -(extents[1] + extents[4])
            }

            function getreversekeyZfn(node) {
                var extents = node.extents;
                return -(extents[2] + extents[5])
            }

            function getreversekeyXZfn(node) {
                var extents = node.extents;
                return -(extents[0] + extents[2] + extents[3] + extents[5])
            }

            function getreversekeyZXfn(node) {
                var extents = node.extents;
                return -(extents[0] - extents[2] + extents[3] - extents[5])
            }
            var nthElement = this._nthElement;
            var calculateSAH = this._calculateSAH;
            var reverse = false;

            function sortNodesHighQualityRecursive(nodes, startIndex, endIndex) {
                var splitNodeIndex = startIndex + endIndex >> 1;
                nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyXfn);
                var sahX = calculateSAH(nodes, startIndex, splitNodeIndex) + calculateSAH(nodes, splitNodeIndex, endIndex);
                nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyYfn);
                var sahY = calculateSAH(nodes, startIndex, splitNodeIndex) + calculateSAH(nodes, splitNodeIndex, endIndex);
                nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyZfn);
                var sahZ = calculateSAH(nodes, startIndex, splitNodeIndex) + calculateSAH(nodes, splitNodeIndex, endIndex);
                nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyXZfn);
                var sahXZ = calculateSAH(nodes, startIndex, splitNodeIndex) + calculateSAH(nodes, splitNodeIndex, endIndex);
                nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyZXfn);
                var sahZX = calculateSAH(nodes, startIndex, splitNodeIndex) + calculateSAH(nodes, splitNodeIndex, endIndex);
                if (sahX <= sahY && sahX <= sahZ && sahX <= sahXZ && sahX <= sahZX) {
                    if (reverse) {
                        nthElement(nodes, startIndex, splitNodeIndex, endIndex, getreversekeyXfn)
                    } else {
                        nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyXfn)
                    }
                } else if (sahZ <= sahY && sahZ <= sahXZ && sahZ <= sahZX) {
                    if (reverse) {
                        nthElement(nodes, startIndex, splitNodeIndex, endIndex, getreversekeyZfn)
                    } else {
                        nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyZfn)
                    }
                } else if (sahY <= sahXZ && sahY <= sahZX) {
                    if (reverse) {
                        nthElement(nodes, startIndex, splitNodeIndex, endIndex, getreversekeyYfn)
                    } else {
                        nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyYfn)
                    }
                } else if (sahXZ <= sahZX) {
                    if (reverse) {
                        nthElement(nodes, startIndex, splitNodeIndex, endIndex, getreversekeyXZfn)
                    } else {
                        nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyXZfn)
                    }
                } else {
                    if (reverse) {
                        nthElement(nodes, startIndex, splitNodeIndex, endIndex, getreversekeyZXfn)
                    } else {
                        nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyZXfn)
                    }
                }
                reverse = !reverse;
                if (startIndex + numNodesLeaf < splitNodeIndex) {
                    sortNodesHighQualityRecursive(nodes, startIndex, splitNodeIndex)
                }
                if (splitNodeIndex + numNodesLeaf < endIndex) {
                    sortNodesHighQualityRecursive(nodes, splitNodeIndex, endIndex)
                }
            }
            sortNodesHighQualityRecursive(nodes, 0, numNodes)
        };
        AABBTree.prototype._calculateSAH = function(buildNodes, startIndex, endIndex) {
            var buildNode, extents, minX, minY, minZ, maxX, maxY, maxZ;
            buildNode = buildNodes[startIndex];
            extents = buildNode.extents;
            minX = extents[0];
            minY = extents[1];
            minZ = extents[2];
            maxX = extents[3];
            maxY = extents[4];
            maxZ = extents[5];
            for (var n = startIndex + 1; n < endIndex; n += 1) {
                buildNode = buildNodes[n];
                extents = buildNode.extents;
                if (minX > extents[0]) {
                    minX = extents[0]
                }
                if (minY > extents[1]) {
                    minY = extents[1]
                }
                if (minZ > extents[2]) {
                    minZ = extents[2]
                }
                if (maxX < extents[3]) {
                    maxX = extents[3]
                }
                if (maxY < extents[4]) {
                    maxY = extents[4]
                }
                if (maxZ < extents[5]) {
                    maxZ = extents[5]
                }
            }
            return maxX - minX + (maxY - minY) + (maxZ - minZ)
        };
        AABBTree.prototype._nthElement = function(nodes, first, nth, last, getkey) {
            function medianFn(a, b, c) {
                if (a < b) {
                    if (b < c) {
                        return b
                    } else if (a < c) {
                        return c
                    } else {
                        return a
                    }
                } else if (a < c) {
                    return a
                } else if (b < c) {
                    return c
                }
                return b
            }

            function insertionSortFn(nodes, first, last, getkey) {
                var sorted = first + 1;
                while (sorted !== last) {
                    var tempNode = nodes[sorted];
                    var tempKey = getkey(tempNode);
                    var next = sorted;
                    var current = sorted - 1;
                    while (next !== first && tempKey < getkey(nodes[current])) {
                        nodes[next] = nodes[current];
                        next -= 1;
                        current -= 1
                    }
                    if (next !== sorted) {
                        nodes[next] = tempNode
                    }
                    sorted += 1
                }
            }
            while (last - first > 8) {
                var midValue = medianFn(getkey(nodes[first]), getkey(nodes[first + (last - first >> 1)]), getkey(nodes[last - 1]));
                var firstPos = first;
                var lastPos = last;
                var midPos;
                for (;; firstPos += 1) {
                    while (getkey(nodes[firstPos]) < midValue) {
                        firstPos += 1
                    }
                    do {
                        lastPos -= 1
                    } while (midValue < getkey(nodes[lastPos]));
                    if (firstPos >= lastPos) {
                        midPos = firstPos;
                        break
                    } else {
                        var temp = nodes[firstPos];
                        nodes[firstPos] = nodes[lastPos];
                        nodes[lastPos] = temp
                    }
                }
                if (midPos <= nth) {
                    first = midPos
                } else {
                    last = midPos
                }
            }
            insertionSortFn(nodes, first, last, getkey)
        };
        AABBTree.prototype._recursiveBuild = function(buildNodes, startIndex, endIndex, lastNodeIndex) {
            var nodes = this.nodes;
            var nodeIndex = lastNodeIndex;
            lastNodeIndex += 1;
            var minX, minY, minZ, maxX, maxY, maxZ, extents;
            var buildNode, lastNode;
            if (startIndex + this.numNodesLeaf >= endIndex) {
                buildNode = buildNodes[startIndex];
                extents = buildNode.extents;
                minX = extents[0];
                minY = extents[1];
                minZ = extents[2];
                maxX = extents[3];
                maxY = extents[4];
                maxZ = extents[5];
                buildNode.externalNode.spatialIndex = lastNodeIndex;
                this._replaceNode(nodes, lastNodeIndex, buildNode);
                for (var n = startIndex + 1; n < endIndex; n += 1) {
                    buildNode = buildNodes[n];
                    extents = buildNode.extents;
                    if (minX > extents[0]) {
                        minX = extents[0]
                    }
                    if (minY > extents[1]) {
                        minY = extents[1]
                    }
                    if (minZ > extents[2]) {
                        minZ = extents[2]
                    }
                    if (maxX < extents[3]) {
                        maxX = extents[3]
                    }
                    if (maxY < extents[4]) {
                        maxY = extents[4]
                    }
                    if (maxZ < extents[5]) {
                        maxZ = extents[5]
                    }
                    lastNodeIndex += 1;
                    buildNode.externalNode.spatialIndex = lastNodeIndex;
                    this._replaceNode(nodes, lastNodeIndex, buildNode)
                }
                lastNode = nodes[lastNodeIndex]
            } else {
                var splitPosIndex = startIndex + endIndex >> 1;
                if (startIndex + 1 >= splitPosIndex) {
                    buildNode = buildNodes[startIndex];
                    buildNode.externalNode.spatialIndex = lastNodeIndex;
                    this._replaceNode(nodes, lastNodeIndex, buildNode)
                } else {
                    this._recursiveBuild(buildNodes, startIndex, splitPosIndex, lastNodeIndex)
                }
                lastNode = nodes[lastNodeIndex];
                extents = lastNode.extents;
                minX = extents[0];
                minY = extents[1];
                minZ = extents[2];
                maxX = extents[3];
                maxY = extents[4];
                maxZ = extents[5];
                lastNodeIndex = lastNodeIndex + lastNode.escapeNodeOffset;
                if (splitPosIndex + 1 >= endIndex) {
                    buildNode = buildNodes[splitPosIndex];
                    buildNode.externalNode.spatialIndex = lastNodeIndex;
                    this._replaceNode(nodes, lastNodeIndex, buildNode)
                } else {
                    this._recursiveBuild(buildNodes, splitPosIndex, endIndex, lastNodeIndex)
                }
                lastNode = nodes[lastNodeIndex];
                extents = lastNode.extents;
                if (minX > extents[0]) {
                    minX = extents[0]
                }
                if (minY > extents[1]) {
                    minY = extents[1]
                }
                if (minZ > extents[2]) {
                    minZ = extents[2]
                }
                if (maxX < extents[3]) {
                    maxX = extents[3]
                }
                if (maxY < extents[4]) {
                    maxY = extents[4]
                }
                if (maxZ < extents[5]) {
                    maxZ = extents[5]
                }
            }
            var node = nodes[nodeIndex];
            if (node === undefined) {
                nodes[nodeIndex] = node = AABBTree.allocateNode()
            }
            node.reset(minX, minY, minZ, maxX, maxY, maxZ, lastNodeIndex + lastNode.escapeNodeOffset - nodeIndex)
        };
        AABBTree.prototype._replaceNode = function(nodes, nodeIndex, newNode) {
            var oldNode = nodes[nodeIndex];
            nodes[nodeIndex] = newNode;
            if (oldNode !== undefined) {
                AABBTree.releaseNode(oldNode)
            }
        };
        AABBTree.prototype._predictNumNodes = function(startIndex, endIndex, lastNodeIndex) {
            lastNodeIndex += 1;
            if (startIndex + this.numNodesLeaf >= endIndex) {
                lastNodeIndex += endIndex - startIndex
            } else {
                var splitPosIndex = startIndex + endIndex >> 1;
                if (startIndex + 1 >= splitPosIndex) {
                    lastNodeIndex += 1
                } else {
                    lastNodeIndex = this._predictNumNodes(startIndex, splitPosIndex, lastNodeIndex)
                }
                if (splitPosIndex + 1 >= endIndex) {
                    lastNodeIndex += 1
                } else {
                    lastNodeIndex = this._predictNumNodes(splitPosIndex, endIndex, lastNodeIndex)
                }
            }
            return lastNodeIndex
        };
        AABBTree.prototype.getVisibleNodes = function(planes, visibleNodes, startIndex) {
            var numVisibleNodes = 0;
            if (this.numExternalNodes > 0) {
                var nodes = this.nodes;
                var endNodeIndex = this.endNode;
                var numPlanes = planes.length;
                var storageIndex = startIndex === undefined ? visibleNodes.length : startIndex;
                var node, extents, endChildren;
                var n0, n1, n2, p0, p1, p2;
                var isInside, n, plane, d0, d1, d2, distance;
                var nodeIndex = 0;
                for (;;) {
                    node = nodes[nodeIndex];
                    extents = node.extents;
                    n0 = extents[0];
                    n1 = extents[1];
                    n2 = extents[2];
                    p0 = extents[3];
                    p1 = extents[4];
                    p2 = extents[5];
                    isInside = true;
                    n = 0;
                    do {
                        plane = planes[n];
                        d0 = plane[0];
                        d1 = plane[1];
                        d2 = plane[2];
                        distance = d0 * (d0 < 0 ? n0 : p0) + d1 * (d1 < 0 ? n1 : p1) + d2 * (d2 < 0 ? n2 : p2);
                        if (distance < plane[3]) {
                            isInside = false;
                            break
                        }
                        n += 1
                    } while (n < numPlanes);
                    if (isInside) {
                        if (node.externalNode) {
                            visibleNodes[storageIndex] = node.externalNode;
                            storageIndex += 1;
                            numVisibleNodes += 1;
                            nodeIndex += 1;
                            if (nodeIndex >= endNodeIndex) {
                                break
                            }
                        } else {
                            isInside = true;
                            n = 0;
                            do {
                                plane = planes[n];
                                d0 = plane[0];
                                d1 = plane[1];
                                d2 = plane[2];
                                distance = d0 * (d0 > 0 ? n0 : p0) + d1 * (d1 > 0 ? n1 : p1) + d2 * (d2 > 0 ? n2 : p2);
                                if (distance < plane[3]) {
                                    isInside = false;
                                    break
                                }
                                n += 1
                            } while (n < numPlanes);
                            if (isInside) {
                                endChildren = nodeIndex + node.escapeNodeOffset;
                                nodeIndex += 1;
                                do {
                                    node = nodes[nodeIndex];
                                    if (node.externalNode) {
                                        visibleNodes[storageIndex] = node.externalNode;
                                        storageIndex += 1;
                                        numVisibleNodes += 1
                                    }
                                    nodeIndex += 1
                                } while (nodeIndex < endChildren);
                                if (nodeIndex >= endNodeIndex) {
                                    break
                                }
                            } else {
                                nodeIndex += 1
                            }
                        }
                    } else {
                        nodeIndex += node.escapeNodeOffset;
                        if (nodeIndex >= endNodeIndex) {
                            break
                        }
                    }
                }
            }
            return numVisibleNodes
        };
        AABBTree.prototype.getOverlappingNodes = function(queryExtents, overlappingNodes, startIndex) {
            if (this.numExternalNodes > 0) {
                var queryMinX = queryExtents[0];
                var queryMinY = queryExtents[1];
                var queryMinZ = queryExtents[2];
                var queryMaxX = queryExtents[3];
                var queryMaxY = queryExtents[4];
                var queryMaxZ = queryExtents[5];
                var nodes = this.nodes;
                var endNodeIndex = this.endNode;
                var node, extents, endChildren;
                var numOverlappingNodes = 0;
                var storageIndex = startIndex === undefined ? overlappingNodes.length : startIndex;
                var nodeIndex = 0;
                for (;;) {
                    node = nodes[nodeIndex];
                    extents = node.extents;
                    var minX = extents[0];
                    var minY = extents[1];
                    var minZ = extents[2];
                    var maxX = extents[3];
                    var maxY = extents[4];
                    var maxZ = extents[5];
                    if (queryMinX <= maxX && queryMinY <= maxY && queryMinZ <= maxZ && queryMaxX >= minX && queryMaxY >= minY && queryMaxZ >= minZ) {
                        if (node.externalNode) {
                            overlappingNodes[storageIndex] = node.externalNode;
                            storageIndex += 1;
                            numOverlappingNodes += 1;
                            nodeIndex += 1;
                            if (nodeIndex >= endNodeIndex) {
                                break
                            }
                        } else {
                            if (queryMaxX >= maxX && queryMaxY >= maxY && queryMaxZ >= maxZ && queryMinX <= minX && queryMinY <= minY && queryMinZ <= minZ) {
                                endChildren = nodeIndex + node.escapeNodeOffset;
                                nodeIndex += 1;
                                do {
                                    node = nodes[nodeIndex];
                                    if (node.externalNode) {
                                        overlappingNodes[storageIndex] = node.externalNode;
                                        storageIndex += 1;
                                        numOverlappingNodes += 1
                                    }
                                    nodeIndex += 1
                                } while (nodeIndex < endChildren);
                                if (nodeIndex >= endNodeIndex) {
                                    break
                                }
                            } else {
                                nodeIndex += 1
                            }
                        }
                    } else {
                        nodeIndex += node.escapeNodeOffset;
                        if (nodeIndex >= endNodeIndex) {
                            break
                        }
                    }
                }
                return numOverlappingNodes
            } else {
                return 0
            }
        };
        AABBTree.prototype.getSphereOverlappingNodes = function(center, radius, overlappingNodes) {
            if (this.numExternalNodes > 0) {
                var radiusSquared = radius * radius;
                var centerX = center[0];
                var centerY = center[1];
                var centerZ = center[2];
                var nodes = this.nodes;
                var endNodeIndex = this.endNode;
                var node, extents;
                var numOverlappingNodes = overlappingNodes.length;
                var nodeIndex = 0;
                for (;;) {
                    node = nodes[nodeIndex];
                    extents = node.extents;
                    var minX = extents[0];
                    var minY = extents[1];
                    var minZ = extents[2];
                    var maxX = extents[3];
                    var maxY = extents[4];
                    var maxZ = extents[5];
                    var totalDistance = 0,
                        sideDistance;
                    if (centerX < minX) {
                        sideDistance = minX - centerX;
                        totalDistance += sideDistance * sideDistance
                    } else if (centerX > maxX) {
                        sideDistance = centerX - maxX;
                        totalDistance += sideDistance * sideDistance
                    }
                    if (centerY < minY) {
                        sideDistance = minY - centerY;
                        totalDistance += sideDistance * sideDistance
                    } else if (centerY > maxY) {
                        sideDistance = centerY - maxY;
                        totalDistance += sideDistance * sideDistance
                    }
                    if (centerZ < minZ) {
                        sideDistance = minZ - centerZ;
                        totalDistance += sideDistance * sideDistance
                    } else if (centerZ > maxZ) {
                        sideDistance = centerZ - maxZ;
                        totalDistance += sideDistance * sideDistance
                    }
                    if (totalDistance <= radiusSquared) {
                        nodeIndex += 1;
                        if (node.externalNode) {
                            overlappingNodes[numOverlappingNodes] = node.externalNode;
                            numOverlappingNodes += 1;
                            if (nodeIndex >= endNodeIndex) {
                                break
                            }
                        }
                    } else {
                        nodeIndex += node.escapeNodeOffset;
                        if (nodeIndex >= endNodeIndex) {
                            break
                        }
                    }
                }
            }
        };
        AABBTree.prototype.getOverlappingPairs = function(overlappingPairs, startIndex) {
            if (this.numExternalNodes > 0) {
                var nodes = this.nodes;
                var endNodeIndex = this.endNode;
                var currentNode, currentExternalNode, node, extents;
                var numInsertions = 0;
                var storageIndex = startIndex === undefined ? overlappingPairs.length : startIndex;
                var currentNodeIndex = 0,
                    nodeIndex;
                for (;;) {
                    currentNode = nodes[currentNodeIndex];
                    while (!currentNode.externalNode) {
                        currentNodeIndex += 1;
                        currentNode = nodes[currentNodeIndex]
                    }
                    currentNodeIndex += 1;
                    if (currentNodeIndex < endNodeIndex) {
                        currentExternalNode = currentNode.externalNode;
                        extents = currentNode.extents;
                        var minX = extents[0];
                        var minY = extents[1];
                        var minZ = extents[2];
                        var maxX = extents[3];
                        var maxY = extents[4];
                        var maxZ = extents[5];
                        nodeIndex = currentNodeIndex;
                        for (;;) {
                            node = nodes[nodeIndex];
                            extents = node.extents;
                            if (minX <= extents[3] && minY <= extents[4] && minZ <= extents[5] && maxX >= extents[0] && maxY >= extents[1] && maxZ >= extents[2]) {
                                nodeIndex += 1;
                                if (node.externalNode) {
                                    overlappingPairs[storageIndex] = currentExternalNode;
                                    overlappingPairs[storageIndex + 1] = node.externalNode;
                                    storageIndex += 2;
                                    numInsertions += 2;
                                    if (nodeIndex >= endNodeIndex) {
                                        break
                                    }
                                }
                            } else {
                                nodeIndex += node.escapeNodeOffset;
                                if (nodeIndex >= endNodeIndex) {
                                    break
                                }
                            }
                        }
                    } else {
                        break
                    }
                }
                return numInsertions
            } else {
                return 0
            }
        };
        AABBTree.prototype.getExtents = function() {
            return 0 < this.nodes.length ? this.nodes[0].extents : null
        };
        AABBTree.prototype.getRootNode = function() {
            return this.nodes[0]
        };
        AABBTree.prototype.getNodes = function() {
            return this.nodes
        };
        AABBTree.prototype.getEndNodeIndex = function() {
            return this.endNode
        };
        AABBTree.prototype.clear = function() {
            if (this.nodes.length) {
                AABBTree.recycleNodes(this.nodes, 0)
            }
            this.endNode = 0;
            this.needsRebuild = false;
            this.needsRebound = false;
            this.numAdds = 0;
            this.numUpdates = 0;
            this.numExternalNodes = 0;
            this.startUpdate = 2147483647;
            this.endUpdate = -2147483647;
            this.ignoreY = false
        };
        AABBTree.rayTest = function(trees, ray, callback) {
            var origin = ray.origin;
            var direction = ray.direction;
            var o0 = origin[0];
            var o1 = origin[1];
            var o2 = origin[2];
            var d0 = direction[0];
            var d1 = direction[1];
            var d2 = direction[2];
            var id0 = 1 / d0;
            var id1 = 1 / d1;
            var id2 = 1 / d2;

            function distanceExtents(extents, upperBound) {
                var min0 = extents[0];
                var min1 = extents[1];
                var min2 = extents[2];
                var max0 = extents[3];
                var max1 = extents[4];
                var max2 = extents[5];
                if (min0 <= o0 && o0 <= max0 && min1 <= o1 && o1 <= max1 && min2 <= o2 && o2 <= max2) {
                    return 0
                }
                var tmin, tmax;
                var tymin, tymax;
                var del;
                if (d0 >= 0) {
                    del = min0 - o0;
                    tmin = del === 0 ? 0 : del * id0;
                    del = max0 - o0;
                    tmax = del === 0 ? 0 : del * id0
                } else {
                    tmin = (max0 - o0) * id0;
                    tmax = (min0 - o0) * id0
                }
                if (d1 >= 0) {
                    del = min1 - o1;
                    tymin = del === 0 ? 0 : del * id1;
                    del = max1 - o1;
                    tymax = del === 0 ? 0 : del * id1
                } else {
                    tymin = (max1 - o1) * id1;
                    tymax = (min1 - o1) * id1
                }
                if (tmin > tymax || tymin > tmax) {
                    return undefined
                }
                if (tymin > tmin) {
                    tmin = tymin
                }
                if (tymax < tmax) {
                    tmax = tymax
                }
                var tzmin, tzmax;
                if (d2 >= 0) {
                    del = min2 - o2;
                    tzmin = del === 0 ? 0 : del * id2;
                    del = max2 - o2;
                    tzmax = del === 0 ? 0 : del * id2
                } else {
                    tzmin = (max2 - o2) * id2;
                    tzmax = (min2 - o2) * id2
                }
                if (tmin > tzmax || tzmin > tmax) {
                    return undefined
                }
                if (tzmin > tmin) {
                    tmin = tzmin
                }
                if (tzmax < tmax) {
                    tmax = tzmax
                }
                if (tmin < 0) {
                    tmin = tmax
                }
                return 0 <= tmin && tmin < upperBound ? tmin : undefined
            }
            var priorityList = [];
            var minimumResult = null;

            function processNode(tree, nodeIndex, upperBound) {
                var nodes = tree.getNodes();
                var node = nodes[nodeIndex];
                var distance = distanceExtents(node.extents, upperBound);
                if (distance === undefined) {
                    return upperBound
                }
                if (node.externalNode) {
                    var result = callback(tree, node.externalNode, ray, distance, upperBound);
                    if (result) {
                        minimumResult = result;
                        upperBound = result.factor
                    }
                } else {
                    var length = priorityList.length;
                    var i;
                    for (i = 0; i < length; i += 1) {
                        var curObj = priorityList[i];
                        if (distance > curObj.distance) {
                            break
                        }
                    }
                    priorityList.splice(i - 1, 0, {
                        tree: tree,
                        nodeIndex: nodeIndex,
                        distance: distance
                    })
                }
                return upperBound
            }
            var upperBound = ray.maxFactor;
            var tree;
            var i;
            for (i = 0; i < trees.length; i += 1) {
                tree = trees[i];
                if (tree.endNode !== 0) {
                    upperBound = processNode(tree, 0, upperBound)
                }
            }
            while (priorityList.length !== 0) {
                var nodeObj = priorityList.pop();
                if (nodeObj.distance >= upperBound) {
                    continue
                }
                var nodeIndex = nodeObj.nodeIndex;
                tree = nodeObj.tree;
                var nodes = tree.getNodes();
                var node = nodes[nodeIndex];
                var maxIndex = nodeIndex + node.escapeNodeOffset;
                var childIndex = nodeIndex + 1;
                do {
                    upperBound = processNode(tree, childIndex, upperBound);
                    childIndex += nodes[childIndex].escapeNodeOffset
                } while (childIndex < maxIndex)
            }
            return minimumResult
        };
        AABBTree.create = function(highQuality) {
            return new AABBTree(highQuality ? true : false)
        };
        AABBTree.version = 1;
        AABBTree.useFloat32Array = false;
        AABBTree.nodesPoolAllocationSize = 128;
        AABBTree.nodesPool = [];
        return AABBTree
    }();
    (function() {
        if (typeof Float32Array !== "undefined") {
            var testArray = new Float32Array(4);
            var textDescriptor = Object.prototype.toString.call(testArray);
            if (textDescriptor === "[object Float32Array]") {
                AABBTree.useFloat32Array = true
            }
        }
    })();
    var Observer = function() {
        function Observer() {}
        Observer.prototype.subscribe = function(subscriber) {
            var subscribers = this.subscribers;
            var length = subscribers.length;
            for (var index = 0; index < length; index += 1) {
                if (subscribers[index] === subscriber) {
                    return
                }
            }
            subscribers.push(subscriber)
        };
        Observer.prototype.unsubscribe = function(subscriber) {
            var subscribers = this.subscribers;
            var length = subscribers.length;
            for (var index = 0; index < length; index += 1) {
                if (subscribers[index] === subscriber) {
                    subscribers.splice(index, 1);
                    break
                }
            }
        };
        Observer.prototype.unsubscribeAll = function() {
            this.subscribers.length = 0
        };
        Observer.prototype.notify = function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
            var subscribers = this.subscribers;
            var length = this.subscribers.length;
            var index = 0;
            while (index < length) {
                subscribers[index].apply(null, arguments);
                if (subscribers.length === length) {
                    index += 1
                } else {
                    length = subscribers.length
                }
            }
        };
        Observer.create = function() {
            var observer = new Observer;
            observer.subscribers = [];
            return observer
        };
        return Observer
    }();
    var DDSLoader = function() {
        function DDSLoader() {}
        DDSLoader.prototype.processBytes = function(bytes, status) {
            if (!this.isValidHeader(bytes)) {
                this.onerror(status);
                return
            }
            var offset = 4;
            var header = this.parseHeader(bytes, offset);
            offset += 31 * 4;
            this.width = header.dwWidth;
            this.height = header.dwHeight;
            if (header.dwCaps2 & this.DDSF_VOLUME && header.dwDepth > 0) {
                this.depth = header.dwDepth
            } else {
                this.depth = 1
            }
            if (header.dwFlags & this.DDSF_MIPMAPCOUNT) {
                this.numLevels = header.dwMipMapCount
            } else {
                this.numLevels = 1
            }
            if (header.dwCaps2 & this.DDSF_CUBEMAP) {
                var numFaces = 0;
                numFaces += header.dwCaps2 & this.DDSF_CUBEMAP_POSITIVEX ? 1 : 0;
                numFaces += header.dwCaps2 & this.DDSF_CUBEMAP_NEGATIVEX ? 1 : 0;
                numFaces += header.dwCaps2 & this.DDSF_CUBEMAP_POSITIVEY ? 1 : 0;
                numFaces += header.dwCaps2 & this.DDSF_CUBEMAP_NEGATIVEY ? 1 : 0;
                numFaces += header.dwCaps2 & this.DDSF_CUBEMAP_POSITIVEZ ? 1 : 0;
                numFaces += header.dwCaps2 & this.DDSF_CUBEMAP_NEGATIVEZ ? 1 : 0;
                if (numFaces !== 6 || this.width !== this.height) {
                    this.onerror(status);
                    return
                }
                this.numFaces = numFaces
            } else {
                this.numFaces = 1
            }
            var compressed = false;
            var bpe = 0;
            var gd = this.gd;
            if (header.ddspf.dwFlags & this.DDSF_FOURCC) {
                switch (header.ddspf.dwFourCC) {
                    case this.FOURCC_DXT1:
                        this.format = gd.PIXELFORMAT_DXT1;
                        bpe = 8;
                        compressed = true;
                        break;
                    case this.FOURCC_DXT2:
                    case this.FOURCC_DXT3:
                        this.format = gd.PIXELFORMAT_DXT3;
                        bpe = 16;
                        compressed = true;
                        break;
                    case this.FOURCC_DXT4:
                    case this.FOURCC_DXT5:
                    case this.FOURCC_RXGB:
                        this.format = gd.PIXELFORMAT_DXT5;
                        bpe = 16;
                        compressed = true;
                        break;
                    case this.FOURCC_R8G8B8:
                        this.bgrFormat = this.BGRPIXELFORMAT_B8G8R8;
                        bpe = 3;
                        break;
                    case this.FOURCC_A8R8G8B8:
                        this.bgrFormat = this.BGRPIXELFORMAT_B8G8R8A8;
                        bpe = 4;
                        break;
                    case this.FOURCC_R5G6B5:
                        this.bgrFormat = this.BGRPIXELFORMAT_B5G6R5;
                        bpe = 2;
                        break;
                    case this.FOURCC_A8:
                        this.format = gd.PIXELFORMAT_A8;
                        bpe = 1;
                        break;
                    case this.FOURCC_A8B8G8R8:
                        this.format = gd.PIXELFORMAT_R8G8B8A8;
                        bpe = 4;
                        break;
                    case this.FOURCC_L8:
                        this.format = gd.PIXELFORMAT_L8;
                        bpe = 1;
                        break;
                    case this.FOURCC_A8L8:
                        this.format = gd.PIXELFORMAT_L8A8;
                        bpe = 2;
                        break;
                    case this.FOURCC_UNKNOWN:
                    case this.FOURCC_ATI1:
                    case this.FOURCC_ATI2:
                    case this.FOURCC_X8R8G8B8:
                    case this.FOURCC_X8B8G8R8:
                    case this.FOURCC_A2B10G10R10:
                    case this.FOURCC_A2R10G10B10:
                    case this.FOURCC_A16B16G16R16:
                    case this.FOURCC_R16F:
                    case this.FOURCC_A16B16G16R16F:
                    case this.FOURCC_R32F:
                    case this.FOURCC_A32B32G32R32F:
                    case this.FOURCC_L16:
                    case this.FOURCC_X1R5G5B5:
                    case this.FOURCC_A1R5G5B5:
                    case this.FOURCC_A4R4G4B4:
                    case this.FOURCC_R3G3B2:
                    case this.FOURCC_A8R3G3B2:
                    case this.FOURCC_X4R4G4B4:
                    case this.FOURCC_A4L4:
                    case this.FOURCC_D16_LOCKABLE:
                    case this.FOURCC_D32:
                    case this.FOURCC_D24X8:
                    case this.FOURCC_D16:
                    case this.FOURCC_D32F_LOCKABLE:
                    case this.FOURCC_G16R16:
                    case this.FOURCC_G16R16F:
                    case this.FOURCC_G32R32F:
                        break;
                    default:
                        this.onerror(status);
                        return
                }
            } else if (header.ddspf.dwFlags === this.DDSF_RGBA && header.ddspf.dwRGBBitCount === 32) {
                if (header.ddspf.dwRBitMask === 255 && header.ddspf.dwGBitMask === 65280 && header.ddspf.dwBBitMask === 16711680 && header.ddspf.dwABitMask === 4278190080) {
                    this.format = gd.PIXELFORMAT_R8G8B8A8
                } else {
                    this.bgrFormat = this.BGRPIXELFORMAT_B8G8R8A8
                }
                bpe = 4
            } else if (header.ddspf.dwFlags === this.DDSF_RGB && header.ddspf.dwRGBBitCount === 32) {
                if (header.ddspf.dwRBitMask === 255 && header.ddspf.dwGBitMask === 65280 && header.ddspf.dwBBitMask === 16711680) {
                    this.format = gd.PIXELFORMAT_R8G8B8A8
                } else {
                    this.bgrFormat = this.BGRPIXELFORMAT_B8G8R8A8
                }
                bpe = 4
            } else if (header.ddspf.dwFlags === this.DDSF_RGB && header.ddspf.dwRGBBitCount === 24) {
                if (header.ddspf.dwRBitMask === 255 && header.ddspf.dwGBitMask === 65280 && header.ddspf.dwBBitMask === 16711680) {
                    this.format = gd.PIXELFORMAT_R8G8B8
                } else {
                    this.bgrFormat = this.BGRPIXELFORMAT_B8G8R8
                }
                bpe = 3
            } else if (header.ddspf.dwFlags === this.DDSF_RGB && header.ddspf.dwRGBBitCount === 16) {
                if (header.ddspf.dwRBitMask === 63488 && header.ddspf.dwGBitMask === 2016 && header.ddspf.dwBBitMask === 31) {
                    this.format = gd.PIXELFORMAT_R5G6B5
                } else {
                    this.bgrFormat = this.BGRPIXELFORMAT_B5G6R5
                }
                bpe = 2
            } else if (header.ddspf.dwRGBBitCount === 8) {
                this.format = gd.PIXELFORMAT_L8;
                bpe = 1
            } else {
                this.onerror(status);
                return
            }
            var size = 0;
            for (var face = 0; face < this.numFaces; face += 1) {
                var w = this.width,
                    h = this.height,
                    d = this.depth;
                for (var level = 0; level < this.numLevels; level += 1) {
                    var ew = compressed ? Math.floor((w + 3) / 4) : w;
                    var eh = compressed ? Math.floor((h + 3) / 4) : h;
                    size += ew * eh * d * bpe;
                    w = w > 1 ? w >> 1 : 1;
                    h = h > 1 ? h >> 1 : 1;
                    d = d > 1 ? d >> 1 : 1
                }
            }
            if (bytes.length < offset + size) {
                this.onerror(status);
                return
            }
            this.bytesPerPixel = bpe;
            var data = bytes.subarray(offset);
            bytes = null;
            var swapBytes = false;
            switch (this.bgrFormat) {
                case this.BGRPIXELFORMAT_B8G8R8:
                    this.format = gd.PIXELFORMAT_R8G8B8;
                    swapBytes = true;
                    break;
                case this.BGRPIXELFORMAT_B8G8R8A8:
                    this.format = gd.PIXELFORMAT_R8G8B8A8;
                    swapBytes = true;
                    break;
                case this.BGRPIXELFORMAT_B5G6R5:
                    this.format = gd.PIXELFORMAT_R5G6B5;
                    swapBytes = true;
                    break;
                default:
                    break
            }
            if (swapBytes) {
                data = this.convertBGR2RGB(data)
            }
            if (this.format === gd.PIXELFORMAT_DXT1) {
                if (!gd.isSupported("TEXTURE_DXT1")) {
                    if (this.hasDXT1Alpha(data)) {
                        this.format = gd.PIXELFORMAT_R5G5B5A1;
                        DDSLoader.decodeInWorker(DDSLoader.WorkerCommand.DXT1A, data, this);
                        return
                    } else {
                        this.format = gd.PIXELFORMAT_R5G6B5;
                        DDSLoader.decodeInWorker(DDSLoader.WorkerCommand.DXT1, data, this);
                        return
                    }
                }
            } else if (this.format === gd.PIXELFORMAT_DXT3) {
                if (!gd.isSupported("TEXTURE_DXT3")) {
                    this.format = gd.PIXELFORMAT_R4G4B4A4;
                    DDSLoader.decodeInWorker(DDSLoader.WorkerCommand.DXT3, data, this);
                    return
                }
            } else if (this.format === gd.PIXELFORMAT_DXT5) {
                if (!gd.isSupported("TEXTURE_DXT5")) {
                    this.format = gd.PIXELFORMAT_R4G4B4A4;
                    DDSLoader.decodeInWorker(DDSLoader.WorkerCommand.DXT5, data, this);
                    return
                }
            }
            this.onload(data, this.width, this.height, this.format, this.numLevels, this.numFaces > 1, this.depth, status)
        };
        DDSLoader.createWorker = function(index) {
            var code = "var convertDXT1To565 = " + this.convertDXT1To565.toString() + ";\n" + "var convertDXT1To5551 = " + this.convertDXT1To5551.toString() + ";\n" + "var convertDXT3To4444 = " + this.convertDXT3To4444.toString() + ";\n" + "var convertDXT5To4444 = " + this.convertDXT5To4444.toString() + ";\n" + "var command, srcWidth, srcHeight, srcNumLevels, srcNumFaces, srcOffset;\n" + "onmessage = function decoderOnMessage(event)\n" + "{\n" + "    var edata = event.data;\n" + "    if (edata instanceof ArrayBuffer)\n" + "    {\n" + "        var data = new Uint8Array(edata, srcOffset);\n" + "        switch (command)\n" + "        {\n" + "            case 0: // DXT1\n" + "                data = convertDXT1To565(data, srcWidth, srcHeight, srcNumLevels, srcNumFaces);\n" + "                break;\n" + "            case 1: // DXT1A\n" + "                data = convertDXT1To5551(data, srcWidth, srcHeight, srcNumLevels, srcNumFaces);\n" + "                break;\n" + "            case 2: // DXT3\n" + "                data = convertDXT3To4444(data, srcWidth, srcHeight, srcNumLevels, srcNumFaces);\n" + "                break;\n" + "            case 3: // DXT4\n" + "                data = convertDXT5To4444(data, srcWidth, srcHeight, srcNumLevels, srcNumFaces);\n" + "                break;\n" + "            default:\n" + "                data = null;\n" + "                break;\n" + "        };\n" + "        if (data)\n" + "        {\n" + "            postMessage(data.buffer, [data.buffer]);\n" + "        }\n" + "        else\n" + "        {\n" + "            postMessage(null);\n" + "        }\n" + "    }\n" + "    else\n" + "    {\n" + "        command = edata.command;\n" + "        srcWidth = edata.width;\n" + "        srcHeight = edata.height;\n" + "        srcNumLevels = edata.numLevels;\n" + "        srcNumFaces = edata.numFaces;\n" + "        srcOffset = edata.byteOffset;\n" + "    }\n" + "};";
            var blob = new Blob([code], {
                type: "text/javascript"
            });
            var url = typeof URL !== "undefined" ? URL : window["webkitURL"];
            var objectURL = url.createObjectURL(blob);
            var worker;
            try {
                worker = new Worker(objectURL)
            } catch (e) {
                worker = null
            }
            if (worker) {
                var workerQueue = DDSLoader.workerQueues[index];
                worker.onmessage = function(event) {
                    var loader = workerQueue.shift();
                    worker["load"] -= ((loader.width + 3) * (loader.height + 3) >> 4) * loader.numLevels * loader.numFaces;
                    var data = event.data;
                    if (data) {
                        loader.onload(data, loader.width, loader.height, loader.format, loader.numLevels, loader.numFaces > 1, loader.depth, 200)
                    } else {
                        loader.onerror(200)
                    }
                };
                worker["load"] = 0
            }
            url.revokeObjectURL(objectURL);
            return worker
        };
        DDSLoader.decodeInWorker = function(command, data, loader) {
            var maxNumWorkers = this.maxNumWorkers;
            if (maxNumWorkers) {
                var workerQueues = this.workerQueues;
                var workers = this.workers;
                var workerIndex = -1;
                var n;
                if (!workers) {
                    this.workerQueues = workerQueues = [];
                    this.workers = workers = [];
                    workerIndex = 0;
                    for (n = 0; n < maxNumWorkers; n += 1) {
                        workerQueues[n] = [];
                        workers[n] = this.createWorker(n);
                        if (!workers[n]) {
                            workerIndex = -1;
                            break
                        }
                    }
                } else {
                    workerIndex = 0;
                    var minLoad = workers[0]["load"];
                    for (n = 1; n < maxNumWorkers; n += 1) {
                        var load = workers[n]["load"];
                        if (minLoad > load) {
                            minLoad = load;
                            workerIndex = n
                        }
                    }
                }
                if (workerIndex !== -1) {
                    var worker = workers[workerIndex];
                    worker["load"] += ((loader.width + 3) * (loader.height + 3) >> 4) * loader.numLevels * loader.numFaces;
                    workerQueues[workerIndex].push(loader);
                    var byteOffset = data.byteOffset;
                    var buffer;
                    if (loader.externalBuffer) {
                        buffer = data.buffer.slice(byteOffset, byteOffset + data.byteLength);
                        byteOffset = 0
                    } else {
                        buffer = data.buffer
                    }
                    worker.postMessage({
                        command: command,
                        width: loader.width,
                        height: loader.height,
                        numLevels: loader.numLevels,
                        numFaces: loader.numFaces,
                        byteOffset: byteOffset
                    });
                    worker.postMessage(buffer, [buffer]);
                    return
                } else {
                    this.maxNumWorkers = 0
                }
            }
            var decoder;
            switch (command) {
                case DDSLoader.WorkerCommand.DXT1:
                    decoder = function() {
                        data = DDSLoader.convertDXT1To565(data, loader.width, loader.height, loader.numLevels, loader.numFaces);
                        loader.onload(data, loader.width, loader.height, loader.format, loader.numLevels, loader.numFaces > 1, loader.depth, 200)
                    };
                    break;
                case DDSLoader.WorkerCommand.DXT1A:
                    decoder = function() {
                        data = DDSLoader.convertDXT1To5551(data, loader.width, loader.height, loader.numLevels, loader.numFaces);
                        loader.onload(data, loader.width, loader.height, loader.format, loader.numLevels, loader.numFaces > 1, loader.depth, 200)
                    };
                    break;
                case DDSLoader.WorkerCommand.DXT3:
                    decoder = function() {
                        data = DDSLoader.convertDXT3To4444(data, loader.width, loader.height, loader.numLevels, loader.numFaces);
                        loader.onload(data, loader.width, loader.height, loader.format, loader.numLevels, loader.numFaces > 1, loader.depth, 200)
                    };
                    break;
                case DDSLoader.WorkerCommand.DXT5:
                    decoder = function() {
                        data = DDSLoader.convertDXT5To4444(data, loader.width, loader.height, loader.numLevels, loader.numFaces);
                        loader.onload(data, loader.width, loader.height, loader.format, loader.numLevels, loader.numFaces > 1, loader.depth, 200)
                    };
                    break;
                default:
                    decoder = null;
                    break
            }
            if (decoder) {
                TurbulenzEngine.setTimeout(decoder, 0)
            } else {
                loader.onerror(200)
            }
        };
        DDSLoader.prototype.parseHeader = function(bytes, offset) {
            function readUInt32() {
                var value = bytes[offset] | bytes[offset + 1] << 8 | bytes[offset + 2] << 16 | bytes[offset + 3] << 24;
                offset += 4;
                return value
            }

            function parsePixelFormatHeader() {
                return {
                    dwSize: readUInt32(),
                    dwFlags: readUInt32(),
                    dwFourCC: readUInt32(),
                    dwRGBBitCount: readUInt32(),
                    dwRBitMask: readUInt32(),
                    dwGBitMask: readUInt32(),
                    dwBBitMask: readUInt32(),
                    dwABitMask: readUInt32()
                }
            }
            var header = {
                dwSize: readUInt32(),
                dwFlags: readUInt32(),
                dwHeight: readUInt32(),
                dwWidth: readUInt32(),
                dwPitchOrLinearSize: readUInt32(),
                dwDepth: readUInt32(),
                dwMipMapCount: readUInt32(),
                dwReserved1: [readUInt32(), readUInt32(), readUInt32(), readUInt32(), readUInt32(), readUInt32(), readUInt32(), readUInt32(), readUInt32(), readUInt32(), readUInt32()],
                ddspf: parsePixelFormatHeader(),
                dwCaps1: readUInt32(),
                dwCaps2: readUInt32(),
                dwReserved2: [readUInt32(), readUInt32(), readUInt32()]
            };
            return header
        };
        DDSLoader.prototype.isValidHeader = function(bytes) {
            return 68 === bytes[0] && 68 === bytes[1] && 83 === bytes[2] && 32 === bytes[3]
        };
        DDSLoader.prototype.convertBGR2RGB = function(data) {
            var bytesPerPixel = this.bytesPerPixel;
            var width = this.width;
            var height = this.height;
            var numLevels = this.numLevels;
            var numFaces = this.numFaces;
            var numPixels = 0;
            for (var level = 0; level < numLevels; level += 1) {
                numPixels += width * height;
                width = width > 1 ? Math.floor(width / 2) : 1;
                height = height > 1 ? Math.floor(height / 2) : 1
            }
            var size = numPixels * bytesPerPixel * numFaces;
            var offset = 0;
            if (bytesPerPixel === 3 || bytesPerPixel === 4) {
                do {
                    var tmp = data[offset];
                    data[offset] = data[offset + 2];
                    data[offset + 2] = tmp;
                    offset += bytesPerPixel
                } while (offset < size)
            } else if (bytesPerPixel === 2) {
                var dst = new Uint16Array(numPixels * numFaces);
                var src = 0,
                    dest = 0;
                var r, g, b;
                var mask5bit = (1 << 5) - 1;
                var midMask6bit = (1 << 6) - 1 << 5;
                do {
                    var value = data[src + 1] << 8 | data[src];
                    src += 2;
                    r = (value & mask5bit) << 11;
                    g = value & midMask6bit;
                    b = value >> 11 & mask5bit;
                    dst[dest] = r | g | b;
                    dest += 1
                } while (offset < size);
                return dst
            }
            return data
        };
        DDSLoader.prototype.decode565 = function(value, color) {
            var r = value >> 11 & 31;
            var g = value >> 5 & 63;
            var b = value & 31;
            color[0] = r << 3 | r >> 2;
            color[1] = g << 2 | g >> 4;
            color[2] = b << 3 | b >> 2;
            color[3] = 255;
            return color
        };
        DDSLoader.prototype.decodeColor = function(data, src, isDXT1, out, scratchpad) {
            var cache = scratchpad.cache;
            var decode565 = DDSLoader.prototype.decode565;
            var col0 = data[src + 1] << 8 | data[src];
            src += 2;
            var col1 = data[src + 1] << 8 | data[src];
            src += 2;
            var c0, c1, c2, c3, i;
            if (col0 !== col1) {
                c0 = decode565(col0, cache[0]);
                c1 = decode565(col1, cache[1]);
                c2 = cache[2];
                c3 = cache[3];
                if (col0 > col1) {
                    for (i = 0; i < 3; i += 1) {
                        var c0i = c0[i];
                        var c1i = c1[i];
                        c2[i] = (c0i * 2 + c1i) / 3 | 0;
                        c3[i] = (c0i + c1i * 2) / 3 | 0
                    }
                    c2[3] = 255;
                    c3[3] = 255
                } else {
                    for (i = 0; i < 3; i += 1) {
                        c2[i] = c0[i] + c1[i] >> 1;
                        c3[i] = 0
                    }
                    c2[3] = 255;
                    c3[3] = 0
                }
            } else {
                c0 = decode565(col0, cache[0]);
                c1 = c0;
                c2 = c0;
                c3 = cache[1];
                for (i = 0; i < 4; i += 1) {
                    c3[i] = 0
                }
            }
            var c = scratchpad.colorArray;
            c[0] = c0;
            c[1] = c1;
            c[2] = c2;
            c[3] = c3;
            var row, dest, color;
            if (isDXT1) {
                for (i = 0; i < 4; i += 1) {
                    row = data[src + i];
                    dest = out[i];
                    dest[0] = c[row & 3];
                    dest[1] = c[row >> 2 & 3];
                    dest[2] = c[row >> 4 & 3];
                    dest[3] = c[row >> 6 & 3]
                }
            } else {
                for (i = 0; i < 4; i += 1) {
                    row = data[src + i];
                    dest = out[i];
                    color = c[row & 3];
                    dest[0][0] = color[0];
                    dest[0][1] = color[1];
                    dest[0][2] = color[2];
                    dest[0][3] = color[3];
                    color = c[row >> 2 & 3];
                    dest[1][0] = color[0];
                    dest[1][1] = color[1];
                    dest[1][2] = color[2];
                    dest[1][3] = color[3];
                    color = c[row >> 4 & 3];
                    dest[2][0] = color[0];
                    dest[2][1] = color[1];
                    dest[2][2] = color[2];
                    dest[2][3] = color[3];
                    color = c[row >> 6 & 3];
                    dest[3][0] = color[0];
                    dest[3][1] = color[1];
                    dest[3][2] = color[2];
                    dest[3][3] = color[3]
                }
            }
        };
        DDSLoader.prototype.decodeDXT3Alpha = function(data, src, out) {
            for (var i = 0; i < 4; i += 1) {
                var row = data[src + 1] << 8 | data[src];
                src += 2;
                var dest = out[i];
                if (row) {
                    dest[0][3] = (row & 15) * (255 / 15);
                    dest[1][3] = (row >> 4 & 15) * (255 / 15);
                    dest[2][3] = (row >> 8 & 15) * (255 / 15);
                    dest[3][3] = (row >> 12 & 15) * (255 / 15)
                } else {
                    dest[0][3] = 0;
                    dest[1][3] = 0;
                    dest[2][3] = 0;
                    dest[3][3] = 0
                }
            }
        };
        DDSLoader.prototype.decodeDXT5Alpha = function(data, src, out, scratchpad) {
            var a0 = data[src];
            src += 1;
            var a1 = data[src];
            src += 1;
            var a = scratchpad.alphaArray;
            a[0] = a0;
            a[1] = a1;
            if (a0 > a1) {
                a[2] = (a0 * 6 + a1 * 1) / 7 | 0;
                a[3] = (a0 * 5 + a1 * 2) / 7 | 0;
                a[4] = (a0 * 4 + a1 * 3) / 7 | 0;
                a[5] = (a0 * 3 + a1 * 4) / 7 | 0;
                a[6] = (a0 * 2 + a1 * 5) / 7 | 0;
                a[7] = (a0 * 1 + a1 * 6) / 7 | 0
            } else if (a0 < a1) {
                a[2] = (a0 * 4 + a1 * 1) / 5 | 0;
                a[3] = (a0 * 3 + a1 * 2) / 5 | 0;
                a[4] = (a0 * 2 + a1 * 3) / 5 | 0;
                a[5] = (a0 * 1 + a1 * 4) / 5 | 0;
                a[6] = 0;
                a[7] = 255
            } else {
                a[2] = a0;
                a[3] = a0;
                a[4] = a0;
                a[5] = a0;
                a[6] = 0;
                a[7] = 255
            }
            var dest;
            for (var i = 0; i < 2; i += 1) {
                var value = data[src] | data[src + 1] << 8 | data[src + 2] << 16;
                src += 3;
                dest = out[i * 2];
                dest[0][3] = a[value & 7];
                dest[1][3] = a[value >> 3 & 7];
                dest[2][3] = a[value >> 6 & 7];
                dest[3][3] = a[value >> 9 & 7];
                dest = out[i * 2 + 1];
                dest[0][3] = a[value >> 12 & 7];
                dest[1][3] = a[value >> 15 & 7];
                dest[2][3] = a[value >> 18 & 7];
                dest[3][3] = a[value >> 21 & 7]
            }
        };
        DDSLoader.prototype.convertToRGBA32 = function(data, decode, srcStride) {
            var level;
            var width = this.width;
            var height = this.height;
            var numLevels = this.numLevels;
            var numFaces = this.numFaces;
            var numPixels = 0;
            for (level = 0; level < numLevels; level += 1) {
                numPixels += width * height;
                width = width > 1 ? width >> 1 : 1;
                height = height > 1 ? height >> 1 : 1
            }
            var dst = new Uint8Array(numPixels * 4 * numFaces);
            var src = 0,
                dest = 0;
            var color = [
                [new Uint8Array(4), new Uint8Array(4), new Uint8Array(4), new Uint8Array(4)],
                [new Uint8Array(4), new Uint8Array(4), new Uint8Array(4), new Uint8Array(4)],
                [new Uint8Array(4), new Uint8Array(4), new Uint8Array(4), new Uint8Array(4)],
                [new Uint8Array(4), new Uint8Array(4), new Uint8Array(4), new Uint8Array(4)]
            ];
            for (var face = 0; face < numFaces; face += 1) {
                width = this.width;
                height = this.height;
                for (var n = 0; n < numLevels; n += 1) {
                    var numColumns = width > 4 ? 4 : width;
                    var numLines = height > 4 ? 4 : height;
                    var heightInBlocks = height + 3 >> 2;
                    var widthInBlocks = width + 3 >> 2;
                    var desinationStride = width * 4;
                    var desinationLineStride = numColumns * 4;
                    var desinationBlockStride = desinationStride * (numLines - 1);
                    for (var y = 0; y < heightInBlocks; y += 1) {
                        for (var x = 0; x < widthInBlocks; x += 1) {
                            decode(data, src, color);
                            var destLine = dest;
                            for (var line = 0; line < numLines; line += 1) {
                                var colorLine = color[line];
                                var destRGBA = destLine;
                                for (var i = 0; i < numColumns; i += 1) {
                                    var rgba = colorLine[i];
                                    dst[destRGBA] = rgba[0];
                                    dst[destRGBA + 1] = rgba[1];
                                    dst[destRGBA + 2] = rgba[2];
                                    dst[destRGBA + 3] = rgba[3];
                                    destRGBA += 4
                                }
                                destLine += desinationStride
                            }
                            src += srcStride;
                            dest += desinationLineStride
                        }
                        dest += desinationBlockStride
                    }
                    width = width > 1 ? width >> 1 : 1;
                    height = height > 1 ? height >> 1 : 1
                }
            }
            return dst
        };
        DDSLoader.prototype.hasDXT1Alpha = function(data) {
            var length16 = data.length >>> 1;
            var data16 = new Uint16Array(data.buffer, data.byteOffset, length16);
            var n, b, i, row;
            for (n = 0; n < length16; n += 4) {
                if (data16[n] <= data16[n + 1]) {
                    b = n + 2 << 1;
                    for (i = 0; i < 4; i += 1) {
                        row = data[b + i];
                        if (2 < row) {
                            if ((row & 3) === 3 || (row >> 2 & 3) === 3 || (row >> 4 & 3) === 3 || (row >> 6 & 3) === 3) {
                                return true
                            }
                        }
                    }
                }
            }
            return false
        };
        DDSLoader.prototype.encodeR5G6B5 = function(rgba) {
            return (rgba[2] & 248) >>> 3 | (rgba[1] & 252) << 3 | (rgba[0] & 248) << 8
        };
        DDSLoader.prototype.encodeR5G5B5A1 = function(rgba) {
            return rgba[3] >>> 7 | (rgba[2] & 248) >>> 2 | (rgba[1] & 248) << 3 | (rgba[0] & 248) << 8
        };
        DDSLoader.prototype.encodeR4G4B4A4 = function(rgba) {
            return rgba[3] >>> 4 | rgba[2] & 240 | (rgba[1] & 240) << 4 | (rgba[0] & 240) << 8
        };
        DDSLoader.convertDXT1To565 = function(srcBuffer, srcWidth, srcHeight, srcNumLevels, srcNumFaces) {
            function decodeDXT1Color(data, src, out, cache, colorArray) {
                function decode565(value, color) {
                    var r = value >> 11 & 31;
                    var g = value >> 5 & 63;
                    var b = value & 31;
                    color[0] = r << 3 | r >> 2;
                    color[1] = g << 2 | g >> 4;
                    color[2] = b << 3 | b >> 2;
                    return color
                }
                var col0 = data[src + 1] << 8 | data[src];
                src += 2;
                var col1 = data[src + 1] << 8 | data[src];
                src += 2;
                var c0, c1, c2, c3, i;
                if (col0 !== col1) {
                    c0 = decode565(col0, cache[0]);
                    c1 = decode565(col1, cache[1]);
                    c2 = cache[2];
                    c3 = cache[3];
                    if (col0 > col1) {
                        for (i = 0; i < 3; i += 1) {
                            var c0i = c0[i];
                            var c1i = c1[i];
                            c2[i] = (c0i * 2 + c1i) / 3 | 0;
                            c3[i] = (c0i + c1i * 2) / 3 | 0
                        }
                    } else {
                        for (i = 0; i < 3; i += 1) {
                            c2[i] = c0[i] + c1[i] >>> 1;
                            c3[i] = 0
                        }
                    }
                } else {
                    c0 = decode565(col0, cache[0]);
                    c1 = c0;
                    c2 = c0;
                    c3 = cache[1]
                }
                var c = colorArray;
                c[0] = (c0[2] & 248) >>> 3 | (c0[1] & 252) << 3 | (c0[0] & 248) << 8;
                c[1] = (c1[2] & 248) >>> 3 | (c1[1] & 252) << 3 | (c1[0] & 248) << 8;
                c[2] = (c2[2] & 248) >>> 3 | (c2[1] & 252) << 3 | (c2[0] & 248) << 8;
                c[3] = (c3[2] & 248) >>> 3 | (c3[1] & 252) << 3 | (c3[0] & 248) << 8;
                var row, dest, color;
                for (i = 0; i < 4; i += 1) {
                    row = data[src + i];
                    dest = out[i];
                    dest[0] = c[row & 3];
                    dest[1] = c[row >> 2 & 3];
                    dest[2] = c[row >> 4 & 3];
                    dest[3] = c[row >> 6 & 3]
                }
            }
            var level;
            var width = srcWidth;
            var height = srcHeight;
            var numLevels = srcNumLevels;
            var numFaces = srcNumFaces;
            var numPixels = 0;
            for (level = 0; level < numLevels; level += 1) {
                numPixels += width * height;
                width = width > 1 ? width >> 1 : 1;
                height = height > 1 ? height >> 1 : 1
            }
            var dst = new Uint16Array(numPixels * 1 * numFaces);
            var src = 0,
                dest = 0;
            var color = [new Uint16Array(4), new Uint16Array(4), new Uint16Array(4), new Uint16Array(4)];
            var cache = [new Uint8Array(3), new Uint8Array(3), new Uint8Array(3), new Uint8Array(3)];
            var colorArray = new Uint16Array(4);
            for (var face = 0; face < numFaces; face += 1) {
                width = srcWidth;
                height = srcHeight;
                for (var n = 0; n < numLevels; n += 1) {
                    var numColumns = width > 4 ? 4 : width;
                    var numLines = height > 4 ? 4 : height;
                    var heightInBlocks = height + 3 >> 2;
                    var widthInBlocks = width + 3 >> 2;
                    var desinationStride = width * 1;
                    var desinationLineStride = numColumns * 1;
                    var desinationBlockStride = desinationStride * (numLines - 1);
                    for (var y = 0; y < heightInBlocks; y += 1) {
                        for (var x = 0; x < widthInBlocks; x += 1) {
                            decodeDXT1Color(srcBuffer, src, color, cache, colorArray);
                            var destLine = dest;
                            for (var line = 0; line < numLines; line += 1) {
                                var colorLine = color[line];
                                var destRGBA = destLine;
                                for (var i = 0; i < numColumns; i += 1) {
                                    dst[destRGBA] = colorLine[i];
                                    destRGBA += 1
                                }
                                destLine += desinationStride
                            }
                            src += 8;
                            dest += desinationLineStride
                        }
                        dest += desinationBlockStride
                    }
                    width = width > 1 ? width >> 1 : 1;
                    height = height > 1 ? height >> 1 : 1
                }
            }
            return dst
        };
        DDSLoader.convertDXT1To5551 = function(srcBuffer, srcWidth, srcHeight, srcNumLevels, srcNumFaces) {
            function decodeDXT1Color(data, src, out, cache, colorArray) {
                function decode565(value, color) {
                    var r = value >> 11 & 31;
                    var g = value >> 5 & 63;
                    var b = value & 31;
                    color[0] = r << 3 | r >> 2;
                    color[1] = g << 2 | g >> 4;
                    color[2] = b << 3 | b >> 2;
                    color[3] = 255;
                    return color
                }
                var col0 = data[src + 1] << 8 | data[src];
                src += 2;
                var col1 = data[src + 1] << 8 | data[src];
                src += 2;
                var c0, c1, c2, c3, i;
                if (col0 !== col1) {
                    c0 = decode565(col0, cache[0]);
                    c1 = decode565(col1, cache[1]);
                    c2 = cache[2];
                    c3 = cache[3];
                    if (col0 > col1) {
                        for (i = 0; i < 3; i += 1) {
                            var c0i = c0[i];
                            var c1i = c1[i];
                            c2[i] = (c0i * 2 + c1i) / 3 | 0;
                            c3[i] = (c0i + c1i * 2) / 3 | 0
                        }
                        c2[3] = 255;
                        c3[3] = 255
                    } else {
                        for (i = 0; i < 3; i += 1) {
                            c2[i] = c0[i] + c1[i] >> 1;
                            c3[i] = 0
                        }
                        c2[3] = 255;
                        c3[3] = 0
                    }
                } else {
                    c0 = decode565(col0, cache[0]);
                    c1 = c0;
                    c2 = c0;
                    c3 = cache[1];
                    for (i = 0; i < 4; i += 1) {
                        c3[i] = 0
                    }
                }
                var c = colorArray;
                c[0] = c0[3] >>> 7 | (c0[2] & 248) >>> 2 | (c0[1] & 248) << 3 | (c0[0] & 248) << 8;
                c[1] = c1[3] >>> 7 | (c1[2] & 248) >>> 2 | (c1[1] & 248) << 3 | (c1[0] & 248) << 8;
                c[2] = c2[3] >>> 7 | (c2[2] & 248) >>> 2 | (c2[1] & 248) << 3 | (c2[0] & 248) << 8;
                c[3] = c3[3] >>> 7 | (c3[2] & 248) >>> 2 | (c3[1] & 248) << 3 | (c3[0] & 248) << 8;
                var row, dest, color;
                for (i = 0; i < 4; i += 1) {
                    row = data[src + i];
                    dest = out[i];
                    dest[0] = c[row & 3];
                    dest[1] = c[row >> 2 & 3];
                    dest[2] = c[row >> 4 & 3];
                    dest[3] = c[row >> 6 & 3]
                }
            }
            var level;
            var width = srcWidth;
            var height = srcHeight;
            var numLevels = srcNumLevels;
            var numFaces = srcNumFaces;
            var numPixels = 0;
            for (level = 0; level < numLevels; level += 1) {
                numPixels += width * height;
                width = width > 1 ? width >> 1 : 1;
                height = height > 1 ? height >> 1 : 1
            }
            var dst = new Uint16Array(numPixels * 1 * numFaces);
            var src = 0,
                dest = 0;
            var color = [new Uint16Array(4), new Uint16Array(4), new Uint16Array(4), new Uint16Array(4)];
            var cache = [new Uint8Array(4), new Uint8Array(4), new Uint8Array(4), new Uint8Array(4)];
            var colorArray = new Uint16Array(4);
            for (var face = 0; face < numFaces; face += 1) {
                width = srcWidth;
                height = srcHeight;
                for (var n = 0; n < numLevels; n += 1) {
                    var numColumns = width > 4 ? 4 : width;
                    var numLines = height > 4 ? 4 : height;
                    var heightInBlocks = height + 3 >> 2;
                    var widthInBlocks = width + 3 >> 2;
                    var desinationStride = width * 1;
                    var desinationLineStride = numColumns * 1;
                    var desinationBlockStride = desinationStride * (numLines - 1);
                    for (var y = 0; y < heightInBlocks; y += 1) {
                        for (var x = 0; x < widthInBlocks; x += 1) {
                            decodeDXT1Color(srcBuffer, src, color, cache, colorArray);
                            var destLine = dest;
                            for (var line = 0; line < numLines; line += 1) {
                                var colorLine = color[line];
                                var destRGBA = destLine;
                                for (var i = 0; i < numColumns; i += 1) {
                                    dst[destRGBA] = colorLine[i];
                                    destRGBA += 1
                                }
                                destLine += desinationStride
                            }
                            src += 8;
                            dest += desinationLineStride
                        }
                        dest += desinationBlockStride
                    }
                    width = width > 1 ? width >> 1 : 1;
                    height = height > 1 ? height >> 1 : 1
                }
            }
            return dst
        };
        DDSLoader.convertDXT3To4444 = function(srcBuffer, srcWidth, srcHeight, srcNumLevels, srcNumFaces) {
            function decodeDXT1Color(data, src, out, cache, colorArray) {
                function decode565(value, color) {
                    var r = value >> 11 & 31;
                    var g = value >> 5 & 63;
                    var b = value & 31;
                    color[0] = r << 3 | r >> 2;
                    color[1] = g << 2 | g >> 4;
                    color[2] = b << 3 | b >> 2;
                    color[3] = 255;
                    return color
                }
                var col0 = data[src + 1] << 8 | data[src];
                src += 2;
                var col1 = data[src + 1] << 8 | data[src];
                src += 2;
                var c0, c1, c2, c3, i;
                if (col0 !== col1) {
                    c0 = decode565(col0, cache[0]);
                    c1 = decode565(col1, cache[1]);
                    c2 = cache[2];
                    c3 = cache[3];
                    if (col0 > col1) {
                        for (i = 0; i < 3; i += 1) {
                            var c0i = c0[i];
                            var c1i = c1[i];
                            c2[i] = (c0i * 2 + c1i) / 3 | 0;
                            c3[i] = (c0i + c1i * 2) / 3 | 0
                        }
                        c2[3] = 255;
                        c3[3] = 255
                    } else {
                        for (i = 0; i < 3; i += 1) {
                            c2[i] = c0[i] + c1[i] >> 1;
                            c3[i] = 0
                        }
                        c2[3] = 255;
                        c3[3] = 0
                    }
                } else {
                    c0 = decode565(col0, cache[0]);
                    c1 = c0;
                    c2 = c0;
                    c3 = cache[1];
                    for (i = 0; i < 4; i += 1) {
                        c3[i] = 0
                    }
                }
                var c = colorArray;
                c[0] = c0;
                c[1] = c1;
                c[2] = c2;
                c[3] = c3;
                var row, dest, color;
                for (i = 0; i < 4; i += 1) {
                    row = data[src + i];
                    dest = out[i];
                    color = c[row & 3];
                    dest[0][0] = color[0];
                    dest[0][1] = color[1];
                    dest[0][2] = color[2];
                    dest[0][3] = color[3];
                    color = c[row >> 2 & 3];
                    dest[1][0] = color[0];
                    dest[1][1] = color[1];
                    dest[1][2] = color[2];
                    dest[1][3] = color[3];
                    color = c[row >> 4 & 3];
                    dest[2][0] = color[0];
                    dest[2][1] = color[1];
                    dest[2][2] = color[2];
                    dest[2][3] = color[3];
                    color = c[row >> 6 & 3];
                    dest[3][0] = color[0];
                    dest[3][1] = color[1];
                    dest[3][2] = color[2];
                    dest[3][3] = color[3]
                }
            }

            function decodeDXT3Alpha(data, src, out) {
                for (var i = 0; i < 4; i += 1) {
                    var row = data[src + 1] << 8 | data[src];
                    src += 2;
                    var dest = out[i];
                    if (row) {
                        dest[0][3] = (row & 15) * (255 / 15);
                        dest[1][3] = (row >> 4 & 15) * (255 / 15);
                        dest[2][3] = (row >> 8 & 15) * (255 / 15);
                        dest[3][3] = (row >> 12 & 15) * (255 / 15)
                    } else {
                        dest[0][3] = 0;
                        dest[1][3] = 0;
                        dest[2][3] = 0;
                        dest[3][3] = 0
                    }
                }
            }
            var level;
            var width = srcWidth;
            var height = srcHeight;
            var numLevels = srcNumLevels;
            var numFaces = srcNumFaces;
            var numPixels = 0;
            for (level = 0; level < numLevels; level += 1) {
                numPixels += width * height;
                width = width > 1 ? width >> 1 : 1;
                height = height > 1 ? height >> 1 : 1
            }
            var dst = new Uint16Array(numPixels * 1 * numFaces);
            var src = 0,
                dest = 0;
            var color = [
                [new Uint8Array(4), new Uint8Array(4), new Uint8Array(4), new Uint8Array(4)],
                [new Uint8Array(4), new Uint8Array(4), new Uint8Array(4), new Uint8Array(4)],
                [new Uint8Array(4), new Uint8Array(4), new Uint8Array(4), new Uint8Array(4)],
                [new Uint8Array(4), new Uint8Array(4), new Uint8Array(4), new Uint8Array(4)]
            ];
            var cache = [new Uint8Array(4), new Uint8Array(4), new Uint8Array(4), new Uint8Array(4)];
            var colorArray = new Array(4);
            for (var face = 0; face < numFaces; face += 1) {
                width = srcWidth;
                height = srcHeight;
                for (var n = 0; n < numLevels; n += 1) {
                    var numColumns = width > 4 ? 4 : width;
                    var numLines = height > 4 ? 4 : height;
                    var heightInBlocks = height + 3 >> 2;
                    var widthInBlocks = width + 3 >> 2;
                    var desinationStride = width * 1;
                    var desinationLineStride = numColumns * 1;
                    var desinationBlockStride = desinationStride * (numLines - 1);
                    for (var y = 0; y < heightInBlocks; y += 1) {
                        for (var x = 0; x < widthInBlocks; x += 1) {
                            decodeDXT1Color(srcBuffer, src + 8, color, cache, colorArray);
                            decodeDXT3Alpha(srcBuffer, src, color);
                            var destLine = dest;
                            for (var line = 0; line < numLines; line += 1) {
                                var colorLine = color[line];
                                var destRGBA = destLine;
                                for (var i = 0; i < numColumns; i += 1) {
                                    var rgba = colorLine[i];
                                    dst[destRGBA] = rgba[3] >>> 4 | rgba[2] & 240 | (rgba[1] & 240) << 4 | (rgba[0] & 240) << 8;
                                    destRGBA += 1
                                }
                                destLine += desinationStride
                            }
                            src += 16;
                            dest += desinationLineStride
                        }
                        dest += desinationBlockStride
                    }
                    width = width > 1 ? width >> 1 : 1;
                    height = height > 1 ? height >> 1 : 1
                }
            }
            return dst
        };
        DDSLoader.convertDXT5To4444 = function(srcBuffer, srcWidth, srcHeight, srcNumLevels, srcNumFaces) {
            function decodeDXT1Color(data, src, out, cache, colorArray) {
                function decode565(value, color) {
                    var r = value >> 11 & 31;
                    var g = value >> 5 & 63;
                    var b = value & 31;
                    color[0] = r << 3 | r >> 2;
                    color[1] = g << 2 | g >> 4;
                    color[2] = b << 3 | b >> 2;
                    color[3] = 255;
                    return color
                }
                var col0 = data[src + 1] << 8 | data[src];
                src += 2;
                var col1 = data[src + 1] << 8 | data[src];
                src += 2;
                var c0, c1, c2, c3, i;
                if (col0 !== col1) {
                    c0 = decode565(col0, cache[0]);
                    c1 = decode565(col1, cache[1]);
                    c2 = cache[2];
                    c3 = cache[3];
                    if (col0 > col1) {
                        for (i = 0; i < 3; i += 1) {
                            var c0i = c0[i];
                            var c1i = c1[i];
                            c2[i] = (c0i * 2 + c1i) / 3 | 0;
                            c3[i] = (c0i + c1i * 2) / 3 | 0
                        }
                        c2[3] = 255;
                        c3[3] = 255
                    } else {
                        for (i = 0; i < 3; i += 1) {
                            c2[i] = c0[i] + c1[i] >> 1;
                            c3[i] = 0
                        }
                        c2[3] = 255;
                        c3[3] = 0
                    }
                } else {
                    c0 = decode565(col0, cache[0]);
                    c1 = c0;
                    c2 = c0;
                    c3 = cache[1];
                    for (i = 0; i < 4; i += 1) {
                        c3[i] = 0
                    }
                }
                var c = colorArray;
                c[0] = c0;
                c[1] = c1;
                c[2] = c2;
                c[3] = c3;
                var row, dest, color;
                for (i = 0; i < 4; i += 1) {
                    row = data[src + i];
                    dest = out[i];
                    color = c[row & 3];
                    dest[0][0] = color[0];
                    dest[0][1] = color[1];
                    dest[0][2] = color[2];
                    dest[0][3] = color[3];
                    color = c[row >> 2 & 3];
                    dest[1][0] = color[0];
                    dest[1][1] = color[1];
                    dest[1][2] = color[2];
                    dest[1][3] = color[3];
                    color = c[row >> 4 & 3];
                    dest[2][0] = color[0];
                    dest[2][1] = color[1];
                    dest[2][2] = color[2];
                    dest[2][3] = color[3];
                    color = c[row >> 6 & 3];
                    dest[3][0] = color[0];
                    dest[3][1] = color[1];
                    dest[3][2] = color[2];
                    dest[3][3] = color[3]
                }
            }

            function decodeDXT5Alpha(data, src, out, alphaArray) {
                var a0 = data[src];
                src += 1;
                var a1 = data[src];
                src += 1;
                var a = alphaArray;
                a[0] = a0;
                a[1] = a1;
                if (a0 > a1) {
                    a[2] = (a0 * 6 + a1 * 1) / 7 | 0;
                    a[3] = (a0 * 5 + a1 * 2) / 7 | 0;
                    a[4] = (a0 * 4 + a1 * 3) / 7 | 0;
                    a[5] = (a0 * 3 + a1 * 4) / 7 | 0;
                    a[6] = (a0 * 2 + a1 * 5) / 7 | 0;
                    a[7] = (a0 * 1 + a1 * 6) / 7 | 0
                } else if (a0 < a1) {
                    a[2] = (a0 * 4 + a1 * 1) / 5 | 0;
                    a[3] = (a0 * 3 + a1 * 2) / 5 | 0;
                    a[4] = (a0 * 2 + a1 * 3) / 5 | 0;
                    a[5] = (a0 * 1 + a1 * 4) / 5 | 0;
                    a[6] = 0;
                    a[7] = 255
                } else {
                    a[2] = a0;
                    a[3] = a0;
                    a[4] = a0;
                    a[5] = a0;
                    a[6] = 0;
                    a[7] = 255
                }
                var dest;
                for (var i = 0; i < 2; i += 1) {
                    var value = data[src] | data[src + 1] << 8 | data[src + 2] << 16;
                    src += 3;
                    dest = out[i * 2];
                    dest[0][3] = a[value & 7];
                    dest[1][3] = a[value >> 3 & 7];
                    dest[2][3] = a[value >> 6 & 7];
                    dest[3][3] = a[value >> 9 & 7];
                    dest = out[i * 2 + 1];
                    dest[0][3] = a[value >> 12 & 7];
                    dest[1][3] = a[value >> 15 & 7];
                    dest[2][3] = a[value >> 18 & 7];
                    dest[3][3] = a[value >> 21 & 7]
                }
            }
            var level;
            var width = srcWidth;
            var height = srcHeight;
            var numLevels = srcNumLevels;
            var numFaces = srcNumFaces;
            var numPixels = 0;
            for (level = 0; level < numLevels; level += 1) {
                numPixels += width * height;
                width = width > 1 ? width >> 1 : 1;
                height = height > 1 ? height >> 1 : 1
            }
            var dst = new Uint16Array(numPixels * 1 * numFaces);
            var src = 0,
                dest = 0;
            var color = [
                [new Uint8Array(4), new Uint8Array(4), new Uint8Array(4), new Uint8Array(4)],
                [new Uint8Array(4), new Uint8Array(4), new Uint8Array(4), new Uint8Array(4)],
                [new Uint8Array(4), new Uint8Array(4), new Uint8Array(4), new Uint8Array(4)],
                [new Uint8Array(4), new Uint8Array(4), new Uint8Array(4), new Uint8Array(4)]
            ];
            var cache = [new Uint8Array(4), new Uint8Array(4), new Uint8Array(4), new Uint8Array(4)];
            var colorArray = new Array(4);
            var alphaArray = new Uint8Array(8);
            for (var face = 0; face < numFaces; face += 1) {
                width = srcWidth;
                height = srcHeight;
                for (var n = 0; n < numLevels; n += 1) {
                    var numColumns = width > 4 ? 4 : width;
                    var numLines = height > 4 ? 4 : height;
                    var heightInBlocks = height + 3 >> 2;
                    var widthInBlocks = width + 3 >> 2;
                    var desinationStride = width * 1;
                    var desinationLineStride = numColumns * 1;
                    var desinationBlockStride = desinationStride * (numLines - 1);
                    for (var y = 0; y < heightInBlocks; y += 1) {
                        for (var x = 0; x < widthInBlocks; x += 1) {
                            decodeDXT1Color(srcBuffer, src + 8, color, cache, colorArray);
                            decodeDXT5Alpha(srcBuffer, src, color, alphaArray);
                            var destLine = dest;
                            for (var line = 0; line < numLines; line += 1) {
                                var colorLine = color[line];
                                var destRGBA = destLine;
                                for (var i = 0; i < numColumns; i += 1) {
                                    var rgba = colorLine[i];
                                    dst[destRGBA] = rgba[3] >>> 4 | rgba[2] & 240 | (rgba[1] & 240) << 4 | (rgba[0] & 240) << 8;
                                    destRGBA += 1
                                }
                                destLine += desinationStride
                            }
                            src += 16;
                            dest += desinationLineStride
                        }
                        dest += desinationBlockStride
                    }
                    width = width > 1 ? width >> 1 : 1;
                    height = height > 1 ? height >> 1 : 1
                }
            }
            return dst
        };
        DDSLoader.create = function(params) {
            var loader = new DDSLoader;
            loader.gd = params.gd;
            loader.onload = params.onload;
            loader.onerror = params.onerror;

            function MAKEFOURCC(c0, c1, c2, c3) {
                return c0.charCodeAt(0) + c1.charCodeAt(0) * 256 + c2.charCodeAt(0) * 65536 + c3.charCodeAt(0) * 16777216
            }
            loader.FOURCC_ATI1 = MAKEFOURCC("A", "T", "I", "1");
            loader.FOURCC_ATI2 = MAKEFOURCC("A", "T", "I", "2");
            loader.FOURCC_RXGB = MAKEFOURCC("R", "X", "G", "B");
            var src = params.src;
            if (src) {
                loader.src = src;
                var xhr;
                if (window.XMLHttpRequest) {
                    xhr = new window.XMLHttpRequest
                } else if (window.ActiveXObject) {
                    xhr = new window.ActiveXObject("Microsoft.XMLHTTP")
                } else {
                    if (params.onerror) {
                        params.onerror(0)
                    }
                    return null
                }
                xhr.onreadystatechange = function() {
                    if (xhr.readyState === 4) {
                        if (!TurbulenzEngine || !TurbulenzEngine.isUnloading()) {
                            var xhrStatus = xhr.status;
                            var xhrStatusText = xhr.status !== 0 && xhr.statusText || "No connection";
                            if (xhrStatus === 0 && (window.location.protocol === "file:" || window.location.protocol === "chrome-extension:")) {
                                xhrStatus = 200
                            }
                            if (xhr.getAllResponseHeaders() === "") {
                                var noBody;
                                if (xhr.responseType === "arraybuffer") {
                                    noBody = !xhr.response
                                } else if (xhr.mozResponseArrayBuffer) {
                                    noBody = !xhr.mozResponseArrayBuffer
                                } else {
                                    noBody = !xhr.responseText
                                }
                                if (noBody) {
                                    if (loader.onerror) {
                                        loader.onerror(0)
                                    }
                                    xhr.onreadystatechange = null;
                                    xhr = null;
                                    return
                                }
                            }
                            if (xhrStatus === 200 || xhrStatus === 0) {
                                var buffer;
                                if (xhr.responseType === "arraybuffer") {
                                    buffer = xhr.response
                                } else if (xhr.mozResponseArrayBuffer) {
                                    buffer = xhr.mozResponseArrayBuffer
                                } else {
                                    var text = xhr.responseText;
                                    var numChars = text.length;
                                    buffer = [];
                                    buffer.length = numChars;
                                    for (var i = 0; i < numChars; i += 1) {
                                        buffer[i] = text.charCodeAt(i) & 255
                                    }
                                }
                                loader.externalBuffer = false;
                                loader.processBytes(new Uint8Array(buffer), xhrStatus)
                            } else {
                                if (loader.onerror) {
                                    loader.onerror(xhrStatus)
                                }
                            }
                        }
                        xhr.onreadystatechange = null;
                        xhr = null
                    }
                };
                xhr.open("GET", params.src, true);
                if (typeof xhr.responseType === "string" || xhr.hasOwnProperty && xhr.hasOwnProperty("responseType")) {
                    xhr.responseType = "arraybuffer"
                } else if (xhr.overrideMimeType) {
                    xhr.overrideMimeType("text/plain; charset=x-user-defined")
                } else {
                    xhr.setRequestHeader("Content-Type", "text/plain; charset=x-user-defined")
                }
                xhr.send(null)
            } else {
                loader.externalBuffer = true;
                loader.processBytes(params.data, 0)
            }
            return loader
        };
        DDSLoader.destroy = function() {
            var maxNumWorkers = this.maxNumWorkers;
            if (maxNumWorkers) {
                this.workerQueues = null;
                var workers = this.workers;
                if (workers) {
                    this.workers = null;
                    var n;
                    for (n = 0; n < maxNumWorkers; n += 1) {
                        workers[n].terminate()
                    }
                }
            }
        };
        DDSLoader.version = 1;
        DDSLoader.maxNumWorkers = typeof Worker !== "undefined" && typeof Blob !== "undefined" && (typeof URL !== "undefined" || typeof window["webkitURL"] !== "undefined") ? 4 : 0;
        DDSLoader.WorkerCommand = {
            DXT1: 0,
            DXT1A: 1,
            DXT3: 2,
            DXT5: 3
        };
        DDSLoader.workerQueues = null;
        DDSLoader.workers = null;
        return DDSLoader
    }();
    DDSLoader.prototype.DDSF_CAPS = 1;
    DDSLoader.prototype.DDSF_HEIGHT = 2;
    DDSLoader.prototype.DDSF_WIDTH = 4;
    DDSLoader.prototype.DDSF_PITCH = 8;
    DDSLoader.prototype.DDSF_PIXELFORMAT = 4096;
    DDSLoader.prototype.DDSF_MIPMAPCOUNT = 131072;
    DDSLoader.prototype.DDSF_LINEARSIZE = 524288;
    DDSLoader.prototype.DDSF_DEPTH = 8388608;
    DDSLoader.prototype.DDSF_ALPHAPIXELS = 1;
    DDSLoader.prototype.DDSF_FOURCC = 4;
    DDSLoader.prototype.DDSF_RGB = 64;
    DDSLoader.prototype.DDSF_RGBA = 65;
    DDSLoader.prototype.DDSF_COMPLEX = 8;
    DDSLoader.prototype.DDSF_TEXTURE = 4096;
    DDSLoader.prototype.DDSF_MIPMAP = 4194304;
    DDSLoader.prototype.DDSF_CUBEMAP = 512;
    DDSLoader.prototype.DDSF_CUBEMAP_POSITIVEX = 1024;
    DDSLoader.prototype.DDSF_CUBEMAP_NEGATIVEX = 2048;
    DDSLoader.prototype.DDSF_CUBEMAP_POSITIVEY = 4096;
    DDSLoader.prototype.DDSF_CUBEMAP_NEGATIVEY = 8192;
    DDSLoader.prototype.DDSF_CUBEMAP_POSITIVEZ = 16384;
    DDSLoader.prototype.DDSF_CUBEMAP_NEGATIVEZ = 32768;
    DDSLoader.prototype.DDSF_CUBEMAP_ALL_FACES = 64512;
    DDSLoader.prototype.DDSF_VOLUME = 2097152;
    DDSLoader.prototype.FOURCC_UNKNOWN = 0;
    DDSLoader.prototype.FOURCC_R8G8B8 = 20;
    DDSLoader.prototype.FOURCC_A8R8G8B8 = 21;
    DDSLoader.prototype.FOURCC_X8R8G8B8 = 22;
    DDSLoader.prototype.FOURCC_R5G6B5 = 23;
    DDSLoader.prototype.FOURCC_X1R5G5B5 = 24;
    DDSLoader.prototype.FOURCC_A1R5G5B5 = 25;
    DDSLoader.prototype.FOURCC_A4R4G4B4 = 26;
    DDSLoader.prototype.FOURCC_R3G3B2 = 27;
    DDSLoader.prototype.FOURCC_A8 = 28;
    DDSLoader.prototype.FOURCC_A8R3G3B2 = 29;
    DDSLoader.prototype.FOURCC_X4R4G4B4 = 30;
    DDSLoader.prototype.FOURCC_A2B10G10R10 = 31;
    DDSLoader.prototype.FOURCC_A8B8G8R8 = 32;
    DDSLoader.prototype.FOURCC_X8B8G8R8 = 33;
    DDSLoader.prototype.FOURCC_G16R16 = 34;
    DDSLoader.prototype.FOURCC_A2R10G10B10 = 35;
    DDSLoader.prototype.FOURCC_A16B16G16R16 = 36;
    DDSLoader.prototype.FOURCC_L8 = 50;
    DDSLoader.prototype.FOURCC_A8L8 = 51;
    DDSLoader.prototype.FOURCC_A4L4 = 52;
    DDSLoader.prototype.FOURCC_DXT1 = 827611204;
    DDSLoader.prototype.FOURCC_DXT2 = 844388420;
    DDSLoader.prototype.FOURCC_DXT3 = 861165636;
    DDSLoader.prototype.FOURCC_DXT4 = 877942852;
    DDSLoader.prototype.FOURCC_DXT5 = 894720068;
    DDSLoader.prototype.FOURCC_D16_LOCKABLE = 70;
    DDSLoader.prototype.FOURCC_D32 = 71;
    DDSLoader.prototype.FOURCC_D24X8 = 77;
    DDSLoader.prototype.FOURCC_D16 = 80;
    DDSLoader.prototype.FOURCC_D32F_LOCKABLE = 82;
    DDSLoader.prototype.FOURCC_L16 = 81;
    DDSLoader.prototype.FOURCC_R16F = 111;
    DDSLoader.prototype.FOURCC_G16R16F = 112;
    DDSLoader.prototype.FOURCC_A16B16G16R16F = 113;
    DDSLoader.prototype.FOURCC_R32F = 114;
    DDSLoader.prototype.FOURCC_G32R32F = 115;
    DDSLoader.prototype.FOURCC_A32B32G32R32F = 116;
    DDSLoader.prototype.BGRPIXELFORMAT_B5G6R5 = 1;
    DDSLoader.prototype.BGRPIXELFORMAT_B8G8R8A8 = 2;
    DDSLoader.prototype.BGRPIXELFORMAT_B8G8R8 = 3;
    var TZWebGLTexture = function() {
        function TZWebGLTexture() {}
        TZWebGLTexture.prototype.setData = function(data, face, level, x, y, w, h) {
            var gd = this.gd;
            var target = this.target;
            gd.bindTexture(target, this.glTexture);
            if (3 <= arguments.length) {
                if (x === undefined) {
                    x = 0
                }
                if (y === undefined) {
                    y = 0
                }
                if (w === undefined) {
                    w = this.width - x
                }
                if (h === undefined) {
                    h = this.height - y
                }
                this.updateSubData(data, face, level, x, y, w, h)
            } else {
                this.updateData(data)
            }
            gd.bindTexture(target, null)
        };
        TZWebGLTexture.prototype.createGLTexture = function(data) {
            var gd = this.gd;
            var gl = gd.gl;
            var target;
            if (this.cubemap) {
                target = gl.TEXTURE_CUBE_MAP
            } else if (this.depth > 1) {
                return false
            } else {
                target = gl.TEXTURE_2D
            }
            this.target = target;
            var gltex = gl.createTexture();
            this.glTexture = gltex;
            gd.bindTexture(target, gltex);
            gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            if (this.mipmaps) {
                gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST)
            } else {
                gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
            }
            gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            this.updateData(data);
            gd.bindTexture(target, null);
            return true
        };
        TZWebGLTexture.prototype.convertDataToRGBA = function(gl, data, internalFormat, gltype, srcStep) {
            var numPixels = data.length / srcStep;
            var rgbaData = new Uint8Array(numPixels * 4);
            var offset = 0;
            var n, value, r, g, b, a;
            if (internalFormat === gl.LUMINANCE) {
                for (n = 0; n < numPixels; n += 1, offset += 4) {
                    r = data[n];
                    rgbaData[offset] = r;
                    rgbaData[offset + 1] = r;
                    rgbaData[offset + 2] = r;
                    rgbaData[offset + 3] = 255
                }
            } else if (internalFormat === gl.ALPHA) {
                for (n = 0; n < numPixels; n += 1, offset += 4) {
                    a = data[n];
                    rgbaData[offset] = 255;
                    rgbaData[offset + 1] = 255;
                    rgbaData[offset + 2] = 255;
                    rgbaData[offset + 3] = a
                }
            } else if (internalFormat === gl.LUMINANCE_ALPHA) {
                for (n = 0; n < numPixels; n += 2, offset += 4) {
                    r = data[n];
                    a = data[n + 1];
                    rgbaData[offset] = r;
                    rgbaData[offset + 1] = r;
                    rgbaData[offset + 2] = r;
                    rgbaData[offset + 3] = a
                }
            } else if (gltype === gl.UNSIGNED_SHORT_5_6_5) {
                for (n = 0; n < numPixels; n += 1, offset += 4) {
                    value = data[n];
                    r = value >> 11 & 31;
                    g = value >> 5 & 63;
                    b = value & 31;
                    rgbaData[offset] = r << 3 | r >> 2;
                    rgbaData[offset + 1] = g << 2 | g >> 4;
                    rgbaData[offset + 2] = b << 3 | b >> 2;
                    rgbaData[offset + 3] = 255
                }
            } else if (gltype === gl.UNSIGNED_SHORT_5_5_5_1) {
                for (n = 0; n < numPixels; n += 1, offset += 4) {
                    value = data[n];
                    r = value >> 11 & 31;
                    g = value >> 6 & 31;
                    b = value >> 1 & 31;
                    a = value & 1;
                    rgbaData[offset] = r << 3 | r >> 2;
                    rgbaData[offset + 1] = g << 3 | g >> 2;
                    rgbaData[offset + 2] = b << 3 | b >> 2;
                    rgbaData[offset + 3] = a ? 255 : 0
                }
            } else if (gltype === gl.UNSIGNED_SHORT_4_4_4_4) {
                for (n = 0; n < numPixels; n += 1, offset += 4) {
                    value = data[n];
                    r = value >> 12 & 15;
                    g = value >> 8 & 15;
                    b = value >> 4 & 15;
                    a = value & 15;
                    rgbaData[offset] = r << 4 | r;
                    rgbaData[offset + 1] = g << 4 | g;
                    rgbaData[offset + 2] = b << 4 | b;
                    rgbaData[offset + 3] = a << 4 | a
                }
            }
            return rgbaData
        };
        TZWebGLTexture.prototype.updateData = function(data) {
            var gd = this.gd;
            var gl = gd.gl;

            function log2(a) {
                return Math.floor(Math.log(a) / Math.LN2)
            }
            var numLevels, generateMipMaps;
            if (this.mipmaps) {
                if (data instanceof Image) {
                    numLevels = 1;
                    generateMipMaps = true
                } else {
                    numLevels = 1 + Math.max(log2(this.width), log2(this.height));
                    generateMipMaps = false
                }
            } else {
                numLevels = 1;
                generateMipMaps = false
            }
            var format = this.format;
            var internalFormat, gltype, srcStep, bufferData = null;
            var compressedTexturesExtension;
            if (format === gd.PIXELFORMAT_A8) {
                internalFormat = gl.ALPHA;
                gltype = gl.UNSIGNED_BYTE;
                srcStep = 1;
                if (data && !data.src) {
                    if (data instanceof Uint8Array) {
                        bufferData = data
                    } else {
                        bufferData = new Uint8Array(data)
                    }
                }
            } else if (format === gd.PIXELFORMAT_L8) {
                internalFormat = gl.LUMINANCE;
                gltype = gl.UNSIGNED_BYTE;
                srcStep = 1;
                if (data && !data.src) {
                    if (data instanceof Uint8Array) {
                        bufferData = data
                    } else {
                        bufferData = new Uint8Array(data)
                    }
                }
            } else if (format === gd.PIXELFORMAT_L8A8) {
                internalFormat = gl.LUMINANCE_ALPHA;
                gltype = gl.UNSIGNED_BYTE;
                srcStep = 2;
                if (data && !data.src) {
                    if (data instanceof Uint8Array) {
                        bufferData = data
                    } else {
                        bufferData = new Uint8Array(data)
                    }
                }
            } else if (format === gd.PIXELFORMAT_R5G5B5A1) {
                internalFormat = gl.RGBA;
                gltype = gl.UNSIGNED_SHORT_5_5_5_1;
                srcStep = 1;
                if (data && !data.src) {
                    if (data instanceof Uint16Array) {
                        bufferData = data
                    } else {
                        bufferData = new Uint16Array(data)
                    }
                }
            } else if (format === gd.PIXELFORMAT_R5G6B5) {
                internalFormat = gl.RGB;
                gltype = gl.UNSIGNED_SHORT_5_6_5;
                srcStep = 1;
                if (data && !data.src) {
                    if (data instanceof Uint16Array) {
                        bufferData = data
                    } else {
                        bufferData = new Uint16Array(data)
                    }
                }
            } else if (format === gd.PIXELFORMAT_R4G4B4A4) {
                internalFormat = gl.RGBA;
                gltype = gl.UNSIGNED_SHORT_4_4_4_4;
                srcStep = 1;
                if (data && !data.src) {
                    if (data instanceof Uint16Array) {
                        bufferData = data
                    } else {
                        bufferData = new Uint16Array(data)
                    }
                }
            } else if (format === gd.PIXELFORMAT_R8G8B8A8) {
                internalFormat = gl.RGBA;
                gltype = gl.UNSIGNED_BYTE;
                srcStep = 4;
                if (data && !data.src) {
                    if (data instanceof Uint8Array) {
                        if (typeof Uint8ClampedArray !== "undefined" && data instanceof Uint8ClampedArray) {
                            bufferData = new Uint8Array(data.buffer)
                        } else {
                            bufferData = data
                        }
                    } else {
                        bufferData = new Uint8Array(data)
                    }
                }
            } else if (format === gd.PIXELFORMAT_R8G8B8) {
                internalFormat = gl.RGB;
                gltype = gl.UNSIGNED_BYTE;
                srcStep = 3;
                if (data && !data.src) {
                    if (data instanceof Uint8Array) {
                        if (typeof Uint8ClampedArray !== "undefined" && data instanceof Uint8ClampedArray) {
                            bufferData = new Uint8Array(data.buffer)
                        } else {
                            bufferData = data
                        }
                    } else {
                        bufferData = new Uint8Array(data)
                    }
                }
            } else if (format === gd.PIXELFORMAT_D24S8) {
                internalFormat = gl.DEPTH_STENCIL;
                gltype = gl.UNSIGNED_INT;
                srcStep = 1;
                if (data && !data.src) {
                    bufferData = new Uint32Array(data)
                }
            } else if (format === gd.PIXELFORMAT_DXT1 || format === gd.PIXELFORMAT_DXT3 || format === gd.PIXELFORMAT_DXT5) {
                compressedTexturesExtension = gd.compressedTexturesExtension;
                if (compressedTexturesExtension) {
                    if (format === gd.PIXELFORMAT_DXT1) {
                        internalFormat = compressedTexturesExtension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                        srcStep = 8
                    } else if (format === gd.PIXELFORMAT_DXT3) {
                        internalFormat = compressedTexturesExtension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        srcStep = 16
                    } else {
                        internalFormat = compressedTexturesExtension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                        srcStep = 16
                    }
                    if (internalFormat === undefined) {
                        return
                    }
                    if (data && !data.src) {
                        if (data instanceof Uint8Array) {
                            bufferData = data
                        } else {
                            bufferData = new Uint8Array(data)
                        }
                    }
                } else {
                    return
                }
            } else if (format === gd.PIXELFORMAT_RGBA32F) {
                if (gd.floatTextureExtension) {
                    internalFormat = gl.RGBA;
                    gltype = gl.FLOAT;
                    srcStep = 4;
                    if (data && !data.src) {
                        if (data instanceof Float32Array) {
                            bufferData = data
                        } else {
                            bufferData = new Float32Array(data)
                        }
                    }
                } else {
                    return
                }
            } else if (format === gd.PIXELFORMAT_RGB32F) {
                if (gd.floatTextureExtension) {
                    internalFormat = gl.RGB;
                    gltype = gl.FLOAT;
                    srcStep = 3;
                    if (data && !data.src) {
                        if (data instanceof Float32Array) {
                            bufferData = data
                        } else {
                            bufferData = new Float32Array(data)
                        }
                    }
                } else {
                    return
                }
            } else {
                return
            }
            if (gd.fixIE && !compressedTexturesExtension) {
                var expand = false;
                if (gd.fixIE < "0.93") {
                    expand = internalFormat !== gl.RGBA && internalFormat !== gl.RGB || gltype !== gl.UNSIGNED_BYTE && gltype !== gl.FLOAT
                } else if (gd.fixIE < "0.94") {
                    expand = gltype !== gl.UNSIGNED_BYTE && gltype !== gl.FLOAT
                }
                if (expand) {
                    if (bufferData) {
                        bufferData = this.convertDataToRGBA(gl, bufferData, internalFormat, gltype, srcStep)
                    }
                    internalFormat = gl.RGBA;
                    gltype = gl.UNSIGNED_BYTE;
                    srcStep = 4
                }
            }
            var w = this.width,
                h = this.height,
                offset = 0,
                target, n, levelSize, levelData;
            if (this.cubemap) {
                if (data && data instanceof WebGLVideo) {
                    return
                }
                target = gl.TEXTURE_CUBE_MAP;
                for (var f = 0; f < 6; f += 1) {
                    var faceTarget = gl.TEXTURE_CUBE_MAP_POSITIVE_X + f;
                    for (n = 0; n < numLevels; n += 1) {
                        if (compressedTexturesExtension) {
                            levelSize = Math.floor((w + 3) / 4) * Math.floor((h + 3) / 4) * srcStep;
                            if (bufferData) {
                                levelData = bufferData.subarray(offset, offset + levelSize)
                            } else {
                                levelData = new Uint8Array(levelSize)
                            }
                            if (gd.WEBGL_compressed_texture_s3tc) {
                                gl.compressedTexImage2D(faceTarget, n, internalFormat, w, h, 0, levelData)
                            } else {
                                compressedTexturesExtension.compressedTexImage2D(faceTarget, n, internalFormat, w, h, 0, levelData)
                            }
                        } else {
                            levelSize = w * h * srcStep;
                            if (bufferData) {
                                levelData = bufferData.subarray(offset, offset + levelSize);
                                gl.texImage2D(faceTarget, n, internalFormat, w, h, 0, internalFormat, gltype, levelData)
                            } else if (data) {
                                gl.texImage2D(faceTarget, n, internalFormat, internalFormat, gltype, data)
                            } else {
                                if (gltype === gl.UNSIGNED_SHORT_5_6_5 || gltype === gl.UNSIGNED_SHORT_5_5_5_1 || gltype === gl.UNSIGNED_SHORT_4_4_4_4) {
                                    levelData = new Uint16Array(levelSize)
                                } else if (gltype === gl.FLOAT) {
                                    levelData = new Float32Array(levelSize)
                                } else {
                                    levelData = new Uint8Array(levelSize)
                                }
                                gl.texImage2D(faceTarget, n, internalFormat, w, h, 0, internalFormat, gltype, levelData)
                            }
                        }
                        offset += levelSize;
                        if (bufferData && bufferData.length <= offset) {
                            bufferData = null;
                            data = null;
                            if (0 === n && 1 < numLevels) {
                                generateMipMaps = true;
                                break
                            }
                        }
                        w = w > 1 ? Math.floor(w / 2) : 1;
                        h = h > 1 ? Math.floor(h / 2) : 1
                    }
                    w = this.width;
                    h = this.height
                }
            } else if (data && data instanceof WebGLVideo) {
                target = gl.TEXTURE_2D;
                gl.texImage2D(target, 0, internalFormat, internalFormat, gltype, data.video)
            } else {
                target = gl.TEXTURE_2D;
                for (n = 0; n < numLevels; n += 1) {
                    if (compressedTexturesExtension) {
                        levelSize = Math.floor((w + 3) / 4) * Math.floor((h + 3) / 4) * srcStep;
                        if (bufferData) {
                            if (numLevels === 1) {
                                levelData = bufferData
                            } else {
                                levelData = bufferData.subarray(offset, offset + levelSize)
                            }
                        } else {
                            levelData = new Uint8Array(levelSize)
                        }
                        if (gd.WEBGL_compressed_texture_s3tc) {
                            gl.compressedTexImage2D(target, n, internalFormat, w, h, 0, levelData)
                        } else {
                            compressedTexturesExtension.compressedTexImage2D(target, n, internalFormat, w, h, 0, levelData)
                        }
                    } else {
                        levelSize = w * h * srcStep;
                        if (bufferData) {
                            if (numLevels === 1) {
                                levelData = bufferData
                            } else {
                                levelData = bufferData.subarray(offset, offset + levelSize)
                            }
                            gl.texImage2D(target, n, internalFormat, w, h, 0, internalFormat, gltype, levelData)
                        } else if (data) {
                            gl.texImage2D(target, n, internalFormat, internalFormat, gltype, data)
                        } else {
                            if (gltype === gl.UNSIGNED_SHORT_5_6_5 || gltype === gl.UNSIGNED_SHORT_5_5_5_1 || gltype === gl.UNSIGNED_SHORT_4_4_4_4) {
                                levelData = new Uint16Array(levelSize)
                            } else if (gltype === gl.FLOAT) {
                                levelData = new Float32Array(levelSize)
                            } else {
                                levelData = new Uint8Array(levelSize)
                            }
                            gl.texImage2D(target, n, internalFormat, w, h, 0, internalFormat, gltype, levelData)
                        }
                    }
                    offset += levelSize;
                    if (bufferData && bufferData.length <= offset) {
                        bufferData = null;
                        data = null;
                        if (0 === n && 1 < numLevels) {
                            generateMipMaps = true;
                            break
                        }
                    }
                    w = w > 1 ? Math.floor(w / 2) : 1;
                    h = h > 1 ? Math.floor(h / 2) : 1
                }
            }
            if (generateMipMaps) {
                gl.generateMipmap(target)
            }
        };
        TZWebGLTexture.prototype.updateSubData = function(data, face, level, x, y, w, h) {
            var gd = this.gd;
            var gl = gd.gl;
            var format = this.format;
            var glformat, gltype, bufferData;
            var compressedTexturesExtension;
            if (format === gd.PIXELFORMAT_A8) {
                glformat = gl.ALPHA;
                gltype = gl.UNSIGNED_BYTE;
                if (data instanceof Uint8Array) {
                    bufferData = data
                } else {
                    bufferData = new Uint8Array(data)
                }
            } else if (format === gd.PIXELFORMAT_L8) {
                glformat = gl.LUMINANCE;
                gltype = gl.UNSIGNED_BYTE;
                if (data instanceof Uint8Array) {
                    bufferData = data
                } else {
                    bufferData = new Uint8Array(data)
                }
            } else if (format === gd.PIXELFORMAT_L8A8) {
                glformat = gl.LUMINANCE_ALPHA;
                gltype = gl.UNSIGNED_BYTE;
                if (data instanceof Uint8Array) {
                    bufferData = data
                } else {
                    bufferData = new Uint8Array(data)
                }
            } else if (format === gd.PIXELFORMAT_R5G5B5A1) {
                glformat = gl.RGBA;
                gltype = gl.UNSIGNED_SHORT_5_5_5_1;
                if (data instanceof Uint16Array) {
                    bufferData = data
                } else {
                    bufferData = new Uint16Array(data)
                }
            } else if (format === gd.PIXELFORMAT_R5G6B5) {
                glformat = gl.RGB;
                gltype = gl.UNSIGNED_SHORT_5_6_5;
                if (data instanceof Uint16Array) {
                    bufferData = data
                } else {
                    bufferData = new Uint16Array(data)
                }
            } else if (format === gd.PIXELFORMAT_R4G4B4A4) {
                glformat = gl.RGBA;
                gltype = gl.UNSIGNED_SHORT_4_4_4_4;
                if (data instanceof Uint16Array) {
                    bufferData = data
                } else {
                    bufferData = new Uint16Array(data)
                }
            } else if (format === gd.PIXELFORMAT_R8G8B8A8) {
                glformat = gl.RGBA;
                gltype = gl.UNSIGNED_BYTE;
                if (data instanceof Uint8Array) {
                    if (typeof Uint8ClampedArray !== "undefined" && data instanceof Uint8ClampedArray) {
                        bufferData = new Uint8Array(data.buffer)
                    } else {
                        bufferData = data
                    }
                } else {
                    bufferData = new Uint8Array(data)
                }
            } else if (format === gd.PIXELFORMAT_R8G8B8) {
                glformat = gl.RGB;
                gltype = gl.UNSIGNED_BYTE;
                if (data instanceof Uint8Array) {
                    if (typeof Uint8ClampedArray !== "undefined" && data instanceof Uint8ClampedArray) {
                        bufferData = new Uint8Array(data.buffer)
                    } else {
                        bufferData = data
                    }
                } else {
                    bufferData = new Uint8Array(data)
                }
            } else if (format === gd.PIXELFORMAT_DXT1 || format === gd.PIXELFORMAT_DXT3 || format === gd.PIXELFORMAT_DXT5) {
                compressedTexturesExtension = gd.compressedTexturesExtension;
                if (compressedTexturesExtension) {
                    if (format === gd.PIXELFORMAT_DXT1) {
                        glformat = compressedTexturesExtension.COMPRESSED_RGBA_S3TC_DXT1_EXT
                    } else if (format === gd.PIXELFORMAT_DXT3) {
                        glformat = compressedTexturesExtension.COMPRESSED_RGBA_S3TC_DXT3_EXT
                    } else {
                        glformat = compressedTexturesExtension.COMPRESSED_RGBA_S3TC_DXT5_EXT
                    }
                    if (data instanceof Uint8Array) {
                        bufferData = data
                    } else {
                        bufferData = new Uint8Array(data)
                    }
                } else {
                    return
                }
            } else if (format === gd.PIXELFORMAT_RGBA32F) {
                if (gd.floatTextureExtension) {
                    glformat = gl.RGBA;
                    gltype = gl.FLOAT;
                    if (data instanceof Float32Array) {
                        bufferData = data
                    } else {
                        bufferData = new Float32Array(data)
                    }
                } else {
                    return
                }
            } else if (format === gd.PIXELFORMAT_RGB32F) {
                if (gd.floatTextureExtension) {
                    glformat = gl.RGB;
                    gltype = gl.FLOAT;
                    if (data instanceof Float32Array) {
                        bufferData = data
                    } else {
                        bufferData = new Float32Array(data)
                    }
                } else {
                    return
                }
            } else {
                return
            }
            var target;
            if (this.cubemap) {
                if (data instanceof WebGLVideo) {
                    return
                }
                target = gl.TEXTURE_CUBE_MAP_POSITIVE_X + face
            } else if (data instanceof WebGLVideo) {
                target = gl.TEXTURE_2D;
                gl.texSubImage2D(target, level, x, y, glformat, gltype, data.video);
                return
            } else {
                target = gl.TEXTURE_2D
            }
            if (compressedTexturesExtension) {
                if (gd.WEBGL_compressed_texture_s3tc) {
                    gl.compressedTexSubImage2D(target, level, x, y, w, h, glformat, bufferData)
                } else {
                    compressedTexturesExtension.compressedTexSubImage2D(target, level, x, y, w, h, glformat, bufferData)
                }
            } else {
                gl.texSubImage2D(target, level, x, y, w, h, glformat, gltype, bufferData)
            }
        };
        TZWebGLTexture.prototype.updateMipmaps = function(face) {
            if (this.mipmaps) {
                if (this.depth > 1) {
                    TurbulenzEngine.callOnError("3D texture mipmap generation unsupported");
                    return
                }
                if (this.cubemap && face !== 5) {
                    return
                }
                var gd = this.gd;
                var gl = gd.gl;
                var target = this.target;
                gd.bindTexture(target, this.glTexture);
                gl.generateMipmap(target);
                gd.bindTexture(target, null)
            }
        };
        TZWebGLTexture.prototype.destroy = function() {
            var gd = this.gd;
            if (gd) {
                var glTexture = this.glTexture;
                if (glTexture) {
                    var gl = gd.gl;
                    if (gl) {
                        gd.unbindTexture(glTexture);
                        gl.deleteTexture(glTexture)
                    }
                    delete this.glTexture
                }
                delete this.sampler;
                delete this.gd
            }
        };
        TZWebGLTexture.prototype.typedArrayIsValid = function(typedArray) {
            var gd = this.gd;
            var format = this.format;
            if (gd) {
                if (format === gd.PIXELFORMAT_A8 || format === gd.PIXELFORMAT_L8 || format === gd.PIXELFORMAT_S8) {
                    return (typedArray instanceof Uint8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray) && typedArray.length === this.width * this.height * this.depth
                }
                if (format === gd.PIXELFORMAT_L8A8) {
                    return (typedArray instanceof Uint8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray) && typedArray.length === 2 * this.width * this.height * this.depth
                }
                if (format === gd.PIXELFORMAT_R8G8B8) {
                    return (typedArray instanceof Uint8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray) && typedArray.length === 3 * this.width * this.height * this.depth
                }
                if (format === gd.PIXELFORMAT_R8G8B8A8) {
                    return (typedArray instanceof Uint8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray) && typedArray.length === 4 * this.width * this.height * this.depth
                }
                if (format === gd.PIXELFORMAT_R5G5B5A1 || format === gd.PIXELFORMAT_R5G6B5 || format === gd.PIXELFORMAT_R4G4B4A4) {
                    return typedArray instanceof Uint16Array && typedArray.length === this.width * this.height * this.depth
                }
                if (format === gd.PIXELFORMAT_RGBA32F) {
                    return typedArray instanceof Float32Array && typedArray.length === 4 * this.width * this.height * this.depth
                }
                if (format === gd.PIXELFORMAT_RGB32F) {
                    return typedArray instanceof Float32Array && typedArray.length === 3 * this.width * this.height * this.depth
                }
            }
            return false
        };
        TZWebGLTexture.create = function(gd, params) {
            var tex = new TZWebGLTexture;
            tex.gd = gd;
            tex.mipmaps = params.mipmaps;
            tex.dynamic = params.dynamic;
            tex.renderable = params.renderable || false;
            tex.id = ++gd.counters.textures;
            var src = params.src;
            if (src) {
                tex.name = params.name || src;
                var extension;
                var data = params.data;
                if (data) {
                    if (data[0] === 137 && data[1] === 80 && data[2] === 78 && data[3] === 71) {
                        extension = ".png"
                    } else if (data[0] === 255 && data[1] === 216 && data[2] === 255 && (data[3] === 224 || data[3] === 225)) {
                        extension = ".jpg"
                    } else if (data[0] === 68 && data[1] === 68 && data[2] === 83 && data[3] === 32) {
                        extension = ".dds"
                    } else {
                        extension = src.slice(-4)
                    }
                } else {
                    extension = src.slice(-4)
                }
                if (extension === ".dds" || extension === ".tga") {
                    if (extension === ".tga" && typeof TGALoader !== "undefined") {
                        var tgaParams = {
                            gd: gd,
                            onload: function tgaLoadedFn(data, width, height, format, status) {
                                tex.width = width;
                                tex.height = height;
                                tex.depth = 1;
                                tex.format = format;
                                tex.cubemap = false;
                                var result = tex.createGLTexture(data);
                                if (params.onload) {
                                    params.onload(result ? tex : null, status)
                                }
                            },
                            onerror: function tgaFailedFn(status) {
                                tex.failed = true;
                                if (params.onload) {
                                    params.onload(null, status)
                                }
                            },
                            data: undefined,
                            src: undefined
                        };
                        if (data) {
                            tgaParams.data = data
                        } else {
                            tgaParams.src = src
                        }
                        TGALoader.create(tgaParams);
                        return tex
                    } else if (extension === ".dds" && typeof DDSLoader !== "undefined") {
                        var ddsParams = {
                            gd: gd,
                            onload: function ddsLoadedFn(data, width, height, format, numLevels, cubemap, depth, status) {
                                tex.width = width;
                                tex.height = height;
                                tex.format = format;
                                tex.cubemap = cubemap;
                                tex.depth = depth;
                                if (1 < numLevels) {
                                    if (!tex.mipmaps) {
                                        tex.mipmaps = true
                                    }
                                }
                                var result = tex.createGLTexture(data);
                                if (params.onload) {
                                    params.onload(result ? tex : null, status)
                                }
                            },
                            onerror: function ddsFailedFn(status) {
                                tex.failed = true;
                                if (params.onload) {
                                    params.onload(null, status)
                                }
                            },
                            data: undefined,
                            src: undefined
                        };
                        if (data) {
                            ddsParams.data = data
                        } else {
                            ddsParams.src = src
                        }
                        DDSLoader.create(ddsParams);
                        return tex
                    } else {
                        TurbulenzEngine.callOnError("Missing image loader required for " + src);
                        tex = TZWebGLTexture.create(gd, {
                            name: params.name || src,
                            width: 2,
                            height: 2,
                            depth: 1,
                            format: "R8G8B8A8",
                            cubemap: false,
                            mipmaps: params.mipmaps,
                            dynamic: params.dynamic,
                            renderable: params.renderable,
                            data: [255, 20, 147, 255, 255, 0, 0, 255, 255, 255, 255, 255, 255, 20, 147, 255]
                        });
                        if (params.onload) {
                            if (TurbulenzEngine) {
                                TurbulenzEngine.setTimeout(function() {
                                    params.onload(tex, 200)
                                }, 0)
                            } else {
                                window.setTimeout(function() {
                                    params.onload(tex, 200)
                                }, 0)
                            }
                        }
                        return tex
                    }
                }
                var img = new Image;
                var imageLoaded = function imageLoadedFn() {
                    tex.width = img.width;
                    tex.height = img.height;
                    tex.depth = 1;
                    tex.format = gd.PIXELFORMAT_R8G8B8A8;
                    tex.cubemap = false;
                    var result = tex.createGLTexture(img);
                    if (params.onload) {
                        params.onload(result ? tex : null, 200)
                    }
                };
                img.onload = imageLoaded;
                img.onerror = function imageFailedFn() {
                    tex.failed = true;
                    if (params.onload) {
                        params.onload(null)
                    }
                };
                if (data) {
                    if (typeof Blob !== "undefined" && typeof URL !== "undefined" && URL.createObjectURL) {
                        var dataBlob;
                        if (extension === ".jpg" || extension === ".jpeg") {
                            dataBlob = new Blob([data], {
                                type: "image/jpeg"
                            })
                        } else if (extension === ".png") {
                            dataBlob = new Blob([data], {
                                type: "image/png"
                            })
                        }
                        img.onload = function blobImageLoadedFn() {
                            imageLoaded();
                            URL.revokeObjectURL(img.src);
                            dataBlob = null
                        };
                        src = URL.createObjectURL(dataBlob)
                    } else {
                        if (extension === ".jpg" || extension === ".jpeg") {
                            src = "data:image/jpeg;base64," + TurbulenzEngine.base64Encode(data)
                        } else if (extension === ".png") {
                            src = "data:image/png;base64," + TurbulenzEngine.base64Encode(data)
                        }
                    }
                    img.src = src
                } else if (typeof URL !== "undefined" && URL.createObjectURL) {
                    var xhr = new XMLHttpRequest;
                    xhr.onreadystatechange = function() {
                        if (xhr.readyState === 4) {
                            if (!TurbulenzEngine || !TurbulenzEngine.isUnloading()) {
                                var xhrStatus = xhr.status;
                                if (xhrStatus === 0 && (window.location.protocol === "file:" || window.location.protocol === "chrome-extension:")) {
                                    xhrStatus = 200
                                }
                                if (xhr.getAllResponseHeaders() === "" && !xhr.response) {
                                    if (params.onload) {
                                        params.onload(null, 0)
                                    }
                                } else {
                                    if (xhrStatus === 200 || xhrStatus === 0) {
                                        var blob = xhr.response;
                                        img.onload = function blobImageLoadedFn() {
                                            imageLoaded();
                                            URL.revokeObjectURL(img.src);
                                            blob = null
                                        };
                                        img.src = URL.createObjectURL(blob)
                                    } else {
                                        params.onload(null, xhrStatus)
                                    }
                                }
                                xhr.onreadystatechange = null;
                                xhr = null
                            }
                            return tex
                        }
                    };
                    xhr.open("GET", src, true);
                    xhr.responseType = "blob";
                    xhr.send()
                } else {
                    img.crossOrigin = "anonymous";
                    img.src = src
                }
            } else {
                if ("" === src && params.onload) {
                    return null
                }
                var format = params.format;
                if (typeof format === "string") {
                    format = gd["PIXELFORMAT_" + format]
                }
                tex.width = params.width;
                tex.height = params.height;
                tex.depth = params.depth;
                tex.format = format;
                tex.cubemap = params.cubemap || false;
                tex.name = params.name;
                var result = tex.createGLTexture(params.data);
                if (!result) {
                    tex = null
                }
                if (params.renderable) {
                    if (gd.PIXELFORMAT_D16 === format) {
                        tex.glDepthAttachment = gd.gl.DEPTH_ATTACHMENT
                    } else if (gd.PIXELFORMAT_D24S8 === format) {
                        tex.glDepthAttachment = gd.gl.DEPTH_STENCIL_ATTACHMENT
                    }
                }
                if (params.onload) {
                    params.onload(tex, 200)
                }
            }
            return tex
        };
        TZWebGLTexture.version = 1;
        return TZWebGLTexture
    }();
    var WebGLVideo = function() {
        function WebGLVideo() {}
        WebGLVideo.prototype.play = function(seek) {
            var video = this.video;
            if (!this.playing) {
                this.playing = true;
                this.paused = false
            }
            if (seek === undefined) {
                seek = 0
            }
            if (.01 < Math.abs(video.currentTime - seek)) {
                try {
                    video.currentTime = seek
                } catch (e) {}
            }
            video.play();
            return true
        };
        WebGLVideo.prototype.stop = function() {
            var playing = this.playing;
            if (playing) {
                this.playing = false;
                this.paused = false;
                var video = this.video;
                video.pause();
                video.currentTime = 0
            }
            return playing
        };
        WebGLVideo.prototype.pause = function() {
            if (this.playing) {
                if (!this.paused) {
                    this.paused = true;
                    this.video.pause()
                }
                return true
            }
            return false
        };
        WebGLVideo.prototype.resume = function(seek) {
            if (this.paused) {
                this.paused = false;
                var video = this.video;
                if (seek !== undefined) {
                    if (.01 < Math.abs(video.currentTime - seek)) {
                        try {
                            video.currentTime = seek
                        } catch (e) {}
                    }
                }
                video.play();
                return true
            }
            return false
        };
        WebGLVideo.prototype.rewind = function() {
            if (this.playing) {
                this.video.currentTime = 0;
                return true
            }
            return false
        };
        WebGLVideo.prototype.destroy = function() {
            this.stop();
            if (this.video) {
                if (this.elementAdded) {
                    this.elementAdded = false;
                    TurbulenzEngine.canvas.parentElement.removeChild(this.video)
                }
                this.video = null
            }
        };
        WebGLVideo.create = function(params) {
            var v = new WebGLVideo;
            var onload = params.onload;
            var looping = params.looping;
            var src = params.src;
            var userAgent = navigator.userAgent.toLowerCase();
            var video = document.createElement("video");
            video.preload = "auto";
            video.autobuffer = true;
            video.muted = true;
            if (looping) {
                if (video.loop !== undefined && !userAgent.match(/firefox/)) {
                    video.loop = true
                } else {
                    video.onended = function() {
                        video.src = src;
                        video.play()
                    }
                }
            } else {
                video.onended = function() {
                    v.playing = false
                }
            }
            v.video = video;
            v.src = src;
            v.playing = false;
            v.paused = false;
            if (userAgent.match(/safari/) && !userAgent.match(/chrome/)) {
                video.setAttribute("style", "visibility: hidden;");
                TurbulenzEngine.canvas.parentElement.appendChild(video);
                v.elementAdded = true
            }
            if (video.webkitDecodedFrameCount !== undefined) {
                var lastFrameCount = -1,
                    tell = 0;
                Object.defineProperty(v, "tell", {
                    get: function tellFn() {
                        if (lastFrameCount !== this.video.webkitDecodedFrameCount) {
                            lastFrameCount = this.video.webkitDecodedFrameCount;
                            tell = this.video.currentTime
                        }
                        return tell
                    },
                    enumerable: true,
                    configurable: false
                })
            } else {
                Object.defineProperty(v, "tell", {
                    get: function tellFn() {
                        return this.video.currentTime
                    },
                    enumerable: true,
                    configurable: false
                })
            }
            Object.defineProperty(v, "looping", {
                get: function loopingFn() {
                    return looping
                },
                enumerable: true,
                configurable: false
            });
            var loadingVideoFailed = function loadingVideoFailedFn() {
                if (onload) {
                    onload(null);
                    onload = null
                }
                video.removeEventListener("error", loadingVideoFailed);
                video = null;
                v.video = null;
                v.playing = false
            };
            video.addEventListener("error", loadingVideoFailed, false);
            var videoCanPlay = function videoCanPlayFn() {
                v.length = video.duration;
                v.width = video.videoWidth;
                v.height = video.videoHeight;
                if (onload) {
                    onload(v, 200);
                    onload = null
                }
                video.removeEventListener("progress", checkProgress);
                video.removeEventListener("canplaythrough", videoCanPlay)
            };
            var checkProgress = function checkProgressFn() {
                if (0 < video.buffered.length && video.buffered.end(0) >= video.duration) {
                    videoCanPlay()
                }
            };
            video.addEventListener("progress", checkProgress, false);
            video.addEventListener("canplaythrough", videoCanPlay, false);
            video.crossorigin = "anonymous";
            video.src = src;
            return v
        };
        WebGLVideo.version = 1;
        return WebGLVideo
    }();
    var WebGLRenderBuffer = function() {
        function WebGLRenderBuffer() {}
        WebGLRenderBuffer.prototype.destroy = function() {
            var gd = this.gd;
            if (gd) {
                var glBuffer = this.glBuffer;
                if (glBuffer) {
                    var gl = gd.gl;
                    if (gl) {
                        gl.deleteRenderbuffer(glBuffer)
                    }
                    delete this.glBuffer
                }
                delete this.gd
            }
        };
        WebGLRenderBuffer.create = function(gd, params) {
            var renderBuffer = new WebGLRenderBuffer;
            var width = params.width;
            var height = params.height;
            var format = params.format;
            if (typeof format === "string") {
                format = gd["PIXELFORMAT_" + format]
            }
            if (format !== gd.PIXELFORMAT_D24S8 && format !== gd.PIXELFORMAT_D16) {
                return null
            }
            var gl = gd.gl;
            var glBuffer = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, glBuffer);
            var internalFormat;
            var attachment;
            if (gd.PIXELFORMAT_D16 === format) {
                internalFormat = gl.DEPTH_COMPONENT16;
                attachment = gl.DEPTH_ATTACHMENT
            } else {
                internalFormat = gl.DEPTH_STENCIL;
                attachment = gl.DEPTH_STENCIL_ATTACHMENT
            }
            gl.renderbufferStorage(gl.RENDERBUFFER, internalFormat, width, height);
            renderBuffer.width = gl.getRenderbufferParameter(gl.RENDERBUFFER, gl.RENDERBUFFER_WIDTH);
            renderBuffer.height = gl.getRenderbufferParameter(gl.RENDERBUFFER, gl.RENDERBUFFER_HEIGHT);
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);
            if (renderBuffer.width < width || renderBuffer.height < height) {
                gl.deleteRenderbuffer(glBuffer);
                return null
            }
            renderBuffer.gd = gd;
            renderBuffer.format = format;
            renderBuffer.glDepthAttachment = attachment;
            renderBuffer.glBuffer = glBuffer;
            renderBuffer.id = ++gd.counters.renderBuffers;
            return renderBuffer
        };
        WebGLRenderBuffer.version = 1;
        return WebGLRenderBuffer
    }();
    var WebGLRenderTarget = function() {
        function WebGLRenderTarget() {}
        WebGLRenderTarget.prototype.copyBox = function(dst, src) {
            dst[0] = src[0];
            dst[1] = src[1];
            dst[2] = src[2];
            dst[3] = src[3]
        };
        WebGLRenderTarget.prototype.bind = function() {
            var gd = this.gd;
            var gl = gd.gl;
            if (this.colorTexture0) {
                gd.unbindTexture(this.colorTexture0.glTexture);
                if (this.colorTexture1) {
                    gd.unbindTexture(this.colorTexture1.glTexture);
                    if (this.colorTexture2) {
                        gd.unbindTexture(this.colorTexture2.glTexture);
                        if (this.colorTexture3) {
                            gd.unbindTexture(this.colorTexture3.glTexture)
                        }
                    }
                }
            }
            if (this.depthTexture) {
                gd.unbindTexture(this.depthTexture.glTexture)
            }
            gl.bindFramebuffer(gl.FRAMEBUFFER, this.glObject);
            if (this.colorTexture1) {
                var drawBuffersExtension = gd.drawBuffersExtension;
                if (drawBuffersExtension) {
                    if (gd.WEBGL_draw_buffers) {
                        drawBuffersExtension.drawBuffersWEBGL(this.buffers)
                    } else {
                        drawBuffersExtension.drawBuffersEXT(this.buffers)
                    }
                }
            }
            var state = gd.state;
            this.copyBox(this.oldViewportBox, state.viewportBox);
            this.copyBox(this.oldScissorBox, state.scissorBox);
            gd.setViewport(0, 0, this.width, this.height);
            gd.setScissor(0, 0, this.width, this.height);
            return true
        };
        WebGLRenderTarget.prototype.unbind = function() {
            var gd = this.gd;
            var gl = gd.gl;
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            if (this.colorTexture1) {
                var drawBuffersExtension = gd.drawBuffersExtension;
                if (drawBuffersExtension) {
                    var buffers = [gl.BACK];
                    if (gd.WEBGL_draw_buffers) {
                        drawBuffersExtension.drawBuffersWEBGL(buffers)
                    } else {
                        drawBuffersExtension.drawBuffersEXT(buffers)
                    }
                }
            }
            var box = this.oldViewportBox;
            gd.setViewport(box[0], box[1], box[2], box[3]);
            box = this.oldScissorBox;
            gd.setScissor(box[0], box[1], box[2], box[3]);
            if (this.colorTexture0) {
                this.colorTexture0.updateMipmaps(this.face);
                if (this.colorTexture1) {
                    this.colorTexture1.updateMipmaps(this.face);
                    if (this.colorTexture2) {
                        this.colorTexture2.updateMipmaps(this.face);
                        if (this.colorTexture3) {
                            this.colorTexture3.updateMipmaps(this.face)
                        }
                    }
                }
            }
            if (this.depthTexture) {
                this.depthTexture.updateMipmaps(this.face)
            }
        };
        WebGLRenderTarget.prototype._updateColorAttachement = function(colorTexture, index) {
            var glTexture = colorTexture.glTexture;
            var gl = this.gd.gl;
            gl.bindFramebuffer(gl.FRAMEBUFFER, this.glObject);
            if (colorTexture.cubemap) {
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + index, gl.TEXTURE_CUBE_MAP_POSITIVE_X + this.face, glTexture, 0)
            } else {
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + index, gl.TEXTURE_2D, glTexture, 0)
            }
            gl.bindFramebuffer(gl.FRAMEBUFFER, null)
        };
        WebGLRenderTarget.prototype.getWidth = function() {
            if (this.colorTexture0) {
                return this.colorTexture0.width
            } else if (this.depthBuffer) {
                return this.depthBuffer.width
            } else if (this.depthTexture) {
                return this.depthTexture.width
            }
        };
        WebGLRenderTarget.prototype.getHeight = function() {
            if (this.colorTexture0) {
                return this.colorTexture0.height
            } else if (this.depthBuffer) {
                return this.depthBuffer.height
            } else if (this.depthTexture) {
                return this.depthTexture.height
            }
        };
        WebGLRenderTarget.prototype.setColorTexture0 = function(colorTexture0) {
            var oldColorTexture0 = this.colorTexture0;
            this.colorTexture0 = colorTexture0;
            this._updateColorAttachement(this.colorTexture0, 0)
        };
        WebGLRenderTarget.prototype.setColorTexture1 = function(colorTexture1) {
            var oldColorTexture1 = this.colorTexture1;
            this.colorTexture1 = colorTexture1;
            this._updateColorAttachement(this.colorTexture1, 1)
        };
        WebGLRenderTarget.prototype.setColorTexture2 = function(colorTexture2) {
            var oldColorTexture2 = this.colorTexture2;
            this.colorTexture2 = colorTexture2;
            this._updateColorAttachement(this.colorTexture2, 2)
        };
        WebGLRenderTarget.prototype.setColorTexture3 = function(colorTexture3) {
            var oldColorTexture3 = this.colorTexture3;
            this.colorTexture3 = colorTexture3;
            this._updateColorAttachement(this.colorTexture3, 3)
        };
        WebGLRenderTarget.prototype.destroy = function() {
            var gd = this.gd;
            if (gd) {
                var glObject = this.glObject;
                if (glObject) {
                    var gl = gd.gl;
                    if (gl) {
                        gl.deleteFramebuffer(glObject)
                    }
                    delete this.glObject
                }
                delete this.colorTexture0;
                delete this.colorTexture1;
                delete this.colorTexture2;
                delete this.colorTexture3;
                delete this.depthBuffer;
                delete this.depthTexture;
                delete this.gd
            }
        };
        WebGLRenderTarget.create = function(gd, params) {
            var renderTarget = new WebGLRenderTarget;
            var colorTexture0 = params.colorTexture0;
            var colorTexture1 = colorTexture0 ? params.colorTexture1 || null : null;
            var colorTexture2 = colorTexture1 ? params.colorTexture2 || null : null;
            var colorTexture3 = colorTexture2 ? params.colorTexture3 || null : null;
            var depthBuffer = params.depthBuffer || null;
            var depthTexture = params.depthTexture || null;
            var face = params.face;
            var maxSupported = gd.maxSupported("RENDERTARGET_COLOR_TEXTURES");
            if (colorTexture1 && maxSupported < 2) {
                return null
            }
            if (colorTexture2 && maxSupported < 3) {
                return null
            }
            if (colorTexture3 && maxSupported < 4) {
                return null
            }
            var gl = gd.gl;
            var colorAttachment0 = gl.COLOR_ATTACHMENT0;
            var glObject = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, glObject);
            var width, height;
            if (colorTexture0) {
                width = colorTexture0.width;
                height = colorTexture0.height;
                var glTexture = colorTexture0.glTexture;
                if (glTexture === undefined) {
                    TurbulenzEngine.callOnError("Color texture is not a Texture");
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                    gl.deleteFramebuffer(glObject);
                    return null
                }
                if (colorTexture0.cubemap) {
                    gl.framebufferTexture2D(gl.FRAMEBUFFER, colorAttachment0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, glTexture, 0)
                } else {
                    gl.framebufferTexture2D(gl.FRAMEBUFFER, colorAttachment0, gl.TEXTURE_2D, glTexture, 0)
                }
                if (colorTexture1) {
                    glTexture = colorTexture1.glTexture;
                    if (colorTexture1.cubemap) {
                        gl.framebufferTexture2D(gl.FRAMEBUFFER, colorAttachment0 + 1, gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, glTexture, 0)
                    } else {
                        gl.framebufferTexture2D(gl.FRAMEBUFFER, colorAttachment0 + 1, gl.TEXTURE_2D, glTexture, 0)
                    }
                    if (colorTexture2) {
                        glTexture = colorTexture2.glTexture;
                        if (colorTexture1.cubemap) {
                            gl.framebufferTexture2D(gl.FRAMEBUFFER, colorAttachment0 + 2, gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, glTexture, 0)
                        } else {
                            gl.framebufferTexture2D(gl.FRAMEBUFFER, colorAttachment0 + 2, gl.TEXTURE_2D, glTexture, 0)
                        }
                        if (colorTexture3) {
                            glTexture = colorTexture3.glTexture;
                            if (colorTexture1.cubemap) {
                                gl.framebufferTexture2D(gl.FRAMEBUFFER, colorAttachment0 + 3, gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, glTexture, 0)
                            } else {
                                gl.framebufferTexture2D(gl.FRAMEBUFFER, colorAttachment0 + 3, gl.TEXTURE_2D, glTexture, 0)
                            }
                        }
                    }
                }
            } else if (depthTexture) {
                width = depthTexture.width;
                height = depthTexture.height
            } else if (depthBuffer) {
                width = depthBuffer.width;
                height = depthBuffer.height
            } else {
                TurbulenzEngine.callOnError("No RenderBuffers or Textures specified for this RenderTarget");
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.deleteFramebuffer(glObject);
                return null
            }
            if (depthTexture) {
                gl.framebufferTexture2D(gl.FRAMEBUFFER, depthTexture.glDepthAttachment, gl.TEXTURE_2D, depthTexture.glTexture, 0)
            } else if (depthBuffer) {
                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, depthBuffer.glDepthAttachment, gl.RENDERBUFFER, depthBuffer.glBuffer)
            }
            var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            if (status !== gl.FRAMEBUFFER_COMPLETE) {
                gl.deleteFramebuffer(glObject);
                return null
            }
            renderTarget.gd = gd;
            renderTarget.glObject = glObject;
            renderTarget.colorTexture0 = colorTexture0;
            renderTarget.colorTexture1 = colorTexture1;
            renderTarget.colorTexture2 = colorTexture2;
            renderTarget.colorTexture3 = colorTexture3;
            renderTarget.depthBuffer = depthBuffer;
            renderTarget.depthTexture = depthTexture;
            renderTarget.width = width;
            renderTarget.height = height;
            renderTarget.face = face;
            if (gd.drawBuffersExtension) {
                var buffers;
                if (colorTexture0) {
                    buffers = [colorAttachment0];
                    if (colorTexture1) {
                        buffers.push(colorAttachment0 + 1);
                        if (colorTexture2) {
                            buffers.push(colorAttachment0 + 2);
                            if (colorTexture3) {
                                buffers.push(colorAttachment0 + 3)
                            }
                        }
                    }
                } else {
                    buffers = [gl.NONE]
                }
                renderTarget.buffers = buffers
            }
            renderTarget.id = ++gd.counters.renderTargets;
            return renderTarget
        };
        WebGLRenderTarget.version = 1;
        return WebGLRenderTarget
    }();
    WebGLRenderTarget.prototype.oldViewportBox = [];
    WebGLRenderTarget.prototype.oldScissorBox = [];
    var WebGLIndexBuffer = function() {
        function WebGLIndexBuffer() {}
        WebGLIndexBuffer.prototype.map = function(offset, numIndices) {
            if (offset === undefined) {
                offset = 0
            }
            if (numIndices === undefined) {
                numIndices = this.numIndices
            }
            var gd = this.gd;
            var gl = gd.gl;
            var format = this.format;
            var data;
            if (format === gl.UNSIGNED_BYTE) {
                data = new Uint8Array(numIndices)
            } else if (format === gl.UNSIGNED_SHORT) {
                data = new Uint16Array(numIndices)
            } else {
                data = new Uint32Array(numIndices)
            }
            var numValues = 0;
            var writer = function indexBufferWriterFn() {
                var numArguments = arguments.length;
                for (var n = 0; n < numArguments; n += 1) {
                    data[numValues] = arguments[n];
                    numValues += 1
                }
            };
            writer.write = writer;
            writer.data = data;
            writer.offset = offset;
            writer.getNumWrittenIndices = function getNumWrittenIndicesFn() {
                return numValues
            };
            writer.write = writer;
            return writer
        };
        WebGLIndexBuffer.prototype.unmap = function(writer) {
            if (writer) {
                var gd = this.gd;
                var gl = gd.gl;
                var data = writer.data;
                delete writer.data;
                var offset = writer.offset;
                delete writer.write;
                var numIndices = writer.getNumWrittenIndices();
                if (!numIndices) {
                    return
                }
                if (numIndices < data.length) {
                    data = data.subarray(0, numIndices)
                }
                gd.setIndexBuffer(this);
                if (numIndices < this.numIndices) {
                    gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, offset, data)
                } else {
                    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, this.usage)
                }
            }
        };
        WebGLIndexBuffer.prototype.setData = function(data, offset, numIndices) {
            if (offset === undefined) {
                offset = 0
            }
            if (numIndices === undefined) {
                numIndices = this.numIndices
            }
            var gd = this.gd;
            var gl = gd.gl;
            var bufferData;
            var format = this.format;
            if (format === gl.UNSIGNED_BYTE) {
                if (data instanceof Uint8Array) {
                    bufferData = data
                } else {
                    bufferData = new Uint8Array(data)
                }
            } else if (format === gl.UNSIGNED_SHORT) {
                if (data instanceof Uint16Array) {
                    bufferData = data
                } else {
                    bufferData = new Uint16Array(data)
                }
                offset *= 2
            } else if (format === gl.UNSIGNED_INT) {
                if (data instanceof Uint32Array) {
                    bufferData = data
                } else {
                    bufferData = new Uint32Array(data)
                }
                offset *= 4
            }
            data = undefined;
            if (numIndices < bufferData.length) {
                bufferData = bufferData.subarray(0, numIndices)
            }
            gd.setIndexBuffer(this);
            if (numIndices < this.numIndices) {
                gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, offset, bufferData)
            } else {
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, bufferData, this.usage)
            }
        };
        WebGLIndexBuffer.prototype.destroy = function() {
            var gd = this.gd;
            if (gd) {
                var glBuffer = this.glBuffer;
                if (glBuffer) {
                    var gl = gd.gl;
                    if (gl) {
                        gd.unsetIndexBuffer(this);
                        gl.deleteBuffer(glBuffer)
                    }
                    delete this.glBuffer
                }
                delete this.gd
            }
        };
        WebGLIndexBuffer.create = function(gd, params) {
            var gl = gd.gl;
            var ib = new WebGLIndexBuffer;
            ib.gd = gd;
            var numIndices = params.numIndices;
            ib.numIndices = numIndices;
            var format = params.format;
            if (typeof format === "string") {
                format = gd["INDEXFORMAT_" + format]
            }
            ib.format = format;
            var stride;
            if (format === gl.UNSIGNED_BYTE) {
                stride = 1
            } else if (format === gl.UNSIGNED_SHORT) {
                stride = 2
            } else {
                stride = 4
            }
            ib.stride = stride;
            ib["transient"] = params["transient"] || false;
            ib.dynamic = params.dynamic || ib["transient"];
            ib.usage = ib["transient"] ? gl.STREAM_DRAW : ib.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
            ib.glBuffer = gl.createBuffer();
            if (params.data) {
                ib.setData(params.data, 0, numIndices)
            } else {
                gd.setIndexBuffer(ib);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, numIndices * stride, ib.usage)
            }
            ib.id = ++gd.counters.indexBuffers;
            return ib
        };
        WebGLIndexBuffer.version = 1;
        return WebGLIndexBuffer
    }();
    var WebGLSemantics = function() {
        function WebGLSemantics() {}
        WebGLSemantics.create = function(gd, attributes) {
            var semantics = new WebGLSemantics;
            var numAttributes = attributes.length;
            semantics.length = numAttributes;
            for (var i = 0; i < numAttributes; i += 1) {
                var attribute = attributes[i];
                if (typeof attribute === "string") {
                    semantics[i] = gd["SEMANTIC_" + attribute]
                } else {
                    semantics[i] = attribute
                }
            }
            return semantics
        };
        WebGLSemantics.version = 1;
        return WebGLSemantics
    }();
    var WebGLVertexBuffer = function() {
        function WebGLVertexBuffer() {}
        WebGLVertexBuffer.prototype.map = function(offset, numVertices) {
            if (offset === undefined) {
                offset = 0
            }
            if (numVertices === undefined) {
                numVertices = this.numVertices
            }
            var gd = this.gd;
            var gl = gd.gl;
            var numValuesPerVertex = this.stride;
            var attributes = this.attributes;
            var numAttributes = attributes.length;
            var data, writer;
            var numValues = 0;
            if (this.hasSingleFormat) {
                var maxNumValues = numVertices * numValuesPerVertex;
                var format = attributes[0].format;
                if (format === gl.FLOAT) {
                    data = new Float32Array(maxNumValues)
                } else if (format === gl.BYTE) {
                    data = new Int8Array(maxNumValues)
                } else if (format === gl.UNSIGNED_BYTE) {
                    data = new Uint8Array(maxNumValues)
                } else if (format === gl.SHORT) {
                    data = new Int16Array(maxNumValues)
                } else if (format === gl.UNSIGNED_SHORT) {
                    data = new Uint16Array(maxNumValues)
                } else if (format === gl.INT) {
                    data = new Int32Array(maxNumValues)
                } else if (format === gl.UNSIGNED_INT) {
                    data = new Uint32Array(maxNumValues)
                }
                writer = function vertexBufferWriterSingleFn() {
                    var numArguments = arguments.length;
                    var currentArgument = 0;
                    for (var a = 0; a < numAttributes; a += 1) {
                        var attribute = attributes[a];
                        var numComponents = attribute.numComponents;
                        var currentComponent = 0,
                            j;
                        do {
                            if (currentArgument < numArguments) {
                                var value = arguments[currentArgument];
                                currentArgument += 1;
                                if (typeof value === "number") {
                                    if (attribute.normalized) {
                                        value *= attribute.normalizationScale
                                    }
                                    data[numValues] = value;
                                    numValues += 1;
                                    currentComponent += 1
                                } else if (currentComponent === 0) {
                                    var numSubArguments = value.length;
                                    if (numSubArguments > numComponents) {
                                        numSubArguments = numComponents
                                    }
                                    if (attribute.normalized) {
                                        var scale = attribute.normalizationScale;
                                        for (j = 0; j < numSubArguments; j += 1) {
                                            data[numValues] = value[j] * scale;
                                            numValues += 1;
                                            currentComponent += 1
                                        }
                                    } else {
                                        for (j = 0; j < numSubArguments; j += 1) {
                                            data[numValues] = value[j];
                                            numValues += 1;
                                            currentComponent += 1
                                        }
                                    }
                                    while (currentComponent < numComponents) {
                                        numValues += 1;
                                        currentComponent += 1
                                    }
                                    break
                                } else {
                                    TurbulenzEngine.callOnError("Missing values for attribute " + a);
                                    return null
                                }
                            } else {
                                numValues += 1;
                                currentComponent += 1
                            }
                        } while (currentComponent < numComponents)
                    }
                }
            } else {
                var destOffset = 0;
                var bufferSize = numVertices * this.strideInBytes;
                data = new ArrayBuffer(bufferSize);
                if (typeof DataView !== "undefined" && "setFloat32" in DataView.prototype) {
                    var dataView = new DataView(data);
                    writer = function vertexBufferWriterDataViewFn() {
                        var numArguments = arguments.length;
                        var currentArgument = 0;
                        for (var a = 0; a < numAttributes; a += 1) {
                            var attribute = attributes[a];
                            var numComponents = attribute.numComponents;
                            var setter = attribute.typedSetter;
                            var componentStride = attribute.componentStride;
                            var currentComponent = 0,
                                j;
                            do {
                                if (currentArgument < numArguments) {
                                    var value = arguments[currentArgument];
                                    currentArgument += 1;
                                    if (typeof value === "number") {
                                        if (attribute.normalized) {
                                            value *= attribute.normalizationScale
                                        }
                                        setter.call(dataView, destOffset, value, true);
                                        destOffset += componentStride;
                                        currentComponent += 1;
                                        numValues += 1
                                    } else if (currentComponent === 0) {
                                        var numSubArguments = value.length;
                                        if (numSubArguments > numComponents) {
                                            numSubArguments = numComponents
                                        }
                                        if (attribute.normalized) {
                                            var scale = attribute.normalizationScale;
                                            for (j = 0; j < numSubArguments; j += 1) {
                                                setter.call(dataView, destOffset, value[j] * scale, true);
                                                destOffset += componentStride;
                                                currentComponent += 1;
                                                numValues += 1
                                            }
                                        } else {
                                            for (j = 0; j < numSubArguments; j += 1) {
                                                setter.call(dataView, destOffset, value[j], true);
                                                destOffset += componentStride;
                                                currentComponent += 1;
                                                numValues += 1
                                            }
                                        }
                                        while (currentComponent < numComponents) {
                                            numValues += 1;
                                            currentComponent += 1
                                        }
                                        break
                                    } else {
                                        TurbulenzEngine.callOnError("Missing values for attribute " + a);
                                        return null
                                    }
                                } else {
                                    numValues += 1;
                                    currentComponent += 1
                                }
                            } while (currentComponent < numComponents)
                        }
                    }
                } else {
                    writer = function vertexBufferWriterMultiFn() {
                        var numArguments = arguments.length;
                        var currentArgument = 0;
                        var dest;
                        for (var a = 0; a < numAttributes; a += 1) {
                            var attribute = attributes[a];
                            var numComponents = attribute.numComponents;
                            dest = new attribute.typedArray(data, destOffset, numComponents);
                            destOffset += attribute.stride;
                            var currentComponent = 0,
                                j;
                            do {
                                if (currentArgument < numArguments) {
                                    var value = arguments[currentArgument];
                                    currentArgument += 1;
                                    if (typeof value === "number") {
                                        if (attribute.normalized) {
                                            value *= attribute.normalizationScale
                                        }
                                        dest[currentComponent] = value;
                                        currentComponent += 1;
                                        numValues += 1
                                    } else if (currentComponent === 0) {
                                        var numSubArguments = value.length;
                                        if (numSubArguments > numComponents) {
                                            numSubArguments = numComponents
                                        }
                                        if (attribute.normalized) {
                                            var scale = attribute.normalizationScale;
                                            for (j = 0; j < numSubArguments; j += 1) {
                                                dest[currentComponent] = value[j] * scale;
                                                currentComponent += 1;
                                                numValues += 1
                                            }
                                        } else {
                                            for (j = 0; j < numSubArguments; j += 1) {
                                                dest[currentComponent] = value[j];
                                                currentComponent += 1;
                                                numValues += 1
                                            }
                                        }
                                        while (currentComponent < numComponents) {
                                            currentComponent += 1;
                                            numValues += 1
                                        }
                                        break
                                    } else {
                                        TurbulenzEngine.callOnError("Missing values for attribute " + a);
                                        return null
                                    }
                                } else {
                                    currentComponent += 1;
                                    numValues += 1
                                }
                            } while (currentComponent < numComponents)
                        }
                    }
                }
            }
            writer.data = data;
            writer.offset = offset;
            writer.getNumWrittenVertices = function getNumWrittenVerticesFn() {
                return Math.floor(numValues / numValuesPerVertex)
            };
            writer.getNumWrittenValues = function getNumWrittenValuesFn() {
                return numValues
            };
            writer.write = writer;
            return writer
        };
        WebGLVertexBuffer.prototype.unmap = function(writer) {
            if (writer) {
                var data = writer.data;
                delete writer.data;
                delete writer.write;
                var numVertices = writer.getNumWrittenVertices();
                if (!numVertices) {
                    return
                }
                var offset = writer.offset;
                var stride = this.strideInBytes;
                if (this.hasSingleFormat) {
                    var numValues = writer.getNumWrittenValues();
                    if (numValues < data.length) {
                        data = data.subarray(0, numValues)
                    }
                } else {
                    var numBytes = numVertices * stride;
                    if (numBytes < data.byteLength) {
                        data = data.slice(0, numBytes)
                    }
                }
                var gd = this.gd;
                var gl = gd.gl;
                gd.bindVertexBuffer(this.glBuffer);
                if (numVertices < this.numVertices) {
                    gl.bufferSubData(gl.ARRAY_BUFFER, offset * stride, data)
                } else {
                    gl.bufferData(gl.ARRAY_BUFFER, data, this.usage)
                }
            }
        };
        WebGLVertexBuffer.prototype.setData = function(data, offset, numVertices) {
            if (offset === undefined) {
                offset = 0
            }
            if (numVertices === undefined) {
                numVertices = this.numVertices
            }
            var gd = this.gd;
            var gl = gd.gl;
            var strideInBytes = this.strideInBytes;
            if (data.constructor === ArrayBuffer) {
                gd.bindVertexBuffer(this.glBuffer);
                if (numVertices < this.numVertices) {
                    gl.bufferSubData(gl.ARRAY_BUFFER, offset * strideInBytes, data)
                } else {
                    gl.bufferData(gl.ARRAY_BUFFER, data, this.usage)
                }
                return
            }
            var attributes = this.attributes;
            var numAttributes = this.numAttributes;
            var attribute, format, bufferData, TypedArrayConstructor;
            if (this.hasSingleFormat) {
                attribute = attributes[0];
                format = attribute.format;
                if (format === gl.FLOAT) {
                    if (!(data instanceof Float32Array)) {
                        TypedArrayConstructor = Float32Array
                    }
                } else if (format === gl.BYTE) {
                    if (!(data instanceof Int8Array)) {
                        TypedArrayConstructor = Int8Array
                    }
                } else if (format === gl.UNSIGNED_BYTE) {
                    if (!(data instanceof Uint8Array)) {
                        TypedArrayConstructor = Uint8Array
                    }
                } else if (format === gl.SHORT) {
                    if (!(data instanceof Int16Array)) {
                        TypedArrayConstructor = Int16Array
                    }
                } else if (format === gl.UNSIGNED_SHORT) {
                    if (!(data instanceof Uint16Array)) {
                        TypedArrayConstructor = Uint16Array
                    }
                } else if (format === gl.INT) {
                    if (!(data instanceof Int32Array)) {
                        TypedArrayConstructor = Int32Array
                    }
                } else if (format === gl.UNSIGNED_INT) {
                    if (!(data instanceof Uint32Array)) {
                        TypedArrayConstructor = Uint32Array
                    }
                }
                var numValuesPerVertex = this.stride;
                var numValues = numVertices * numValuesPerVertex;
                if (TypedArrayConstructor) {
                    if (attribute.normalized) {
                        data = this.scaleValues(data, attribute.normalizationScale, numValues)
                    }
                    bufferData = new TypedArrayConstructor(data);
                    if (numValues < bufferData.length) {
                        bufferData = bufferData.subarray(0, numValues)
                    }
                } else {
                    bufferData = data
                }
                if (numValues < data.length) {
                    bufferData = bufferData.subarray(0, numValues)
                }
            } else {
                var bufferSize = numVertices * strideInBytes;
                bufferData = new ArrayBuffer(bufferSize);
                var srcOffset = 0,
                    destOffset = 0,
                    v, c, a, numComponents, componentStride, scale;
                if (typeof DataView !== "undefined" && "setFloat32" in DataView.prototype) {
                    var dataView = new DataView(bufferData);
                    for (v = 0; v < numVertices; v += 1) {
                        for (a = 0; a < numAttributes; a += 1) {
                            attribute = attributes[a];
                            numComponents = attribute.numComponents;
                            componentStride = attribute.componentStride;
                            var setter = attribute.typedSetter;
                            if (attribute.normalized) {
                                scale = attribute.normalizationScale;
                                for (c = 0; c < numComponents; c += 1) {
                                    setter.call(dataView, destOffset, data[srcOffset] * scale, true);
                                    destOffset += componentStride;
                                    srcOffset += 1
                                }
                            } else {
                                for (c = 0; c < numComponents; c += 1) {
                                    setter.call(dataView, destOffset, data[srcOffset], true);
                                    destOffset += componentStride;
                                    srcOffset += 1
                                }
                            }
                        }
                    }
                } else {
                    for (v = 0; v < numVertices; v += 1) {
                        for (a = 0; a < numAttributes; a += 1) {
                            attribute = attributes[a];
                            numComponents = attribute.numComponents;
                            var dest = new attribute.typedArray(bufferData, destOffset, numComponents);
                            destOffset += attribute.stride;
                            if (attribute.normalized) {
                                scale = attribute.normalizationScale;
                                for (c = 0; c < numComponents; c += 1) {
                                    dest[c] = data[srcOffset] * scale;
                                    srcOffset += 1
                                }
                            } else {
                                for (c = 0; c < numComponents; c += 1) {
                                    dest[c] = data[srcOffset];
                                    srcOffset += 1
                                }
                            }
                        }
                    }
                }
            }
            data = undefined;
            gd.bindVertexBuffer(this.glBuffer);
            if (numVertices < this.numVertices) {
                gl.bufferSubData(gl.ARRAY_BUFFER, offset * strideInBytes, bufferData)
            } else {
                gl.bufferData(gl.ARRAY_BUFFER, bufferData, this.usage)
            }
        };
        WebGLVertexBuffer.prototype.scaleValues = function(values, scale, numValues) {
            if (numValues === undefined) {
                numValues = values.length
            }
            var scaledValues = new values.constructor(numValues);
            for (var n = 0; n < numValues; n += 1) {
                scaledValues[n] = values[n] * scale
            }
            return scaledValues
        };
        WebGLVertexBuffer.prototype.bindAttributes = function(numAttributes, attributes, offset) {
            var gd = this.gd;
            var gl = gd.gl;
            var vertexAttributes = this.attributes;
            var stride = this.strideInBytes;
            var attributeMask = 0;
            for (var n = 0; n < numAttributes; n += 1) {
                var vertexAttribute = vertexAttributes[n];
                var attribute = attributes[n];
                attributeMask |= 1 << attribute;
                gl.vertexAttribPointer(attribute, vertexAttribute.numComponents, vertexAttribute.format, vertexAttribute.normalized, stride, offset);
                offset += vertexAttribute.stride
            }
            return attributeMask
        };
        WebGLVertexBuffer.prototype.setAttributes = function(attributes) {
            var gd = this.gd;
            var numAttributes = attributes.length;
            this.numAttributes = numAttributes;
            this.attributes = [];
            var stride = 0,
                numValuesPerVertex = 0,
                hasSingleFormat = true;
            for (var i = 0; i < numAttributes; i += 1) {
                var format = attributes[i];
                if (typeof format === "string") {
                    format = gd["VERTEXFORMAT_" + format]
                }
                this.attributes[i] = format;
                stride += format.stride;
                numValuesPerVertex += format.numComponents;
                if (hasSingleFormat && i) {
                    if (format.format !== this.attributes[i - 1].format) {
                        hasSingleFormat = false
                    }
                }
            }
            this.strideInBytes = stride;
            this.stride = numValuesPerVertex;
            this.hasSingleFormat = hasSingleFormat;
            return stride
        };
        WebGLVertexBuffer.prototype.resize = function(size) {
            if (size !== this.strideInBytes * this.numVertices) {
                var gd = this.gd;
                var gl = gd.gl;
                gd.bindVertexBuffer(this.glBuffer);
                var bufferType = gl.ARRAY_BUFFER;
                gl.bufferData(bufferType, size, this.usage);
                var bufferSize = gl.getBufferParameter(bufferType, gl.BUFFER_SIZE);
                this.numVertices = Math.floor(bufferSize / this.strideInBytes)
            }
        };
        WebGLVertexBuffer.prototype.destroy = function() {
            var gd = this.gd;
            if (gd) {
                var glBuffer = this.glBuffer;
                if (glBuffer) {
                    var gl = gd.gl;
                    if (gl) {
                        gd.unbindVertexBuffer(glBuffer);
                        gl.deleteBuffer(glBuffer)
                    }
                    delete this.glBuffer
                }
                delete this.gd
            }
        };
        WebGLVertexBuffer.create = function(gd, params) {
            var gl = gd.gl;
            var vb = new WebGLVertexBuffer;
            vb.gd = gd;
            var numVertices = params.numVertices;
            vb.numVertices = numVertices;
            var strideInBytes = vb.setAttributes(params.attributes);
            vb["transient"] = params["transient"] || false;
            vb.dynamic = params.dynamic || vb["transient"];
            vb.usage = vb["transient"] ? gl.STREAM_DRAW : vb.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
            vb.glBuffer = gl.createBuffer();
            var bufferSize = numVertices * strideInBytes;
            if (params.data) {
                vb.setData(params.data, 0, numVertices)
            } else {
                gd.bindVertexBuffer(vb.glBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, bufferSize, vb.usage)
            }
            vb.id = ++gd.counters.vertexBuffers;
            return vb
        };
        WebGLVertexBuffer.version = 1;
        return WebGLVertexBuffer
    }();
    var WebGLPass = function() {
        function WebGLPass() {}
        WebGLPass.prototype.updateParametersData = function(gd) {
            var gl = gd.gl;
            this.dirty = false;
            var parameters = this.parameters;
            for (var p in parameters) {
                if (parameters.hasOwnProperty(p)) {
                    var parameter = parameters[p];
                    if (parameter.dirty) {
                        parameter.dirty = 0;
                        var paramInfo = parameter.info;
                        var location = parameter.location;
                        if (paramInfo && null !== location) {
                            var parameterValues = paramInfo.values;
                            var numColumns;
                            if (paramInfo.type === "float") {
                                numColumns = paramInfo.columns;
                                if (4 === numColumns) {
                                    gl.uniform4fv(location, parameterValues)
                                } else if (3 === numColumns) {
                                    gl.uniform3fv(location, parameterValues)
                                } else if (2 === numColumns) {
                                    gl.uniform2fv(location, parameterValues)
                                } else if (1 === paramInfo.rows) {
                                    gl.uniform1f(location, parameterValues[0])
                                } else {
                                    gl.uniform1fv(location, parameterValues)
                                }
                            } else if (paramInfo.sampler !== undefined) {
                                gd.setTexture(parameter.textureUnit, parameterValues, paramInfo.sampler)
                            } else {
                                numColumns = paramInfo.columns;
                                if (4 === numColumns) {
                                    gl.uniform4iv(location, parameterValues)
                                } else if (3 === numColumns) {
                                    gl.uniform3iv(location, parameterValues)
                                } else if (2 === numColumns) {
                                    gl.uniform2iv(location, parameterValues)
                                } else if (1 === paramInfo.rows) {
                                    gl.uniform1i(location, parameterValues[0])
                                } else {
                                    gl.uniform1iv(location, parameterValues)
                                }
                            }
                        }
                    }
                }
            }
        };
        WebGLPass.prototype.initializeParameters = function(gd) {
            var gl = gd.gl;
            var glProgram = this.glProgram;
            gd.setProgram(glProgram);
            var passParameters = this.parameters;
            for (var p in passParameters) {
                if (passParameters.hasOwnProperty(p)) {
                    var parameter = passParameters[p];
                    var paramInfo = parameter.info;
                    if (paramInfo) {
                        var location = gl.getUniformLocation(glProgram, p);
                        if (null !== location) {
                            parameter.location = location;
                            if (paramInfo.sampler) {
                                gl.uniform1i(location, parameter.textureUnit)
                            } else {
                                var parameterValues = paramInfo.values;
                                var numColumns;
                                if (paramInfo.type === "float") {
                                    numColumns = paramInfo.columns;
                                    if (4 === numColumns) {
                                        gl.uniform4fv(location, parameterValues)
                                    } else if (3 === numColumns) {
                                        gl.uniform3fv(location, parameterValues)
                                    } else if (2 === numColumns) {
                                        gl.uniform2fv(location, parameterValues)
                                    } else if (1 === paramInfo.rows) {
                                        gl.uniform1f(location, parameterValues[0])
                                    } else {
                                        gl.uniform1fv(location, parameterValues)
                                    }
                                } else {
                                    numColumns = paramInfo.columns;
                                    if (4 === numColumns) {
                                        gl.uniform4iv(location, parameterValues)
                                    } else if (3 === numColumns) {
                                        gl.uniform3iv(location, parameterValues)
                                    } else if (2 === numColumns) {
                                        gl.uniform2iv(location, parameterValues)
                                    } else if (1 === paramInfo.rows) {
                                        gl.uniform1i(location, parameterValues[0])
                                    } else {
                                        gl.uniform1iv(location, parameterValues)
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
        WebGLPass.prototype.destroy = function() {
            delete this.glProgram;
            delete this.semanticsMask;
            delete this.parameters;
            delete this.states;
            delete this.statesSet
        };
        WebGLPass.create = function(gd, shader, params) {
            var gl = gd.gl;
            var pass = new WebGLPass;
            pass.name = params.name || null;
            var programs = shader.programs;
            var parameters = shader.parameters;
            var parameterNames = params.parameters;
            var programNames = params.programs;
            var semanticNames = params.semantics;
            var states = params.states;
            var compoundProgramName = programNames.join(":");
            var linkedProgram = shader.linkedPrograms[compoundProgramName];
            var glProgram, semanticsMask, p, s;
            if (linkedProgram === undefined) {
                glProgram = gl.createProgram();
                var numPrograms = programNames.length;
                for (p = 0; p < numPrograms; p += 1) {
                    var glShader = programs[programNames[p]];
                    if (glShader) {
                        gl.attachShader(glProgram, glShader)
                    }
                }
                var numSemantics = semanticNames.length;
                semanticsMask = 0;
                for (s = 0; s < numSemantics; s += 1) {
                    var semanticName = semanticNames[s];
                    var attribute = gd["SEMANTIC_" + semanticName];
                    if (attribute !== undefined) {
                        semanticsMask |= 1 << attribute;
                        if (0 === semanticName.indexOf("ATTR")) {
                            gl.bindAttribLocation(glProgram, attribute, semanticName)
                        } else {
                            var attributeName = WebGLPass.semanticToAttr[semanticName];
                            gl.bindAttribLocation(glProgram, attribute, attributeName)
                        }
                    }
                }
                gl.linkProgram(glProgram);
                shader.linkedPrograms[compoundProgramName] = {
                    glProgram: glProgram,
                    semanticsMask: semanticsMask
                }
            } else {
                glProgram = linkedProgram.glProgram;
                semanticsMask = linkedProgram.semanticsMask
            }
            pass.glProgram = glProgram;
            pass.semanticsMask = semanticsMask;
            var numTextureUnits = 0;
            var passParameters = {};
            pass.parameters = passParameters;
            var numParameters = parameterNames ? parameterNames.length : 0;
            for (p = 0; p < numParameters; p += 1) {
                var parameterName = parameterNames[p];
                var parameter = {};
                passParameters[parameterName] = parameter;
                var paramInfo = parameters[parameterName];
                parameter.info = paramInfo;
                if (paramInfo) {
                    parameter.location = null;
                    if (paramInfo.sampler) {
                        parameter.textureUnit = numTextureUnits;
                        numTextureUnits += 1
                    } else {
                        parameter.textureUnit = undefined
                    }
                }
            }
            pass.numTextureUnits = numTextureUnits;
            pass.numParameters = numParameters;

            function equalRenderStates(defaultValues, values) {
                var numDefaultValues = defaultValues.length;
                var n;
                for (n = 0; n < numDefaultValues; n += 1) {
                    if (defaultValues[n] !== values[n]) {
                        return false
                    }
                }
                return true
            }
            var stateHandlers = gd.stateHandlers;
            var passStates = [];
            var passStatesSet = {};
            pass.states = passStates;
            pass.statesSet = passStatesSet;
            for (s in states) {
                if (states.hasOwnProperty(s)) {
                    var stateHandler = stateHandlers[s];
                    if (stateHandler) {
                        var values = stateHandler.parse(states[s]);
                        if (values !== null) {
                            if (equalRenderStates(stateHandler.defaultValues, values)) {
                                continue
                            }
                            passStates.push({
                                name: s,
                                set: stateHandler.set,
                                reset: stateHandler.reset,
                                values: values
                            });
                            passStatesSet[s] = true
                        } else {
                            TurbulenzEngine.callOnError("Unknown value for state " + s + ": " + states[s])
                        }
                    }
                }
            }
            return pass
        };
        WebGLPass.version = 1;
        WebGLPass.semanticToAttr = {
            POSITION: "ATTR0",
            POSITION0: "ATTR0",
            BLENDWEIGHT: "ATTR1",
            BLENDWEIGHT0: "ATTR1",
            NORMAL: "ATTR2",
            NORMAL0: "ATTR2",
            COLOR: "ATTR3",
            COLOR0: "ATTR3",
            COLOR1: "ATTR4",
            SPECULAR: "ATTR4",
            FOGCOORD: "ATTR5",
            TESSFACTOR: "ATTR5",
            PSIZE0: "ATTR6",
            BLENDINDICES: "ATTR7",
            BLENDINDICES0: "ATTR7",
            TEXCOORD: "ATTR8",
            TEXCOORD0: "ATTR8",
            TEXCOORD1: "ATTR9",
            TEXCOORD2: "ATTR10",
            TEXCOORD3: "ATTR11",
            TEXCOORD4: "ATTR12",
            TEXCOORD5: "ATTR13",
            TEXCOORD6: "ATTR14",
            TEXCOORD7: "ATTR15",
            TANGENT: "ATTR14",
            TANGENT0: "ATTR14",
            BINORMAL0: "ATTR15",
            BINORMAL: "ATTR15",
            PSIZE: "ATTR6"
        };
        return WebGLPass
    }();
    var WebGLTechnique = function() {
        function WebGLTechnique() {}
        WebGLTechnique.prototype.getPass = function(id) {
            var passes = this.passes;
            var numPasses = passes.length;
            if (typeof id === "string") {
                for (var n = 0; n < numPasses; n += 1) {
                    var pass = passes[n];
                    if (pass.name === id) {
                        return pass
                    }
                }
            } else {
                id = id | 0;
                if (id < numPasses) {
                    return passes[id]
                }
            }
            return null
        };
        WebGLTechnique.prototype.activate = function(gd) {
            this.device = gd;
            if (!this.initialized) {
                this.shader.initialize(gd);
                this.initialize(gd)
            }
        };
        WebGLTechnique.prototype.deactivate = function() {
            this.device = null
        };
        WebGLTechnique.prototype.checkProperties = function(gd) {
            var fakeTechniqueParameters = {},
                p;
            for (p in this) {
                if (p !== "version" && p !== "name" && p !== "id" && p !== "passes" && p !== "numPasses" && p !== "device" && p !== "numParameters") {
                    fakeTechniqueParameters[p] = this[p]
                }
            }
            if (fakeTechniqueParameters) {
                var passes = this.passes;
                if (passes.length === 1) {
                    gd.setParametersImmediate(passes[0].parameters, fakeTechniqueParameters)
                } else {
                    gd.setParametersDeferred(gd, passes, fakeTechniqueParameters)
                }
                for (p in fakeTechniqueParameters) {
                    if (fakeTechniqueParameters.hasOwnProperty(p)) {
                        delete this[p]
                    }
                }
            }
        };
        WebGLTechnique.prototype.initialize = function(gd) {
            if (this.initialized) {
                return
            }
            var passes = this.passes;
            if (passes) {
                var numPasses = passes.length;
                var n;
                for (n = 0; n < numPasses; n += 1) {
                    passes[n].initializeParameters(gd)
                }
            }
            if (Object.defineProperty) {
                this.initializeParametersSetters(gd)
            }
            this.initialized = true
        };
        WebGLTechnique.prototype.initializeParametersSetters = function(gd) {
            var gl = gd.gl;

            function make_sampler_setter(pass, parameter) {
                return function(parameterValues) {
                    if (this.device) {
                        gd.setTexture(parameter.textureUnit, parameterValues, parameter.info.sampler)
                    } else {
                        pass.dirty = true;
                        parameter.dirty = 1;
                        parameter.info.values = parameterValues
                    }
                }
            }

            function make_float_uniform_setter(pass, parameter) {
                var paramInfo = parameter.info;
                var location = parameter.location;

                function setDeferredParameter(parameterValues) {
                    if (typeof parameterValues !== "number") {
                        var values = paramInfo.values;
                        var numValues = Math.min(paramInfo.numValues, parameterValues.length);
                        for (var v = 0; v < numValues; v += 1) {
                            values[v] = parameterValues[v]
                        }
                        parameter.dirty = Math.max(numValues, parameter.dirty || 0)
                    } else {
                        paramInfo.values[0] = parameterValues;
                        parameter.dirty = parameter.dirty || 1
                    }
                    pass.dirty = true
                }
                switch (paramInfo.columns) {
                    case 1:
                        if (1 === paramInfo.numValues) {
                            return function(parameterValues) {
                                if (this.device) {
                                    gl.uniform1f(location, parameterValues)
                                } else {
                                    setDeferredParameter(parameterValues)
                                }
                            }
                        }
                        return function(parameterValues) {
                            if (this.device) {
                                gl.uniform1fv(location, parameterValues)
                            } else {
                                setDeferredParameter(parameterValues)
                            }
                        };
                    case 2:
                        return function(parameterValues) {
                            if (this.device) {
                                gl.uniform2fv(location, parameterValues)
                            } else {
                                setDeferredParameter(parameterValues)
                            }
                        };
                    case 3:
                        return function(parameterValues) {
                            if (this.device) {
                                gl.uniform3fv(location, parameterValues)
                            } else {
                                setDeferredParameter(parameterValues)
                            }
                        };
                    case 4:
                        return function(parameterValues) {
                            if (this.device) {
                                gl.uniform4fv(location, parameterValues)
                            } else {
                                setDeferredParameter(parameterValues)
                            }
                        };
                    default:
                        return null
                }
            }

            function make_int_uniform_setter(pass, parameter) {
                var paramInfo = parameter.info;
                var location = parameter.location;

                function setDeferredParameter(parameterValues) {
                    if (typeof parameterValues !== "number") {
                        var values = paramInfo.values;
                        var numValues = Math.min(paramInfo.numValues, parameterValues.length);
                        for (var v = 0; v < numValues; v += 1) {
                            values[v] = parameterValues[v]
                        }
                        parameter.dirty = Math.max(numValues, parameter.dirty || 0)
                    } else {
                        paramInfo.values[0] = parameterValues;
                        parameter.dirty = parameter.dirty || 1
                    }
                    pass.dirty = true
                }
                switch (paramInfo.columns) {
                    case 1:
                        if (1 === paramInfo.numValues) {
                            return function(parameterValues) {
                                if (this.device) {
                                    gl.uniform1i(location, parameterValues)
                                } else {
                                    setDeferredParameter(parameterValues)
                                }
                            }
                        }
                        return function(parameterValues) {
                            if (this.device) {
                                gl.uniform1iv(location, parameterValues)
                            } else {
                                setDeferredParameter(parameterValues)
                            }
                        };
                    case 2:
                        return function(parameterValues) {
                            if (this.device) {
                                gl.uniform2iv(location, parameterValues)
                            } else {
                                setDeferredParameter(parameterValues)
                            }
                        };
                    case 3:
                        return function(parameterValues) {
                            if (this.device) {
                                gl.uniform3iv(location, parameterValues)
                            } else {
                                setDeferredParameter(parameterValues)
                            }
                        };
                    case 4:
                        return function(parameterValues) {
                            if (this.device) {
                                gl.uniform4iv(location, parameterValues)
                            } else {
                                setDeferredParameter(parameterValues)
                            }
                        };
                    default:
                        return null
                }
            }
            var passes = this.passes;
            var numPasses = passes.length;
            var pass, parameters, p, parameter, paramInfo, setter;
            if (numPasses === 1) {
                pass = passes[0];
                parameters = pass.parameters;
                for (p in parameters) {
                    if (parameters.hasOwnProperty(p)) {
                        parameter = parameters[p];
                        paramInfo = parameter.info;
                        if (paramInfo) {
                            if (undefined !== parameter.location) {
                                if (paramInfo.sampler) {
                                    setter = make_sampler_setter(pass, parameter)
                                } else {
                                    if (paramInfo.type === "float") {
                                        setter = make_float_uniform_setter(pass, parameter)
                                    } else {
                                        setter = make_int_uniform_setter(pass, parameter)
                                    }
                                }
                                Object.defineProperty(this, p, {
                                    set: setter,
                                    enumerable: false,
                                    configurable: false
                                })
                            }
                        }
                    }
                }
                this.checkProperties = null
            } else {
                Object.defineProperty(this, "device", {
                    writable: true,
                    enumerable: false,
                    configurable: false
                });
                Object.defineProperty(this, "version", {
                    writable: false,
                    enumerable: false,
                    configurable: false
                });
                Object.defineProperty(this, "name", {
                    writable: false,
                    enumerable: false,
                    configurable: false
                });
                Object.defineProperty(this, "id", {
                    writable: false,
                    enumerable: false,
                    configurable: false
                });
                Object.defineProperty(this, "passes", {
                    writable: false,
                    enumerable: false,
                    configurable: false
                });
                Object.defineProperty(this, "numParameters", {
                    writable: false,
                    enumerable: false,
                    configurable: false
                })
            }
        };
        WebGLTechnique.prototype.destroy = function() {
            var passes = this.passes;
            if (passes) {
                var numPasses = passes.length;
                var n;
                for (n = 0; n < numPasses; n += 1) {
                    passes[n].destroy()
                }
                passes.length = 0;
                delete this.passes
            }
            delete this.device
        };
        WebGLTechnique.create = function(gd, shader, name, passes) {
            var technique = new WebGLTechnique;
            technique.initialized = false;
            technique.shader = shader;
            technique.name = name;
            var numPasses = passes.length,
                n;
            var numParameters = 0;
            technique.passes = [];
            technique.numPasses = numPasses;
            for (n = 0; n < numPasses; n += 1) {
                var passParams = passes[n];
                if (passParams.parameters) {
                    numParameters += passParams.parameters.length
                }
                technique.passes[n] = WebGLPass.create(gd, shader, passParams)
            }
            technique.numParameters = numParameters;
            technique.device = null;
            technique.id = ++gd.counters.techniques;
            if (1 < numPasses) {
                if (gd.drawArray !== gd.drawArrayMultiPass) {
                    gd.drawArray = gd.drawArrayMultiPass
                }
            }
            return technique
        };
        WebGLTechnique.version = 1;
        return WebGLTechnique
    }();
    var TZWebGLShader = function() {
        function TZWebGLShader() {}
        TZWebGLShader.prototype.getTechnique = function(name) {
            if (typeof name === "string") {
                return this.techniques[name]
            } else {
                var techniques = this.techniques;
                for (var t in techniques) {
                    if (techniques.hasOwnProperty(t)) {
                        if (name === 0) {
                            return techniques[t]
                        } else {
                            name -= 1
                        }
                    }
                }
                return null
            }
        };
        TZWebGLShader.prototype.getParameter = function(name) {
            if (typeof name === "string") {
                return this.parameters[name]
            } else {
                name = name | 0;
                var parameters = this.parameters;
                for (var p in parameters) {
                    if (parameters.hasOwnProperty(p)) {
                        if (name === 0) {
                            return parameters[p]
                        } else {
                            name -= 1
                        }
                    }
                }
                return null
            }
        };
        TZWebGLShader.prototype.initialize = function(gd) {
            if (this.initialized) {
                return
            }
            var gl = gd.gl;
            var p;
            var shaderPrograms = this.programs;
            for (p in shaderPrograms) {
                if (shaderPrograms.hasOwnProperty(p)) {
                    var compiledProgram = shaderPrograms[p];
                    var compiled = gl.getShaderParameter(compiledProgram, gl.COMPILE_STATUS);
                    if (!compiled) {
                        var compilerInfo = gl.getShaderInfoLog(compiledProgram);
                        TurbulenzEngine.callOnError('Program "' + p + '" failed to compile: ' + compilerInfo)
                    }
                }
            }
            var linkedPrograms = this.linkedPrograms;
            for (p in linkedPrograms) {
                if (linkedPrograms.hasOwnProperty(p)) {
                    var linkedProgram = linkedPrograms[p];
                    var glProgram = linkedProgram.glProgram;
                    if (glProgram) {
                        var linked = gl.getProgramParameter(glProgram, gl.LINK_STATUS);
                        if (!linked) {
                            var linkerInfo = gl.getProgramInfoLog(glProgram);
                            TurbulenzEngine.callOnError('Program "' + p + '" failed to link: ' + linkerInfo)
                        }
                    }
                }
            }
            this.initialized = true
        };
        TZWebGLShader.prototype.destroy = function() {
            var gd = this.gd;
            if (gd) {
                var gl = gd.gl;
                var p;
                var techniques = this.techniques;
                if (techniques) {
                    for (p in techniques) {
                        if (techniques.hasOwnProperty(p)) {
                            techniques[p].destroy()
                        }
                    }
                    delete this.techniques
                }
                var linkedPrograms = this.linkedPrograms;
                if (linkedPrograms) {
                    if (gl) {
                        for (p in linkedPrograms) {
                            if (linkedPrograms.hasOwnProperty(p)) {
                                var linkedProgram = linkedPrograms[p];
                                var glProgram = linkedProgram.glProgram;
                                if (glProgram) {
                                    gl.deleteProgram(glProgram);
                                    delete linkedProgram.glProgram
                                }
                            }
                        }
                    }
                    delete this.linkedPrograms
                }
                var programs = this.programs;
                if (programs) {
                    if (gl) {
                        for (p in programs) {
                            if (programs.hasOwnProperty(p)) {
                                gl.deleteShader(programs[p])
                            }
                        }
                    }
                    delete this.programs
                }
                delete this.samplers;
                delete this.parameters;
                delete this.gd
            }
        };
        TZWebGLShader.create = function(gd, params) {
            var gl = gd.gl;
            var shader = new TZWebGLShader;
            shader.initialized = false;
            var techniques = params.techniques;
            var parameters = params.parameters;
            var programs = params.programs;
            var samplers = params.samplers;
            var p;
            shader.gd = gd;
            shader.name = params.name;
            var shaderPrograms = {};
            shader.programs = shaderPrograms;
            for (p in programs) {
                if (programs.hasOwnProperty(p)) {
                    var program = programs[p];
                    var glShaderType;
                    if (program.type === "fragment") {
                        glShaderType = gl.FRAGMENT_SHADER
                    } else if (program.type === "vertex") {
                        glShaderType = gl.VERTEX_SHADER
                    }
                    var glShader = gl.createShader(glShaderType);
                    var code = program.code;
                    if (gd.fixIE && gd.fixIE < "0.93") {
                        code = code.replace(/#.*\n/g, "");
                        code = code.replace(/TZ_LOWP/g, "");
                        if (-1 !== code.indexOf("texture2DProj")) {
                            code = "vec4 texture2DProj(sampler2D s, vec3 uv){ return texture2D(s, uv.xy / uv.z);}\n" + code
                        }
                    }
                    gl.shaderSource(glShader, code);
                    gl.compileShader(glShader);
                    shaderPrograms[p] = glShader
                }
            }
            var linkedPrograms = {};
            shader.linkedPrograms = linkedPrograms;
            var defaultSampler = gd.DEFAULT_SAMPLER;
            var maxAnisotropy = gd.maxAnisotropy;
            shader.samplers = {};
            var sampler;
            for (p in samplers) {
                if (samplers.hasOwnProperty(p)) {
                    sampler = samplers[p];
                    var samplerMaxAnisotropy = sampler.MaxAnisotropy;
                    if (samplerMaxAnisotropy) {
                        if (samplerMaxAnisotropy > maxAnisotropy) {
                            samplerMaxAnisotropy = maxAnisotropy
                        }
                    } else {
                        samplerMaxAnisotropy = defaultSampler.maxAnisotropy
                    }
                    sampler = {
                        minFilter: sampler.MinFilter || defaultSampler.minFilter,
                        magFilter: sampler.MagFilter || defaultSampler.magFilter,
                        wrapS: sampler.WrapS || defaultSampler.wrapS,
                        wrapT: sampler.WrapT || defaultSampler.wrapT,
                        wrapR: sampler.WrapR || defaultSampler.wrapR,
                        maxAnisotropy: samplerMaxAnisotropy
                    };
                    if (sampler.wrapS === 10496) {
                        sampler.wrapS = gl.CLAMP_TO_EDGE
                    }
                    if (sampler.wrapT === 10496) {
                        sampler.wrapT = gl.CLAMP_TO_EDGE
                    }
                    if (sampler.wrapR === 10496) {
                        sampler.wrapR = gl.CLAMP_TO_EDGE
                    }
                    shader.samplers[p] = gd.createSampler(sampler)
                }
            }
            var numParameters = 0;
            shader.parameters = {};
            for (p in parameters) {
                if (parameters.hasOwnProperty(p)) {
                    var parameter = parameters[p];
                    if (!parameter.columns) {
                        parameter.columns = 1
                    }
                    if (!parameter.rows) {
                        parameter.rows = 1
                    }
                    parameter.numValues = parameter.columns * parameter.rows;
                    var parameterType = parameter.type;
                    if (parameterType === "float" || parameterType === "int" || parameterType === "bool") {
                        var parameterValues = parameter.values;
                        if (parameterValues) {
                            if (parameterType === "float") {
                                parameter.values = new Float32Array(parameterValues)
                            } else {
                                parameter.values = new Int32Array(parameterValues)
                            }
                        } else {
                            if (parameterType === "float") {
                                parameter.values = new Float32Array(parameter.numValues)
                            } else {
                                parameter.values = new Int32Array(parameter.numValues)
                            }
                        }
                        parameter.sampler = undefined
                    } else {
                        sampler = shader.samplers[p];
                        if (!sampler) {
                            sampler = defaultSampler;
                            shader.samplers[p] = defaultSampler
                        }
                        parameter.sampler = sampler;
                        parameter.values = null
                    }
                    parameter.name = p;
                    shader.parameters[p] = parameter;
                    numParameters += 1
                }
            }
            shader.numParameters = numParameters;
            var shaderTechniques = {};
            var numTechniques = 0;
            shader.techniques = shaderTechniques;
            for (p in techniques) {
                if (techniques.hasOwnProperty(p)) {
                    shaderTechniques[p] = WebGLTechnique.create(gd, shader, p, techniques[p]);
                    numTechniques += 1
                }
            }
            shader.numTechniques = numTechniques;
            shader.id = ++gd.counters.shaders;
            return shader
        };
        TZWebGLShader.version = 1;
        return TZWebGLShader
    }();
    var WebGLTechniqueParameters = function() {
        function WebGLTechniqueParameters() {}
        WebGLTechniqueParameters.create = function(params) {
            var techniqueParameters = new WebGLTechniqueParameters;
            if (params) {
                for (var p in params) {
                    if (params.hasOwnProperty(p)) {
                        techniqueParameters[p] = params[p]
                    }
                }
            }
            return techniqueParameters
        };
        return WebGLTechniqueParameters
    }();
    var techniqueParameterBufferCreate = function techniqueParameterBufferCreateFn(params) {
        if (Float32Array.prototype.map === undefined) {
            Float32Array.prototype.map = function techniqueParameterBufferMap(offset, numFloats) {
                if (offset === undefined) {
                    offset = 0
                }
                var buffer = this;
                if (numFloats === undefined) {
                    numFloats = this.length
                }

                function techniqueParameterBufferWriter() {
                    var numArguments = arguments.length;
                    for (var a = 0; a < numArguments; a += 1) {
                        var value = arguments[a];
                        if (typeof value === "number") {
                            buffer[offset] = value;
                            offset += 1
                        } else {
                            buffer.setData(value, offset, value.length);
                            offset += value.length
                        }
                    }
                }
                return techniqueParameterBufferWriter
            };
            Float32Array.prototype.unmap = function techniqueParameterBufferUnmap(writer) {};
            Float32Array.prototype.setData = function techniqueParameterBufferSetData(data, offset, numValues) {
                if (offset === undefined) {
                    offset = 0
                }
                if (numValues === undefined) {
                    numValues = this.length
                }
                for (var n = 0; n < numValues; n += 1, offset += 1) {
                    this[offset] = data[n]
                }
            }
        }
        return new Float32Array(params.numFloats)
    };
    var WebGLDrawParameters = function() {
        function WebGLDrawParameters() {
            this.sortKey = 0;
            this.technique = null;
            this.endStreams = 0;
            this.endTechniqueParameters = 16 * 3;
            this.endInstances = 16 * 3 + 8;
            this.indexBuffer = null;
            this.primitive = -1;
            this.count = 0;
            this.firstIndex = 0;
            this.userData = null;
            this[0] = null;
            this[1] = null;
            this[2] = 0;
            this[16 * 3 + 0] = null;
            this[16 * 3 + 1] = null;
            return this
        }
        WebGLDrawParameters.prototype.setTechniqueParameters = function(indx, techniqueParameters) {
            if (indx < 8) {
                indx += 16 * 3;
                this[indx] = techniqueParameters;
                var endTechniqueParameters = this.endTechniqueParameters;
                if (techniqueParameters) {
                    if (endTechniqueParameters <= indx) {
                        this.endTechniqueParameters = indx + 1
                    }
                } else {
                    while (16 * 3 < endTechniqueParameters && !this[endTechniqueParameters - 1]) {
                        endTechniqueParameters -= 1
                    }
                    this.endTechniqueParameters = endTechniqueParameters
                }
            }
        };
        WebGLDrawParameters.prototype.setVertexBuffer = function(indx, vertexBuffer) {
            if (indx < 16) {
                indx *= 3;
                this[indx] = vertexBuffer;
                var endStreams = this.endStreams;
                if (vertexBuffer) {
                    if (endStreams <= indx) {
                        this.endStreams = indx + 3
                    }
                } else {
                    while (0 < endStreams && !this[endStreams - 3]) {
                        endStreams -= 3
                    }
                    this.endStreams = endStreams
                }
            }
        };
        WebGLDrawParameters.prototype.setSemantics = function(indx, semantics) {
            if (indx < 16) {
                this[indx * 3 + 1] = semantics
            }
        };
        WebGLDrawParameters.prototype.setOffset = function(indx, offset) {
            if (indx < 16) {
                this[indx * 3 + 2] = offset
            }
        };
        WebGLDrawParameters.prototype.getTechniqueParameters = function(indx) {
            if (indx < 8) {
                return this[indx + 16 * 3]
            } else {
                return undefined
            }
        };
        WebGLDrawParameters.prototype.getVertexBuffer = function(indx) {
            if (indx < 16) {
                return this[indx * 3 + 0]
            } else {
                return undefined
            }
        };
        WebGLDrawParameters.prototype.getSemantics = function(indx) {
            if (indx < 16) {
                return this[indx * 3 + 1]
            } else {
                return undefined
            }
        };
        WebGLDrawParameters.prototype.getOffset = function(indx) {
            if (indx < 16) {
                return this[indx * 3 + 2]
            } else {
                return undefined
            }
        };
        WebGLDrawParameters.prototype.addInstance = function(instanceParameters) {
            if (instanceParameters) {
                var endInstances = this.endInstances;
                this.endInstances = endInstances + 1;
                this[endInstances] = instanceParameters
            }
        };
        WebGLDrawParameters.prototype.removeInstances = function() {
            this.endInstances = 16 * 3 + 8
        };
        WebGLDrawParameters.prototype.getNumInstances = function() {
            return this.endInstances - (16 * 3 + 8)
        };
        WebGLDrawParameters.create = function() {
            return new WebGLDrawParameters
        };
        WebGLDrawParameters.version = 1;
        return WebGLDrawParameters
    }();
    var WebGLGraphicsDevice = function() {
        function WebGLGraphicsDevice() {}
        WebGLGraphicsDevice.prototype.drawIndexed = function(primitive, numIndices, first) {
            var gl = this.gl;
            var indexBuffer = this.activeIndexBuffer;
            var offset;
            if (first) {
                offset = first * indexBuffer.stride
            } else {
                offset = 0
            }
            var format = indexBuffer.format;
            var attributeMask = this.attributeMask;
            var activeTechnique = this.activeTechnique;
            var passes = activeTechnique.passes;
            var numPasses = passes.length;
            var mask;
            if (activeTechnique.checkProperties) {
                activeTechnique.checkProperties(this)
            }
            if (1 === numPasses) {
                mask = passes[0].semanticsMask & attributeMask;
                if (mask !== this.clientStateMask) {
                    this.enableClientState(mask)
                }
                gl.drawElements(primitive, numIndices, format, offset)
            } else {
                for (var p = 0; p < numPasses; p += 1) {
                    var pass = passes[p];
                    mask = pass.semanticsMask & attributeMask;
                    if (mask !== this.clientStateMask) {
                        this.enableClientState(mask)
                    }
                    this.setPass(pass);
                    gl.drawElements(primitive, numIndices, format, offset)
                }
            }
        };
        WebGLGraphicsDevice.prototype.draw = function(primitive, numVertices, first) {
            var gl = this.gl;
            var attributeMask = this.attributeMask;
            var activeTechnique = this.activeTechnique;
            var passes = activeTechnique.passes;
            var numPasses = passes.length;
            var mask;
            if (activeTechnique.checkProperties) {
                activeTechnique.checkProperties(this)
            }
            if (1 === numPasses) {
                mask = passes[0].semanticsMask & attributeMask;
                if (mask !== this.clientStateMask) {
                    this.enableClientState(mask)
                }
                gl.drawArrays(primitive, first, numVertices)
            } else {
                for (var p = 0; p < numPasses; p += 1) {
                    var pass = passes[p];
                    mask = pass.semanticsMask & attributeMask;
                    if (mask !== this.clientStateMask) {
                        this.enableClientState(mask)
                    }
                    this.setPass(pass);
                    gl.drawArrays(primitive, first, numVertices)
                }
            }
        };
        WebGLGraphicsDevice.prototype.setTechniqueParameters = function() {
            var activeTechnique = this.activeTechnique;
            var passes = activeTechnique.passes;
            var numTechniqueParameters = arguments.length;
            var t;
            if (1 === passes.length) {
                var parameters = passes[0].parameters;
                for (t = 0; t < numTechniqueParameters; t += 1) {
                    this.setParametersImmediate(parameters, arguments[t])
                }
            } else {
                for (t = 0; t < numTechniqueParameters; t += 1) {
                    this.setParametersDeferred(this, passes, arguments[t])
                }
            }
        };
        WebGLGraphicsDevice.prototype.setParametersImmediate = function(parameters, techniqueParameters) {
            var gl = this.gl;
            for (var p in techniqueParameters) {
                var parameter = parameters[p];
                if (parameter !== undefined) {
                    var parameterValues = techniqueParameters[p];
                    if (parameterValues !== undefined) {
                        var paramInfo = parameter.info;
                        var numColumns, location;
                        if (paramInfo.type === "float") {
                            numColumns = paramInfo.columns;
                            location = parameter.location;
                            if (4 === numColumns) {
                                gl.uniform4fv(location, parameterValues)
                            } else if (3 === numColumns) {
                                gl.uniform3fv(location, parameterValues)
                            } else if (2 === numColumns) {
                                gl.uniform2fv(location, parameterValues)
                            } else if (1 === paramInfo.rows) {
                                gl.uniform1f(location, parameterValues)
                            } else {
                                gl.uniform1fv(location, parameterValues)
                            }
                        } else if (paramInfo.sampler !== undefined) {
                            this.setTexture(parameter.textureUnit, parameterValues, paramInfo.sampler)
                        } else {
                            numColumns = paramInfo.columns;
                            location = parameter.location;
                            if (4 === numColumns) {
                                gl.uniform4iv(location, parameterValues)
                            } else if (3 === numColumns) {
                                gl.uniform3iv(location, parameterValues)
                            } else if (2 === numColumns) {
                                gl.uniform2iv(location, parameterValues)
                            } else if (1 === paramInfo.rows) {
                                gl.uniform1i(location, parameterValues)
                            } else {
                                gl.uniform1iv(location, parameterValues)
                            }
                        }
                    } else {
                        delete techniqueParameters[p]
                    }
                }
            }
        };
        WebGLGraphicsDevice.prototype.setParametersCaching = function(parameters, techniqueParameters) {
            var gl = this.gl;
            for (var p in techniqueParameters) {
                var parameter = parameters[p];
                if (parameter !== undefined) {
                    var parameterValues = techniqueParameters[p];
                    if (parameter.value !== parameterValues) {
                        if (parameterValues !== undefined) {
                            parameter.value = parameterValues;
                            var paramInfo = parameter.info;
                            var numColumns, location;
                            if (paramInfo.type === "float") {
                                numColumns = paramInfo.columns;
                                location = parameter.location;
                                if (4 === numColumns) {
                                    gl.uniform4fv(location, parameterValues)
                                } else if (3 === numColumns) {
                                    gl.uniform3fv(location, parameterValues)
                                } else if (2 === numColumns) {
                                    gl.uniform2fv(location, parameterValues)
                                } else if (1 === paramInfo.rows) {
                                    gl.uniform1f(location, parameterValues)
                                } else {
                                    gl.uniform1fv(location, parameterValues)
                                }
                            } else if (paramInfo.sampler !== undefined) {
                                this.setTexture(parameter.textureUnit, parameterValues, paramInfo.sampler)
                            } else {
                                numColumns = paramInfo.columns;
                                location = parameter.location;
                                if (4 === numColumns) {
                                    gl.uniform4iv(location, parameterValues)
                                } else if (3 === numColumns) {
                                    gl.uniform3iv(location, parameterValues)
                                } else if (2 === numColumns) {
                                    gl.uniform2iv(location, parameterValues)
                                } else if (1 === paramInfo.rows) {
                                    gl.uniform1i(location, parameterValues)
                                } else {
                                    gl.uniform1iv(location, parameterValues)
                                }
                            }
                        } else {
                            delete techniqueParameters[p]
                        }
                    }
                }
            }
        };
        WebGLGraphicsDevice.prototype.setParametersCachingMultiPass = function(gd, passes, techniqueParameters) {
            gd.setParametersCaching(passes[0].parameters, techniqueParameters)
        };
        WebGLGraphicsDevice.prototype.setParametersDeferred = function(gd, passes, techniqueParameters) {
            var numPasses = passes.length;
            var min = Math.min;
            var max = Math.max;
            for (var n = 0; n < numPasses; n += 1) {
                var pass = passes[n];
                var parameters = pass.parameters;
                pass.dirty = true;
                for (var p in techniqueParameters) {
                    var parameter = parameters[p];
                    if (parameter) {
                        var parameterValues = techniqueParameters[p];
                        if (parameterValues !== undefined) {
                            var paramInfo = parameter.info;
                            if (paramInfo.sampler) {
                                paramInfo.values = parameterValues;
                                parameter.dirty = 1
                            } else if (typeof parameterValues !== "number") {
                                var values = paramInfo.values;
                                var numValues = min(paramInfo.numValues, parameterValues.length);
                                for (var v = 0; v < numValues; v += 1) {
                                    values[v] = parameterValues[v]
                                }
                                parameter.dirty = max(numValues, parameter.dirty || 0)
                            } else {
                                paramInfo.values[0] = parameterValues;
                                parameter.dirty = parameter.dirty || 1
                            }
                        } else {
                            delete techniqueParameters[p]
                        }
                    }
                }
            }
        };
        WebGLGraphicsDevice.prototype.setTechnique = function(technique) {
            var activeTechnique = this.activeTechnique;
            if (activeTechnique !== technique) {
                if (activeTechnique) {
                    activeTechnique.deactivate()
                }
                this.activeTechnique = technique;
                technique.activate(this);
                var passes = technique.passes;
                if (1 === passes.length) {
                    this.setPass(passes[0])
                }
            }
        };
        WebGLGraphicsDevice.prototype.setTechniqueCaching = function(technique) {
            var pass = technique.passes[0];
            var activeTechnique = this.activeTechnique;
            if (activeTechnique !== technique) {
                if (activeTechnique) {
                    activeTechnique.deactivate()
                }
                this.activeTechnique = technique;
                technique.activate(this);
                this.setPass(pass)
            }
            var parameters = pass.parameters;
            for (var p in parameters) {
                if (parameters.hasOwnProperty(p)) {
                    parameters[p].value = null
                }
            }
        };
        WebGLGraphicsDevice.prototype.setStream = function(vertexBuffer, semantics, offset) {
            if (offset) {
                offset *= vertexBuffer.strideInBytes
            } else {
                offset = 0
            }
            this.bindVertexBuffer(vertexBuffer.glBuffer);
            var attributes = semantics;
            var numAttributes = attributes.length;
            if (numAttributes > vertexBuffer.numAttributes) {
                numAttributes = vertexBuffer.numAttributes
            }
            this.attributeMask |= vertexBuffer.bindAttributes(numAttributes, attributes, offset)
        };
        WebGLGraphicsDevice.prototype.setIndexBuffer = function(indexBuffer) {
            if (this.activeIndexBuffer !== indexBuffer) {
                this.activeIndexBuffer = indexBuffer;
                var glBuffer;
                if (indexBuffer) {
                    glBuffer = indexBuffer.glBuffer
                } else {
                    glBuffer = null
                }
                var gl = this.gl;
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, glBuffer)
            }
        };
        WebGLGraphicsDevice.prototype.drawArray = function(drawParametersArray, globalTechniqueParametersArray, sortMode) {
            var gl = this.gl;
            var ELEMENT_ARRAY_BUFFER = gl.ELEMENT_ARRAY_BUFFER;
            var numGlobalTechniqueParameters = globalTechniqueParametersArray.length;
            var numDrawParameters = drawParametersArray.length;
            if (numDrawParameters > 1 && sortMode) {
                if (sortMode > 0) {
                    drawParametersArray.sort(this._drawArraySortPositive)
                } else {
                    drawParametersArray.sort(this._drawArraySortNegative)
                }
            }
            var activeIndexBuffer = this.activeIndexBuffer;
            var attributeMask = this.attributeMask;
            var lastTechnique = null;
            var lastEndStreams = -1;
            var lastDrawParameters = null;
            var techniqueParameters = null;
            var v = 0;
            var streamsMatch = false;
            var vertexBuffer = null;
            var pass = null;
            var passParameters = null;
            var indexFormat = 0;
            var indexStride = 0;
            var mask = 0;
            var t = 0;
            if (activeIndexBuffer) {
                indexFormat = activeIndexBuffer.format;
                indexStride = activeIndexBuffer.stride
            }
            for (var n = 0; n < numDrawParameters; n += 1) {
                var drawParameters = drawParametersArray[n];
                var technique = drawParameters.technique;
                var endTechniqueParameters = drawParameters.endTechniqueParameters;
                var endStreams = drawParameters.endStreams;
                var endInstances = drawParameters.endInstances;
                var indexBuffer = drawParameters.indexBuffer;
                var primitive = drawParameters.primitive;
                var count = drawParameters.count;
                var firstIndex = drawParameters.firstIndex;
                if (lastTechnique !== technique) {
                    lastTechnique = technique;
                    this.setTechniqueCaching(technique);
                    pass = technique.passes[0];
                    passParameters = pass.parameters;
                    mask = pass.semanticsMask & attributeMask;
                    if (mask !== this.clientStateMask) {
                        this.enableClientState(mask)
                    }
                    if (technique.checkProperties) {
                        technique.checkProperties(this)
                    }
                    for (t = 0; t < numGlobalTechniqueParameters; t += 1) {
                        this.setParametersCaching(passParameters, globalTechniqueParametersArray[t])
                    }
                }
                for (t = 16 * 3; t < endTechniqueParameters; t += 1) {
                    techniqueParameters = drawParameters[t];
                    if (techniqueParameters) {
                        this.setParametersCaching(passParameters, techniqueParameters)
                    }
                }
                streamsMatch = lastEndStreams === endStreams;
                for (v = 0; streamsMatch && v < endStreams; v += 3) {
                    streamsMatch = lastDrawParameters[v] === drawParameters[v] && lastDrawParameters[v + 1] === drawParameters[v + 1] && lastDrawParameters[v + 2] === drawParameters[v + 2]
                }
                if (!streamsMatch) {
                    lastEndStreams = endStreams;
                    for (v = 0; v < endStreams; v += 3) {
                        vertexBuffer = drawParameters[v];
                        if (vertexBuffer) {
                            this.setStream(vertexBuffer, drawParameters[v + 1], drawParameters[v + 2])
                        }
                    }
                    attributeMask = this.attributeMask;
                    mask = pass.semanticsMask & attributeMask;
                    if (mask !== this.clientStateMask) {
                        this.enableClientState(mask)
                    }
                }
                lastDrawParameters = drawParameters;
                if (indexBuffer) {
                    if (activeIndexBuffer !== indexBuffer) {
                        activeIndexBuffer = indexBuffer;
                        gl.bindBuffer(ELEMENT_ARRAY_BUFFER, indexBuffer.glBuffer);
                        indexFormat = indexBuffer.format;
                        indexStride = indexBuffer.stride
                    }
                    firstIndex *= indexStride;
                    t = 16 * 3 + 8;
                    if (t < endInstances) {
                        do {
                            this.setParametersCaching(passParameters, drawParameters[t]);
                            gl.drawElements(primitive, count, indexFormat, firstIndex);
                            t += 1
                        } while (t < endInstances)
                    } else {
                        gl.drawElements(primitive, count, indexFormat, firstIndex)
                    }
                } else {
                    t = 16 * 3 + 8;
                    if (t < endInstances) {
                        do {
                            this.setParametersCaching(passParameters, drawParameters[t]);
                            gl.drawArrays(primitive, firstIndex, count);
                            t += 1
                        } while (t < endInstances)
                    } else {
                        gl.drawArrays(primitive, firstIndex, count)
                    }
                }
            }
            this.activeIndexBuffer = activeIndexBuffer
        };
        WebGLGraphicsDevice.prototype.drawArrayMultiPass = function(drawParametersArray, globalTechniqueParametersArray, sortMode) {
            var gl = this.gl;
            var ELEMENT_ARRAY_BUFFER = gl.ELEMENT_ARRAY_BUFFER;
            var setParametersCaching = this.setParametersCachingMultiPass;
            var setParametersDeferred = this.setParametersDeferred;
            var numGlobalTechniqueParameters = globalTechniqueParametersArray.length;
            var numDrawParameters = drawParametersArray.length;
            if (numDrawParameters > 1 && sortMode) {
                if (sortMode > 0) {
                    drawParametersArray.sort(this._drawArraySortPositive)
                } else {
                    drawParametersArray.sort(this._drawArraySortNegative)
                }
            }
            var activeIndexBuffer = this.activeIndexBuffer;
            var attributeMask = this.attributeMask;
            var setParameters = null;
            var lastTechnique = null;
            var lastEndStreams = -1;
            var lastDrawParameters = null;
            var techniqueParameters = null;
            var v = 0;
            var streamsMatch = false;
            var vertexBuffer = null;
            var passes = null;
            var p = null;
            var pass = null;
            var indexFormat = 0;
            var indexStride = 0;
            var numPasses = 0;
            var mask = 0;
            var t = 0;
            if (activeIndexBuffer) {
                indexFormat = activeIndexBuffer.format;
                indexStride = activeIndexBuffer.stride
            }
            for (var n = 0; n < numDrawParameters; n += 1) {
                var drawParameters = drawParametersArray[n];
                var technique = drawParameters.technique;
                var endTechniqueParameters = drawParameters.endTechniqueParameters;
                var endStreams = drawParameters.endStreams;
                var endInstances = drawParameters.endInstances;
                var indexBuffer = drawParameters.indexBuffer;
                var primitive = drawParameters.primitive;
                var count = drawParameters.count;
                var firstIndex = drawParameters.firstIndex;
                if (lastTechnique !== technique) {
                    lastTechnique = technique;
                    passes = technique.passes;
                    numPasses = passes.length;
                    if (1 === numPasses) {
                        this.setTechniqueCaching(technique);
                        setParameters = setParametersCaching;
                        mask = passes[0].semanticsMask & attributeMask;
                        if (mask !== this.clientStateMask) {
                            this.enableClientState(mask)
                        }
                    } else {
                        this.setTechnique(technique);
                        setParameters = setParametersDeferred
                    }
                    if (technique.checkProperties) {
                        technique.checkProperties(this)
                    }
                    for (t = 0; t < numGlobalTechniqueParameters; t += 1) {
                        setParameters(this, passes, globalTechniqueParametersArray[t])
                    }
                }
                for (t = 16 * 3; t < endTechniqueParameters; t += 1) {
                    techniqueParameters = drawParameters[t];
                    if (techniqueParameters) {
                        setParameters(this, passes, techniqueParameters)
                    }
                }
                streamsMatch = lastEndStreams === endStreams;
                for (v = 0; streamsMatch && v < endStreams; v += 3) {
                    streamsMatch = lastDrawParameters[v] === drawParameters[v] && lastDrawParameters[v + 1] === drawParameters[v + 1] && lastDrawParameters[v + 2] === drawParameters[v + 2]
                }
                if (!streamsMatch) {
                    lastEndStreams = endStreams;
                    for (v = 0; v < endStreams; v += 3) {
                        vertexBuffer = drawParameters[v];
                        if (vertexBuffer) {
                            this.setStream(vertexBuffer, drawParameters[v + 1], drawParameters[v + 2])
                        }
                    }
                    attributeMask = this.attributeMask;
                    if (1 === numPasses) {
                        mask = passes[0].semanticsMask & attributeMask;
                        if (mask !== this.clientStateMask) {
                            this.enableClientState(mask)
                        }
                    }
                }
                lastDrawParameters = drawParameters;
                if (indexBuffer) {
                    if (activeIndexBuffer !== indexBuffer) {
                        activeIndexBuffer = indexBuffer;
                        gl.bindBuffer(ELEMENT_ARRAY_BUFFER, indexBuffer.glBuffer);
                        indexFormat = indexBuffer.format;
                        indexStride = indexBuffer.stride
                    }
                    firstIndex *= indexStride;
                    if (1 === numPasses) {
                        t = 16 * 3 + 8;
                        if (t < endInstances) {
                            do {
                                setParameters(this, passes, drawParameters[t]);
                                gl.drawElements(primitive, count, indexFormat, firstIndex);
                                t += 1
                            } while (t < endInstances)
                        } else {
                            gl.drawElements(primitive, count, indexFormat, firstIndex)
                        }
                    } else {
                        t = 16 * 3 + 8;
                        if (t < endInstances) {
                            do {
                                setParameters(this, passes, drawParameters[t]);
                                for (p = 0; p < numPasses; p += 1) {
                                    pass = passes[p];
                                    mask = pass.semanticsMask & attributeMask;
                                    if (mask !== this.clientStateMask) {
                                        this.enableClientState(mask)
                                    }
                                    this.setPass(pass);
                                    gl.drawElements(primitive, count, indexFormat, firstIndex)
                                }
                                t += 1
                            } while (t < endInstances)
                        } else {
                            for (p = 0; p < numPasses; p += 1) {
                                pass = passes[p];
                                mask = pass.semanticsMask & attributeMask;
                                if (mask !== this.clientStateMask) {
                                    this.enableClientState(mask)
                                }
                                this.setPass(pass);
                                gl.drawElements(primitive, count, indexFormat, firstIndex)
                            }
                        }
                    }
                } else {
                    if (1 === numPasses) {
                        t = 16 * 3 + 8;
                        if (t < endInstances) {
                            do {
                                setParameters(this, passes, drawParameters[t]);
                                gl.drawArrays(primitive, firstIndex, count);
                                t += 1
                            } while (t < endInstances)
                        } else {
                            gl.drawArrays(primitive, firstIndex, count)
                        }
                    } else {
                        t = 16 * 3 + 8;
                        if (t < endInstances) {
                            do {
                                setParameters(this, passes, drawParameters[t]);
                                for (p = 0; p < numPasses; p += 1) {
                                    pass = passes[p];
                                    mask = pass.semanticsMask & attributeMask;
                                    if (mask !== this.clientStateMask) {
                                        this.enableClientState(mask)
                                    }
                                    this.setPass(pass);
                                    gl.drawArrays(primitive, firstIndex, count)
                                }
                                t += 1
                            } while (t < endInstances)
                        } else {
                            for (p = 0; p < numPasses; p += 1) {
                                pass = passes[p];
                                mask = pass.semanticsMask & attributeMask;
                                if (mask !== this.clientStateMask) {
                                    this.enableClientState(mask)
                                }
                                this.setPass(pass);
                                gl.drawArrays(primitive, firstIndex, count)
                            }
                        }
                    }
                }
            }
            this.activeIndexBuffer = activeIndexBuffer
        };
        WebGLGraphicsDevice.prototype.beginDraw = function(primitive, numVertices, formats, semantics) {
            this.immediatePrimitive = primitive;
            if (numVertices) {
                var n;
                var immediateSemantics = this.immediateSemantics;
                var attributes = semantics;
                var numAttributes = attributes.length;
                immediateSemantics.length = numAttributes;
                for (n = 0; n < numAttributes; n += 1) {
                    var attribute = attributes[n];
                    if (typeof attribute === "string") {
                        attribute = this["SEMANTIC_" + attribute]
                    }
                    immediateSemantics[n] = attribute
                }
                var immediateVertexBuffer = this.immediateVertexBuffer;
                var oldStride = immediateVertexBuffer.strideInBytes;
                var oldSize = oldStride * immediateVertexBuffer.numVertices;
                var stride = immediateVertexBuffer.setAttributes(formats);
                if (stride !== oldStride) {
                    immediateVertexBuffer.numVertices = Math.floor(oldSize / stride)
                }
                var size = stride * numVertices;
                if (size > oldSize) {
                    immediateVertexBuffer.resize(size)
                }
                return immediateVertexBuffer.map(0, numVertices)
            }
            return null
        };
        WebGLGraphicsDevice.prototype.endDraw = function(writer) {
            var immediateVertexBuffer = this.immediateVertexBuffer;
            var numVerticesWritten = writer.getNumWrittenVertices();
            immediateVertexBuffer.unmap(writer);
            if (numVerticesWritten) {
                var gl = this.gl;
                var stride = immediateVertexBuffer.strideInBytes;
                var offset = 0;
                var vertexAttributes = immediateVertexBuffer.attributes;
                var semantics = this.immediateSemantics;
                var numSemantics = semantics.length;
                var deltaAttributeMask = 0;
                for (var n = 0; n < numSemantics; n += 1) {
                    var vertexAttribute = vertexAttributes[n];
                    var attribute = semantics[n];
                    deltaAttributeMask |= 1 << attribute;
                    gl.vertexAttribPointer(attribute, vertexAttribute.numComponents, vertexAttribute.format, vertexAttribute.normalized, stride, offset);
                    offset += vertexAttribute.stride
                }
                this.attributeMask |= deltaAttributeMask;
                this.draw(this.immediatePrimitive, numVerticesWritten, 0)
            }
        };
        WebGLGraphicsDevice.prototype.setViewport = function(x, y, w, h) {
            var currentBox = this.state.viewportBox;
            if (currentBox[0] !== x || currentBox[1] !== y || currentBox[2] !== w || currentBox[3] !== h) {
                currentBox[0] = x;
                currentBox[1] = y;
                currentBox[2] = w;
                currentBox[3] = h;
                this.gl.viewport(x, y, w, h)
            }
        };
        WebGLGraphicsDevice.prototype.setScissor = function(x, y, w, h) {
            var currentBox = this.state.scissorBox;
            if (currentBox[0] !== x || currentBox[1] !== y || currentBox[2] !== w || currentBox[3] !== h) {
                currentBox[0] = x;
                currentBox[1] = y;
                currentBox[2] = w;
                currentBox[3] = h;
                this.gl.scissor(x, y, w, h)
            }
        };
        WebGLGraphicsDevice.prototype.clear = function(color, depth, stencil) {
            var gl = this.gl;
            var state = this.state;
            var clearMask = 0;
            if (color) {
                clearMask += gl.COLOR_BUFFER_BIT;
                var currentColor = state.clearColor;
                var color0 = color[0];
                var color1 = color[1];
                var color2 = color[2];
                var color3 = color[3];
                if (currentColor[0] !== color0 || currentColor[1] !== color1 || currentColor[2] !== color2 || currentColor[3] !== color3) {
                    currentColor[0] = color0;
                    currentColor[1] = color1;
                    currentColor[2] = color2;
                    currentColor[3] = color3;
                    gl.clearColor(color0, color1, color2, color3)
                }
            }
            if (typeof depth === "number") {
                clearMask += gl.DEPTH_BUFFER_BIT;
                if (state.clearDepth !== depth) {
                    state.clearDepth = depth;
                    gl.clearDepth(depth)
                }
                if (typeof stencil === "number") {
                    clearMask += gl.STENCIL_BUFFER_BIT;
                    if (state.clearStencil !== stencil) {
                        state.clearStencil = stencil;
                        gl.clearStencil(stencil)
                    }
                }
            }
            if (clearMask) {
                var colorMask = state.colorMask;
                var colorMaskEnabled = colorMask[0] || colorMask[1] || colorMask[2] || colorMask[3];
                var depthMask = state.depthMask;
                var program = state.program;
                if (color) {
                    if (!colorMaskEnabled) {
                        gl.colorMask(true, true, true, true)
                    }
                }
                if (typeof depth === "number") {
                    if (!depthMask) {
                        gl.depthMask(true)
                    }
                }
                if (program) {
                    gl.useProgram(null)
                }
                gl.clear(clearMask);
                if (color) {
                    if (!colorMaskEnabled) {
                        gl.colorMask(false, false, false, false)
                    }
                }
                if (typeof depth === "number") {
                    if (!depthMask) {
                        gl.depthMask(false)
                    }
                }
                if (program) {
                    gl.useProgram(program)
                }
            }
        };
        WebGLGraphicsDevice.prototype.beginFrame = function() {
            var gl = this.gl;
            this.attributeMask = 0;
            var clientStateMask = this.clientStateMask;
            var n;
            if (clientStateMask) {
                for (n = 0; n < 16; n += 1) {
                    if (clientStateMask & 1 << n) {
                        gl.disableVertexAttribArray(n)
                    }
                }
                this.clientStateMask = 0
            }
            this.resetStates();
            this.setScissor(0, 0, this.width, this.height);
            this.setViewport(0, 0, this.width, this.height);
            return !(document.hidden || document["webkitHidden"])
        };
        WebGLGraphicsDevice.prototype.beginRenderTarget = function(renderTarget) {
            this.activeRenderTarget = renderTarget;
            return renderTarget.bind()
        };
        WebGLGraphicsDevice.prototype.endRenderTarget = function() {
            this.activeRenderTarget.unbind();
            this.activeRenderTarget = null
        };
        WebGLGraphicsDevice.prototype.beginOcclusionQuery = function() {
            return false
        };
        WebGLGraphicsDevice.prototype.endOcclusionQuery = function() {};
        WebGLGraphicsDevice.prototype.endFrame = function() {
            var gl = this.gl;
            if (this.activeTechnique) {
                this.activeTechnique.deactivate();
                this.activeTechnique = null
            }
            if (this.activeIndexBuffer) {
                this.setIndexBuffer(null)
            }
            var state = this.state;
            if (state.program) {
                state.program = null;
                gl.useProgram(null)
            }
            this.numFrames += 1;
            var currentFrameTime = TurbulenzEngine.getTime();
            var diffTime = currentFrameTime - this.previousFrameTime;
            if (diffTime >= 1e3) {
                this.fps = this.numFrames / (diffTime * .001);
                this.numFrames = 0;
                this.previousFrameTime = currentFrameTime
            }
            var canvas = gl.canvas;
            var width = gl.drawingBufferWidth || canvas.width;
            var height = gl.drawingBufferHeight || canvas.height;
            if (this.width !== width || this.height !== height) {
                this.width = width;
                this.height = height;
                this.setViewport(0, 0, width, height);
                this.setScissor(0, 0, width, height)
            }
            this.checkFullScreen()
        };
        WebGLGraphicsDevice.prototype.createTechniqueParameters = function(params) {
            return WebGLTechniqueParameters.create(params)
        };
        WebGLGraphicsDevice.prototype.createSemantics = function(attributes) {
            return WebGLSemantics.create(this, attributes)
        };
        WebGLGraphicsDevice.prototype.createVertexBuffer = function(params) {
            return WebGLVertexBuffer.create(this, params)
        };
        WebGLGraphicsDevice.prototype.createIndexBuffer = function(params) {
            return WebGLIndexBuffer.create(this, params)
        };
        WebGLGraphicsDevice.prototype.createTexture = function(params) {
            return TZWebGLTexture.create(this, params)
        };
        WebGLGraphicsDevice.prototype.createVideo = function(params) {
            return WebGLVideo.create(params)
        };
        WebGLGraphicsDevice.prototype.createShader = function(params) {
            return TZWebGLShader.create(this, params)
        };
        WebGLGraphicsDevice.prototype.createTechniqueParameterBuffer = function(params) {
            return techniqueParameterBufferCreate(params)
        };
        WebGLGraphicsDevice.prototype.createRenderBuffer = function(params) {
            return WebGLRenderBuffer.create(this, params)
        };
        WebGLGraphicsDevice.prototype.createRenderTarget = function(params) {
            return WebGLRenderTarget.create(this, params)
        };
        WebGLGraphicsDevice.prototype.createOcclusionQuery = function() {
            return null
        };
        WebGLGraphicsDevice.prototype.createDrawParameters = function() {
            return WebGLDrawParameters.create()
        };
        WebGLGraphicsDevice.prototype.isSupported = function(name) {
            var gl = this.gl;
            if ("OCCLUSION_QUERIES" === name) {
                return false
            } else if ("NPOT_MIPMAPPED_TEXTURES" === name) {
                return false
            } else if ("TEXTURE_DXT1" === name || "TEXTURE_DXT3" === name || "TEXTURE_DXT5" === name) {
                var compressedTexturesExtension = this.compressedTexturesExtension;
                if (compressedTexturesExtension) {
                    var compressedFormats = gl.getParameter(gl.COMPRESSED_TEXTURE_FORMATS);
                    if (compressedFormats) {
                        var requestedFormat;
                        if ("TEXTURE_DXT1" === name) {
                            requestedFormat = compressedTexturesExtension.COMPRESSED_RGBA_S3TC_DXT1_EXT
                        } else if ("TEXTURE_DXT3" === name) {
                            requestedFormat = compressedTexturesExtension.COMPRESSED_RGBA_S3TC_DXT3_EXT
                        } else {
                            requestedFormat = compressedTexturesExtension.COMPRESSED_RGBA_S3TC_DXT5_EXT
                        }
                        var numCompressedFormats = compressedFormats.length;
                        for (var n = 0; n < numCompressedFormats; n += 1) {
                            if (compressedFormats[n] === requestedFormat) {
                                return true
                            }
                        }
                    }
                }
                return false
            } else if ("TEXTURE_ETC1" === name) {
                return false
            } else if ("TEXTURE_FLOAT" === name) {
                if (this.floatTextureExtension) {
                    return true
                }
                return false
            } else if ("INDEXFORMAT_UINT" === name) {
                if (gl.getExtension("OES_element_index_uint")) {
                    return true
                }
                return false
            } else if ("FILEFORMAT_WEBM" === name) {
                return "webm" in this.supportedVideoExtensions
            } else if ("FILEFORMAT_MP4" === name) {
                return "mp4" in this.supportedVideoExtensions
            } else if ("FILEFORMAT_JPG" === name) {
                return true
            } else if ("FILEFORMAT_PNG" === name) {
                return true
            } else if ("FILEFORMAT_DDS" === name) {
                return typeof DDSLoader !== "undefined"
            } else if ("FILEFORMAT_TGA" === name) {
                return typeof TGALoader !== "undefined"
            }
            return undefined
        };
        WebGLGraphicsDevice.prototype.maxSupported = function(name) {
            var gl = this.gl;
            if ("ANISOTROPY" === name) {
                return this.maxAnisotropy
            } else if ("TEXTURE_SIZE" === name) {
                return gl.getParameter(gl.MAX_TEXTURE_SIZE)
            } else if ("CUBEMAP_TEXTURE_SIZE" === name) {
                return gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE)
            } else if ("3D_TEXTURE_SIZE" === name) {
                return 0
            } else if ("RENDERTARGET_COLOR_TEXTURES" === name) {
                if (this.drawBuffersExtension) {
                    if (this.WEBGL_draw_buffers) {
                        return gl.getParameter(this.drawBuffersExtension.MAX_COLOR_ATTACHMENTS_WEBGL)
                    } else {
                        return gl.getParameter(this.drawBuffersExtension.MAX_COLOR_ATTACHMENTS_EXT)
                    }
                }
                return 1
            } else if ("RENDERBUFFER_SIZE" === name) {
                return gl.getParameter(gl.MAX_RENDERBUFFER_SIZE)
            } else if ("TEXTURE_UNITS" === name) {
                return gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS)
            } else if ("VERTEX_TEXTURE_UNITS" === name) {
                return gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
            } else if ("VERTEX_SHADER_PRECISION" === name || "FRAGMENT_SHADER_PRECISION" === name) {
                var shaderType;
                if ("VERTEX_SHADER_PRECISION" === name) {
                    shaderType = gl.VERTEX_SHADER
                } else {
                    shaderType = gl.FRAGMENT_SHADER
                }
                if (!gl.getShaderPrecisionFormat) {
                    return 0
                }
                var sp = gl.getShaderPrecisionFormat(shaderType, gl.HIGH_FLOAT);
                if (!sp || !sp.precision) {
                    sp = gl.getShaderPrecisionFormat(shaderType, gl.MEDIUM_FLOAT);
                    if (!sp || !sp.precision) {
                        sp = gl.getShaderPrecisionFormat(shaderType, gl.LOW_FLOAT);
                        if (!sp || !sp.precision) {
                            return 0
                        }
                    }
                }
                return sp.precision
            }
            return 0
        };
        WebGLGraphicsDevice.prototype.loadTexturesArchive = function(params) {
            var src = params.src;
            if (typeof TARLoader !== "undefined") {
                TARLoader.create({
                    gd: this,
                    src: src,
                    mipmaps: params.mipmaps,
                    ontextureload: function tarTextureLoadedFn(texture) {
                        params.ontextureload(texture)
                    },
                    onload: function tarLoadedFn(success, status) {
                        if (params.onload) {
                            params.onload(success, status)
                        }
                    },
                    onerror: function tarFailedFn(status) {
                        if (params.onload) {
                            params.onload(false, status)
                        }
                    }
                });
                return true
            } else {
                TurbulenzEngine.callOnError("Missing archive loader required for " + src);
                return false
            }
        };
        WebGLGraphicsDevice.prototype.getScreenshot = function(compress, x, y, width, height) {
            var gl = this.gl;
            var canvas = gl.canvas;
            if (compress) {
                return canvas.toDataURL("image/jpeg")
            } else {
                if (x === undefined) {
                    x = 0
                }
                if (y === undefined) {
                    y = 0
                }
                var target = this.activeRenderTarget;
                if (!target) {
                    target = canvas
                }
                if (width === undefined) {
                    width = target.width
                }
                if (height === undefined) {
                    height = target.height
                }
                var pixels = new Uint8Array(4 * width * height);
                gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
                return pixels
            }
        };
        WebGLGraphicsDevice.prototype.flush = function() {
            this.gl.flush()
        };
        WebGLGraphicsDevice.prototype.finish = function() {
            this.gl.finish()
        };
        WebGLGraphicsDevice.prototype._drawArraySortPositive = function(a, b) {
            return b.sortKey - a.sortKey
        };
        WebGLGraphicsDevice.prototype._drawArraySortNegative = function(a, b) {
            return a.sortKey - b.sortKey
        };
        WebGLGraphicsDevice.prototype.checkFullScreen = function() {
            var fullscreen = this.fullscreen;
            if (this.oldFullscreen !== fullscreen) {
                this.oldFullscreen = fullscreen;
                this.requestFullScreen(fullscreen)
            }
        };
        WebGLGraphicsDevice.prototype.requestFullScreen = function(fullscreen) {
            if (fullscreen) {
                var canvas = this.gl.canvas;
                if (canvas.webkitRequestFullScreenWithKeys) {
                    canvas.webkitRequestFullScreenWithKeys()
                } else if (canvas.requestFullScreenWithKeys) {
                    canvas.requestFullScreenWithKeys()
                } else if (canvas.webkitRequestFullScreen) {
                    canvas.webkitRequestFullScreen(canvas.ALLOW_KEYBOARD_INPUT)
                } else if (canvas.mozRequestFullScreen) {
                    canvas.mozRequestFullScreen()
                } else if (canvas.msRequestFullscreen) {
                    canvas.msRequestFullscreen()
                } else if (canvas.requestFullScreen) {
                    canvas.requestFullScreen()
                } else if (canvas.requestFullscreen) {
                    canvas.requestFullscreen()
                }
            } else {
                if (document.webkitCancelFullScreen) {
                    document.webkitCancelFullScreen()
                } else if (document["mozCancelFullScreen"]) {
                    document["mozCancelFullScreen"]()
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen()
                } else if (document.cancelFullScreen) {
                    document.cancelFullScreen()
                } else if (document.exitFullscreen) {
                    document.exitFullscreen()
                }
            }
            return true
        };
        WebGLGraphicsDevice.prototype.createSampler = function(sampler) {
            var samplerKey = sampler.minFilter.toString() + ":" + sampler.magFilter.toString() + ":" + sampler.wrapS.toString() + ":" + sampler.wrapT.toString() + ":" + sampler.wrapR.toString() + ":" + sampler.maxAnisotropy.toString();
            var cachedSamplers = this.cachedSamplers;
            var cachedSampler = cachedSamplers[samplerKey];
            if (!cachedSampler) {
                cachedSamplers[samplerKey] = sampler;
                return sampler
            }
            return cachedSampler
        };
        WebGLGraphicsDevice.prototype.unsetIndexBuffer = function(indexBuffer) {
            if (this.activeIndexBuffer === indexBuffer) {
                this.activeIndexBuffer = null;
                var gl = this.gl;
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null)
            }
        };
        WebGLGraphicsDevice.prototype.bindVertexBuffer = function(buffer) {
            if (this.bindedVertexBuffer !== buffer) {
                this.bindedVertexBuffer = buffer;
                var gl = this.gl;
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
            }
        };
        WebGLGraphicsDevice.prototype.unbindVertexBuffer = function(buffer) {
            if (this.bindedVertexBuffer === buffer) {
                this.bindedVertexBuffer = null;
                var gl = this.gl;
                gl.bindBuffer(gl.ARRAY_BUFFER, null)
            }
        };
        WebGLGraphicsDevice.prototype.bindTextureUnit = function(unit, target, texture) {
            var state = this.state;
            var gl = this.gl;
            if (state.activeTextureUnit !== unit) {
                state.activeTextureUnit = unit;
                gl.activeTexture(gl.TEXTURE0 + unit)
            }
            gl.bindTexture(target, texture)
        };
        WebGLGraphicsDevice.prototype.bindTexture = function(target, texture) {
            var state = this.state;
            var gl = this.gl;
            var dummyUnit = state.maxTextureUnit - 1;
            if (state.activeTextureUnit !== dummyUnit) {
                state.activeTextureUnit = dummyUnit;
                gl.activeTexture(gl.TEXTURE0 + dummyUnit)
            }
            gl.bindTexture(target, texture)
        };
        WebGLGraphicsDevice.prototype.unbindTexture = function(texture) {
            var state = this.state;
            var lastMaxTextureUnit = state.lastMaxTextureUnit;
            var textureUnits = state.textureUnits;
            for (var u = 0; u < lastMaxTextureUnit; u += 1) {
                var textureUnit = textureUnits[u];
                if (textureUnit.texture === texture) {
                    textureUnit.texture = null;
                    this.bindTextureUnit(u, textureUnit.target, null)
                }
            }
        };
        WebGLGraphicsDevice.prototype.setSampler = function(sampler, target) {
            if (sampler) {
                var gl = this.gl;
                gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, sampler.minFilter);
                gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, sampler.magFilter);
                gl.texParameteri(target, gl.TEXTURE_WRAP_S, sampler.wrapS);
                gl.texParameteri(target, gl.TEXTURE_WRAP_T, sampler.wrapT);
                if (this.TEXTURE_MAX_ANISOTROPY_EXT) {
                    gl.texParameteri(target, this.TEXTURE_MAX_ANISOTROPY_EXT, sampler.maxAnisotropy)
                }
            }
        };
        WebGLGraphicsDevice.prototype.setPass = function(pass) {
            var gl = this.gl;
            var state = this.state;
            var renderStatesSet = pass.statesSet;
            var renderStates = pass.states;
            var numRenderStates = renderStates.length;
            var r, renderState;
            for (r = 0; r < numRenderStates; r += 1) {
                renderState = renderStates[r];
                renderState.set.apply(renderState, renderState.values)
            }
            var renderStatesToReset = state.renderStatesToReset;
            var numRenderStatesToReset = renderStatesToReset.length;
            for (r = 0; r < numRenderStatesToReset; r += 1) {
                renderState = renderStatesToReset[r];
                if (!(renderState.name in renderStatesSet)) {
                    renderState.reset()
                }
            }
            state.renderStatesToReset = renderStates;
            var lastMaxTextureUnit = state.lastMaxTextureUnit;
            var textureUnits = state.textureUnits;
            var currentMaxTextureUnit = pass.numTextureUnits;
            if (currentMaxTextureUnit < lastMaxTextureUnit) {
                var u = currentMaxTextureUnit;
                do {
                    var textureUnit = textureUnits[u];
                    if (textureUnit.texture) {
                        textureUnit.texture = null;
                        this.bindTextureUnit(u, textureUnit.target, null)
                    }
                    u += 1
                } while (u < lastMaxTextureUnit)
            }
            state.lastMaxTextureUnit = currentMaxTextureUnit;
            var program = pass.glProgram;
            if (state.program !== program) {
                state.program = program;
                gl.useProgram(program)
            }
            if (pass.dirty) {
                pass.updateParametersData(this)
            }
        };
        WebGLGraphicsDevice.prototype.enableClientState = function(mask) {
            var gl = this.gl;
            var oldMask = this.clientStateMask;
            this.clientStateMask = mask;
            var disableMask = oldMask & ~mask;
            var enableMask = ~oldMask & mask;
            var n;
            if (disableMask) {
                if ((disableMask & 255) === 0) {
                    disableMask >>= 8;
                    n = 8
                } else {
                    n = 0
                }
                do {
                    if (0 !== (1 & disableMask)) {
                        gl.disableVertexAttribArray(n)
                    }
                    n += 1;
                    disableMask >>= 1
                } while (disableMask)
            }
            if (enableMask) {
                if ((enableMask & 255) === 0) {
                    enableMask >>= 8;
                    n = 8
                } else {
                    n = 0
                }
                do {
                    if (0 !== (1 & enableMask)) {
                        gl.enableVertexAttribArray(n)
                    }
                    n += 1;
                    enableMask >>= 1
                } while (enableMask)
            }
        };
        WebGLGraphicsDevice.prototype.setTexture = function(textureUnitIndex, texture, sampler) {
            var state = this.state;
            var gl = this.gl;
            var textureUnit = state.textureUnits[textureUnitIndex];
            var oldgltarget = textureUnit.target;
            var oldglobject = textureUnit.texture;
            if (texture) {
                var gltarget = texture.target;
                var globject = texture.glTexture;
                if (oldglobject !== globject || oldgltarget !== gltarget) {
                    textureUnit.target = gltarget;
                    textureUnit.texture = globject;
                    if (state.activeTextureUnit !== textureUnitIndex) {
                        state.activeTextureUnit = textureUnitIndex;
                        gl.activeTexture(gl.TEXTURE0 + textureUnitIndex)
                    }
                    if (oldgltarget !== gltarget && oldglobject) {
                        gl.bindTexture(oldgltarget, null)
                    }
                    gl.bindTexture(gltarget, globject);
                    if (texture.sampler !== sampler) {
                        texture.sampler = sampler;
                        this.setSampler(sampler, gltarget)
                    }
                }
            } else {
                if (oldgltarget && oldglobject) {
                    textureUnit.target = 0;
                    textureUnit.texture = null;
                    if (state.activeTextureUnit !== textureUnitIndex) {
                        state.activeTextureUnit = textureUnitIndex;
                        gl.activeTexture(gl.TEXTURE0 + textureUnitIndex)
                    }
                    gl.bindTexture(oldgltarget, null)
                }
            }
        };
        WebGLGraphicsDevice.prototype.setProgram = function(program) {
            var state = this.state;
            if (state.program !== program) {
                state.program = program;
                this.gl.useProgram(program)
            }
        };
        WebGLGraphicsDevice.prototype.syncState = function() {
            var state = this.state;
            var gl = this.gl;
            if (state.depthTestEnable) {
                gl.enable(gl.DEPTH_TEST)
            } else {
                gl.disable(gl.DEPTH_TEST)
            }
            gl.depthFunc(state.depthFunc);
            gl.depthMask(state.depthMask);
            if (state.blendEnable) {
                gl.enable(gl.BLEND)
            } else {
                gl.disable(gl.BLEND)
            }
            gl.blendFunc(state.blendSrc, state.blendDst);
            if (state.cullFaceEnable) {
                gl.enable(gl.CULL_FACE)
            } else {
                gl.disable(gl.CULL_FACE)
            }
            gl.cullFace(state.cullFace);
            gl.frontFace(state.frontFace);
            var colorMask = state.colorMask;
            gl.colorMask(colorMask[0], colorMask[1], colorMask[2], colorMask[3]);
            if (state.stencilTestEnable) {
                gl.enable(gl.STENCIL_TEST)
            } else {
                gl.disable(gl.STENCIL_TEST)
            }
            gl.stencilFunc(state.stencilFunc, state.stencilRef, state.stencilMask);
            gl.stencilOp(state.stencilFail, state.stencilZFail, state.stencilZPass);
            if (state.polygonOffsetFillEnable) {
                gl.enable(gl.POLYGON_OFFSET_FILL)
            } else {
                gl.disable(gl.POLYGON_OFFSET_FILL)
            }
            gl.polygonOffset(state.polygonOffsetFactor, state.polygonOffsetUnits);
            gl.lineWidth(state.lineWidth);
            gl.activeTexture(gl.TEXTURE0 + state.activeTextureUnit);
            var currentBox = this.state.viewportBox;
            gl.viewport(currentBox[0], currentBox[1], currentBox[2], currentBox[3]);
            currentBox = this.state.scissorBox;
            gl.scissor(currentBox[0], currentBox[1], currentBox[2], currentBox[3]);
            var currentColor = state.clearColor;
            gl.clearColor(currentColor[0], currentColor[1], currentColor[2], currentColor[3]);
            gl.clearDepth(state.clearDepth);
            gl.clearStencil(state.clearStencil)
        };
        WebGLGraphicsDevice.prototype.resetStates = function() {
            var state = this.state;
            var lastMaxTextureUnit = state.lastMaxTextureUnit;
            var textureUnits = state.textureUnits;
            for (var u = 0; u < lastMaxTextureUnit; u += 1) {
                var textureUnit = textureUnits[u];
                if (textureUnit.texture) {
                    this.bindTextureUnit(u, textureUnit.target, null);
                    textureUnit.texture = null;
                    textureUnit.target = 0
                }
            }
        };
        WebGLGraphicsDevice.prototype.destroy = function() {
            delete this.activeTechnique;
            delete this.activeIndexBuffer;
            delete this.bindedVertexBuffer;
            if (this.immediateVertexBuffer) {
                this.immediateVertexBuffer.destroy();
                delete this.immediateVertexBuffer
            }
            delete this.gl;
            if (typeof DDSLoader !== "undefined") {
                DDSLoader.destroy()
            }
        };
        WebGLGraphicsDevice.create = function(canvas, params) {
            var getAvailableContext = function getAvailableContextFn(canvas, params, contextList) {
                if (canvas.getContext) {
                    var canvasParams = {
                        alpha: false,
                        depth: true,
                        stencil: true,
                        antialias: false
                    };
                    var multisample = params.multisample;
                    if (multisample !== undefined && 1 < multisample) {
                        canvasParams.antialias = true
                    }
                    var alpha = params.alpha;
                    if (alpha) {
                        canvasParams.alpha = true
                    }
                    if (params.depth === false) {
                        canvasParams.depth = false
                    }
                    if (params.stencil === false) {
                        canvasParams.stencil = false
                    }
                    var numContexts = contextList.length,
                        i;
                    for (i = 0; i < numContexts; i += 1) {
                        try {
                            var context = canvas.getContext(contextList[i], canvasParams);
                            if (context) {
                                return context
                            }
                        } catch (ex) {}
                    }
                }
                return null
            };
            var gl = getAvailableContext(canvas, params, ["webgl", "experimental-webgl"]);
            if (!gl) {
                return null
            }
            var width = gl.drawingBufferWidth || canvas.width;
            var height = gl.drawingBufferHeight || canvas.height;
            gl.enable(gl.SCISSOR_TEST);
            gl.depthRange(0, 1);
            gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
            var gd = new WebGLGraphicsDevice;
            gd.gl = gl;
            gd.width = width;
            gd.height = height;
            var extensions = gl.getSupportedExtensions();
            var extensionsMap = {};
            var numExtensions = extensions.length;
            var n;
            for (n = 0; n < numExtensions; n += 1) {
                extensionsMap[extensions[n]] = true
            }
            if (extensions) {
                extensions = extensions.join(" ")
            } else {
                extensions = ""
            }
            gd.extensions = extensions;
            gd.shadingLanguageVersion = gl.getParameter(gl.SHADING_LANGUAGE_VERSION);
            gd.rendererVersion = gl.getParameter(gl.VERSION);
            gd.renderer = gl.getParameter(gl.RENDERER);
            gd.vendor = gl.getParameter(gl.VENDOR);
            if (extensionsMap["WEBGL_compressed_texture_s3tc"]) {
                gd.WEBGL_compressed_texture_s3tc = true;
                gd.compressedTexturesExtension = gl.getExtension("WEBGL_compressed_texture_s3tc")
            } else if (extensionsMap["WEBKIT_WEBGL_compressed_texture_s3tc"]) {
                gd.WEBGL_compressed_texture_s3tc = true;
                gd.compressedTexturesExtension = gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc")
            } else if (extensionsMap["MOZ_WEBGL_compressed_texture_s3tc"]) {
                gd.WEBGL_compressed_texture_s3tc = true;
                gd.compressedTexturesExtension = gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc")
            } else if (extensionsMap["WEBKIT_WEBGL_compressed_textures"]) {
                gd.compressedTexturesExtension = gl.getExtension("WEBKIT_WEBGL_compressed_textures")
            }
            var anisotropyExtension;
            if (extensionsMap["EXT_texture_filter_anisotropic"]) {
                anisotropyExtension = gl.getExtension("EXT_texture_filter_anisotropic")
            } else if (extensionsMap["MOZ_EXT_texture_filter_anisotropic"]) {
                anisotropyExtension = gl.getExtension("MOZ_EXT_texture_filter_anisotropic")
            } else if (extensionsMap["WEBKIT_EXT_texture_filter_anisotropic"]) {
                anisotropyExtension = gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic")
            }
            if (anisotropyExtension) {
                gd.TEXTURE_MAX_ANISOTROPY_EXT = anisotropyExtension.TEXTURE_MAX_ANISOTROPY_EXT;
                gd.maxAnisotropy = gl.getParameter(anisotropyExtension.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
            } else {
                gd.maxAnisotropy = 1
            }
            gl.getExtension("OES_element_index_uint");
            if (extensionsMap["WEBGL_draw_buffers"]) {
                gd.WEBGL_draw_buffers = true;
                gd.drawBuffersExtension = gl.getExtension("WEBGL_draw_buffers")
            } else if (extensionsMap["EXT_draw_buffers"]) {
                gd.drawBuffersExtension = gl.getExtension("EXT_draw_buffers")
            }
            if (extensionsMap["OES_texture_float"]) {
                gd.floatTextureExtension = gl.getExtension("OES_texture_float")
            }
            if (extensionsMap["WEBGL_color_buffer_float"]) {
                gd.floatTextureExtension = gl.getExtension("WEBGL_color_buffer_float")
            }
            var proto = WebGLGraphicsDevice.prototype;
            proto.PRIMITIVE_POINTS = gl.POINTS;
            proto.PRIMITIVE_LINES = gl.LINES;
            proto.PRIMITIVE_LINE_LOOP = gl.LINE_LOOP;
            proto.PRIMITIVE_LINE_STRIP = gl.LINE_STRIP;
            proto.PRIMITIVE_TRIANGLES = gl.TRIANGLES;
            proto.PRIMITIVE_TRIANGLE_STRIP = gl.TRIANGLE_STRIP;
            proto.PRIMITIVE_TRIANGLE_FAN = gl.TRIANGLE_FAN;
            proto.INDEXFORMAT_UBYTE = gl.UNSIGNED_BYTE;
            proto.INDEXFORMAT_USHORT = gl.UNSIGNED_SHORT;
            proto.INDEXFORMAT_UINT = gl.UNSIGNED_INT;
            var ieVersionIndex = gd.vendor === "Microsoft" ? gd.rendererVersion.indexOf("0.9") : -1;
            if (-1 !== ieVersionIndex) {
                gd.fixIE = gd.rendererVersion.substr(ieVersionIndex, 4)
            } else {
                gd.fixIE = null
            }
            var getNormalizationScale = function getNormalizationScaleFn(format) {
                if (format === gl.BYTE) {
                    return 127
                } else if (format === gl.UNSIGNED_BYTE) {
                    return 255
                } else if (format === gl.SHORT) {
                    return 32767
                } else if (format === gl.UNSIGNED_SHORT) {
                    return 65535
                } else if (format === gl.INT) {
                    return 2147483647
                } else if (format === gl.UNSIGNED_INT) {
                    return 4294967295
                } else {
                    return 1
                }
            };
            var makeVertexformat = function makeVertexformatFn(n, c, s, f, name) {
                var attributeFormat = {
                    numComponents: c,
                    stride: s,
                    componentStride: s / c,
                    format: f,
                    name: name,
                    normalized: undefined,
                    normalizationScale: undefined,
                    typedSetter: undefined,
                    typedArray: undefined
                };
                if (n) {
                    attributeFormat.normalized = true;
                    attributeFormat.normalizationScale = getNormalizationScale(f)
                } else {
                    attributeFormat.normalized = false;
                    attributeFormat.normalizationScale = 1
                }
                if (typeof DataView !== "undefined" && "setFloat32" in DataView.prototype) {
                    if (f === gl.BYTE) {
                        attributeFormat.typedSetter = DataView.prototype.setInt8
                    } else if (f === gl.UNSIGNED_BYTE) {
                        attributeFormat.typedSetter = DataView.prototype.setUint8
                    } else if (f === gl.SHORT) {
                        attributeFormat.typedSetter = DataView.prototype.setInt16
                    } else if (f === gl.UNSIGNED_SHORT) {
                        attributeFormat.typedSetter = DataView.prototype.setUint16
                    } else if (f === gl.INT) {
                        attributeFormat.typedSetter = DataView.prototype.setInt32
                    } else if (f === gl.UNSIGNED_INT) {
                        attributeFormat.typedSetter = DataView.prototype.setUint32
                    } else {
                        attributeFormat.typedSetter = DataView.prototype.setFloat32
                    }
                } else {
                    if (f === gl.BYTE) {
                        attributeFormat.typedArray = Int8Array
                    } else if (f === gl.UNSIGNED_BYTE) {
                        attributeFormat.typedArray = Uint8Array
                    } else if (f === gl.SHORT) {
                        attributeFormat.typedArray = Int16Array
                    } else if (f === gl.UNSIGNED_SHORT) {
                        attributeFormat.typedArray = Uint16Array
                    } else if (f === gl.INT) {
                        attributeFormat.typedArray = Int32Array
                    } else if (f === gl.UNSIGNED_INT) {
                        attributeFormat.typedArray = Uint32Array
                    } else {
                        attributeFormat.typedArray = Float32Array
                    }
                }
                return attributeFormat
            };
            if (gd.fixIE && gd.fixIE < "0.93") {
                proto.VERTEXFORMAT_BYTE4 = makeVertexformat(0, 4, 16, gl.FLOAT, "BYTE4");
                proto.VERTEXFORMAT_BYTE4N = makeVertexformat(0, 4, 16, gl.FLOAT, "BYTE4N");
                proto.VERTEXFORMAT_UBYTE4 = makeVertexformat(0, 4, 16, gl.FLOAT, "UBYTE4");
                proto.VERTEXFORMAT_UBYTE4N = makeVertexformat(0, 4, 16, gl.FLOAT, "UBYTE4N");
                proto.VERTEXFORMAT_SHORT2 = makeVertexformat(0, 2, 8, gl.FLOAT, "SHORT2");
                proto.VERTEXFORMAT_SHORT2N = makeVertexformat(0, 2, 8, gl.FLOAT, "SHORT2N");
                proto.VERTEXFORMAT_SHORT4 = makeVertexformat(0, 4, 16, gl.FLOAT, "SHORT4");
                proto.VERTEXFORMAT_SHORT4N = makeVertexformat(0, 4, 16, gl.FLOAT, "SHORT4N");
                proto.VERTEXFORMAT_USHORT2 = makeVertexformat(0, 2, 8, gl.FLOAT, "USHORT2");
                proto.VERTEXFORMAT_USHORT2N = makeVertexformat(0, 2, 8, gl.FLOAT, "USHORT2N");
                proto.VERTEXFORMAT_USHORT4 = makeVertexformat(0, 4, 16, gl.FLOAT, "USHORT4");
                proto.VERTEXFORMAT_USHORT4N = makeVertexformat(0, 4, 16, gl.FLOAT, "USHORT4N");
                proto.VERTEXFORMAT_FLOAT1 = makeVertexformat(0, 1, 4, gl.FLOAT, "FLOAT1");
                proto.VERTEXFORMAT_FLOAT2 = makeVertexformat(0, 2, 8, gl.FLOAT, "FLOAT2");
                proto.VERTEXFORMAT_FLOAT3 = makeVertexformat(0, 3, 12, gl.FLOAT, "FLOAT3");
                proto.VERTEXFORMAT_FLOAT4 = makeVertexformat(0, 4, 16, gl.FLOAT, "FLOAT4")
            } else {
                proto.VERTEXFORMAT_BYTE4 = makeVertexformat(0, 4, 4, gl.BYTE, "BYTE4");
                proto.VERTEXFORMAT_BYTE4N = makeVertexformat(1, 4, 4, gl.BYTE, "BYTE4N");
                proto.VERTEXFORMAT_UBYTE4 = makeVertexformat(0, 4, 4, gl.UNSIGNED_BYTE, "UBYTE4");
                proto.VERTEXFORMAT_UBYTE4N = makeVertexformat(1, 4, 4, gl.UNSIGNED_BYTE, "UBYTE4N");
                proto.VERTEXFORMAT_SHORT2 = makeVertexformat(0, 2, 4, gl.SHORT, "SHORT2");
                proto.VERTEXFORMAT_SHORT2N = makeVertexformat(1, 2, 4, gl.SHORT, "SHORT2N");
                proto.VERTEXFORMAT_SHORT4 = makeVertexformat(0, 4, 8, gl.SHORT, "SHORT4");
                proto.VERTEXFORMAT_SHORT4N = makeVertexformat(1, 4, 8, gl.SHORT, "SHORT4N");
                proto.VERTEXFORMAT_USHORT2 = makeVertexformat(0, 2, 4, gl.UNSIGNED_SHORT, "USHORT2");
                proto.VERTEXFORMAT_USHORT2N = makeVertexformat(1, 2, 4, gl.UNSIGNED_SHORT, "USHORT2N");
                proto.VERTEXFORMAT_USHORT4 = makeVertexformat(0, 4, 8, gl.UNSIGNED_SHORT, "USHORT4");
                proto.VERTEXFORMAT_USHORT4N = makeVertexformat(1, 4, 8, gl.UNSIGNED_SHORT, "USHORT4N");
                proto.VERTEXFORMAT_FLOAT1 = makeVertexformat(0, 1, 4, gl.FLOAT, "FLOAT1");
                proto.VERTEXFORMAT_FLOAT2 = makeVertexformat(0, 2, 8, gl.FLOAT, "FLOAT2");
                proto.VERTEXFORMAT_FLOAT3 = makeVertexformat(0, 3, 12, gl.FLOAT, "FLOAT3");
                proto.VERTEXFORMAT_FLOAT4 = makeVertexformat(0, 4, 16, gl.FLOAT, "FLOAT4")
            }
            var maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
            if (maxAttributes < 16) {
                proto.SEMANTIC_ATTR0 = proto.SEMANTIC_POSITION = proto.SEMANTIC_POSITION0 = 0;
                proto.SEMANTIC_ATTR1 = proto.SEMANTIC_BLENDWEIGHT = proto.SEMANTIC_BLENDWEIGHT0 = 1;
                proto.SEMANTIC_ATTR2 = proto.SEMANTIC_NORMAL = proto.SEMANTIC_NORMAL0 = 2;
                proto.SEMANTIC_ATTR3 = proto.SEMANTIC_COLOR = proto.SEMANTIC_COLOR0 = 3;
                proto.SEMANTIC_ATTR7 = proto.SEMANTIC_BLENDINDICES = proto.SEMANTIC_BLENDINDICES0 = 4;
                proto.SEMANTIC_ATTR8 = proto.SEMANTIC_TEXCOORD = proto.SEMANTIC_TEXCOORD0 = 5;
                proto.SEMANTIC_ATTR9 = proto.SEMANTIC_TEXCOORD1 = 6;
                proto.SEMANTIC_ATTR14 = proto.SEMANTIC_TEXCOORD6 = proto.SEMANTIC_TANGENT = proto.SEMANTIC_TANGENT0 = 7;
                proto.SEMANTIC_ATTR15 = proto.SEMANTIC_TEXCOORD7 = proto.SEMANTIC_BINORMAL0 = proto.SEMANTIC_BINORMAL = 8;
                proto.SEMANTIC_ATTR10 = proto.SEMANTIC_TEXCOORD2 = 9;
                proto.SEMANTIC_ATTR11 = proto.SEMANTIC_TEXCOORD3 = 10;
                proto.SEMANTIC_ATTR12 = proto.SEMANTIC_TEXCOORD4 = 11;
                proto.SEMANTIC_ATTR13 = proto.SEMANTIC_TEXCOORD5 = 12;
                proto.SEMANTIC_ATTR4 = proto.SEMANTIC_COLOR1 = proto.SEMANTIC_SPECULAR = 13;
                proto.SEMANTIC_ATTR5 = proto.SEMANTIC_FOGCOORD = proto.SEMANTIC_TESSFACTOR = 14;
                proto.SEMANTIC_ATTR6 = proto.SEMANTIC_PSIZE = proto.SEMANTIC_PSIZE0 = 15
            }
            proto.DEFAULT_SAMPLER = {
                minFilter: gl.LINEAR_MIPMAP_LINEAR,
                magFilter: gl.LINEAR,
                wrapS: gl.REPEAT,
                wrapT: gl.REPEAT,
                wrapR: gl.REPEAT,
                maxAnisotropy: 1
            };
            gd.cachedSamplers = {};
            var maxTextureUnit = 1;
            var maxUnit = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
            if (maxTextureUnit < maxUnit) {
                maxTextureUnit = maxUnit
            }
            maxUnit = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
            if (maxTextureUnit < maxUnit) {
                maxTextureUnit = maxUnit
            }
            var textureUnits = [];
            textureUnits.length = maxTextureUnit;
            for (var t = 0; t < maxTextureUnit; t += 1) {
                textureUnits[t] = {
                    texture: null,
                    target: 0
                }
            }
            var defaultDepthFunc = gl.LEQUAL;
            var defaultBlendFuncSrc = gl.SRC_ALPHA;
            var defaultBlendFuncDst = gl.ONE_MINUS_SRC_ALPHA;
            var defaultCullFace = gl.BACK;
            var defaultFrontFace = gl.CCW;
            var defaultStencilFunc = gl.ALWAYS;
            var defaultStencilOp = gl.KEEP;
            var currentState = {
                depthTestEnable: true,
                blendEnable: false,
                cullFaceEnable: true,
                stencilTestEnable: false,
                polygonOffsetFillEnable: false,
                depthMask: true,
                depthFunc: defaultDepthFunc,
                blendSrc: defaultBlendFuncSrc,
                blendDst: defaultBlendFuncDst,
                cullFace: defaultCullFace,
                frontFace: defaultFrontFace,
                colorMask: [true, true, true, true],
                stencilFunc: defaultStencilFunc,
                stencilRef: 0,
                stencilMask: 4294967295,
                stencilFail: defaultStencilOp,
                stencilZFail: defaultStencilOp,
                stencilZPass: defaultStencilOp,
                polygonOffsetFactor: 0,
                polygonOffsetUnits: 0,
                lineWidth: 1,
                renderStatesToReset: [],
                viewportBox: [0, 0, width, height],
                scissorBox: [0, 0, width, height],
                clearColor: [0, 0, 0, 1],
                clearDepth: 1,
                clearStencil: 0,
                activeTextureUnit: 0,
                maxTextureUnit: maxTextureUnit,
                lastMaxTextureUnit: 0,
                textureUnits: textureUnits,
                program: null
            };
            gd.state = currentState;
            gd.counters = {
                textures: 0,
                vertexBuffers: 0,
                indexBuffers: 0,
                renderTargets: 0,
                renderBuffers: 0,
                shaders: 0,
                techniques: 0
            };

            function setDepthTestEnable(enable) {
                if (currentState.depthTestEnable !== enable) {
                    currentState.depthTestEnable = enable;
                    if (enable) {
                        gl.enable(gl.DEPTH_TEST)
                    } else {
                        gl.disable(gl.DEPTH_TEST)
                    }
                }
            }

            function setDepthFunc(func) {
                if (currentState.depthFunc !== func) {
                    currentState.depthFunc = func;
                    gl.depthFunc(func)
                }
            }

            function setDepthMask(enable) {
                if (currentState.depthMask !== enable) {
                    currentState.depthMask = enable;
                    gl.depthMask(enable)
                }
            }

            function setBlendEnable(enable) {
                if (currentState.blendEnable !== enable) {
                    currentState.blendEnable = enable;
                    if (enable) {
                        gl.enable(gl.BLEND)
                    } else {
                        gl.disable(gl.BLEND)
                    }
                }
            }

            function setBlendFunc(src, dst) {
                if (currentState.blendSrc !== src || currentState.blendDst !== dst) {
                    currentState.blendSrc = src;
                    currentState.blendDst = dst;
                    gl.blendFunc(src, dst)
                }
            }

            function setCullFaceEnable(enable) {
                if (currentState.cullFaceEnable !== enable) {
                    currentState.cullFaceEnable = enable;
                    if (enable) {
                        gl.enable(gl.CULL_FACE)
                    } else {
                        gl.disable(gl.CULL_FACE)
                    }
                }
            }

            function setCullFace(face) {
                if (currentState.cullFace !== face) {
                    currentState.cullFace = face;
                    gl.cullFace(face)
                }
            }

            function setFrontFace(face) {
                if (currentState.frontFace !== face) {
                    currentState.frontFace = face;
                    gl.frontFace(face)
                }
            }

            function setColorMask(mask0, mask1, mask2, mask3) {
                var colorMask = currentState.colorMask;
                if (colorMask[0] !== mask0 || colorMask[1] !== mask1 || colorMask[2] !== mask2 || colorMask[3] !== mask3) {
                    colorMask[0] = mask0;
                    colorMask[1] = mask1;
                    colorMask[2] = mask2;
                    colorMask[3] = mask3;
                    gl.colorMask(mask0, mask1, mask2, mask3)
                }
            }

            function setStencilTestEnable(enable) {
                if (currentState.stencilTestEnable !== enable) {
                    currentState.stencilTestEnable = enable;
                    if (enable) {
                        gl.enable(gl.STENCIL_TEST)
                    } else {
                        gl.disable(gl.STENCIL_TEST)
                    }
                }
            }

            function setStencilFunc(stencilFunc, stencilRef, stencilMask) {
                if (currentState.stencilFunc !== stencilFunc || currentState.stencilRef !== stencilRef || currentState.stencilMask !== stencilMask) {
                    currentState.stencilFunc = stencilFunc;
                    currentState.stencilRef = stencilRef;
                    currentState.stencilMask = stencilMask;
                    gl.stencilFunc(stencilFunc, stencilRef, stencilMask)
                }
            }

            function setStencilOp(stencilFail, stencilZfail, stencilZpass) {
                if (currentState.stencilFail !== stencilFail || currentState.stencilZFail !== stencilZfail || currentState.stencilZPass !== stencilZpass) {
                    currentState.stencilFail = stencilFail;
                    currentState.stencilZFail = stencilZfail;
                    currentState.stencilZPass = stencilZpass;
                    gl.stencilOp(stencilFail, stencilZfail, stencilZpass)
                }
            }

            function setPolygonOffsetFillEnable(enable) {
                if (currentState.polygonOffsetFillEnable !== enable) {
                    currentState.polygonOffsetFillEnable = enable;
                    if (enable) {
                        gl.enable(gl.POLYGON_OFFSET_FILL)
                    } else {
                        gl.disable(gl.POLYGON_OFFSET_FILL)
                    }
                }
            }

            function setPolygonOffset(factor, units) {
                if (currentState.polygonOffsetFactor !== factor || currentState.polygonOffsetUnits !== units) {
                    currentState.polygonOffsetFactor = factor;
                    currentState.polygonOffsetUnits = units;
                    gl.polygonOffset(factor, units)
                }
            }

            function setLineWidth(lineWidth) {
                if (currentState.lineWidth !== lineWidth) {
                    currentState.lineWidth = lineWidth;
                    gl.lineWidth(lineWidth)
                }
            }

            function resetDepthTestEnable() {
                if (!currentState.depthTestEnable) {
                    currentState.depthTestEnable = true;
                    gl.enable(gl.DEPTH_TEST)
                }
            }

            function resetDepthFunc() {
                var func = defaultDepthFunc;
                if (currentState.depthFunc !== func) {
                    currentState.depthFunc = func;
                    gl.depthFunc(func)
                }
            }

            function resetDepthMask() {
                if (!currentState.depthMask) {
                    currentState.depthMask = true;
                    gl.depthMask(true)
                }
            }

            function resetBlendEnable() {
                if (currentState.blendEnable) {
                    currentState.blendEnable = false;
                    gl.disable(gl.BLEND)
                }
            }

            function resetBlendFunc() {
                var src = defaultBlendFuncSrc;
                var dst = defaultBlendFuncDst;
                if (currentState.blendSrc !== src || currentState.blendDst !== dst) {
                    currentState.blendSrc = src;
                    currentState.blendDst = dst;
                    gl.blendFunc(src, dst)
                }
            }

            function resetCullFaceEnable() {
                if (!currentState.cullFaceEnable) {
                    currentState.cullFaceEnable = true;
                    gl.enable(gl.CULL_FACE)
                }
            }

            function resetCullFace() {
                var face = defaultCullFace;
                if (currentState.cullFace !== face) {
                    currentState.cullFace = face;
                    gl.cullFace(face)
                }
            }

            function resetFrontFace() {
                var face = defaultFrontFace;
                if (currentState.frontFace !== face) {
                    currentState.frontFace = face;
                    gl.frontFace(face)
                }
            }

            function resetColorMask() {
                var colorMask = currentState.colorMask;
                if (colorMask[0] !== true || colorMask[1] !== true || colorMask[2] !== true || colorMask[3] !== true) {
                    colorMask[0] = true;
                    colorMask[1] = true;
                    colorMask[2] = true;
                    colorMask[3] = true;
                    gl.colorMask(true, true, true, true)
                }
            }

            function resetStencilTestEnable() {
                if (currentState.stencilTestEnable) {
                    currentState.stencilTestEnable = false;
                    gl.disable(gl.STENCIL_TEST)
                }
            }

            function resetStencilFunc() {
                var stencilFunc = defaultStencilFunc;
                if (currentState.stencilFunc !== stencilFunc || currentState.stencilRef !== 0 || currentState.stencilMask !== 4294967295) {
                    currentState.stencilFunc = stencilFunc;
                    currentState.stencilRef = 0;
                    currentState.stencilMask = 4294967295;
                    gl.stencilFunc(stencilFunc, 0, 4294967295)
                }
            }

            function resetStencilOp() {
                var stencilOp = defaultStencilOp;
                if (currentState.stencilFail !== stencilOp || currentState.stencilZFail !== stencilOp || currentState.stencilZPass !== stencilOp) {
                    currentState.stencilFail = stencilOp;
                    currentState.stencilZFail = stencilOp;
                    currentState.stencilZPass = stencilOp;
                    gl.stencilOp(stencilOp, stencilOp, stencilOp)
                }
            }

            function resetPolygonOffsetFillEnable() {
                if (currentState.polygonOffsetFillEnable) {
                    currentState.polygonOffsetFillEnable = false;
                    gl.disable(gl.POLYGON_OFFSET_FILL)
                }
            }

            function resetPolygonOffset() {
                if (currentState.polygonOffsetFactor !== 0 || currentState.polygonOffsetUnits !== 0) {
                    currentState.polygonOffsetFactor = 0;
                    currentState.polygonOffsetUnits = 0;
                    gl.polygonOffset(0, 0)
                }
            }

            function resetLineWidth() {
                if (currentState.lineWidth !== 1) {
                    currentState.lineWidth = 1;
                    gl.lineWidth(1)
                }
            }

            function parseBoolean(state) {
                if (typeof state !== "boolean") {
                    return [state ? true : false]
                }
                return [state]
            }

            function parseEnum(state) {
                if (typeof state !== "number") {
                    return null
                }
                return [state]
            }

            function parseEnum2(state) {
                if (typeof state === "object") {
                    var value0 = state[0],
                        value1 = state[1];
                    if (typeof value0 !== "number") {
                        return null
                    }
                    if (typeof value1 !== "number") {
                        return null
                    }
                    return [value0, value1]
                }
                return null
            }

            function parseEnum3(state) {
                if (typeof state === "object") {
                    var value0 = state[0],
                        value1 = state[1],
                        value2 = state[2];
                    if (typeof value0 !== "number") {
                        return null
                    }
                    if (typeof value1 !== "number") {
                        return null
                    }
                    if (typeof value2 !== "number") {
                        return null
                    }
                    return [value0, value1, value2]
                }
                return null
            }

            function parseFloat(state) {
                if (typeof state !== "number") {
                    return null
                }
                return [state]
            }

            function parseFloat2(state) {
                if (typeof state === "object") {
                    var value0 = state[0],
                        value1 = state[1];
                    if (typeof value0 !== "number") {
                        return null
                    }
                    if (typeof value1 !== "number") {
                        return null
                    }
                    return [value0, value1]
                }
                return null
            }

            function parseColorMask(state) {
                if (typeof state === "object") {
                    var value0 = state[0],
                        value1 = state[1],
                        value2 = state[2],
                        value3 = state[3];
                    if (typeof value0 !== "number") {
                        return null
                    }
                    if (typeof value1 !== "number") {
                        return null
                    }
                    if (typeof value2 !== "number") {
                        return null
                    }
                    if (typeof value3 !== "number") {
                        return null
                    }
                    return [value0, value1, value2, value3]
                }
                return null
            }
            var stateHandlers = {};
            var addStateHandler = function addStateHandlerFn(name, sf, rf, pf, dv) {
                stateHandlers[name] = {
                    set: sf,
                    reset: rf,
                    parse: pf,
                    defaultValues: dv
                }
            };
            addStateHandler("DepthTestEnable", setDepthTestEnable, resetDepthTestEnable, parseBoolean, [true]);
            addStateHandler("DepthFunc", setDepthFunc, resetDepthFunc, parseEnum, [defaultDepthFunc]);
            addStateHandler("DepthMask", setDepthMask, resetDepthMask, parseBoolean, [true]);
            addStateHandler("BlendEnable", setBlendEnable, resetBlendEnable, parseBoolean, [false]);
            addStateHandler("BlendFunc", setBlendFunc, resetBlendFunc, parseEnum2, [defaultBlendFuncSrc, defaultBlendFuncDst]);
            addStateHandler("CullFaceEnable", setCullFaceEnable, resetCullFaceEnable, parseBoolean, [true]);
            addStateHandler("CullFace", setCullFace, resetCullFace, parseEnum, [defaultCullFace]);
            addStateHandler("FrontFace", setFrontFace, resetFrontFace, parseEnum, [defaultFrontFace]);
            addStateHandler("ColorMask", setColorMask, resetColorMask, parseColorMask, [true, true, true, true]);
            addStateHandler("StencilTestEnable", setStencilTestEnable, resetStencilTestEnable, parseBoolean, [false]);
            addStateHandler("StencilFunc", setStencilFunc, resetStencilFunc, parseEnum3, [defaultStencilFunc, 0, 4294967295]);
            addStateHandler("StencilOp", setStencilOp, resetStencilOp, parseEnum3, [defaultStencilOp, defaultStencilOp, defaultStencilOp]);
            addStateHandler("PolygonOffsetFillEnable", setPolygonOffsetFillEnable, resetPolygonOffsetFillEnable, parseBoolean, [false]);
            addStateHandler("PolygonOffset", setPolygonOffset, resetPolygonOffset, parseFloat2, [0, 0]);
            if (!gd.fixIE) {
                addStateHandler("LineWidth", setLineWidth, resetLineWidth, parseFloat, [1])
            }
            gd.stateHandlers = stateHandlers;
            gd.syncState();
            gd.videoRam = 0;
            gd.desktopWidth = window.screen.width;
            gd.desktopHeight = window.screen.height;
            if (Object.defineProperty) {
                Object.defineProperty(gd, "fullscreen", {
                    get: function getFullscreenFn() {
                        return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement ? true : false
                    },
                    set: function setFullscreenFn(newFullscreen) {
                        gd.requestFullScreen(newFullscreen)
                    },
                    enumerable: true,
                    configurable: false
                });
                gd.checkFullScreen = function dummyCheckFullScreenFn() {}
            } else {
                gd.fullscreen = false;
                gd.oldFullscreen = false
            }
            gd.clientStateMask = 0;
            gd.attributeMask = 0;
            gd.activeTechnique = null;
            gd.activeIndexBuffer = null;
            gd.bindedVertexBuffer = null;
            gd.activeRenderTarget = null;
            gd.immediateVertexBuffer = gd.createVertexBuffer({
                numVertices: 256 * 1024 / 16,
                attributes: ["FLOAT4"],
                dynamic: true,
                "transient": true
            });
            gd.immediatePrimitive = -1;
            gd.immediateSemantics = WebGLSemantics.create(gd, []);
            gd.fps = 0;
            gd.numFrames = 0;
            gd.previousFrameTime = TurbulenzEngine.getTime();
            var video = document.createElement("video");
            var supportedVideoExtensions = {};
            if (video) {
                if (video.canPlayType("video/webm")) {
                    supportedVideoExtensions.webm = true
                }
                if (video.canPlayType("video/mp4")) {
                    supportedVideoExtensions.mp4 = true
                }
            }
            gd.supportedVideoExtensions = supportedVideoExtensions;
            video = null;
            return gd
        };
        WebGLGraphicsDevice.version = 1;
        return WebGLGraphicsDevice
    }();
    WebGLGraphicsDevice.prototype.SEMANTIC_POSITION = 0;
    WebGLGraphicsDevice.prototype.SEMANTIC_POSITION0 = 0;
    WebGLGraphicsDevice.prototype.SEMANTIC_BLENDWEIGHT = 1;
    WebGLGraphicsDevice.prototype.SEMANTIC_BLENDWEIGHT0 = 1;
    WebGLGraphicsDevice.prototype.SEMANTIC_NORMAL = 2;
    WebGLGraphicsDevice.prototype.SEMANTIC_NORMAL0 = 2;
    WebGLGraphicsDevice.prototype.SEMANTIC_COLOR = 3;
    WebGLGraphicsDevice.prototype.SEMANTIC_COLOR0 = 3;
    WebGLGraphicsDevice.prototype.SEMANTIC_COLOR1 = 4;
    WebGLGraphicsDevice.prototype.SEMANTIC_SPECULAR = 4;
    WebGLGraphicsDevice.prototype.SEMANTIC_FOGCOORD = 5;
    WebGLGraphicsDevice.prototype.SEMANTIC_TESSFACTOR = 5;
    WebGLGraphicsDevice.prototype.SEMANTIC_PSIZE0 = 6;
    WebGLGraphicsDevice.prototype.SEMANTIC_BLENDINDICES = 7;
    WebGLGraphicsDevice.prototype.SEMANTIC_BLENDINDICES0 = 7;
    WebGLGraphicsDevice.prototype.SEMANTIC_TEXCOORD = 8;
    WebGLGraphicsDevice.prototype.SEMANTIC_TEXCOORD0 = 8;
    WebGLGraphicsDevice.prototype.SEMANTIC_TEXCOORD1 = 9;
    WebGLGraphicsDevice.prototype.SEMANTIC_TEXCOORD2 = 10;
    WebGLGraphicsDevice.prototype.SEMANTIC_TEXCOORD3 = 11;
    WebGLGraphicsDevice.prototype.SEMANTIC_TEXCOORD4 = 12;
    WebGLGraphicsDevice.prototype.SEMANTIC_TEXCOORD5 = 13;
    WebGLGraphicsDevice.prototype.SEMANTIC_TEXCOORD6 = 14;
    WebGLGraphicsDevice.prototype.SEMANTIC_TEXCOORD7 = 15;
    WebGLGraphicsDevice.prototype.SEMANTIC_TANGENT = 14;
    WebGLGraphicsDevice.prototype.SEMANTIC_TANGENT0 = 14;
    WebGLGraphicsDevice.prototype.SEMANTIC_BINORMAL0 = 15;
    WebGLGraphicsDevice.prototype.SEMANTIC_BINORMAL = 15;
    WebGLGraphicsDevice.prototype.SEMANTIC_PSIZE = 6;
    WebGLGraphicsDevice.prototype.SEMANTIC_ATTR0 = 0;
    WebGLGraphicsDevice.prototype.SEMANTIC_ATTR1 = 1;
    WebGLGraphicsDevice.prototype.SEMANTIC_ATTR2 = 2;
    WebGLGraphicsDevice.prototype.SEMANTIC_ATTR3 = 3;
    WebGLGraphicsDevice.prototype.SEMANTIC_ATTR4 = 4;
    WebGLGraphicsDevice.prototype.SEMANTIC_ATTR5 = 5;
    WebGLGraphicsDevice.prototype.SEMANTIC_ATTR6 = 6;
    WebGLGraphicsDevice.prototype.SEMANTIC_ATTR7 = 7;
    WebGLGraphicsDevice.prototype.SEMANTIC_ATTR8 = 8;
    WebGLGraphicsDevice.prototype.SEMANTIC_ATTR9 = 9;
    WebGLGraphicsDevice.prototype.SEMANTIC_ATTR10 = 10;
    WebGLGraphicsDevice.prototype.SEMANTIC_ATTR11 = 11;
    WebGLGraphicsDevice.prototype.SEMANTIC_ATTR12 = 12;
    WebGLGraphicsDevice.prototype.SEMANTIC_ATTR13 = 13;
    WebGLGraphicsDevice.prototype.SEMANTIC_ATTR14 = 14;
    WebGLGraphicsDevice.prototype.SEMANTIC_ATTR15 = 15;
    WebGLGraphicsDevice.prototype.PIXELFORMAT_A8 = 0;
    WebGLGraphicsDevice.prototype.PIXELFORMAT_L8 = 1;
    WebGLGraphicsDevice.prototype.PIXELFORMAT_L8A8 = 2;
    WebGLGraphicsDevice.prototype.PIXELFORMAT_R5G5B5A1 = 3;
    WebGLGraphicsDevice.prototype.PIXELFORMAT_R5G6B5 = 4;
    WebGLGraphicsDevice.prototype.PIXELFORMAT_R4G4B4A4 = 5;
    WebGLGraphicsDevice.prototype.PIXELFORMAT_R8G8B8A8 = 6;
    WebGLGraphicsDevice.prototype.PIXELFORMAT_R8G8B8 = 7;
    WebGLGraphicsDevice.prototype.PIXELFORMAT_D24S8 = 8;
    WebGLGraphicsDevice.prototype.PIXELFORMAT_D16 = 9;
    WebGLGraphicsDevice.prototype.PIXELFORMAT_DXT1 = 10;
    WebGLGraphicsDevice.prototype.PIXELFORMAT_DXT3 = 11;
    WebGLGraphicsDevice.prototype.PIXELFORMAT_DXT5 = 12;
    WebGLGraphicsDevice.prototype.PIXELFORMAT_S8 = 13;
    WebGLGraphicsDevice.prototype.PIXELFORMAT_RGBA32F = 14;
    WebGLGraphicsDevice.prototype.PIXELFORMAT_RGB32F = 15;
    var WebGLInputDevice = function() {
        function WebGLInputDevice() {}
        WebGLInputDevice.prototype.update = function() {
            if (!this.isWindowFocused) {
                return
            }
            this.updateGamePad()
        };
        WebGLInputDevice.prototype.addEventListener = function(eventType, eventListener) {
            var i;
            var length;
            var eventHandlers;
            if (this.handlers.hasOwnProperty(eventType)) {
                eventHandlers = this.handlers[eventType];
                if (eventListener) {
                    length = eventHandlers.length;
                    for (i = 0; i < length; i += 1) {
                        if (eventHandlers[i] === eventListener) {
                            return
                        }
                    }
                    eventHandlers.push(eventListener)
                }
            }
        };
        WebGLInputDevice.prototype.removeEventListener = function(eventType, eventListener) {
            var i;
            var length;
            var eventHandlers;
            if (this.handlers.hasOwnProperty(eventType)) {
                eventHandlers = this.handlers[eventType];
                if (eventListener) {
                    length = eventHandlers.length;
                    for (i = 0; i < length; i += 1) {
                        if (eventHandlers[i] === eventListener) {
                            eventHandlers.splice(i, 1);
                            break
                        }
                    }
                }
            }
        };
        WebGLInputDevice.prototype.lockMouse = function() {
            if (this.isHovering && this.isWindowFocused) {
                this.isMouseLocked = true;
                this.hideMouse();
                this.requestBrowserLock();
                this.setEventHandlersLock();
                return true
            } else {
                return false
            }
        };
        WebGLInputDevice.prototype.unlockMouse = function() {
            if (this.isMouseLocked) {
                this.isMouseLocked = false;
                this.showMouse();
                this.requestBrowserUnlock();
                this.setEventHandlersUnlock();
                if (this.isOutsideEngine) {
                    this.isOutsideEngine = false;
                    this.isHovering = false;
                    this.setEventHandlersMouseLeave();
                    this.sendEventToHandlers(this.handlers.mouseleave)
                }
                this.sendEventToHandlers(this.handlers.mouselocklost);
                return true
            } else {
                return false
            }
        };
        WebGLInputDevice.prototype.isLocked = function() {
            return this.isMouseLocked
        };
        WebGLInputDevice.prototype.hideMouse = function() {
            if (this.isHovering) {
                if (!this.isCursorHidden) {
                    this.isCursorHidden = true;
                    this.previousCursor = document.body.style.cursor;
                    document.body.style.cursor = "none";
                    if (this.webkit) {
                        this.ignoreNextMouseMoves = 2
                    }
                }
                return true
            } else {
                return false
            }
        };
        WebGLInputDevice.prototype.showMouse = function() {
            if (this.isCursorHidden && !this.isMouseLocked) {
                this.isCursorHidden = false;
                document.body.style.cursor = this.previousCursor;
                return true
            } else {
                return false
            }
        };
        WebGLInputDevice.prototype.isHidden = function() {
            return this.isCursorHidden
        };
        WebGLInputDevice.prototype.isFocused = function() {
            return this.isWindowFocused
        };
        WebGLInputDevice.prototype.convertToUnicode = function(keyCodeArray) {
            var keyCodeToUnicode = this.keyCodeToUnicode;
            var result = {};
            var length = keyCodeArray.length;
            var i;
            var keyCode;
            for (i = 0; i < length; i += 1) {
                keyCode = keyCodeArray[i];
                result[keyCode] = keyCodeToUnicode[keyCode] || ""
            }
            return result
        };
        WebGLInputDevice.prototype.sendEventToHandlers = function(eventHandlers, arg0, arg1, arg2, arg3, arg4, arg5) {
            var i;
            var length = eventHandlers.length;
            if (length) {
                for (i = 0; i < length; i += 1) {
                    eventHandlers[i](arg0, arg1, arg2, arg3, arg4, arg5)
                }
            }
        };
        WebGLInputDevice.prototype.sendEventToHandlersASync = function(handlers, a0, a1, a2, a3, a4, a5) {
            var sendEvent = WebGLInputDevice.prototype.sendEventToHandlers;
            TurbulenzEngine.setTimeout(function callSendEventToHandlersFn() {
                sendEvent(handlers, a0, a1, a2, a3, a4, a5)
            }, 0)
        };
        WebGLInputDevice.prototype.updateGamePad = function() {
            var magnitude;
            var normalizedMagnitude;
            var gamepads = navigator.gamepads || navigator.webkitGamepads || navigator.getGamepads && navigator.getGamepads() || navigator.webkitGetGamepads && navigator.webkitGetGamepads();
            if (gamepads) {
                var deadZone = this.padAxisDeadZone;
                var maxAxisRange = this.maxAxisRange;
                var sendEvent = this.sendEventToHandlersASync;
                var handlers = this.handlers;
                var padButtons = this.padButtons;
                var padMap = this.padMap;
                var leftThumbX = 0;
                var leftThumbY = 0;
                var rightThumbX = 0;
                var rightThumbY = 0;
                var numGamePads = gamepads.length;
                for (var i = 0; i < numGamePads; i += 1) {
                    var gamepad = gamepads[i];
                    if (gamepad) {
                        var buttons = gamepad.buttons;
                        if (this.padTimestampUpdate < gamepad.timestamp) {
                            this.padTimestampUpdate = gamepad.timestamp;
                            var numButtons = buttons.length;
                            for (var n = 0; n < numButtons; n += 1) {
                                var value = buttons[n];
                                if (typeof value === "object") {
                                    value = value.value
                                }
                                if (padButtons[n] !== value) {
                                    padButtons[n] = value;
                                    var padCode = padMap[n];
                                    if (padCode !== undefined) {
                                        if (value) {
                                            sendEvent(handlers.paddown, padCode)
                                        } else {
                                            sendEvent(handlers.padup, padCode)
                                        }
                                    }
                                }
                            }
                        }
                        var axes = gamepad.axes;
                        if (axes.length <= 4) {
                            var lX = axes[0];
                            var lY = -axes[1];
                            magnitude = lX * lX + lY * lY;
                            if (magnitude > deadZone * deadZone) {
                                magnitude = Math.sqrt(magnitude);
                                lX = lX / magnitude;
                                lY = lY / magnitude;
                                if (magnitude > maxAxisRange) {
                                    magnitude = maxAxisRange
                                }
                                magnitude -= deadZone;
                                normalizedMagnitude = magnitude / (maxAxisRange - deadZone);
                                leftThumbX = lX * normalizedMagnitude;
                                leftThumbY = lY * normalizedMagnitude
                            }
                            var rX = axes[2];
                            var rY = -axes[3];
                            magnitude = rX * rX + rY * rY;
                            if (magnitude > deadZone * deadZone) {
                                magnitude = Math.sqrt(magnitude);
                                rX = rX / magnitude;
                                rY = rY / magnitude;
                                if (magnitude > maxAxisRange) {
                                    magnitude = maxAxisRange
                                }
                                magnitude -= deadZone;
                                normalizedMagnitude = magnitude / (maxAxisRange - deadZone);
                                rightThumbX = rX * normalizedMagnitude;
                                rightThumbY = rY * normalizedMagnitude
                            }
                            sendEvent(handlers.padmove, leftThumbX, leftThumbY, buttons[6], rightThumbX, rightThumbY, buttons[7])
                        }
                        break
                    }
                }
            }
        };
        WebGLInputDevice.prototype.getLocale = function() {
            return ""
        };
        WebGLInputDevice.prototype.getCanvasPosition = function(event, position) {
            if (event.offsetX !== undefined) {
                position.x = event.offsetX;
                position.y = event.offsetY
            } else if (event.layerX !== undefined) {
                position.x = event.layerX;
                position.y = event.layerY
            }
        };
        WebGLInputDevice.prototype.resetKeyStates = function() {
            var k;
            var pressedKeys = this.pressedKeys;
            var keyUpHandlers = this.handlers.keyup;
            for (k in pressedKeys) {
                if (pressedKeys.hasOwnProperty(k) && pressedKeys[k]) {
                    k = parseInt(k, 10);
                    pressedKeys[k] = false;
                    this.sendEventToHandlers(keyUpHandlers, k)
                }
            }
        };
        WebGLInputDevice.prototype.onMouseOver = function(event) {
            var position = {};
            var mouseOverHandlers = this.handlers.mouseover;
            event.stopPropagation();
            event.preventDefault();
            this.getCanvasPosition(event, position);
            this.lastX = event.screenX;
            this.lastY = event.screenY;
            this.sendEventToHandlers(mouseOverHandlers, position.x, position.y)
        };
        WebGLInputDevice.prototype.onMouseMove = function(event) {
            var mouseMoveHandlers = this.handlers.mousemove;
            var deltaX, deltaY;
            event.stopPropagation();
            event.preventDefault();
            if (this.ignoreNextMouseMoves) {
                this.ignoreNextMouseMoves -= 1;
                return
            }
            if (event.movementX !== undefined) {
                deltaX = event.movementX;
                deltaY = event.movementY
            } else if (event.mozMovementX !== undefined) {
                deltaX = event.mozMovementX;
                deltaY = event.mozMovementY
            } else if (event.webkitMovementX !== undefined) {
                deltaX = event.webkitMovementX;
                deltaY = event.webkitMovementY
            } else {
                deltaX = event.screenX - this.lastX;
                deltaY = event.screenY - this.lastY;
                if (0 === deltaX && 0 === deltaY) {
                    return
                }
            }
            this.lastX = event.screenX;
            this.lastY = event.screenY;
            this.sendEventToHandlers(mouseMoveHandlers, deltaX, deltaY)
        };
        WebGLInputDevice.prototype.onWheel = function(event) {
            var mouseWheelHandlers = this.handlers.mousewheel;
            var scrollDelta;
            event.stopPropagation();
            event.preventDefault();
            if (event.wheelDelta) {
                if (window.opera) {
                    scrollDelta = event.wheelDelta < 0 ? 1 : -1
                } else {
                    scrollDelta = event.wheelDelta > 0 ? 1 : -1
                }
            } else {
                scrollDelta = event.detail < 0 ? 1 : -1
            }
            this.sendEventToHandlers(mouseWheelHandlers, scrollDelta)
        };
        WebGLInputDevice.prototype.emptyEvent = function(event) {
            event.stopPropagation();
            event.preventDefault()
        };
        WebGLInputDevice.prototype.onWindowFocus = function() {
            if (this.isHovering && window.document.activeElement === this.canvas) {
                this.addInternalEventListener(window, "mousedown", this.onMouseDown)
            }
        };
        WebGLInputDevice.prototype.onFocus = function() {
            var canvas = this.canvas;
            var handlers = this.handlers;
            var focusHandlers = handlers.focus;
            if (!this.isWindowFocused) {
                this.isWindowFocused = true;
                window.focus();
                canvas.focus();
                this.setEventHandlersFocus();
                canvas.oncontextmenu = function() {
                    return false
                };
                this.sendEventToHandlers(focusHandlers)
            }
        };
        WebGLInputDevice.prototype.onBlur = function() {
            if (this.ignoreNextBlur) {
                this.ignoreNextBlur = false;
                return
            }
            var canvas = this.canvas;
            var handlers = this.handlers;
            var blurHandlers = handlers.blur;
            if (this.isMouseLocked) {
                this.unlockMouse()
            }
            if (this.isWindowFocused) {
                this.isWindowFocused = false;
                this.resetKeyStates();
                this.setEventHandlersBlur();
                canvas.oncontextmenu = null;
                this.sendEventToHandlers(blurHandlers)
            }
        };
        WebGLInputDevice.prototype.onMouseDown = function(event) {
            var handlers = this.handlers;
            if (this.isHovering) {
                var mouseDownHandlers = handlers.mousedown;
                var button = event.button;
                var position = {};
                this.onFocus();
                event.stopPropagation();
                event.preventDefault();
                if (button < 3) {
                    button = this.mouseMap[button]
                }
                this.getCanvasPosition(event, position);
                this.sendEventToHandlers(mouseDownHandlers, button, position.x, position.y)
            } else {
                this.onBlur()
            }
        };
        WebGLInputDevice.prototype.onMouseUp = function(event) {
            var mouseUpHandlers = this.handlers.mouseup;
            if (this.isHovering) {
                var button = event.button;
                var position = {};
                event.stopPropagation();
                event.preventDefault();
                if (button < 3) {
                    button = this.mouseMap[button]
                }
                this.getCanvasPosition(event, position);
                this.sendEventToHandlers(mouseUpHandlers, button, position.x, position.y)
            }
        };
        WebGLInputDevice.prototype.onKeyDown = function(event) {
            var keyDownHandlers = this.handlers.keydown;
            var pressedKeys = this.pressedKeys;
            var keyCodes = this.keyCodes;
            var keyCode = event.keyCode;
            keyCode = this.keyMap[keyCode];
            if (undefined === keyCode) {
                return
            }
            event.stopPropagation();
            event.preventDefault();
            if (keyCodes.ESCAPE !== keyCode) {
                var keyLocation = typeof event.location === "number" ? event.location : event.keyLocation;
                if (2 === keyLocation) {
                    keyCode = keyCode + 1
                }
                if (!pressedKeys[keyCode]) {
                    pressedKeys[keyCode] = true;
                    this.sendEventToHandlers(keyDownHandlers, keyCode)
                }
            }
        };
        WebGLInputDevice.prototype.onKeyUp = function(event) {
            var keyUpHandlers = this.handlers.keyup;
            var pressedKeys = this.pressedKeys;
            var keyCodes = this.keyCodes;
            var keyCode = event.keyCode;
            keyCode = this.keyMap[keyCode];
            if (undefined === keyCode) {
                return
            }
            event.stopPropagation();
            event.preventDefault();
            if (keyCode === keyCodes.ESCAPE) {
                this.unlockMouse();
                if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) {
                    if (document.webkitCancelFullScreen) {
                        document.webkitCancelFullScreen()
                    } else if (document.cancelFullScreen) {
                        document.cancelFullScreen()
                    } else if (document["mozCancelFullScreen"]) {
                        document["mozCancelFullScreen"]()
                    } else if (document.msExitFullscreen) {
                        document.msExitFullscreen()
                    } else if (document.exitFullscreen) {
                        document.exitFullscreen()
                    }
                }
            } else {
                var keyLocation = typeof event.location === "number" ? event.location : event.keyLocation;
                if (2 === keyLocation) {
                    keyCode = keyCode + 1
                }
                if (pressedKeys[keyCode]) {
                    pressedKeys[keyCode] = false;
                    this.sendEventToHandlers(keyUpHandlers, keyCode);
                    if ((627 === keyCode || 628 === keyCode) && this.macosx) {
                        this.resetKeyStates()
                    }
                }
            }
        };
        WebGLInputDevice.prototype.onPointerDown = function(event) {
            if (event.preventManipulation) {
                event.preventManipulation()
            }
            if (event.preventDefault) {
                event.preventDefault()
            }
            var touch = this.convertPointerToTurbulenzTouch(event);
            var e = this.createTurbulenzTouchEvent(touch);
            var eventHandlers = this.handlers.touchstart;
            this.sendEventToHandlers(eventHandlers, e)
        };
        WebGLInputDevice.prototype.onPointerMove = function(event) {
            if (event.preventManipulation) {
                event.preventManipulation()
            }
            if (event.preventDefault) {
                event.preventDefault()
            }
            var touch = this.convertPointerToTurbulenzTouch(event);
            var e = this.createTurbulenzTouchEvent(touch);
            var eventHandlers = this.handlers.touchmove;
            this.sendEventToHandlers(eventHandlers, e)
        };
        WebGLInputDevice.prototype.onPointerUp = function(event) {
            if (event.preventManipulation) {
                event.preventManipulation()
            }
            if (event.preventDefault) {
                event.preventDefault()
            }
            var touch = this.convertPointerToTurbulenzTouch(event);
            var e = this.createTurbulenzTouchEvent(touch);
            var eventHandlers = this.handlers.touchend;
            this.sendEventToHandlers(eventHandlers, e);
            this.removePointerById(event.pointerId, touch.identifier)
        };
        WebGLInputDevice.prototype.onPointerCancel = function(event) {
            if (event.preventManipulation) {
                event.preventManipulation()
            }
            if (event.preventDefault) {
                event.preventDefault()
            }
            var touch = this.convertPointerToTurbulenzTouch(event);
            var e = this.createTurbulenzTouchEvent(touch);
            var eventHandlers = this.handlers.touchend;
            this.sendEventToHandlers(eventHandlers, e);
            this.removePointerById(event.pointerId, touch.identifier)
        };
        WebGLInputDevice.prototype.onTouchStart = function(event) {
            var eventHandlers = this.handlers.touchstart;
            event.preventDefault();
            this.addTouches(event.changedTouches);
            event = this.convertW3TouchEventToTurbulenzTouchEvent(event);
            this.sendEventToHandlers(eventHandlers, event)
        };
        WebGLInputDevice.prototype.onTouchEnd = function(event) {
            var eventHandlers = this.handlers.touchend;
            event.preventDefault();
            event = this.convertW3TouchEventToTurbulenzTouchEvent(event);
            this.removeTouches(event.changedTouches);
            this.sendEventToHandlers(eventHandlers, event)
        };
        WebGLInputDevice.prototype.onTouchMove = function(event) {
            var eventHandlers = this.handlers.touchmove;
            event.preventDefault();
            this.addTouches(event.changedTouches);
            event = this.convertW3TouchEventToTurbulenzTouchEvent(event);
            this.sendEventToHandlers(eventHandlers, event)
        };
        WebGLInputDevice.prototype.onTouchEnter = function(event) {
            var eventHandlers = this.handlers.touchenter;
            event.preventDefault();
            event = this.convertW3TouchEventToTurbulenzTouchEvent(event);
            this.sendEventToHandlers(eventHandlers, event)
        };
        WebGLInputDevice.prototype.onTouchLeave = function(event) {
            var eventHandlers = this.handlers.touchleave;
            event.preventDefault();
            event = this.convertW3TouchEventToTurbulenzTouchEvent(event);
            this.sendEventToHandlers(eventHandlers, event)
        };
        WebGLInputDevice.prototype.onTouchCancel = function(event) {
            var eventHandlers = this.handlers.touchcancel;
            event.preventDefault();
            event = this.convertW3TouchEventToTurbulenzTouchEvent(event);
            this.removeTouches(event.changedTouches);
            this.sendEventToHandlers(eventHandlers, event)
        };
        WebGLInputDevice.prototype.convertPointerToTurbulenzTouch = function(event) {
            var pointerId = event.pointerId;
            var pointerIdToTouch = this.pointerIdToTouch;
            var canvasElement = this.canvas;
            var canvasRect = canvasElement.getBoundingClientRect();
            var isGameTouch = event.target === canvasElement;
            var positionX = event.pageX - canvasRect.left;
            var positionY = event.pageY - canvasRect.top;
            var touch = pointerIdToTouch[pointerId];
            if (touch) {
                touch.isGameTouch = isGameTouch;
                touch.positionX = positionX;
                touch.positionY = positionY
            } else {
                var touches = this.touches;
                var touchId = 0;
                while (touchId < 32) {
                    if (!touches.hasOwnProperty(touchId)) {
                        touch = {
                            force: 0,
                            identifier: touchId,
                            isGameTouch: isGameTouch,
                            positionX: positionX,
                            positionY: positionY,
                            radiusX: 1,
                            radiusY: 1,
                            rotationAngle: 0
                        };
                        this.touches[touchId] = touch;
                        this.pointerIdToTouch[pointerId] = touch;
                        return touch
                    }
                    touchId += 1
                }
            }
            return touch
        };
        WebGLInputDevice.prototype.createTurbulenzTouchEvent = function(changedTouch) {
            var touches = [];
            var gameTouches = [];
            var pointerIdToTouch = this.touches;
            var pointerId;
            var touch;
            for (pointerId in pointerIdToTouch) {
                if (pointerIdToTouch.hasOwnProperty(pointerId)) {
                    touch = pointerIdToTouch[pointerId];
                    touches.push(touch);
                    if (touch.isGameTouch) {
                        gameTouches.push(touch)
                    }
                }
            }
            return {
                changedTouches: [changedTouch],
                gameTouches: gameTouches,
                touches: touches
            }
        };
        WebGLInputDevice.prototype.removePointerById = function(eventId, touchId) {
            delete this.pointerIdToTouch[eventId];
            this.removeTouchById(touchId)
        };
        WebGLInputDevice.prototype.convertW3TouchEventToTurbulenzTouchEvent = function(w3TouchEvent) {
            var changedTouches = this.convertW3TouchListToTurbulenzTouchList(w3TouchEvent.changedTouches);
            var gameTouches = this.convertW3TouchListToTurbulenzTouchList(w3TouchEvent.targetTouches);
            var touches = this.convertW3TouchListToTurbulenzTouchList(w3TouchEvent.touches);
            var touchEventParams = {
                changedTouches: changedTouches,
                gameTouches: gameTouches,
                touches: touches
            };
            return WebGLTouchEvent.create(touchEventParams)
        };
        WebGLInputDevice.prototype.convertW3TouchListToTurbulenzTouchList = function(w3TouchList) {
            var w3TouchListLength = w3TouchList.length;
            var touchList = [];
            var touch;
            var touchIndex;
            touchList.length = w3TouchListLength;
            for (touchIndex = 0; touchIndex < w3TouchListLength; touchIndex += 1) {
                touch = this.getTouchById(w3TouchList[touchIndex].identifier);
                touchList[touchIndex] = touch
            }
            return touchList
        };
        WebGLInputDevice.prototype.convertW3TouchToTurbulenzTouch = function(w3Touch) {
            var canvasElement = this.canvas;
            var canvasRect = canvasElement.getBoundingClientRect();
            var touchParams = {
                force: w3Touch.force || w3Touch.webkitForce || 0,
                identifier: w3Touch.identifier,
                isGameTouch: w3Touch.target === canvasElement,
                positionX: w3Touch.pageX - canvasRect.left,
                positionY: w3Touch.pageY - canvasRect.top,
                radiusX: w3Touch.radiusX || w3Touch.webkitRadiusX || 1,
                radiusY: w3Touch.radiusY || w3Touch.webkitRadiusY || 1,
                rotationAngle: w3Touch.rotationAngle || w3Touch.webkitRotationAngle || 0
            };
            return Touch.create(touchParams)
        };
        WebGLInputDevice.prototype.addTouches = function(w3TouchList) {
            var w3TouchListLength = w3TouchList.length;
            var touchIndex;
            var touch;
            for (touchIndex = 0; touchIndex < w3TouchListLength; touchIndex += 1) {
                touch = this.convertW3TouchToTurbulenzTouch(w3TouchList[touchIndex]);
                this.addTouch(touch)
            }
        };
        WebGLInputDevice.prototype.removeTouches = function(w3TouchList) {
            var w3TouchListLength = w3TouchList.length;
            var touchIndex;
            var touchId;
            for (touchIndex = 0; touchIndex < w3TouchListLength; touchIndex += 1) {
                touchId = w3TouchList[touchIndex].identifier;
                this.removeTouchById(touchId)
            }
        };
        WebGLInputDevice.prototype.addTouch = function(touch) {
            this.touches[touch.identifier] = touch
        };
        WebGLInputDevice.prototype.getTouchById = function(id) {
            return this.touches[id]
        };
        WebGLInputDevice.prototype.removeTouchById = function(id) {
            delete this.touches[id]
        };
        WebGLInputDevice.prototype.canvasOnMouseOver = function(event) {
            var mouseEnterHandlers = this.handlers.mouseenter;
            if (!this.isMouseLocked) {
                this.isHovering = true;
                this.lastX = event.screenX;
                this.lastY = event.screenY;
                this.setEventHandlersMouseEnter();
                this.sendEventToHandlers(mouseEnterHandlers)
            } else {
                this.isOutsideEngine = false
            }
        };
        WebGLInputDevice.prototype.canvasOnMouseOut = function() {
            var mouseLeaveHandlers = this.handlers.mouseleave;
            if (!this.isMouseLocked) {
                this.isHovering = false;
                if (this.isCursorHidden) {
                    this.showMouse()
                }
                this.setEventHandlersMouseLeave();
                this.sendEventToHandlers(mouseLeaveHandlers)
            } else {
                this.isOutsideEngine = true
            }
        };
        WebGLInputDevice.prototype.canvasOnMouseDown = function(event) {
            var mouseEnterHandlers = this.handlers.mouseenter;
            this.canvas.onmousedown = null;
            if (!this.isHovering) {
                this.isHovering = true;
                this.lastX = event.screenX;
                this.lastY = event.screenY;
                this.setEventHandlersMouseEnter();
                this.sendEventToHandlers(mouseEnterHandlers);
                this.onMouseDown(event)
            }
            return false
        };
        WebGLInputDevice.prototype.onFullscreenChanged = function() {
            if (this.isMouseLocked) {
                if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) {
                    this.ignoreNextMouseMoves = 2;
                    this.requestBrowserLock()
                } else {
                    this.unlockMouse()
                }
            }
        };
        WebGLInputDevice.prototype.setEventHandlersMouseEnter = function() {
            if (!this.isFocused()) {
                this.addInternalEventListener(window, "mousedown", this.onMouseDown)
            }
            this.addInternalEventListener(window, "mouseup", this.onMouseUp);
            this.addInternalEventListener(window, "mousemove", this.onMouseOver);
            this.addInternalEventListener(window, "DOMMouseScroll", this.onWheel);
            this.addInternalEventListener(window, "mousewheel", this.onWheel);
            this.addInternalEventListener(window, "click", this.emptyEvent)
        };
        WebGLInputDevice.prototype.setEventHandlersMouseLeave = function() {
            if (!this.isFocused()) {
                this.removeInternalEventListener(window, "mousedown", this.onMouseDown)
            }
            this.removeInternalEventListener(window, "mouseup", this.onMouseUp);
            this.removeInternalEventListener(window, "mousemove", this.onMouseOver);
            this.removeInternalEventListener(window, "DOMMouseScroll", this.onWheel);
            this.removeInternalEventListener(window, "mousewheel", this.onWheel);
            this.removeInternalEventListener(window, "click", this.emptyEvent)
        };
        WebGLInputDevice.prototype.setEventHandlersFocus = function() {
            this.addInternalEventListener(window, "keydown", this.onKeyDown);
            this.addInternalEventListener(window, "keyup", this.onKeyUp)
        };
        WebGLInputDevice.prototype.setEventHandlersBlur = function() {
            this.removeInternalEventListener(window, "keydown", this.onKeyDown);
            this.removeInternalEventListener(window, "keyup", this.onKeyUp);
            this.removeInternalEventListener(window, "mousedown", this.onMouseDown)
        };
        WebGLInputDevice.prototype.setEventHandlersLock = function() {
            this.removeInternalEventListener(window, "mousemove", this.onMouseOver);
            this.addInternalEventListener(window, "mousemove", this.onMouseMove);
            this.addInternalEventListener(document, "fullscreenchange", this.onFullscreenChanged);
            this.addInternalEventListener(document, "mozfullscreenchange", this.onFullscreenChanged);
            this.addInternalEventListener(document, "webkitfullscreenchange", this.onFullscreenChanged);
            this.addInternalEventListener(document, "MSFullscreenChange", this.onFullscreenChanged)
        };
        WebGLInputDevice.prototype.setEventHandlersUnlock = function() {
            this.removeInternalEventListener(document, "webkitfullscreenchange", this.onFullscreenChanged);
            this.removeInternalEventListener(document, "mozfullscreenchange", this.onFullscreenChanged);
            this.removeInternalEventListener(document, "MSFullscreenChange", this.onFullscreenChanged);
            this.removeInternalEventListener(window, "mousemove", this.onMouseMove);
            this.addInternalEventListener(window, "mousemove", this.onMouseOver)
        };
        WebGLInputDevice.prototype.setEventHandlersCanvas = function() {
            var canvas = this.canvas;
            this.addInternalEventListener(canvas, "mouseover", this.canvasOnMouseOver);
            this.addInternalEventListener(canvas, "mouseout", this.canvasOnMouseOut);
            this.addInternalEventListener(canvas, "mousedown", this.canvasOnMouseDown)
        };
        WebGLInputDevice.prototype.setEventHandlersWindow = function() {
            this.addInternalEventListener(window, "blur", this.onBlur);
            this.addInternalEventListener(window, "focus", this.onWindowFocus)
        };
        WebGLInputDevice.prototype.removeEventHandlersWindow = function() {
            this.removeInternalEventListener(window, "blur", this.onBlur);
            this.removeInternalEventListener(window, "focus", this.onWindowFocus)
        };
        WebGLInputDevice.prototype.setEventHandlersTouch = function() {
            var canvas = this.canvas;
            this.addInternalEventListener(canvas, "pointerdown", this.onPointerDown);
            this.addInternalEventListener(canvas, "pointermove", this.onPointerMove);
            this.addInternalEventListener(canvas, "pointerup", this.onPointerUp);
            this.addInternalEventListener(canvas, "pointerout", this.onPointerUp);
            this.addInternalEventListener(canvas, "touchstart", this.onTouchStart);
            this.addInternalEventListener(canvas, "touchend", this.onTouchEnd);
            this.addInternalEventListener(canvas, "touchenter", this.onTouchEnter);
            this.addInternalEventListener(canvas, "touchleave", this.onTouchLeave);
            this.addInternalEventListener(canvas, "touchmove", this.onTouchMove);
            this.addInternalEventListener(canvas, "touchcancel", this.onTouchCancel)
        };
        WebGLInputDevice.prototype.addInternalEventListener = function(element, eventName, eventHandler) {
            var elementEventFlag = this.elementEventFlags[element];
            if (!elementEventFlag) {
                this.elementEventFlags[element] = elementEventFlag = {}
            }
            if (!elementEventFlag[eventName]) {
                elementEventFlag[eventName] = true;
                var boundEventHandler = this.boundFunctions[eventHandler];
                if (!boundEventHandler) {
                    this.boundFunctions[eventHandler] = boundEventHandler = eventHandler.bind(this)
                }
                element.addEventListener(eventName, boundEventHandler, false)
            }
        };
        WebGLInputDevice.prototype.removeInternalEventListener = function(element, eventName, eventHandler) {
            var elementEventFlag = this.elementEventFlags[element];
            if (elementEventFlag) {
                if (elementEventFlag[eventName]) {
                    elementEventFlag[eventName] = false;
                    var boundEventHandler = this.boundFunctions[eventHandler];
                    element.removeEventListener(eventName, boundEventHandler, false)
                }
            }
        };
        WebGLInputDevice.prototype.destroy = function() {
            if (this.isLocked()) {
                this.setEventHandlersUnlock()
            }
            if (this.isHovering) {
                this.setEventHandlersMouseLeave()
            }
            if (this.isWindowFocused) {
                this.setEventHandlersBlur()
            }
            this.removeEventHandlersWindow();
            var canvas = this.canvas;
            canvas.onmouseover = null;
            canvas.onmouseout = null;
            canvas.onmousedown = null
        };
        WebGLInputDevice.prototype.isSupported = function(name) {
            var canvas = this.canvas;
            if (canvas && name === "POINTER_LOCK") {
                var havePointerLock = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document;
                var requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock || canvas.webkitRequestPointerLock;
                if (havePointerLock && requestPointerLock) {
                    return true
                }
            }
            return false
        };
        WebGLInputDevice.create = function(canvas) {
            var id = new WebGLInputDevice;
            id.lastX = 0;
            id.lastY = 0;
            id.touches = {};
            id.boundFunctions = {};
            id.elementEventFlags = {};
            id.canvas = canvas;
            id.isMouseLocked = false;
            id.isHovering = false;
            id.isWindowFocused = false;
            id.isCursorHidden = false;
            id.isOutsideEngine = false;
            id.previousCursor = "";
            id.ignoreNextMouseMoves = 0;
            id.ignoreNextBlur = false;
            id.pressedKeys = {};
            id.handlers = {
                keydown: [],
                keyup: [],
                mousedown: [],
                mouseup: [],
                mousewheel: [],
                mouseover: [],
                mousemove: [],
                paddown: [],
                padup: [],
                padmove: [],
                mouseenter: [],
                mouseleave: [],
                focus: [],
                blur: [],
                mouselocklost: [],
                touchstart: [],
                touchend: [],
                touchenter: [],
                touchleave: [],
                touchmove: [],
                touchcancel: []
            };
            var keyCodeToUnicodeTable = {};
            var keyCodes = id.keyCodes;
            for (var k in keyCodes) {
                if (keyCodes.hasOwnProperty(k)) {
                    var code = keyCodes[k];
                    keyCodeToUnicodeTable[code] = k
                }
            }
            keyCodeToUnicodeTable[keyCodes.SPACE] = " ";
            keyCodeToUnicodeTable[keyCodes.NUMBER_0] = "0";
            keyCodeToUnicodeTable[keyCodes.NUMBER_1] = "1";
            keyCodeToUnicodeTable[keyCodes.NUMBER_2] = "2";
            keyCodeToUnicodeTable[keyCodes.NUMBER_3] = "3";
            keyCodeToUnicodeTable[keyCodes.NUMBER_4] = "4";
            keyCodeToUnicodeTable[keyCodes.NUMBER_5] = "5";
            keyCodeToUnicodeTable[keyCodes.NUMBER_6] = "6";
            keyCodeToUnicodeTable[keyCodes.NUMBER_7] = "7";
            keyCodeToUnicodeTable[keyCodes.NUMBER_8] = "8";
            keyCodeToUnicodeTable[keyCodes.NUMBER_9] = "9";
            keyCodeToUnicodeTable[keyCodes.GRAVE] = "`";
            keyCodeToUnicodeTable[keyCodes.MINUS] = "-";
            keyCodeToUnicodeTable[keyCodes.EQUALS] = "=";
            keyCodeToUnicodeTable[keyCodes.LEFT_BRACKET] = "[";
            keyCodeToUnicodeTable[keyCodes.RIGHT_BRACKET] = "]";
            keyCodeToUnicodeTable[keyCodes.SEMI_COLON] = ";";
            keyCodeToUnicodeTable[keyCodes.APOSTROPHE] = "'";
            keyCodeToUnicodeTable[keyCodes.COMMA] = ",";
            keyCodeToUnicodeTable[keyCodes.PERIOD] = ".";
            keyCodeToUnicodeTable[keyCodes.SLASH] = "/";
            keyCodeToUnicodeTable[keyCodes.BACKSLASH] = "\\";
            var keyMap = {};
            keyMap[65] = 0;
            keyMap[66] = 1;
            keyMap[67] = 2;
            keyMap[68] = 3;
            keyMap[69] = 4;
            keyMap[70] = 5;
            keyMap[71] = 6;
            keyMap[72] = 7;
            keyMap[73] = 8;
            keyMap[74] = 9;
            keyMap[75] = 10;
            keyMap[76] = 11;
            keyMap[77] = 12;
            keyMap[78] = 13;
            keyMap[79] = 14;
            keyMap[80] = 15;
            keyMap[81] = 16;
            keyMap[82] = 17;
            keyMap[83] = 18;
            keyMap[84] = 19;
            keyMap[85] = 20;
            keyMap[86] = 21;
            keyMap[87] = 22;
            keyMap[88] = 23;
            keyMap[89] = 24;
            keyMap[90] = 25;
            keyMap[48] = 100;
            keyMap[49] = 101;
            keyMap[50] = 102;
            keyMap[51] = 103;
            keyMap[52] = 104;
            keyMap[53] = 105;
            keyMap[54] = 106;
            keyMap[55] = 107;
            keyMap[56] = 108;
            keyMap[57] = 109;
            keyMap[37] = 200;
            keyMap[39] = 201;
            keyMap[38] = 202;
            keyMap[40] = 203;
            keyMap[16] = 300;
            keyMap[17] = 302;
            keyMap[18] = 304;
            keyMap[0] = 305;
            keyMap[27] = 400;
            keyMap[9] = 401;
            keyMap[32] = 402;
            keyMap[8] = 403;
            keyMap[13] = 404;
            keyMap[223] = 500;
            keyMap[173] = 501;
            keyMap[189] = 501;
            keyMap[61] = 502;
            keyMap[187] = 502;
            keyMap[219] = 503;
            keyMap[221] = 504;
            keyMap[59] = 505;
            keyMap[186] = 505;
            keyMap[192] = 500;
            keyMap[188] = 507;
            keyMap[190] = 508;
            keyMap[222] = 506;
            if (navigator.appVersion.indexOf("Mac") !== -1) {
                keyMap[0] = 500
            }
            keyMap[112] = 600;
            keyMap[113] = 601;
            keyMap[114] = 602;
            keyMap[115] = 603;
            keyMap[116] = 604;
            keyMap[117] = 605;
            keyMap[118] = 606;
            keyMap[119] = 607;
            keyMap[120] = 608;
            keyMap[121] = 609;
            keyMap[122] = 610;
            keyMap[123] = 611;
            keyMap[96] = 612;
            keyMap[97] = 613;
            keyMap[98] = 614;
            keyMap[99] = 615;
            keyMap[100] = 616;
            keyMap[12] = 617;
            keyMap[101] = 617;
            keyMap[144] = 617;
            keyMap[102] = 618;
            keyMap[103] = 619;
            keyMap[104] = 620;
            keyMap[105] = 621;
            keyMap[111] = 623;
            keyMap[191] = 623;
            keyMap[106] = 624;
            keyMap[107] = 625;
            keyMap[109] = 626;
            keyMap[91] = 627;
            keyMap[224] = 627;
            keyMap[92] = 628;
            keyMap[93] = 628;
            keyMap[20] = 631;
            keyMap[45] = 632;
            keyMap[46] = 633;
            keyMap[36] = 634;
            keyMap[35] = 635;
            keyMap[33] = 636;
            keyMap[34] = 637;
            id.keyMap = keyMap;
            var mouseMap = {
                0: 0,
                1: 2,
                2: 1
            };
            id.mouseMap = mouseMap;
            var padMap = {
                0: 4,
                1: 5,
                2: 6,
                3: 7,
                4: 10,
                5: 11,
                8: 19,
                9: 18,
                10: 12,
                11: 15,
                12: 0,
                13: 2,
                14: 1,
                15: 3
            };
            id.padMap = padMap;
            id.keyCodeToUnicode = keyCodeToUnicodeTable;
            id.padButtons = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
            id.padMap = padMap;
            id.padAxisDeadZone = .26;
            id.maxAxisRange = 1;
            id.padTimestampUpdate = 0;
            var requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock || canvas.webkitRequestPointerLock;
            if (requestPointerLock) {
                var exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock;
                id.onPointerLockChanged = function onPointerLockChangedFn() {
                    var pointerLockElement = document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement;
                    if (pointerLockElement !== id.canvas) {
                        id.unlockMouse()
                    }
                };
                id.onPointerLockError = function onPointerLockErrorFn() {
                    id.unlockMouse()
                };
                if ("mozPointerLockElement" in document) {
                    id.setEventHandlersPointerLock = function setEventHandlersPointerLockFn() {
                        this.ignoreNextBlur = true;
                        document.addEventListener("mozpointerlockchange", this.onPointerLockChanged, false);
                        document.addEventListener("mozpointerlockerror", this.onPointerLockError, false)
                    };
                    id.setEventHandlersPointerUnlock = function setEventHandlersPointerUnlockFn() {
                        this.ignoreNextBlur = false;
                        document.removeEventListener("mozpointerlockchange", this.onPointerLockChanged, false);
                        document.removeEventListener("mozpointerlockerror", this.onPointerLockError, false)
                    }
                } else if ("webkitPointerLockElement" in document) {
                    id.setEventHandlersPointerLock = function setEventHandlersPointerLockFn() {
                        document.addEventListener("webkitpointerlockchange", this.onPointerLockChanged, false);
                        document.addEventListener("webkitpointerlockerror", this.onPointerLockError, false)
                    };
                    id.setEventHandlersPointerUnlock = function setEventHandlersPointerUnlockFn() {
                        document.removeEventListener("webkitpointerlockchange", this.onPointerLockChanged, false);
                        document.removeEventListener("webkitpointerlockerror", this.onPointerLockError, false)
                    }
                } else if ("pointerLockElement" in document) {
                    id.setEventHandlersPointerLock = function setEventHandlersPointerLockFn() {
                        document.addEventListener("pointerlockchange", this.onPointerLockChanged, false);
                        document.addEventListener("pointerlockerror", this.onPointerLockError, false)
                    };
                    id.setEventHandlersPointerUnlock = function setEventHandlersPointerUnlockFn() {
                        document.removeEventListener("pointerlockchange", this.onPointerLockChanged, false);
                        document.removeEventListener("pointerlockerror", this.onPointerLockError, false)
                    }
                }
                id.requestBrowserLock = function requestBrowserLockFn() {
                    var pointerLockElement = document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement;
                    if (pointerLockElement !== canvas) {
                        this.setEventHandlersPointerLock();
                        requestPointerLock.call(canvas)
                    }
                };
                id.requestBrowserUnlock = function requestBrowserUnlockFn() {
                    this.setEventHandlersPointerUnlock();
                    var pointerLockElement = document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement;
                    if (pointerLockElement === canvas) {
                        exitPointerLock.call(document)
                    }
                }
            } else {
                var pointer = navigator.pointer || navigator.webkitPointer;
                if (pointer) {
                    id.requestBrowserLock = function requestBrowserLockFn() {
                        if (!pointer.isLocked) {
                            pointer.lock(canvas)
                        }
                    };
                    id.requestBrowserUnlock = function requestBrowserUnlockFn() {
                        if (pointer.isLocked) {
                            pointer.unlock()
                        }
                    }
                } else {
                    id.requestBrowserLock = function requestBrowserLockFn() {};
                    id.requestBrowserUnlock = function requestBrowserUnlockFn() {}
                }
            }
            id.setEventHandlersCanvas();
            id.setEventHandlersWindow();
            id.setEventHandlersTouch();
            var sysInfo = TurbulenzEngine.getSystemInfo();
            id.macosx = "Darwin" === sysInfo.osName;
            id.webkit = /WebKit/.test(navigator.userAgent);
            id.pointerIdToTouch = {};
            return id
        };
        WebGLInputDevice.version = 1;
        return WebGLInputDevice
    }();
    WebGLInputDevice.prototype.keyCodes = {
        A: 0,
        B: 1,
        C: 2,
        D: 3,
        E: 4,
        F: 5,
        G: 6,
        H: 7,
        I: 8,
        J: 9,
        K: 10,
        L: 11,
        M: 12,
        N: 13,
        O: 14,
        P: 15,
        Q: 16,
        R: 17,
        S: 18,
        T: 19,
        U: 20,
        V: 21,
        W: 22,
        X: 23,
        Y: 24,
        Z: 25,
        NUMBER_0: 100,
        NUMBER_1: 101,
        NUMBER_2: 102,
        NUMBER_3: 103,
        NUMBER_4: 104,
        NUMBER_5: 105,
        NUMBER_6: 106,
        NUMBER_7: 107,
        NUMBER_8: 108,
        NUMBER_9: 109,
        LEFT: 200,
        RIGHT: 201,
        UP: 202,
        DOWN: 203,
        LEFT_SHIFT: 300,
        RIGHT_SHIFT: 301,
        LEFT_CONTROL: 302,
        RIGHT_CONTROL: 303,
        LEFT_ALT: 304,
        RIGHT_ALT: 305,
        ESCAPE: 400,
        TAB: 401,
        SPACE: 402,
        BACKSPACE: 403,
        RETURN: 404,
        GRAVE: 500,
        MINUS: 501,
        EQUALS: 502,
        LEFT_BRACKET: 503,
        RIGHT_BRACKET: 504,
        SEMI_COLON: 505,
        APOSTROPHE: 506,
        COMMA: 507,
        PERIOD: 508,
        SLASH: 509,
        BACKSLASH: 510,
        F1: 600,
        F2: 601,
        F3: 602,
        F4: 603,
        F5: 604,
        F6: 605,
        F7: 606,
        F8: 607,
        F9: 608,
        F10: 609,
        F11: 610,
        F12: 611,
        NUMPAD_0: 612,
        NUMPAD_1: 613,
        NUMPAD_2: 614,
        NUMPAD_3: 615,
        NUMPAD_4: 616,
        NUMPAD_5: 617,
        NUMPAD_6: 618,
        NUMPAD_7: 619,
        NUMPAD_8: 620,
        NUMPAD_9: 621,
        NUMPAD_ENTER: 622,
        NUMPAD_DIVIDE: 623,
        NUMPAD_MULTIPLY: 624,
        NUMPAD_ADD: 625,
        NUMPAD_SUBTRACT: 626,
        LEFT_WIN: 627,
        RIGHT_WIN: 628,
        LEFT_OPTION: 629,
        RIGHT_OPTION: 630,
        CAPS_LOCK: 631,
        INSERT: 632,
        DELETE: 633,
        HOME: 634,
        END: 635,
        PAGE_UP: 636,
        PAGE_DOWN: 637,
        BACK: 638
    };
    WebGLInputDevice.prototype.mouseCodes = {
        BUTTON_0: 0,
        BUTTON_1: 1,
        BUTTON_2: 2,
        DELTA_X: 100,
        DELTA_Y: 101,
        MOUSE_WHEEL: 102
    };
    WebGLInputDevice.prototype.padCodes = {
        UP: 0,
        LEFT: 1,
        DOWN: 2,
        RIGHT: 3,
        A: 4,
        B: 5,
        X: 6,
        Y: 7,
        LEFT_TRIGGER: 8,
        RIGHT_TRIGGER: 9,
        LEFT_SHOULDER: 10,
        RIGHT_SHOULDER: 11,
        LEFT_THUMB: 12,
        LEFT_THUMB_X: 13,
        LEFT_THUMB_Y: 14,
        RIGHT_THUMB: 15,
        RIGHT_THUMB_X: 16,
        RIGHT_THUMB_Y: 17,
        START: 18,
        BACK: 19
    };
    WebGLMathDevice = VMath;
    var WebGLNetworkDevice = function() {
        function WebGLNetworkDevice() {}
        WebGLNetworkDevice.prototype.createWebSocket = function(url, protocol) {
            var WebSocketConstructor = this.WebSocketConstructor;
            if (WebSocketConstructor) {
                var ws;
                if (protocol) {
                    ws = new WebSocketConstructor(url, protocol)
                } else {
                    ws = new WebSocketConstructor(url)
                }
                if (typeof ws.destroy === "undefined") {
                    ws.destroy = function websocketDestroyFn() {
                        this.onopen = null;
                        this.onerror = null;
                        this.onclose = null;
                        this.onmessage = null;
                        this.close()
                    }
                }
                return ws
            } else {
                return null
            }
        };
        WebGLNetworkDevice.prototype.update = function() {};
        WebGLNetworkDevice.create = function(params) {
            var nd = new WebGLNetworkDevice;
            return nd
        };
        WebGLNetworkDevice.version = 1;
        return WebGLNetworkDevice
    }();
    WebGLNetworkDevice.prototype.WebSocketConstructor = window.WebSocket ? window.WebSocket : window.MozWebSocket;
    var WebGLPhysicsShape = function() {
        function WebGLPhysicsShape() {}
        WebGLPhysicsShape.version = 1;
        return WebGLPhysicsShape
    }();
    var WebGLPhysicsConfig = {
        CONTACT_SLOP: .015,
        CONTACT_BAUMGRAUTE: .35,
        CONTACT_STATIC_BAUMGRAUTE: .65,
        CONTACT_MAX_Y_SEPERATION: .05,
        CONTACT_MAX_SQ_XZ_SEPERATION: 2 * (.245 * .245),
        CONTACT_INHERIT_SQ_SEPERATION: 3 * (.75 * .75),
        CONTACT_EQUAL_SQ_SEPERATION: 3 * (.001 * .001),
        GJK_EPA_DISTANCE_THRESHOLD: 1e-4,
        GJK_FRACTIONAL_THRESHOLD: 1e-4,
        CONTINUOUS_LINEAR_SQ: .35,
        CONTINUOUS_ANGULAR_SQ: .25,
        CONTINUOUS_LINEAR_BULLET: .75,
        CONTINUOUS_ANGULAR_BULLET: .5,
        CONTINUOUS_SLOP: .015,
        SLEEP_LINEAR_SQ: .01,
        SLEEP_ANGULAR_SQ: .1,
        SLEEP_DELAY: 60,
        MAX_ANGULAR: Math.PI,
        QUADRATIC_THRESHOLD: 1e-8,
        DONT_NORMALIZE_THRESHOLD: 1e-8,
        COLLINEAR_THRESHOLD: 1e-10,
        COPLANAR_THRESHOLD: 1e-16
    };
    var webGLPhysicsClone = function webGLPhysicsCloneFn(dst, src) {
        for (var p in src) {
            if (src.hasOwnProperty(p)) {
                var v = src[p];
                if (v === null || v === undefined) {
                    continue
                }
                if (typeof v === "object" && p !== "shape" && p !== "userData" && p !== "world" && p !== "object" && p !== "arbiters" && p !== "islandRoot" && p !== "island" && p !== "bodyA" && p !== "bodyB" && p !== "triangleArray") {
                    if ("slice" in v) {
                        v = v.slice()
                    } else {
                        v = webGLPhysicsClone({}, v)
                    }
                }
                dst[p] = v
            }
        }
        return dst
    };
    var initShapeProperties = function initShapePropertiesFn(s, type, nomargin) {
        if (!nomargin) {
            Object.defineProperty(s, "margin", {
                get: function shapeGetMargin() {
                    return this._private.collisionRadius
                },
                set: function shapeSetMargin(margin) {
                    var pr = this._private;
                    pr.halfExtents[0] += margin - pr.collisionRadius;
                    pr.halfExtents[1] += margin - pr.collisionRadius;
                    pr.halfExtents[2] += margin - pr.collisionRadius;
                    pr.radius += margin - pr.collisionRadius;
                    pr.collisionRadius = margin
                },
                enumerable: true
            })
        }
        Object.defineProperty(s, "halfExtents", {
            get: function shapeGetHalfExtents() {
                return VMath.v3Copy(this._private.halfExtents)
            },
            enumerable: true
        });
        Object.defineProperty(s, "inertia", {
            get: function shapeGetInertia() {
                return VMath.v3Copy(this._private.inertia)
            },
            enumerable: true
        });
        Object.defineProperty(s, "radius", {
            get: function shapeGetRadius() {
                return this._private.radius
            },
            enumerable: true
        });
        Object.defineProperty(s, "type", {
            value: type,
            enumerable: true
        })
    };
    var WebGLPhysicsPlaneShape = function() {
        function WebGLPhysicsPlaneShape() {}
        WebGLPhysicsPlaneShape.prototype.rayTest = function(ray) {
            var dir = ray.direction;
            var origin = ray.origin;
            var dir0 = dir[0];
            var dir1 = dir[1];
            var dir2 = dir[2];
            var o0 = origin[0];
            var o1 = origin[1];
            var o2 = origin[2];
            var normal = this.normal;
            var n0 = normal[0];
            var n1 = normal[1];
            var n2 = normal[2];
            var dot = dir0 * n0 + dir1 * n1 + dir2 * n2;
            if (dot * dot < WebGLPhysicsConfig.COPLANAR_THRESHOLD) {
                return null
            }
            var distance = (this.distance - (o0 * n0 + o1 * n1 + o2 * n2)) / dot;
            if (0 <= distance && distance <= ray.maxFactor) {
                if (dot > 0) {
                    n0 = -n0;
                    n1 = -n1;
                    n2 = -n2
                }
                var hit0 = o0 + dir0 * distance;
                var hit1 = o1 + dir1 * distance;
                var hit2 = o2 + dir2 * distance;
                return {
                    factor: distance,
                    hitPoint: VMath.v3Build(hit0, hit1, hit2),
                    hitNormal: VMath.v3Build(n0, n1, n2)
                }
            } else {
                return null
            }
        };
        WebGLPhysicsPlaneShape.create = function(params) {
            var retp = new WebGLPhysicsShape;
            var p = new WebGLPhysicsPlaneShape;
            retp._private = p;
            p._public = retp;
            p.collisionRadius = params.margin !== undefined ? params.margin : .04;
            p.distance = params.distance;
            var normal = p.normal = VMath.v3Copy(params.normal);
            var abs = Math.abs;
            var maxValue = Number.MAX_VALUE;
            p.radius = maxValue;
            var buffer = new Float32Array(6);
            if (abs(normal[0]) === 1) {
                p.halfExtents = VMath.v3Build(abs(p.distance), maxValue, maxValue, buffer.subarray(0, 3))
            } else if (abs(normal[1]) === 1) {
                p.halfExtents = VMath.v3Build(maxValue, abs(p.distance), maxValue, buffer.subarray(0, 3))
            } else if (abs(normal[2]) === 1) {
                p.halfExtents = VMath.v3Build(maxValue, maxValue, abs(p.distance), buffer.subarray(0, 3))
            }
            p.center = undefined;
            p.inertia = VMath.v3BuildZero(buffer.subarray(3, 6));
            initShapeProperties(retp, "PLANE");
            return retp
        };
        WebGLPhysicsPlaneShape.version = 1;
        return WebGLPhysicsPlaneShape
    }();
    WebGLPhysicsPlaneShape.prototype.type = "PLANE";
    var WebGLPhysicsCapsuleShape = function() {
        function WebGLPhysicsCapsuleShape() {}
        WebGLPhysicsCapsuleShape.prototype.rayTestCap = function(ray, height, scale) {
            var origin = ray.origin;
            var direction = ray.direction;
            var o0 = origin[0];
            var o1 = origin[1];
            var o2 = origin[2];
            var dir0 = direction[0];
            var dir1 = direction[1];
            var dir2 = direction[2];
            var radius = this.capsuleRadius;
            var a = dir0 * dir0 + dir1 * dir1 + dir2 * dir2;
            var dy = o1 - height;
            var b = 2 * (dir0 * o0 + dir1 * dy + dir2 * o2);
            var c = o0 * o0 + dy * dy + o2 * o2 - radius * radius;
            var d = b * b - 4 * a * c;
            if (d < 0) {
                return null
            }
            var distance;
            var normalScale = 1;
            var hit1;
            var rec = 1 / (2 * a);
            var rootD = Math.sqrt(d);
            distance = (-b - rootD) * rec;
            hit1 = o1 + dir1 * distance;
            if (distance < 0 || scale * (hit1 - height) < 0) {
                distance += 2 * rootD * rec;
                hit1 = o1 + dir1 * distance;
                normalScale = -1
            }
            if (scale * (hit1 - height) >= 0 && (0 <= distance && distance <= ray.maxFactor)) {
                var hit0 = o0 + dir0 * distance;
                var hit2 = o2 + dir2 * distance;
                var nScale = normalScale / radius;
                return {
                    factor: distance,
                    hitPoint: VMath.v3Build(hit0, hit1, hit2),
                    hitNormal: VMath.v3Build(hit0 * nScale, (hit1 - height) * nScale, hit2 * nScale)
                }
            } else {
                return null
            }
        };
        WebGLPhysicsCapsuleShape.prototype.rayTest = function(ray) {
            var origin = ray.origin;
            var direction = ray.direction;
            var o0 = origin[0];
            var o1 = origin[1];
            var o2 = origin[2];
            var dir0 = direction[0];
            var dir1 = direction[1];
            var dir2 = direction[2];
            var maxFactor = ray.maxFactor;
            var radius = this.capsuleRadius;
            var halfHeight = this.halfHeight;
            var radius2 = radius * radius;
            var distance;
            var normalScale = 1;
            var hit0;
            var hit1;
            var hit2;
            var a = dir0 * dir0 + dir2 * dir2;
            if (a >= WebGLPhysicsConfig.QUADRATIC_THRESHOLD) {
                var b = 2 * (o0 * dir0 + o2 * dir2);
                var c = o0 * o0 + o2 * o2 - radius2;
                var d = b * b - 4 * a * c;
                var rec = 1 / (2 * a);
                if (d < WebGLPhysicsConfig.QUADRATIC_THRESHOLD) {
                    distance = -b * rec
                } else if (d > 0) {
                    var rootD = Math.sqrt(d);
                    distance = (-b - rootD) * rec;
                    if (distance < 0) {
                        distance += rootD * 2 * rec;
                        normalScale = -1
                    }
                }
                var scale;
                hit1 = o1 + dir1 * distance;
                if (-halfHeight <= hit1 && hit1 <= halfHeight) {
                    if (0 <= distance && distance <= maxFactor) {
                        hit0 = o0 + dir0 * distance;
                        hit2 = o2 + dir2 * distance;
                        scale = normalScale / radius;
                        return {
                            factor: distance,
                            hitPoint: VMath.v3Build(hit0, hit1, hit2),
                            hitNormal: VMath.v3Build(hit0 * scale, 0, hit2 * scale)
                        }
                    } else {
                        return null
                    }
                }
            }
            return this.rayTestCap(ray, halfHeight, 1) || this.rayTestCap(ray, -halfHeight, -1)
        };
        WebGLPhysicsCapsuleShape.prototype.localSupportWithoutMargin = function(vec, dst) {
            dst[0] = 0;
            dst[1] = vec[1] >= 0 ? this.halfHeight : -this.halfHeight;
            dst[2] = 0
        };
        WebGLPhysicsCapsuleShape.create = function(params) {
            var retc = new WebGLPhysicsShape;
            var c = new WebGLPhysicsCapsuleShape;
            retc._private = c;
            c._public = retc;
            var margin = params.margin !== undefined ? params.margin : .04;
            var radius = params.radius;
            var height = params.height;
            var halfHeight = .5 * height;
            var maxRadius = radius + halfHeight;
            var h0 = radius + margin;
            var h1 = maxRadius + margin;
            var h2 = radius + margin;
            var lx = 2 * h0;
            var ly = 2 * h1;
            var lz = 2 * h2;
            lx *= lx;
            ly *= ly;
            lz *= lz;
            var massRatio = 1 / 12;
            var buffer = new Float32Array(6);
            c.radius = maxRadius + margin;
            c.capsuleRadius = radius;
            c.halfHeight = halfHeight;
            c.halfExtents = VMath.v3Build(h0, h1, h2, buffer.subarray(0, 3));
            c.inertia = VMath.v3Build(massRatio * (ly + lz), massRatio * (lx + lz), massRatio * (lx + ly), buffer.subarray(3, 6));
            c.collisionRadius = radius + margin;
            c.center = undefined;
            Object.defineProperty(retc, "margin", {
                get: function capsuleShapeGetMargin() {
                    return this._private.collisionRadius - this._private.capsuleRadius
                },
                set: function capsuleShapeSetMargin(margin) {
                    var pr = this._private;
                    pr.collisionRadius = pr.capsuleRadius + margin;
                    pr.halfExtents[0] = pr.capsuleRadius + margin;
                    pr.halfExtents[1] = pr.capsuleRadius + pr.halfHeight + margin;
                    pr.halfExtents[2] = pr.capsuleRadius + margin;
                    pr.radius = pr.capsuleRadius + pr.halfHeight + margin
                },
                enumerable: true
            });
            initShapeProperties(retc, "CAPSULE", true);
            return retc
        };
        WebGLPhysicsCapsuleShape.version = 1;
        return WebGLPhysicsCapsuleShape
    }();
    WebGLPhysicsShape.prototype.type = "CAPSULE";
    var WebGLPhysicsSphereShape = function() {
        function WebGLPhysicsSphereShape() {}
        WebGLPhysicsSphereShape.prototype.rayTest = function(ray) {
            var origin = ray.origin;
            var direction = ray.direction;
            var radius = this.sphereRadius;
            var dir0 = direction[0];
            var dir1 = direction[1];
            var dir2 = direction[2];
            var o0 = origin[0];
            var o1 = origin[1];
            var o2 = origin[2];
            var a = dir0 * dir0 + dir1 * dir1 + dir2 * dir2;
            var b = 2 * (o0 * dir0 + o1 * dir1 + o2 * dir2);
            var c = o0 * o0 + o1 * o1 + o2 * o2 - radius * radius;
            var distance;
            var d = b * b - 4 * a * c;
            if (d <= 0) {
                return null
            }
            var normalScale = 1;
            var rec = 1 / (2 * a);
            var rootD = Math.sqrt(d);
            distance = (-b - rootD) * rec;
            if (distance < 0) {
                distance += rootD * 2 * rec;
                normalScale = -1
            }
            if (0 <= distance && distance < ray.maxFactor) {
                var hit0 = o0 + dir0 * distance;
                var hit1 = o1 + dir1 * distance;
                var hit2 = o2 + dir2 * distance;
                var scale = normalScale / radius;
                return {
                    factor: distance,
                    hitPoint: VMath.v3Build(hit0, hit1, hit2),
                    hitNormal: VMath.v3Build(hit0 * scale, hit1 * scale, hit2 * scale)
                }
            } else {
                return null
            }
        };
        WebGLPhysicsSphereShape.prototype.localSupportWithoutMargin = function(vec, dst) {
            dst[0] = dst[1] = dst[2] = 0
        };
        WebGLPhysicsSphereShape.create = function(params) {
            var rets = new WebGLPhysicsShape;
            var s = new WebGLPhysicsSphereShape;
            rets._private = s;
            s._public = rets;
            var margin = params.margin !== undefined ? params.margin : .04;
            var radius = params.radius;
            var i = .4 * radius * radius;
            var buffer = new Float32Array(6);
            s.sphereRadius = radius;
            s.radius = s.sphereRadius + margin;
            s.collisionRadius = radius + margin;
            s.halfExtents = VMath.v3Build(radius + margin, radius + margin, radius + margin, buffer.subarray(0, 3));
            s.inertia = VMath.v3Build(i, i, i, buffer.subarray(3, 6));
            s.center = undefined;
            Object.defineProperty(rets, "margin", {
                get: function sphereShapeGetMargin() {
                    return this._private.collisionRadius - this._private.radius
                },
                set: function sphereShapeSetMargin(margin) {
                    var pr = this._private;
                    pr.collisionRadius = pr.radius + margin;
                    pr.halfExtents[0] = pr.collisionRadius;
                    pr.halfExtents[1] = pr.collisionRadius;
                    pr.halfExtents[2] = pr.collisionRadius;
                    pr.radius = pr.collisionRadius
                },
                enumerable: true
            });
            initShapeProperties(rets, "SPHERE", true);
            return rets
        };
        WebGLPhysicsSphereShape.version = 1;
        return WebGLPhysicsSphereShape
    }();
    WebGLPhysicsSphereShape.prototype.type = "SPHERE";
    var WebGLPhysicsBoxShape = function() {
        function WebGLPhysicsBoxShape() {}
        WebGLPhysicsBoxShape.prototype.rayTest = function(ray) {
            var origin = ray.origin;
            var direction = ray.direction;
            var o0 = origin[0];
            var o1 = origin[1];
            var o2 = origin[2];
            var d0 = direction[0];
            var d1 = direction[1];
            var d2 = direction[2];
            var halfExtents = this.halfExtents;
            var h0 = halfExtents[0];
            var h1 = halfExtents[1];
            var h2 = halfExtents[2];
            var minDistance;
            var axis;
            var t, f, hx, hy;
            if (d0 !== 0 && (d0 > 0 && o0 <= -h0 || d0 < 0 && o0 >= h0)) {
                f = d0 > 0 ? o0 >= -h0 ? h0 : -h0 : o0 <= h0 ? -h0 : h0;
                t = (f - o0) / d0;
                if (minDistance === undefined || t < minDistance) {
                    hx = o1 + d1 * t;
                    hy = o2 + d2 * t;
                    if (-h1 <= hx && hx <= h1 && (-h2 <= hy && hy <= h2)) {
                        minDistance = t;
                        axis = 0
                    }
                }
            }
            if (d1 !== 0 && (d1 > 0 && o1 <= -h1 || d1 < 0 && o1 >= h1)) {
                f = d1 > 0 ? o1 >= -h1 ? h1 : -h1 : o1 <= h1 ? -h1 : h1;
                t = (f - o1) / d1;
                if (minDistance === undefined || t < minDistance) {
                    hx = o0 + d0 * t;
                    hy = o2 + d2 * t;
                    if (-h0 <= hx && hx <= h0 && (-h2 <= hy && hy <= h2)) {
                        minDistance = t;
                        axis = 1
                    }
                }
            }
            if (d2 !== 0 && (d2 > 0 && o2 <= -h2 || d2 < 0 && o2 >= h2)) {
                f = d2 > 0 ? o2 >= -h2 ? h2 : -h2 : o2 <= h2 ? -h2 : h2;
                t = (f - o2) / d2;
                if (minDistance === undefined || t < minDistance) {
                    hx = o1 + d1 * t;
                    hy = o0 + d0 * t;
                    if (-h1 <= hx && hx <= h1 && (-h0 <= hy && hy <= h0)) {
                        minDistance = t;
                        axis = 2
                    }
                }
            }
            if (minDistance !== undefined && minDistance < ray.maxFactor) {
                return {
                    hitPoint: VMath.v3Build(o0 + d0 * minDistance, o1 + d1 * minDistance, o2 + d2 * minDistance),
                    hitNormal: VMath.v3Build(axis === 0 ? d0 > 0 ? -1 : 1 : 0, axis === 1 ? d1 > 0 ? -1 : 1 : 0, axis === 2 ? d2 > 0 ? -1 : 1 : 0),
                    factor: minDistance
                }
            } else {
                return null
            }
        };
        WebGLPhysicsBoxShape.prototype.localSupportWithoutMargin = function(vec, dst) {
            var v0 = vec[0];
            var v1 = vec[1];
            var v2 = vec[2];
            var halfExtents = this.halfExtents;
            var h0 = halfExtents[0];
            var h1 = halfExtents[1];
            var h2 = halfExtents[2];
            dst[0] = v0 < 0 ? -h0 : h0;
            dst[1] = v1 < 0 ? -h1 : h1;
            dst[2] = v2 < 0 ? -h2 : h2
        };
        WebGLPhysicsBoxShape.create = function(params) {
            var retb = new WebGLPhysicsShape;
            var b = new WebGLPhysicsBoxShape;
            retb._private = b;
            b._public = retb;
            var margin = params.margin !== undefined ? params.margin : .04;
            var halfExtents = params.halfExtents;
            var h0 = halfExtents[0] + margin;
            var h1 = halfExtents[1] + margin;
            var h2 = halfExtents[2] + margin;
            var lx = 2 * h0;
            var ly = 2 * h1;
            var lz = 2 * h2;
            lx *= lx;
            ly *= ly;
            lz *= lz;
            var buffer = new Float32Array(6);
            b.center = undefined;
            b.radius = Math.sqrt(h0 * h0 + h1 * h1 + h2 * h2);
            b.halfExtents = VMath.v3Build(h0, h1, h2, buffer.subarray(0, 3));
            b.inertia = VMath.v3Build(1 / 12 * (ly + lz), 1 / 12 * (lx + lz), 1 / 12 * (lx + ly), buffer.subarray(3, 6));
            b.collisionRadius = margin;
            initShapeProperties(retb, "BOX");
            return retb
        };
        WebGLPhysicsBoxShape.version = 1;
        return WebGLPhysicsBoxShape
    }();
    WebGLPhysicsBoxShape.prototype.type = "BOX";
    var WebGLPhysicsCylinderShape = function() {
        function WebGLPhysicsCylinderShape() {}
        WebGLPhysicsCylinderShape.prototype.rayTest = function(ray) {
            var origin = ray.origin;
            var direction = ray.direction;
            var o0 = origin[0];
            var o1 = origin[1];
            var o2 = origin[2];
            var dir0 = direction[0];
            var dir1 = direction[1];
            var dir2 = direction[2];
            var maxFactor = ray.maxFactor;
            var radius = this.cylinderRadius;
            var halfHeight = this.halfHeight;
            var radius2 = radius * radius;
            var a = dir0 * dir0 + dir2 * dir2;
            var b = 2 * (o0 * dir0 + o2 * dir2);
            var c = o0 * o0 + o2 * o2 - radius2;
            var distance;
            var normalScale = 1;
            var hit0, hit1, hit2;
            var scale, rec;
            var d = b * b - 4 * a * c;
            if (d >= 0) {
                rec = 1 / (2 * a);
                var rootD = Math.sqrt(d);
                distance = (-b - rootD) * rec;
                if (distance < 0) {
                    distance += rootD * 2 * rec;
                    normalScale = -1
                }
                hit1 = o1 + dir1 * distance;
                if (-halfHeight <= hit1 && hit1 <= halfHeight) {
                    if (0 <= distance && distance <= maxFactor) {
                        hit0 = o0 + dir0 * distance;
                        hit2 = o2 + dir2 * distance;
                        scale = normalScale / radius;
                        return {
                            factor: distance,
                            hitPoint: VMath.v3Build(hit0, hit1, hit2),
                            hitNormal: VMath.v3Build(hit0 * scale, 0, hit2 * scale)
                        }
                    } else {
                        return null
                    }
                }
            }
            if (dir1 * dir1 >= WebGLPhysicsConfig.COPLANAR_THRESHOLD) {
                scale = dir1 < 0 ? -1 : 1;
                hit1 = -scale * halfHeight;
                rec = 1 / dir1;
                distance = (hit1 - o1) * rec;
                if (distance < 0) {
                    hit1 = scale * halfHeight;
                    distance = (hit1 - o1) * rec
                }
                if (0 <= distance && distance <= maxFactor) {
                    hit0 = o0 + dir0 * distance;
                    hit2 = o2 + dir2 * distance;
                    if (hit0 * hit0 + hit2 * hit2 <= radius2) {
                        return {
                            factor: distance,
                            hitPoint: VMath.v3Build(hit0, hit1, hit2),
                            hitNormal: VMath.v3Build(0, -scale, 0)
                        }
                    }
                }
            }
            return null
        };
        WebGLPhysicsCylinderShape.prototype.localSupportWithoutMargin = function(vec, dst) {
            var v0 = vec[0];
            var v2 = vec[2];
            var vmag2 = v0 * v0 + v2 * v2;
            if (vmag2 === 0) {
                if (vec[1] > 0) {
                    dst[0] = this.cylinderRadius;
                    dst[1] = this.halfHeight;
                    dst[2] = 0
                } else {
                    dst[0] = 0;
                    dst[1] = -this.halfHeight;
                    dst[2] = -this.cylinderRadius
                }
                return
            }
            var scale = this.cylinderRadius / Math.sqrt(vmag2);
            dst[0] = v0 * scale;
            dst[1] = (vec[1] > 0 ? 1 : -1) * this.halfHeight;
            dst[2] = v2 * scale
        };
        WebGLPhysicsCylinderShape.create = function(params) {
            var retc = new WebGLPhysicsShape;
            var c = new WebGLPhysicsCylinderShape;
            retc._private = c;
            c._public = retc;
            var margin = params.margin !== undefined ? params.margin : .04;
            var halfExtents = params.halfExtents;
            var h0 = halfExtents[0] + margin;
            var h1 = halfExtents[1] + margin;
            var h2 = halfExtents[2] + margin;
            var radius2 = h0 * h0;
            var height2 = 4 * h1 * h1;
            var t1 = 1 / 12 * height2 + 1 / 4 * radius2;
            var t2 = 1 / 2 * radius2;
            var buffer = new Float32Array(6);
            c.center = undefined;
            c.radius = Math.sqrt(h0 * h0 + h1 * h1 + h2 * h2);
            c.halfExtents = VMath.v3Build(h0, h1, h2, buffer.subarray(0, 3));
            c.cylinderRadius = halfExtents[0];
            c.halfHeight = halfExtents[1];
            c.inertia = VMath.v3Build(t1, t2, t1, buffer.subarray(3, 6));
            c.collisionRadius = margin;
            initShapeProperties(retc, "CYLINDER");
            return retc
        };
        WebGLPhysicsCylinderShape.version = 1;
        return WebGLPhysicsCylinderShape
    }();
    WebGLPhysicsCylinderShape.prototype.type = "CYLINDER";
    var WebGLPhysicsConeShape = function() {
        function WebGLPhysicsConeShape() {}
        WebGLPhysicsConeShape.prototype.rayTest = function(ray) {
            var origin = ray.origin;
            var direction = ray.direction;
            var o0 = origin[0];
            var o1 = origin[1];
            var o2 = origin[2];
            var dir0 = direction[0];
            var dir1 = direction[1];
            var dir2 = direction[2];
            var maxFactor = ray.maxFactor;
            var radius = this.coneRadius;
            var halfHeight = this.halfHeight;
            var conicK = radius / (2 * halfHeight);
            conicK *= conicK;
            var d1 = o1 - halfHeight;
            var a = dir0 * dir0 + dir2 * dir2 - conicK * dir1 * dir1;
            var b = 2 * (o0 * dir0 + o2 * dir2 - conicK * d1 * dir1);
            var c = o0 * o0 + o2 * o2 - conicK * d1 * d1;
            var distance;
            var normalScale = 1;
            var hit0, hit1, hit2;
            var d = b * b - 4 * a * c;
            if (d >= 0) {
                var rec = 1 / (2 * a);
                var rootD = Math.sqrt(d);
                distance = (-b - rootD) * rec;
                hit1 = o1 + dir1 * distance;
                if (distance < 0 || hit1 < -halfHeight || hit1 > halfHeight) {
                    distance += 2 * rootD * rec;
                    normalScale = -1;
                    hit1 = o1 + dir1 * distance;
                    if (distance < 0 || hit1 < -halfHeight || hit1 > halfHeight) {
                        distance = undefined
                    }
                }
            }
            var t;
            if (dir1 !== 0) {
                t = (-halfHeight - o1) / dir1;
                hit0 = o0 + dir0 * t;
                hit2 = o2 + dir2 * t;
                if (t < 0 || hit0 * hit0 + hit2 * hit2 > radius * radius) {
                    t = undefined
                }
            }
            if (t === undefined && distance === undefined) {
                return null
            }
            if (t === undefined || distance !== undefined && distance < t) {
                if (distance >= maxFactor) {
                    return null
                }
                hit0 = o0 + dir0 * distance;
                hit1 = o1 + dir1 * distance;
                hit2 = o2 + dir2 * distance;
                var n1 = conicK * (hit1 - halfHeight);
                var scale = normalScale / Math.sqrt(hit0 * hit0 + n1 * n1 + hit2 * hit2);
                return {
                    hitPoint: VMath.v3Build(hit0, hit1, hit2),
                    hitNormal: VMath.v3Build(scale * hit0, scale * n1, scale * hit2),
                    factor: distance
                }
            } else {
                if (t >= maxFactor) {
                    return null
                }
                hit0 = o0 + dir0 * t;
                hit1 = o1 + dir1 * t;
                hit2 = o2 + dir2 * t;
                return {
                    hitPoint: VMath.v3Build(hit0, hit1, hit2),
                    hitNormal: VMath.v3Build(0, o1 < -halfHeight ? -1 : 1, 0),
                    factor: t
                }
            }
        };
        WebGLPhysicsConeShape.prototype.localSupportWithoutMargin = function(vec, dst) {
            var v0 = vec[0];
            var v1 = vec[1];
            var v2 = vec[2];
            var vxz = Math.sqrt(v0 * v0 + v2 * v2);
            if (-this.coneRadius * vxz + 2 * this.halfHeight * v1 > 0) {
                dst[0] = dst[2] = 0;
                dst[1] = this.halfHeight
            } else {
                if (vxz === 0) {
                    dst[0] = this.coneRadius;
                    dst[2] = 0
                } else {
                    dst[0] = v0 * this.coneRadius / vxz;
                    dst[2] = v2 * this.coneRadius / vxz
                }
                dst[1] = -this.halfHeight
            }
        };
        WebGLPhysicsConeShape.create = function(params) {
            var retc = new WebGLPhysicsShape;
            var c = new WebGLPhysicsConeShape;
            retc._private = c;
            c._public = retc;
            var margin = params.margin !== undefined ? params.margin : .04;
            var radius = params.radius;
            var height = params.height;
            var halfHeight = .5 * height;
            var h0 = radius + margin;
            var h1 = halfHeight + margin;
            var h2 = radius + margin;
            var lx = 2 * h0;
            var ly = 2 * h1;
            var lz = 2 * h2;
            lx *= lx;
            ly *= ly;
            lz *= lz;
            var massRatio = 1 / 12;
            var buffer = new Float32Array(6);
            c.halfHeight = halfHeight;
            c.coneRadius = radius;
            c.radius = Math.sqrt(h0 * h0 + h1 * h1 + h2 * h2);
            c.halfExtents = VMath.v3Build(h0, h1, h2, buffer.subarray(0, 3));
            c.inertia = VMath.v3Build(massRatio * (ly + lz), massRatio * (lx + lz), massRatio * (lx + ly), buffer.subarray(3, 6));
            c.collisionRadius = margin;
            c.center = undefined;
            initShapeProperties(retc, "CONE");
            return retc
        };
        WebGLPhysicsConeShape.version = 1;
        return WebGLPhysicsConeShape
    }();
    WebGLPhysicsConeShape.prototype.type = "CONE";
    var WebGLPhysicsTriangleArray = function() {
        function WebGLPhysicsTriangleArray() {}
        WebGLPhysicsTriangleArray.create = function(params) {
            var rett = new WebGLPhysicsTriangleArray;
            var t = new WebGLPhysicsPrivateTriangleArray;
            rett._private = t;
            t._public = rett;
            var vertices = params.vertices;
            var numVertices = vertices.length / 3;
            var indices = params.indices;
            var numTriangles = indices.length / 3;
            var minExtent = params.minExtent;
            var maxExtent = params.maxExtent;
            var v0;
            var v1;
            var v2;
            if (!minExtent || !maxExtent) {
                var min0 = vertices[0];
                var min1 = vertices[1];
                var min2 = vertices[2];
                var max0 = min0;
                var max1 = min1;
                var max2 = min2;
                var maxN = vertices.length;
                for (var n = 3; n < maxN; n += 3) {
                    v0 = vertices[n];
                    v1 = vertices[n + 1];
                    v2 = vertices[n + 2];
                    if (min0 > v0) {
                        min0 = v0
                    } else if (max0 < v0) {
                        max0 = v0
                    }
                    if (min1 > v1) {
                        min1 = v1
                    } else if (max1 < v1) {
                        max1 = v1
                    }
                    if (min2 > v2) {
                        min2 = v2
                    } else if (max2 < v2) {
                        max2 = v2
                    }
                }
                minExtent = [min0, min1, min2];
                maxExtent = [max0, max1, max2]
            }
            var extents = new Float32Array(6);
            extents[0] = minExtent[0];
            extents[1] = minExtent[1];
            extents[2] = minExtent[2];
            extents[3] = maxExtent[0];
            extents[4] = maxExtent[1];
            extents[5] = maxExtent[2];
            t.vertices = params.dontCopy ? vertices : new Float32Array(vertices);
            t.numVertices = numVertices;
            t.indices = params.dontCopy ? indices : numVertices < 65536 ? new Uint16Array(indices) : new Uint32Array(indices);
            t.numTriangles = numTriangles;
            t.extents = extents;
            Object.defineProperty(rett, "vertices", {
                value: t.vertices,
                enumerable: true
            });
            Object.defineProperty(rett, "indices", {
                value: t.indices,
                enumerable: true
            });
            var triangles = new Float32Array(WebGLPhysicsPrivateTriangleArray.prototype.TRIANGLE_SIZE * numTriangles);
            var spatialMap = null;
            if (numTriangles >= 8) {
                spatialMap = AABBTree.create(true);
                extents = new Float32Array(6)
            }
            var i;
            for (i = 0; i < numTriangles; i = i + 1) {
                var i3 = i * 3;
                var itri = i * WebGLPhysicsPrivateTriangleArray.prototype.TRIANGLE_SIZE;
                var i0 = indices[i3] * 3;
                var i1 = indices[i3 + 1] * 3;
                var i2 = indices[i3 + 2] * 3;
                var v00 = vertices[i0];
                var v01 = vertices[i0 + 1];
                var v02 = vertices[i0 + 2];
                var v10 = vertices[i1];
                var v11 = vertices[i1 + 1];
                var v12 = vertices[i1 + 2];
                var v20 = vertices[i2];
                var v21 = vertices[i2 + 1];
                var v22 = vertices[i2 + 2];
                var u0 = v10 - v00;
                var u1 = v11 - v01;
                var u2 = v12 - v02;
                v0 = v20 - v00;
                v1 = v21 - v01;
                v2 = v22 - v02;
                var n0 = u1 * v2 - u2 * v1;
                var n1 = u2 * v0 - u0 * v2;
                var n2 = u0 * v1 - u1 * v0;
                var nn = 1 / Math.sqrt(n0 * n0 + n1 * n1 + n2 * n2);
                var distance = (n0 * v00 + n1 * v01 + n2 * v02) * nn;
                var dotuv = u0 * v0 + u1 * v1 + u2 * v2;
                var dotuu = u0 * u0 + u1 * u1 + u2 * u2;
                var dotvv = v0 * v0 + v1 * v1 + v2 * v2;
                var negLimit = dotuv * dotuv - dotuu * dotvv;
                triangles[itri] = n0 * nn;
                triangles[itri + 1] = n1 * nn;
                triangles[itri + 2] = n2 * nn;
                triangles[itri + 3] = v00;
                triangles[itri + 4] = v01;
                triangles[itri + 5] = v02;
                triangles[itri + 6] = u0;
                triangles[itri + 7] = u1;
                triangles[itri + 8] = u2;
                triangles[itri + 9] = v0;
                triangles[itri + 10] = v1;
                triangles[itri + 11] = v2;
                triangles[itri + 12] = dotuu;
                triangles[itri + 13] = dotvv;
                triangles[itri + 14] = dotuv;
                triangles[itri + 15] = negLimit;
                triangles[itri + 16] = distance;
                if (spatialMap) {
                    extents[0] = Math.min(v00, v10, v20);
                    extents[1] = Math.min(v01, v11, v21);
                    extents[2] = Math.min(v02, v12, v22);
                    extents[3] = Math.max(v00, v10, v20);
                    extents[4] = Math.max(v01, v11, v21);
                    extents[5] = Math.max(v02, v12, v22);
                    var triNode = {
                        index: itri,
                        spatialIndex: undefined
                    };
                    spatialMap.add(triNode, extents)
                }
            }
            if (spatialMap) {
                spatialMap.finalize()
            }
            t.triangles = triangles;
            t.spatialMap = spatialMap;
            return rett
        };
        WebGLPhysicsTriangleArray.version = 1;
        return WebGLPhysicsTriangleArray
    }();
    var WebGLPhysicsPrivateTriangleArray = function() {
        function WebGLPhysicsPrivateTriangleArray() {}
        WebGLPhysicsPrivateTriangleArray.prototype.rayTest = function(ray) {
            var triangles = this.triangles;
            var spatialMap = this.spatialMap;

            function rayCallback(tree, triangle, ray, unusedAABBDistance, upperBound) {
                var dir = ray.direction;
                var dir0 = dir[0];
                var dir1 = dir[1];
                var dir2 = dir[2];
                var origin = ray.origin;
                var o0 = origin[0];
                var o1 = origin[1];
                var o2 = origin[2];
                var i = triangle.index;
                var n0 = triangles[i];
                var n1 = triangles[i + 1];
                var n2 = triangles[i + 2];
                var dot = dir0 * n0 + dir1 * n1 + dir2 * n2;
                if (dot * dot < WebGLPhysicsConfig.COPLANAR_THRESHOLD) {
                    return null
                }
                var d = triangles[i + 16];
                var v00 = triangles[i + 3];
                var v01 = triangles[i + 4];
                var v02 = triangles[i + 5];
                var distance = (d - (o0 * n0 + o1 * n1 + o2 * n2)) / dot;
                if (distance < 0 || distance >= upperBound) {
                    return null
                }
                if (dot > 0) {
                    n0 = -n0;
                    n1 = -n1;
                    n2 = -n2;
                    dot = -dot
                }
                var hit0 = o0 + dir0 * distance;
                var hit1 = o1 + dir1 * distance;
                var hit2 = o2 + dir2 * distance;
                var wx = hit0 - v00;
                var wy = hit1 - v01;
                var wz = hit2 - v02;
                var dotuu = triangles[i + 12];
                var dotvv = triangles[i + 13];
                var dotuv = triangles[i + 14];
                var negLimit = triangles[i + 15];
                var u0 = triangles[i + 6];
                var u1 = triangles[i + 7];
                var u2 = triangles[i + 8];
                var v0 = triangles[i + 9];
                var v1 = triangles[i + 10];
                var v2 = triangles[i + 11];
                var dotwu = wx * u0 + wy * u1 + wz * u2;
                var dotwv = wx * v0 + wy * v1 + wz * v2;
                var alpha = dotuv * dotwv - dotvv * dotwu;
                if (alpha > 0 || alpha < negLimit) {
                    return null
                }
                var beta = dotuv * dotwu - dotuu * dotwv;
                if (beta > 0 || alpha + beta < negLimit) {
                    return null
                }
                return {
                    factor: distance,
                    hitPoint: VMath.v3Build(hit0, hit1, hit2),
                    hitNormal: VMath.v3Build(n0, n1, n2)
                }
            }
            if (spatialMap) {
                return AABBTree.rayTest([spatialMap], ray, rayCallback)
            } else {
                var minimumResult = null;
                var upperBound = ray.maxFactor;
                var triNode = {
                    index: 0
                };
                var i;
                var numTris = this.numTriangles * WebGLPhysicsPrivateTriangleArray.prototype.TRIANGLE_SIZE;
                for (i = 0; i < numTris; i += WebGLPhysicsPrivateTriangleArray.prototype.TRIANGLE_SIZE) {
                    triNode.index = i;
                    var result = rayCallback(null, triNode, ray, 0, upperBound);
                    if (result) {
                        minimumResult = result;
                        upperBound = minimumResult.factor
                    }
                }
                return minimumResult
            }
        };
        WebGLPhysicsPrivateTriangleArray.version = 1;
        return WebGLPhysicsPrivateTriangleArray
    }();
    WebGLPhysicsPrivateTriangleArray.prototype.TRIANGLE_SIZE = 17;
    var WebGLPhysicsConvexHullHelpers = {
        isPlanar: function isPlanarFn(points) {
            var tolerance = WebGLPhysicsConfig.COPLANAR_THRESHOLD;
            var p00 = points[0];
            var p01 = points[1];
            var p02 = points[2];
            var e10 = points[3] - p00;
            var e11 = points[4] - p01;
            var e12 = points[5] - p02;
            var e20 = points[6] - p00;
            var e21 = points[7] - p01;
            var e22 = points[8] - p02;
            var n0 = e11 * e22 - e12 * e21;
            var n1 = e12 * e20 - e10 * e22;
            var n2 = e10 * e21 - e11 * e20;
            var normalScale = 1 / Math.sqrt(n0 * n0 + n1 * n1 + n2 * n2);
            n0 *= normalScale;
            n1 *= normalScale;
            n2 *= normalScale;
            var planeDistance = -(p00 * n0 + p01 * n1 + p02 * n2);
            var i;
            var maxN = points.length;
            for (i = 0; i < maxN; i += 3) {
                var distance = points[i] * n0 + points[i + 1] * n1 + points[i + 2] * n2 + planeDistance;
                if (distance * distance > tolerance) {
                    return false
                }
            }
            return true
        },
        makePlanarConvexHull: function makePlanarConvexHullFn(points) {
            var DONT_NORMALIZE_THRESHOLD = 1e-6;
            var p00 = points[0];
            var p01 = points[1];
            var p02 = points[2];
            var e10 = points[3] - p00;
            var e11 = points[4] - p01;
            var e12 = points[5] - p02;
            var e20 = points[6] - p00;
            var e21 = points[7] - p01;
            var e22 = points[8] - p02;
            var normal0 = e11 * e22 - e12 * e21;
            var normal1 = e12 * e20 - e10 * e22;
            var normal2 = e10 * e21 - e11 * e20;
            var tangent0, tangent1, tangent2;
            if (normal0 * normal0 + normal2 * normal2 < DONT_NORMALIZE_THRESHOLD) {
                tangent0 = 1;
                tangent1 = tangent2 = 0
            } else {
                tangent0 = -normal2;
                tangent1 = 0;
                tangent2 = normal0
            }
            var bitangent0 = normal1 * tangent2 - normal2 * tangent1;
            var bitangent1 = normal2 * tangent0 - normal0 * tangent2;
            var bitangent2 = normal0 * tangent1 - normal1 * tangent0;
            var numPoints = points.length / 3;
            var projs = new Float32Array(numPoints * 2);
            var p0, p1, p2;
            var i;
            for (i = 0; i < numPoints; i += 1) {
                p0 = points[i * 3];
                p1 = points[i * 3 + 1];
                p2 = points[i * 3 + 2];
                projs[i * 2] = p0 * tangent0 + p1 * tangent1 + p2 * tangent2;
                projs[i * 2 + 1] = p0 * bitangent0 + p1 * bitangent1 + p2 * bitangent2
            }
            var i0 = 0;
            p00 = projs[0];
            p01 = projs[1];
            for (i = 2; i < numPoints * 2; i += 2) {
                p0 = projs[i];
                p1 = projs[i + 1];
                if (p0 < p00 || p0 === p00 && p1 < p01) {
                    i0 = i / 2;
                    p00 = p0;
                    p01 = p1
                }
            }
            var hullVertices = {};
            hullVertices[i0] = 0;
            var outVertexCount = 1;
            var hullTriangles = [];
            var fsti = i0;
            for (;;) {
                var max0, max1, maxDistance;
                var i1 = -1;
                for (i = 0; i < numPoints * 2; i += 2) {
                    if (i === i0 * 2) {
                        continue
                    }
                    p0 = projs[i];
                    p1 = projs[i + 1];
                    var plsq = (p0 - p00) * (p0 - p00) + (p1 - p01) * (p1 - p01);
                    if (i1 === -1) {
                        i1 = i / 2;
                        max0 = p0;
                        max1 = p1;
                        maxDistance = plsq;
                        continue
                    }
                    var turn = (max0 - p00) * (p1 - p01) - (max1 - p01) * (p0 - p00);
                    if (turn < 0 || turn === 0 && plsq > maxDistance) {
                        i1 = i / 2;
                        max0 = p0;
                        max1 = p1;
                        maxDistance = plsq
                    }
                }
                if (i1 in hullVertices) {
                    break
                }
                hullVertices[i1] = outVertexCount;
                outVertexCount += 1;
                if (i0 !== fsti) {
                    hullTriangles.push(fsti);
                    hullTriangles.push(i0);
                    hullTriangles.push(i1)
                }
                i0 = i1;
                p00 = projs[i1 * 2];
                p01 = projs[i1 * 2 + 1]
            }
            return this.createArray(points, hullTriangles, hullVertices, outVertexCount)
        },
        makeConvexHull: function makeConvexHullFn(points) {
            var i0 = 0;
            var p00 = points[0];
            var p01 = points[1];
            var p02 = points[2];
            var i;
            var p0, p1, p2;
            var numPoints = points.length / 3;
            for (i = 3; i < numPoints * 3; i += 3) {
                p0 = points[i];
                p1 = points[i + 1];
                p2 = points[i + 2];
                if (p0 < p00 || p0 === p00 && (p1 < p01 || p1 === p01 && p2 < p02)) {
                    i0 = i / 3;
                    p00 = p0;
                    p01 = p1;
                    p02 = p2
                }
            }
            var i1 = -1;
            var cos1 = -2;
            var lsq1 = 0;
            var d0, d1;
            for (i = 0; i < numPoints * 3; i += 3) {
                if (i === i0 * 3) {
                    continue
                }
                p0 = points[i];
                p1 = points[i + 1];
                d0 = p0 - p00;
                d1 = p1 - p01;
                var lsq = d0 * d0 + d1 * d1;
                if (lsq === 0) {
                    if (i1 === -1) {
                        i1 = i / 3
                    }
                    continue
                }
                var cos = d1 / Math.sqrt(lsq);
                if (cos > cos1 || cos === cos1 && lsq > lsq1) {
                    cos1 = cos;
                    lsq1 = lsq;
                    i1 = i / 3
                }
            }
            var closedSet = {};
            var openSet = [i0, i1, i1, i0];
            var hullVertices = {};
            hullVertices[i0] = 0;
            hullVertices[i1] = 1;
            var outVertexCount = 2;
            var hullTriangles = [];
            while (openSet.length > 0) {
                i1 = openSet.pop();
                i0 = openSet.pop();
                if (i0 + ":" + i1 in closedSet) {
                    continue
                }
                var i2 = -1;
                var maxEdge0, maxEdge1, maxEdge2;
                var maxDistance, maxProjection;
                p00 = points[i0 * 3];
                p01 = points[i0 * 3 + 1];
                p02 = points[i0 * 3 + 2];
                var edge0 = points[i1 * 3] - p00;
                var edge1 = points[i1 * 3 + 1] - p01;
                var edge2 = points[i1 * 3 + 2] - p02;
                var isq = 1 / (edge0 * edge0 + edge1 * edge1 * (edge2 * edge2));
                for (i = 0; i < numPoints * 3; i += 3) {
                    if (i === i0 * 3 || i === i1 * 3) {
                        continue
                    }
                    p0 = points[i];
                    p1 = points[i + 1];
                    p2 = points[i + 2];
                    var t = ((p0 - p00) * edge0 + (p1 - p01) * edge1 + (p2 - p02) * edge2) * isq;
                    var pEdge0 = p0 - (p00 + edge0 * t);
                    var pEdge1 = p1 - (p01 + edge1 * t);
                    var pEdge2 = p2 - (p02 + edge2 * t);
                    var plsq = pEdge0 * pEdge0 + pEdge1 * pEdge1 + pEdge2 * pEdge2;
                    if (plsq <= WebGLPhysicsConfig.COLLINEAR_THRESHOLD) {
                        continue
                    }
                    if (i2 === -1) {
                        i2 = i / 3;
                        maxEdge0 = pEdge0;
                        maxEdge1 = pEdge1;
                        maxEdge2 = pEdge2;
                        maxDistance = plsq;
                        maxProjection = t;
                        continue
                    }
                    var axis0 = pEdge1 * maxEdge2 - pEdge2 * maxEdge1;
                    var axis1 = pEdge2 * maxEdge0 - pEdge0 * maxEdge2;
                    var axis2 = pEdge0 * maxEdge1 - pEdge1 * maxEdge0;
                    var coplanar = pEdge0 * (edge1 * maxEdge2 - edge2 * maxEdge1) + pEdge1 * (edge2 * maxEdge0 - edge0 * maxEdge2) + pEdge2 * (edge0 * maxEdge1 - edge1 * maxEdge0);
                    if (coplanar * coplanar < WebGLPhysicsConfig.COPLANAR_THRESHOLD) {
                        if (pEdge0 * maxEdge0 + pEdge1 * maxEdge1 + pEdge2 * maxEdge2 >= 0) {
                            if (plsq > maxDistance || plsq === maxDistance && t > maxProjection) {
                                i2 = i / 3;
                                maxEdge0 = pEdge0;
                                maxEdge1 = pEdge1;
                                maxEdge2 = pEdge2;
                                maxDistance = plsq;
                                maxProjection = t
                            }
                        } else {
                            d0 = p0 - p00;
                            d1 = p1 - p01;
                            var d2 = p2 - p02;
                            axis0 = d1 * edge2 - d2 * edge1;
                            axis1 = d2 * edge0 - d0 * edge2;
                            axis2 = d0 * edge1 - d1 * edge0;
                            var internal = true;
                            var j;
                            for (j = 0; j < numPoints * 3; j += 3) {
                                if (axis0 * (points[j] - p00) + axis1 * (points[j + 1] - p01) + axis2 * (points[j + 2] - p02) < 0) {
                                    internal = false;
                                    break
                                }
                            }
                            if (internal) {
                                i2 = i / 3;
                                maxEdge0 = pEdge0;
                                maxEdge1 = pEdge1;
                                maxEdge2 = pEdge2;
                                maxDistance = plsq;
                                maxProjection = t
                            }
                        }
                    } else {
                        var turn = axis0 * edge0 + axis1 * edge1 + axis2 * edge2;
                        if (turn < 0 || turn <= WebGLPhysicsConfig.COLLINEAR_THRESHOLD && plsq > maxDistance) {
                            i2 = i / 3;
                            maxEdge0 = pEdge0;
                            maxEdge1 = pEdge1;
                            maxEdge2 = pEdge2;
                            maxDistance = plsq;
                            maxProjection = t
                        }
                    }
                }
                if (!(i2 in hullVertices)) {
                    hullVertices[i2] = outVertexCount;
                    outVertexCount += 1
                }
                if (!(i0 + ":" + i1 in closedSet || i1 + ":" + i2 in closedSet || i2 + ":" + i0 in closedSet)) {
                    hullTriangles.push(i0);
                    hullTriangles.push(i1);
                    hullTriangles.push(i2);
                    closedSet[i0 + ":" + i1] = true;
                    closedSet[i1 + ":" + i2] = true;
                    closedSet[i2 + ":" + i0] = true;
                    openSet.push(i2);
                    openSet.push(i1);
                    openSet.push(i0);
                    openSet.push(i2)
                }
            }
            return this.createArray(points, hullTriangles, hullVertices, outVertexCount)
        },
        createArray: function createArrayFn(points, indices, mapping, vertexCount) {
            var outPoints = new Float32Array(vertexCount * 3);
            var triangleCount = indices.length;
            var outIndices = vertexCount < 65536 ? new Uint16Array(triangleCount) : new Uint32Array(triangleCount);
            var numPoints = points.length / 3;
            var i;
            for (i = 0; i < numPoints; i += 1) {
                if (!(i in mapping)) {
                    continue
                }
                var newIndex = mapping[i] * 3;
                outPoints[newIndex] = points[i * 3];
                outPoints[newIndex + 1] = points[i * 3 + 1];
                outPoints[newIndex + 2] = points[i * 3 + 2]
            }
            for (i = 0; i < triangleCount; i += 1) {
                outIndices[i] = mapping[indices[i]]
            }
            return WebGLPhysicsTriangleArray.create({
                vertices: outPoints,
                indices: outIndices,
                dontCopy: true
            })._private
        }
    };
    var WebGLPhysicsTriangleMeshShape = function() {
        function WebGLPhysicsTriangleMeshShape() {}
        WebGLPhysicsTriangleMeshShape.prototype.rayTest = function(ray) {
            return this.triangleArray.rayTest(ray)
        };
        WebGLPhysicsTriangleMeshShape.create = function(params) {
            var rett = new WebGLPhysicsShape;
            var t = new WebGLPhysicsTriangleMeshShape;
            rett._private = t;
            t._public = rett;
            var margin = params.margin !== undefined ? params.margin : .04;
            var triangleArray = params.triangleArray._private;
            var extents = triangleArray.extents;
            var e0 = extents[0];
            var e1 = extents[1];
            var e2 = extents[2];
            var e3 = extents[3];
            var e4 = extents[4];
            var e5 = extents[5];
            var h0 = .5 * (e3 - e0) + margin;
            var h1 = .5 * (e4 - e1) + margin;
            var h2 = .5 * (e5 - e2) + margin;
            var c0 = .5 * (e0 + e3);
            var c1 = .5 * (e1 + e4);
            var c2 = .5 * (e2 + e5);
            var buffer = new Float32Array(6);
            t.triangleArray = triangleArray;
            t.radius = Math.sqrt(h0 * h0 + h1 * h1 + h2 * h2);
            t.halfExtents = VMath.v3Build(h0, h1, h2, buffer.subarray(0, 3));
            if (c0 !== 0 || c1 !== 0 || c2 !== 0) {
                t.center = VMath.v3Build(c0, c1, c2)
            } else {
                t.center = undefined
            }
            t.inertia = VMath.v3Build(0, 0, 0, buffer.subarray(3, 6));
            t.collisionRadius = margin;
            initShapeProperties(rett, "TRIANGLE_MESH");
            Object.defineProperty(rett, "triangleArray", {
                get: function shapeGetTriangleArray() {
                    return this._private.triangleArray
                },
                enumerable: true
            });
            return rett
        };
        WebGLPhysicsTriangleMeshShape.version = 1;
        return WebGLPhysicsTriangleMeshShape
    }();
    WebGLPhysicsTriangleMeshShape.prototype.type = "TRIANGLE_MESH";
    var WebGLPhysicsConvexHullShape = function() {
        function WebGLPhysicsConvexHullShape() {}
        WebGLPhysicsConvexHullShape.prototype.rayTest = function(ray) {
            var triangleArray = this.triangleArray;
            if (triangleArray === undefined) {
                return null
            }
            return triangleArray.rayTest(ray)
        };
        WebGLPhysicsConvexHullShape.prototype.localSupportWithoutMargin = function(vec, dst) {
            var v0 = vec[0];
            var v1 = vec[1];
            var v2 = vec[2];
            var topology = this.supportTopology;
            var points = this.triangleArray.vertices;
            if (this.lastSupport === undefined) {
                this.lastSupport = 0
            }
            var maxv = this.lastSupport;
            var ind = topology[maxv];
            var max = points[ind] * v0 + points[ind + 1] * v1 + points[ind + 2] * v2;
            for (;;) {
                var next = -1;
                var n;
                var maxN = topology[maxv + 1];
                for (n = 0; n < maxN; n += 1) {
                    var v = topology[maxv + 2 + n];
                    ind = topology[v];
                    var vdot = points[ind] * v0 + points[ind + 1] * v1 + points[ind + 2] * v2;
                    if (vdot > max) {
                        max = vdot;
                        next = v
                    }
                }
                if (next !== -1) {
                    maxv = next;
                    continue
                } else {
                    break
                }
            }
            this.lastSupport = maxv;
            ind = topology[maxv];
            dst[0] = points[ind];
            dst[1] = points[ind + 1];
            dst[2] = points[ind + 2]
        };
        WebGLPhysicsConvexHullShape.create = function(params) {
            var retc = new WebGLPhysicsShape;
            var c = new WebGLPhysicsConvexHullShape;
            retc._private = c;
            c._public = retc;
            var margin = params.margin !== undefined ? params.margin : .04;
            var points = params.points;
            var minExtent = params.minExtent;
            var maxExtent = params.maxExtent;
            var min0, min1, min2, max0, max1, max2;
            if (!minExtent || !maxExtent) {
                min0 = points[0];
                min1 = points[1];
                min2 = points[2];
                max0 = min0;
                max1 = min1;
                max2 = min2;
                var maxN = points.length;
                var n;
                var v0, v1, v2;
                for (n = 3; n < maxN; n += 3) {
                    v0 = points[n];
                    v1 = points[n + 1];
                    v2 = points[n + 2];
                    if (min0 > v0) {
                        min0 = v0
                    } else if (max0 < v0) {
                        max0 = v0
                    }
                    if (min1 > v1) {
                        min1 = v1
                    } else if (max1 < v1) {
                        max1 = v1
                    }
                    if (min2 > v2) {
                        min2 = v2
                    } else if (max2 < v2) {
                        max2 = v2
                    }
                }
            } else {
                min0 = minExtent[0];
                min1 = minExtent[1];
                min2 = minExtent[2];
                max0 = maxExtent[0];
                max1 = maxExtent[1];
                max2 = maxExtent[2]
            }
            var h0 = .5 * (max0 - min0) + margin;
            var h1 = .5 * (max1 - min1) + margin;
            var h2 = .5 * (max2 - min2) + margin;
            var c0 = .5 * (min0 + max0);
            var c1 = .5 * (min1 + max1);
            var c2 = .5 * (min2 + max2);
            var lx = 2 * h0;
            var ly = 2 * h1;
            var lz = 2 * h2;
            lx *= lx;
            ly *= ly;
            lz *= lz;
            var massRatio = 1 / 12;
            var buffer = new Float32Array(6);
            c.points = new Float32Array(points);
            c.radius = Math.sqrt(h0 * h0 + h1 * h1 + h2 * h2);
            c.halfExtents = VMath.v3Build(h0, h1, h2, buffer.subarray(0, 3));
            if (c0 !== 0 || c1 !== 0 || c2 !== 0) {
                c.center = VMath.v3Build(c0, c1, c2)
            } else {
                c.center = undefined
            }
            c.inertia = VMath.v3Build(massRatio * (ly + lz), massRatio * (lx + lz), massRatio * (lx + ly), buffer.subarray(3, 6));
            c.collisionRadius = margin;
            if (points.length < 9) {
                throw "At present time, WebGL PhysicsDevice does not permit a convex hull to contain " + "less than 3 vertices"
            } else {
                var planar = WebGLPhysicsConvexHullHelpers.isPlanar(points);
                if (planar) {
                    c.triangleArray = WebGLPhysicsConvexHullHelpers.makePlanarConvexHull(points)
                } else {
                    c.triangleArray = WebGLPhysicsConvexHullHelpers.makeConvexHull(points)
                }
                var supportTopology = [];
                points = c.triangleArray.vertices;
                maxN = points.length;
                for (n = 0; n < maxN; n += 3) {
                    supportTopology[n / 3] = []
                }
                var m;
                if (planar) {
                    for (n = 0; n < maxN / 3; n += 1) {
                        m = (n + 1) % (maxN / 3);
                        supportTopology[n].push(m);
                        supportTopology[m].push(n)
                    }
                } else {
                    var triangles = c.triangleArray.indices;
                    maxN = triangles.length;
                    for (n = 0; n < maxN; n += 3) {
                        var i0 = triangles[n];
                        var i1 = triangles[n + 1];
                        var i2 = triangles[n + 2];
                        supportTopology[i0].push(i1);
                        supportTopology[i1].push(i2);
                        supportTopology[i2].push(i0)
                    }
                }
                maxN = points.length;
                if (planar && maxN >= 3 * 6 || !planar && maxN >= 3 * 10) {
                    for (n = 0; n < maxN; n += 3) {
                        var min = Number.MAX_VALUE;
                        v0 = points[n];
                        v1 = points[n + 1];
                        v2 = points[n + 2];
                        var minm;
                        for (m = 0; m < maxN; m += 3) {
                            var dot = v0 * points[m] + v1 * points[m + 1] + v2 * points[m + 2];
                            if (dot < min) {
                                min = dot;
                                minm = m
                            }
                        }
                        supportTopology[n / 3].push(minm / 3)
                    }
                }
                var mapping = [];
                var size = 0;
                for (n = 0; n < maxN / 3; n += 1) {
                    mapping.push(size);
                    size += supportTopology[n].length + 2
                }
                c.supportTopology = size > 65536 ? new Uint32Array(size) : new Uint16Array(size);
                var index = 0;
                for (n = 0; n < maxN / 3; n += 1) {
                    c.supportTopology[index] = n * 3;
                    index += 1;
                    var topology = supportTopology[n];
                    c.supportTopology[index] = topology.length;
                    index += 1;
                    for (m = 0; m < topology.length; m += 1) {
                        c.supportTopology[index] = mapping[topology[m]];
                        index += 1
                    }
                }
            }
            initShapeProperties(retc, "CONVEX_HULL");
            return retc
        };
        WebGLPhysicsConvexHullShape.version = 1;
        return WebGLPhysicsConvexHullShape
    }();
    WebGLPhysicsConvexHullShape.prototype.type = "CONVEX_HULL";
    var WebGLPhysicsPrivateBody = function() {
        function WebGLPhysicsPrivateBody(params, publicObject) {
            this._public = publicObject;
            this.id = WebGLPhysicsPrivateBody.uniqueId;
            WebGLPhysicsPrivateBody.uniqueId += 1;
            this.world = null;
            this.shape = params.shape._private;
            this.friction = params.friction !== undefined ? params.friction : .5;
            this.restitution = params.restitution !== undefined ? params.restitution : 0;
            var buffer = new Float32Array(12 + 12 + 6 + 12 + 12 + 12 + 12);
            var bufferIndex = 0;
            var xform = params.transform;
            this.transform = xform ? VMath.m43Copy(xform, buffer.subarray(bufferIndex, bufferIndex + 12)) : VMath.m43BuildIdentity(buffer.subarray(bufferIndex, bufferIndex + 12));
            bufferIndex += 12;
            this.arbiters = [];
            this.constraints = [];
            this.velocity = buffer.subarray(bufferIndex, bufferIndex + 12);
            bufferIndex += 12;
            var vel = params.linearVelocity;
            if (vel) {
                this.velocity[0] = vel[0];
                this.velocity[1] = vel[1];
                this.velocity[2] = vel[2]
            }
            vel = params.angularVelocity;
            if (vel) {
                this.velocity[3] = vel[0];
                this.velocity[4] = vel[1];
                this.velocity[5] = vel[2]
            }
            this.linearDamping = params.linearDamping !== undefined ? params.linearDamping : 0;
            this.angularDamping = params.angularDamping !== undefined ? params.angularDamping : 0;
            this.extents = buffer.subarray(bufferIndex, bufferIndex + 6);
            bufferIndex += 6;
            this.startTransform = VMath.m43BuildIdentity(buffer.subarray(bufferIndex, bufferIndex + 12));
            bufferIndex += 12;
            this.endTransform = VMath.m43BuildIdentity(buffer.subarray(bufferIndex, bufferIndex + 12));
            bufferIndex += 12;
            this.prevTransform = VMath.m43Copy(this.transform, buffer.subarray(bufferIndex, bufferIndex + 12));
            bufferIndex += 12;
            this.newTransform = VMath.m43BuildIdentity(buffer.subarray(bufferIndex, bufferIndex + 12));
            bufferIndex += 12;
            this.island = null;
            this.islandRoot = this;
            this.islandRank = 0;
            this.delaySleep = true;
            this.group = 0;
            this.mask = 0;
            this.kinematic = false;
            this.fixedRotation = false;
            this.mass = 0;
            this.inverseMass = 0;
            this.inverseInertiaLocal = null;
            this.inverseInertia = null;
            this.collisionObject = false;
            this.permitSleep = false;
            this.sweepFrozen = false;
            this.active = false;
            this.contactCallbacks = null
        }
        WebGLPhysicsPrivateBody.prototype.computeDeltaVelocity = function(timeStep, from, to, inputVelocity) {
            var velocity = inputVelocity || this.velocity;
            var active = false;
            velocity[0] = to[9] - from[9];
            velocity[1] = to[10] - from[10];
            velocity[2] = to[11] - from[11];
            if (velocity[0] !== 0 || velocity[1] !== 0 || velocity[2] !== 0) {
                active = true
            }
            velocity[0] /= timeStep;
            velocity[1] /= timeStep;
            velocity[2] /= timeStep;
            var m0 = from[0] * to[0] + from[3] * to[3] + from[6] * to[6];
            var m1 = from[0] * to[1] + from[3] * to[4] + from[6] * to[7];
            var m2 = from[0] * to[2] + from[3] * to[5] + from[6] * to[8];
            var m3 = from[1] * to[0] + from[4] * to[3] + from[7] * to[6];
            var m4 = from[1] * to[1] + from[4] * to[4] + from[7] * to[7];
            var m5 = from[1] * to[2] + from[4] * to[5] + from[7] * to[8];
            var m6 = from[2] * to[0] + from[5] * to[3] + from[8] * to[6];
            var m7 = from[2] * to[1] + from[5] * to[4] + from[8] * to[7];
            var m8 = from[2] * to[2] + from[5] * to[5] + from[8] * to[8];
            var x, y, z, w, s;
            var trace = m0 + m4 + m8 + 1;
            if (trace > VMath.precision) {
                w = Math.sqrt(trace) / 2;
                x = (m5 - m7) / (4 * w);
                y = (m6 - m2) / (4 * w);
                z = (m1 - m3) / (4 * w)
            } else {
                if (m0 > m4 && m0 > m8) {
                    s = Math.sqrt(1 + m0 - m4 - m8) * 2;
                    w = (m5 - m7) / s;
                    x = .25 * s;
                    y = (m3 + m1) / s;
                    z = (m6 + m2) / s
                } else if (m4 > m8) {
                    s = Math.sqrt(1 + m4 - m0 - m8) * 2;
                    w = (m6 - m2) / s;
                    x = (m3 + m1) / s;
                    y = .25 * s;
                    z = (m7 + m5) / s
                } else {
                    s = Math.sqrt(1 + m8 - m0 - m4) * 2;
                    w = (m1 - m3) / s;
                    x = (m6 + m2) / s;
                    y = (m7 + m5) / s;
                    z = .25 * s
                }
            }
            var angle = Math.acos(w) * 2;
            var sin_sqrd = 1 - w * w;
            if (sin_sqrd < VMath.precision || angle === 0) {
                velocity[3] = velocity[4] = velocity[5] = 0
            } else {
                var scale = angle / (timeStep * Math.sqrt(sin_sqrd));
                velocity[3] = x * scale;
                velocity[4] = y * scale;
                velocity[5] = z * scale;
                active = true
            }
            return active
        };
        WebGLPhysicsPrivateBody.prototype.calculateSweptExtents = function(extents) {
            var shape = this.shape;
            var radius = shape.radius;
            var startTransform = this.startTransform;
            var x0 = startTransform[9];
            var x1 = startTransform[10];
            var x2 = startTransform[11];
            var transform = this.transform;
            var y0 = transform[9];
            var y1 = transform[10];
            var y2 = transform[11];
            var tmp;
            if (x0 > y0) {
                tmp = x0;
                x0 = y0;
                y0 = tmp
            }
            if (x1 > y1) {
                tmp = x1;
                x1 = y1;
                y1 = tmp
            }
            if (x2 > y2) {
                tmp = x2;
                x2 = y2;
                y2 = tmp
            }
            extents[0] = x0 - radius;
            extents[1] = x1 - radius;
            extents[2] = x2 - radius;
            extents[3] = y0 + radius;
            extents[4] = y1 + radius;
            extents[5] = y2 + radius
        };
        WebGLPhysicsPrivateBody.prototype.calculateExtents = function(extents) {
            var shape = this.shape;
            var center = shape.center;
            var halfExtents = shape.halfExtents;
            var h0 = halfExtents[0];
            var h1 = halfExtents[1];
            var h2 = halfExtents[2];
            var transform = this.transform;
            var m0 = transform[0];
            var m1 = transform[1];
            var m2 = transform[2];
            var m3 = transform[3];
            var m4 = transform[4];
            var m5 = transform[5];
            var m6 = transform[6];
            var m7 = transform[7];
            var m8 = transform[8];
            var ct0 = transform[9];
            var ct1 = transform[10];
            var ct2 = transform[11];
            if (center) {
                var c0 = center[0];
                var c1 = center[1];
                var c2 = center[2];
                if (c0 !== 0 || c1 !== 0 || c2 !== 0) {
                    ct0 += m0 * c0 + m3 * c1 + m6 * c2;
                    ct1 += m1 * c0 + m4 * c1 + m7 * c2;
                    ct2 += m2 * c0 + m5 * c1 + m8 * c2
                }
            }
            var ht0 = (m0 < 0 ? -m0 * h0 : m0 > 0 ? m0 * h0 : 0) + (m3 < 0 ? -m3 * h1 : m3 > 0 ? m3 * h1 : 0) + (m6 < 0 ? -m6 * h2 : m6 > 0 ? m6 * h2 : 0);
            var ht1 = (m1 < 0 ? -m1 * h0 : m1 > 0 ? m1 * h0 : 0) + (m4 < 0 ? -m4 * h1 : m4 > 0 ? m4 * h1 : 0) + (m7 < 0 ? -m7 * h2 : m7 > 0 ? m7 * h2 : 0);
            var ht2 = (m2 < 0 ? -m2 * h0 : m2 > 0 ? m2 * h0 : 0) + (m5 < 0 ? -m5 * h1 : m5 > 0 ? m5 * h1 : 0) + (m8 < 0 ? -m8 * h2 : m8 > 0 ? m8 * h2 : 0);
            extents[0] = ct0 - ht0;
            extents[1] = ct1 - ht1;
            extents[2] = ct2 - ht2;
            extents[3] = ct0 + ht0;
            extents[4] = ct1 + ht1;
            extents[5] = ct2 + ht2
        };
        WebGLPhysicsPrivateBody.prototype.rayTest = function(ray) {
            var transform = this.transform;
            var rayT = {
                origin: WebGLPrivatePhysicsWorld.prototype.m43InverseOrthonormalTransformPoint(transform, ray.origin),
                direction: WebGLPrivatePhysicsWorld.prototype.m43InverseOrthonormalTransformVector(transform, ray.direction),
                maxFactor: ray.maxFactor
            };
            var result = this.shape.rayTest(rayT);
            if (result !== null) {
                result.hitPoint = VMath.m43TransformPoint(transform, result.hitPoint, result.hitPoint);
                result.hitNormal = VMath.m43TransformVector(transform, result.hitNormal, result.hitNormal)
            }
            return result
        };
        WebGLPhysicsPrivateBody.prototype.integratePositionWithVelocities = function(transform, outTransform, timeStep, offset) {
            var velocity = this.velocity;
            var sqrt = Math.sqrt;
            outTransform[9] = transform[9] + timeStep * velocity[offset];
            outTransform[10] = transform[10] + timeStep * velocity[offset + 1];
            outTransform[11] = transform[11] + timeStep * velocity[offset + 2];
            var w0 = velocity[offset + 3] * timeStep;
            var w1 = velocity[offset + 4] * timeStep;
            var w2 = velocity[offset + 5] * timeStep;
            var A0 = transform[0];
            var A1 = transform[1];
            var A2 = transform[2];
            var A3 = transform[3];
            var A4 = transform[4];
            var A5 = transform[5];
            var A6 = transform[6];
            var A7 = transform[7];
            var A8 = transform[8];
            var B0 = A0 - w2 * A1 + w1 * A2;
            var B1 = A1 + w2 * A0 - w0 * A2;
            var B2 = A2 - w1 * A0 + w0 * A1;
            var B3 = A3 - w2 * A4 + w1 * A5;
            var B4 = A4 + w2 * A3 - w0 * A5;
            var B5 = A5 - w1 * A3 + w0 * A4;
            var B6 = A6 - w2 * A7 + w1 * A8;
            var B7 = A7 + w2 * A6 - w0 * A8;
            var B8 = A8 - w1 * A6 + w0 * A7;
            var scale = 1 / sqrt(B0 * B0 + B1 * B1 + B2 * B2);
            B0 *= scale;
            B1 *= scale;
            B2 *= scale;
            scale = -(B0 * B3 + B1 * B4 + B2 * B5);
            B3 += B0 * scale;
            B4 += B1 * scale;
            B5 += B2 * scale;
            scale = 1 / sqrt(B3 * B3 + B4 * B4 + B5 * B5);
            B3 *= scale;
            B4 *= scale;
            B5 *= scale;
            scale = -(B0 * B6 + B1 * B7 + B2 * B8);
            B6 += B0 * scale;
            B7 += B1 * scale;
            B8 += B2 * scale;
            scale = -(B3 * B6 + B4 * B7 + B5 * B8);
            B6 += B3 * scale;
            B7 += B4 * scale;
            B8 += B5 * scale;
            scale = 1 / sqrt(B6 * B6 + B7 * B7 + B8 * B8);
            B6 *= scale;
            B7 *= scale;
            B8 *= scale;
            outTransform[0] = B0;
            outTransform[1] = B1;
            outTransform[2] = B2;
            outTransform[3] = B3;
            outTransform[4] = B4;
            outTransform[5] = B5;
            outTransform[6] = B6;
            outTransform[7] = B7;
            outTransform[8] = B8
        };
        WebGLPhysicsPrivateBody.prototype.applyBiasVelocities = function(timeStep) {
            var velocity = this.velocity;
            this.integratePositionWithVelocities(this.transform, this.startTransform, timeStep, 6);
            velocity[6] = velocity[7] = velocity[8] = 0;
            velocity[9] = velocity[10] = velocity[11] = 0
        };
        WebGLPhysicsPrivateBody.prototype.integratePosition = function(timeStep) {
            this.integratePositionWithVelocities(this.startTransform, this.transform, timeStep, 0)
        };
        WebGLPhysicsPrivateBody.prototype.refreshInertiaTensor = function() {
            var A = this.transform;
            var inertia = this.inverseInertiaLocal;
            var i0 = inertia[0];
            var i1 = inertia[1];
            var i2 = inertia[2];
            var A0 = A[0];
            var A1 = A[1];
            var A2 = A[2];
            var A3 = A[3];
            var A4 = A[4];
            var A5 = A[5];
            var A6 = A[6];
            var A7 = A[7];
            var A8 = A[8];
            var I = this.inverseInertia;
            I[0] = A0 * A0 * i0 + A3 * A3 * i1 + A6 * A6 * i2;
            I[1] = A0 * A1 * i0 + A3 * A4 * i1 + A6 * A7 * i2;
            I[2] = A0 * A2 * i0 + A3 * A5 * i1 + A6 * A8 * i2;
            I[3] = A1 * A0 * i0 + A4 * A3 * i1 + A7 * A6 * i2;
            I[4] = A1 * A1 * i0 + A4 * A4 * i1 + A7 * A7 * i2;
            I[5] = A1 * A2 * i0 + A4 * A5 * i1 + A7 * A8 * i2;
            I[6] = A2 * A0 * i0 + A5 * A3 * i1 + A8 * A6 * i2;
            I[7] = A2 * A1 * i0 + A5 * A4 * i1 + A8 * A7 * i2;
            I[8] = A2 * A2 * i0 + A5 * A5 * i1 + A8 * A8 * i2
        };
        WebGLPhysicsPrivateBody.prototype.integrateVelocity = function(gravity, timeStep) {
            var velocity = this.velocity;
            var pow = Math.pow;
            var linDrag = pow(1 - this.linearDamping, timeStep);
            velocity[0] = (velocity[0] + timeStep * gravity[0]) * linDrag;
            velocity[1] = (velocity[1] + timeStep * gravity[1]) * linDrag;
            velocity[2] = (velocity[2] + timeStep * gravity[2]) * linDrag;
            var angDrag = pow(1 - this.angularDamping, timeStep);
            var w0 = velocity[3] * angDrag;
            var w1 = velocity[4] * angDrag;
            var w2 = velocity[5] * angDrag;
            var max_angular = WebGLPhysicsConfig.MAX_ANGULAR / timeStep;
            var wlsq = w0 * w0 + w1 * w1 + w2 * w2;
            if (wlsq > max_angular * max_angular) {
                var scale = max_angular / Math.sqrt(wlsq);
                w0 *= scale;
                w1 *= scale;
                w2 *= scale
            }
            velocity[3] = w0;
            velocity[4] = w1;
            velocity[5] = w2
        };
        WebGLPhysicsPrivateBody.prototype.isActiveVelocity = function(linear, angular) {
            var r = this.shape.radius;
            var velocity = this.velocity;
            var v0 = velocity[0];
            var v1 = velocity[1];
            var v2 = velocity[2];
            var vmag = v0 * v0 + v1 * v1 + v2 * v2;
            if (vmag > linear * r * r) {
                return true
            }
            v0 = velocity[3];
            v1 = velocity[4];
            v2 = velocity[5];
            if (v0 * v0 + v1 * v1 + v2 * v2 > angular) {
                return true
            }
            return false
        };
        WebGLPhysicsPrivateBody.prototype.isActive = function() {
            if (!this.permitSleep) {
                return true
            }
            if (this.isActiveVelocity(WebGLPhysicsConfig.SLEEP_LINEAR_SQ, WebGLPhysicsConfig.SLEEP_ANGULAR_SQ)) {
                this.wakeTimeStamp = this.world.timeStamp;
                return true
            }
            return this.wakeTimeStamp + WebGLPhysicsConfig.SLEEP_DELAY > this.world.timeStamp
        };
        WebGLPhysicsPrivateBody.version = 1;
        WebGLPhysicsPrivateBody.uniqueId = 0;
        return WebGLPhysicsPrivateBody
    }();
    var WebGLPhysicsCollisionObject = function() {
        function WebGLPhysicsCollisionObject() {}
        WebGLPhysicsCollisionObject.prototype.calculateExtents = function(extents) {
            this._private.calculateExtents(extents)
        };
        WebGLPhysicsCollisionObject.prototype.calculateTransform = function(transform, origin) {
            var privateTransform = this._private.transform;
            if (origin) {
                VMath.m43NegOffset(privateTransform, origin, transform)
            } else {
                transform[0] = privateTransform[0];
                transform[1] = privateTransform[1];
                transform[2] = privateTransform[2];
                transform[3] = privateTransform[3];
                transform[4] = privateTransform[4];
                transform[5] = privateTransform[5];
                transform[6] = privateTransform[6];
                transform[7] = privateTransform[7];
                transform[8] = privateTransform[8];
                transform[9] = privateTransform[9];
                transform[10] = privateTransform[10];
                transform[11] = privateTransform[11]
            }
        };
        WebGLPhysicsCollisionObject.prototype.clone = function() {
            return WebGLPhysicsCollisionObject.create(this)
        };
        WebGLPhysicsCollisionObject.create = function(params) {
            var rets = new WebGLPhysicsCollisionObject;
            var s = new WebGLPhysicsPrivateBody(params, rets);
            rets._private = s;
            rets.userData = "userData" in params ? params.userData : null;
            Object.defineProperty(rets, "shape", {
                value: params.shape,
                enumerable: true
            });
            var kinematic = params.kinematic !== undefined ? params.kinematic : false;
            Object.defineProperty(rets, "transform", {
                get: function collisionObjectGetTransform() {
                    return VMath.m43Copy(this._private.transform)
                },
                set: function collisionObjectSetTransform(transform) {
                    var pr = this._private;
                    if (pr.kinematic || !pr.world) {
                        VMath.m43Copy(transform, pr.transform);
                        if (pr.world) {
                            pr.world.wakeBody(pr)
                        }
                    }
                },
                enumerable: true
            });
            var group = params.group !== undefined ? params.group : WebGLPhysicsDevice.prototype.FILTER_STATIC;
            Object.defineProperty(rets, "group", {
                value: group,
                enumerable: true
            });
            var mask = params.mask !== undefined ? params.mask : WebGLPhysicsDevice.prototype.FILTER_ALL ^ WebGLPhysicsDevice.prototype.FILTER_STATIC;
            Object.defineProperty(rets, "mask", {
                value: mask,
                enumerable: true
            });
            Object.defineProperty(rets, "friction", {
                get: function collisionObjectGetFriction() {
                    return this._private.friction
                },
                set: function collisionObjectSetFriction(friction) {
                    var pr = this._private;
                    pr.friction = friction;
                    var arbiters = pr.arbiters;
                    var i;
                    var limit = arbiters.length;
                    for (i = 0; i < limit; i += 1) {
                        arbiters[i].invalidateParameters()
                    }
                },
                enumerable: true
            });
            Object.defineProperty(rets, "restitution", {
                get: function collisionObjectGetFriction() {
                    return this._private.restitution
                },
                set: function collisionObjectSetFriction(restitution) {
                    var pr = this._private;
                    pr.restitution = restitution;
                    var arbiters = pr.arbiters;
                    var i;
                    var limit = arbiters.length;
                    for (i = 0; i < limit; i += 1) {
                        arbiters[i].invalidateParameters()
                    }
                },
                enumerable: true
            });
            Object.defineProperty(rets, "kinematic", {
                value: kinematic,
                enumerable: true
            });
            s.group = group;
            s.mask = mask;
            s.kinematic = kinematic;
            s.fixedRotation = !kinematic;
            s.mass = 0;
            s.inverseMass = 0;
            s.inverseInertiaLocal = WebGLPhysicsCollisionObject.sharedInverseInertiaLocal;
            s.inverseInertia = WebGLPhysicsCollisionObject.sharedInverseInertia;
            s.collisionObject = true;
            s.permitSleep = false;
            s.sweepFrozen = true;
            s.active = kinematic;
            if (params.onPreSolveContact || params.onAddedContacts || params.onProcessedContacts || params.onRemovedContacts) {
                s.contactCallbacks = new WebGLPhysicsContactCallbacks(params, mask)
            } else {
                s.contactCallbacks = null
            }
            return rets
        };
        WebGLPhysicsCollisionObject.version = 1;
        WebGLPhysicsCollisionObject.sharedInverseInertiaLocal = VMath.v3BuildZero();
        WebGLPhysicsCollisionObject.sharedInverseInertia = new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0]);
        return WebGLPhysicsCollisionObject
    }();
    var WebGLPhysicsContactCallbacks = function() {
        function WebGLPhysicsContactCallbacks(params, mask) {
            this.mask = params.contactCallbacksMask !== undefined ? params.contactCallbacksMask : mask;
            this.added = false;
            this.deferred = params.onAddedContacts || params.onProcessedContacts || params.onRemovedContacts;
            this.onPreSolveContact = params.onPreSolveContact || null;
            this.onAddedContacts = params.onAddedContacts || null;
            this.onProcessedContacts = params.onProcessedContacts || null;
            this.onRemovedContacts = params.onRemovedContacts || null;
            this.trigger = params.trigger || false;
            return this
        }
        return WebGLPhysicsContactCallbacks
    }();
    var WebGLPhysicsRigidBody = function() {
        function WebGLPhysicsRigidBody() {
            this.calculateExtents = WebGLPhysicsCollisionObject.prototype.calculateExtents;
            this.calculateTransform = WebGLPhysicsCollisionObject.prototype.calculateTransform
        }
        WebGLPhysicsRigidBody.prototype.clone = function() {
            return WebGLPhysicsRigidBody.create(this)
        };
        WebGLPhysicsRigidBody.create = function(params) {
            var retr = new WebGLPhysicsRigidBody;
            var r = new WebGLPhysicsPrivateBody(params, retr);
            retr._private = r;
            retr.userData = "userData" in params ? params.userData : null;
            Object.defineProperty(retr, "shape", {
                value: params.shape,
                enumerable: true
            });
            Object.defineProperty(retr, "linearVelocity", {
                get: function rigidBodyGetVelocity() {
                    var vel = this._private.velocity;
                    return VMath.v3Build(vel[0], vel[1], vel[2])
                },
                set: function rigidBodySetVelocity(linearVelocity) {
                    var vel = this._private.velocity;
                    vel[0] = linearVelocity[0];
                    vel[1] = linearVelocity[1];
                    vel[2] = linearVelocity[2]
                },
                enumerable: true
            });
            Object.defineProperty(retr, "angularVelocity", {
                get: function rigidBodyGetVelocity() {
                    var vel = this._private.velocity;
                    return VMath.v3Build(vel[3], vel[4], vel[5])
                },
                set: function rigidBodySetVelocity(angularVelocity) {
                    var vel = this._private.velocity;
                    vel[3] = angularVelocity[0];
                    vel[4] = angularVelocity[1];
                    vel[5] = angularVelocity[2]
                },
                enumerable: true
            });
            Object.defineProperty(retr, "transform", {
                get: function rigidBodyGetTransform() {
                    return VMath.m43Copy(this._private.transform)
                },
                set: function rigidBodySetTransform(transform) {
                    var pr = this._private;
                    VMath.m43Copy(transform, pr.transform);
                    var arbiters = pr.arbiters;
                    var i;
                    var limit = arbiters.length;
                    for (i = 0; i < limit; i += 1) {
                        arbiters[i].skipDiscreteCollisions = false
                    }
                },
                enumerable: true
            });
            Object.defineProperty(retr, "active", {
                get: function rigidBodyGetActive() {
                    return this._private.active
                },
                set: function rigidBodySetActive(active) {
                    var pr = this._private;
                    if (active === pr.active) {
                        if (pr.world && active) {
                            pr.wakeTimeStamp = pr.world.timeStamp
                        }
                    } else if (pr.world) {
                        if (active) {
                            pr.world.wakeBody(pr)
                        } else {
                            var list = pr.world.activeBodies;
                            list[list.indexOf(pr)] = list[list.length - 1];
                            list.pop();
                            pr.active = false;
                            var arbiters = pr.arbiters;
                            var n;
                            var maxN = arbiters.length;
                            for (n = 0; n < maxN; n += 1) {
                                var arb = arbiters[n];
                                if (!arb.active) {
                                    continue
                                }
                                arb.active = false;
                                var worldList = pr.world.activeArbiters;
                                worldList[worldList.indexOf(arb)] = worldList[worldList.length - 1];
                                worldList.pop()
                            }
                            pr.world.syncBody(pr)
                        }
                    } else {
                        pr.active = active
                    }
                },
                enumerable: true
            });
            var group = params.group !== undefined ? params.group : WebGLPhysicsDevice.prototype.FILTER_DYNAMIC;
            Object.defineProperty(retr, "group", {
                value: group,
                enumerable: true
            });
            var mask = params.mask !== undefined ? params.mask : WebGLPhysicsDevice.prototype.FILTER_ALL;
            Object.defineProperty(retr, "mask", {
                value: mask,
                enumerable: true
            });
            Object.defineProperty(retr, "friction", {
                get: function rigidBodyGetFriction() {
                    return this._private.friction
                },
                set: function rigidBodySetFriction(friction) {
                    var pr = this._private;
                    pr.friction = friction;
                    var arbiters = pr.arbiters;
                    var i;
                    var limit = arbiters.length;
                    for (i = 0; i < limit; i += 1) {
                        arbiters[i].invalidateParameters()
                    }
                },
                enumerable: true
            });
            Object.defineProperty(retr, "restitution", {
                get: function rigidBodyGetRestitution() {
                    return this._private.restitution
                },
                set: function rigidBodySetRestitution(restitution) {
                    var pr = this._private;
                    pr.restitution = restitution;
                    var arbiters = pr.arbiters;
                    var i;
                    var limit = arbiters.length;
                    for (i = 0; i < limit; i += 1) {
                        arbiters[i].invalidateParameters()
                    }
                },
                enumerable: true
            });
            Object.defineProperty(retr, "linearDamping", {
                get: function rigidBodyGetLinearDamping() {
                    return this._private.linearDamping
                },
                set: function rigidBodySetLinearDamping(linearDamping) {
                    this._private.linearDamping = linearDamping
                },
                enumerable: true
            });
            Object.defineProperty(retr, "angularDamping", {
                get: function rigidBodyGetLinearDamping() {
                    return this._private.angularDamping
                },
                set: function rigidBodySetLinearDamping(angularDamping) {
                    this._private.angularDamping = angularDamping
                },
                enumerable: true
            });
            var kinematic = params.kinematic !== undefined ? params.kinematic : false;
            Object.defineProperty(retr, "kinematic", {
                value: kinematic,
                enumerable: true
            });
            var mass = params.mass !== undefined ? params.mass : 1;
            Object.defineProperty(retr, "mass", {
                value: mass,
                enumerable: true
            });
            var inertia = params.inertia ? VMath.v3Copy(params.inertia) : VMath.v3ScalarMul(params.shape.inertia, mass);
            Object.defineProperty(retr, "inertia", {
                get: function rigidBodyGetInertia() {
                    return VMath.v3Copy(inertia)
                },
                enumerable: true
            });
            r.group = group;
            r.mask = mask;
            r.active = params.active !== undefined ? params.active : params.frozen !== undefined ? !params.frozen : true;
            r.kinematic = kinematic;
            r.fixedRotation = kinematic || (params.fixedRotation !== undefined ? params.fixedRotation : false);
            r.inverseInertiaLocal = r.fixedRotation ? VMath.v3BuildZero() : VMath.v3Build(1 / inertia[0], 1 / inertia[1], 1 / inertia[2]);
            r.inverseInertia = VMath.m33BuildIdentity();
            r.mass = mass;
            r.inverseMass = kinematic ? 0 : 1 / r.mass;
            r.collisionObject = false;
            r.permitSleep = params.permitSleep !== undefined ? params.permitSleep : !kinematic;
            r.sweepFrozen = kinematic;
            if (params.onPreSolveContact || params.onAddedContacts || params.onProcessedContacts || params.onRemovedContacts) {
                r.contactCallbacks = new WebGLPhysicsContactCallbacks(params, mask)
            } else {
                r.contactCallbacks = null
            }
            return retr
        };
        WebGLPhysicsRigidBody.version = 1;
        return WebGLPhysicsRigidBody
    }();
    var WebGLPhysicsConstraint = function() {
        function WebGLPhysicsConstraint() {}
        WebGLPhysicsConstraint.prototype.preStep = function(timeStepRatio, timeStep) {};
        WebGLPhysicsConstraint.prototype.applyCachedImpulses = function() {};
        WebGLPhysicsConstraint.prototype.computeAndApplyImpulses = function() {};
        WebGLPhysicsConstraint.create = function(type, params) {
            var s = new WebGLPhysicsConstraint;
            s.world = null;
            s.userData = null;
            webGLPhysicsClone(s, params);
            s.type = type;
            return s
        };
        WebGLPhysicsConstraint.version = 1;
        return WebGLPhysicsConstraint
    }();
    var initConstraintProperties = function initConstraintPropertiesFn(c, params) {
        c.userData = params.userData;
        var pc = c._private;
        pc.world = null;
        pc.bodyA = params.bodyA._private;
        Object.defineProperty(c, "bodyA", {
            value: params.bodyA,
            enumerable: true
        });
        pc.bodyB = params.bodyB ? params.bodyB._private : null;
        Object.defineProperty(c, "bodyB", {
            value: params.bodyB,
            enumerable: true
        });
        pc.active = params.active !== undefined ? params.active : true;
        Object.defineProperty(c, "active", {
            get: function constraintGetActive() {
                return this._private.active
            },
            set: function constraintSetActive(active) {
                var pc = this._private;
                if (active === pc.active) {
                    if (pc.world && active) {
                        pc.wakeTimeStamp = pc.world.timeStamp
                    }
                } else if (pc.world) {
                    if (active) {
                        pc.world.wakeConstraint(pc)
                    } else {
                        var list = pc.world.activeConstraints;
                        list[list.indexOf(pc)] = list[list.length - 1];
                        list.pop();
                        pc.active = false
                    }
                } else {
                    pc.active = active
                }
            },
            enumerable: true
        })
    };
    var WebGLPhysicsPoint2PointConstraint = function() {
        function WebGLPhysicsPoint2PointConstraint() {}
        WebGLPhysicsPoint2PointConstraint.create = function(params) {
            var c = new WebGLPhysicsPoint2PointConstraint;
            var pc = new WebGLPhysicsPrivatePoint2PointConstraint;
            c._private = pc;
            initConstraintProperties(c, params);
            var data = pc.data;
            data[0] = params.pivotA[0];
            data[1] = params.pivotA[1];
            data[2] = params.pivotA[2];
            Object.defineProperty(c, "pivotA", {
                get: function point2pointGetPivotA() {
                    var data = this._private.data;
                    return VMath.v3Build(data[0], data[1], data[2])
                },
                set: function point2pointSetPivotA(pivotA) {
                    var data = this._private.data;
                    data[0] = pivotA[0];
                    data[1] = pivotA[1];
                    data[2] = pivotA[2]
                },
                enumerable: true
            });
            if (params.pivotB) {
                data[3] = params.pivotB[0];
                data[4] = params.pivotB[1];
                data[5] = params.pivotB[2]
            } else {
                var pivotB = VMath.m43TransformPoint(pc.bodyA.transform, params.pivotA);
                data[3] = pivotB[0];
                data[4] = pivotB[1];
                data[5] = pivotB[2]
            }
            Object.defineProperty(c, "pivotB", {
                get: function point2pointGetPivotB() {
                    var data = this._private.data;
                    return VMath.v3Build(data[3], data[4], data[5])
                },
                set: function point2pointSetPivotB(pivotB) {
                    var data = this._private.data;
                    data[3] = pivotB[0];
                    data[4] = pivotB[1];
                    data[5] = pivotB[2]
                },
                enumerable: true
            });
            data[30] = params.force !== undefined ? params.force : .3;
            Object.defineProperty(c, "force", {
                get: function point2pointGetForce() {
                    return this._private.data[30]
                },
                set: function point2pointSetForce(force) {
                    this._private.data[30] = force
                },
                enumerable: true
            });
            data[31] = params.damping !== undefined ? params.damping : 1;
            Object.defineProperty(c, "damping", {
                get: function point2pointGetForce() {
                    return this._private.data[31]
                },
                set: function point2pointSetForce(damping) {
                    this._private.data[31] = damping
                },
                enumerable: true
            });
            data[32] = params.impulseClamp !== undefined ? params.impulseClamp : 0;
            Object.defineProperty(c, "impulseClamp", {
                get: function point2pointGetForce() {
                    return this._private.data[32]
                },
                set: function point2pointSetForce(impulseClamp) {
                    this._private.data[32] = impulseClamp
                },
                enumerable: true
            });
            return c
        };
        WebGLPhysicsPoint2PointConstraint.version = 1;
        return WebGLPhysicsPoint2PointConstraint
    }();
    WebGLPhysicsPoint2PointConstraint.prototype.type = "POINT2POINT";
    var WebGLPhysicsPrivatePoint2PointConstraint = function() {
        function WebGLPhysicsPrivatePoint2PointConstraint() {
            this.bodyA = null;
            this.bodyB = null;
            this.data = new Float32Array(46);
            return this
        }
        WebGLPhysicsPrivatePoint2PointConstraint.prototype.preStep = function(timeStepRatio, timeStep) {
            var bodyA = this.bodyA;
            var bodyB = this.bodyB;
            var data = this.data;
            var a0 = data[0];
            var a1 = data[1];
            var a2 = data[2];
            var b0 = data[3];
            var b1 = data[4];
            var b2 = data[5];
            var A = bodyA.transform;
            var ra0 = data[6] = A[0] * a0 + A[3] * a1 + A[6] * a2;
            var ra1 = data[7] = A[1] * a0 + A[4] * a1 + A[7] * a2;
            var ra2 = data[8] = A[2] * a0 + A[5] * a1 + A[8] * a2;
            var rb0, rb1, rb2, B;
            if (bodyB) {
                B = bodyB.transform;
                rb0 = data[9] = B[0] * b0 + B[3] * b1 + B[6] * b2;
                rb1 = data[10] = B[1] * b0 + B[4] * b1 + B[7] * b2;
                rb2 = data[11] = B[2] * b0 + B[5] * b1 + B[8] * b2
            }
            var I = bodyA.inverseInertia;
            data[12] = -ra2 * I[3] + ra1 * I[6];
            data[13] = -ra2 * I[4] + ra1 * I[7];
            data[14] = -ra2 * I[5] + ra1 * I[8];
            data[15] = ra2 * I[0] + -ra0 * I[6];
            data[16] = ra2 * I[1] + -ra0 * I[7];
            data[17] = ra2 * I[2] + -ra0 * I[8];
            data[18] = -ra1 * I[0] + ra0 * I[3];
            data[19] = -ra1 * I[1] + ra0 * I[4];
            data[20] = -ra1 * I[2] + ra0 * I[5];
            var mass_sum = bodyA.inverseMass + (bodyB ? bodyB.inverseMass : 0);
            var K0 = mass_sum + data[13] * -ra2 + data[14] * ra1;
            var K3 = mass_sum + data[15] * ra2 + data[17] * -ra0;
            var K5 = mass_sum + data[18] * -ra1 + data[19] * ra0;
            var K1 = data[12] * ra2 + data[14] * -ra0;
            var K2 = data[12] * -ra1 + data[13] * ra0;
            var K4 = data[15] * -ra1 + data[16] * ra0;
            if (bodyB) {
                I = bodyB.inverseInertia;
                data[21] = -rb2 * I[3] + rb1 * I[6];
                data[22] = -rb2 * I[4] + rb1 * I[7];
                data[23] = -rb2 * I[5] + rb1 * I[8];
                data[24] = rb2 * I[0] + -rb0 * I[6];
                data[25] = rb2 * I[1] + -rb0 * I[7];
                data[26] = rb2 * I[2] + -rb0 * I[8];
                data[27] = -rb1 * I[0] + rb0 * I[3];
                data[28] = -rb1 * I[1] + rb0 * I[4];
                data[29] = -rb1 * I[2] + rb0 * I[5];
                K0 += data[22] * -rb2 + data[23] * rb1;
                K3 += data[24] * rb2 + data[26] * -rb0;
                K5 += data[27] * -rb1 + data[28] * rb0;
                K1 += data[21] * rb2 + data[23] * -rb0;
                K2 += data[21] * -rb1 + data[22] * rb0;
                K4 += data[24] * -rb1 + data[25] * rb0
            }
            var force = data[30];
            var omega = 2 / timeStep * force * data[31] / (1 - force);
            var gk = force / (omega * omega);
            var ig = 1 / (1 + gk);
            data[33] = 1 - gk * ig;
            var i0 = K3 * K5 - K4 * K4;
            var i1 = K2 * K4 - K1 * K5;
            var i2 = K1 * K4 - K2 * K3;
            var idet = ig / (K0 * i0 + K1 * i1 + K2 * i2);
            data[34] = idet * i0;
            data[35] = idet * i1;
            data[36] = idet * i2;
            data[37] = idet * (K0 * K5 - K2 * K2);
            data[38] = idet * (K1 * K2 - K0 * K4);
            data[39] = idet * (K0 * K3 - K1 * K1);
            var C0 = ra0 + A[9];
            var C1 = ra1 + A[10];
            var C2 = ra2 + A[11];
            if (bodyB) {
                C0 -= rb0 + B[9];
                C1 -= rb1 + B[10];
                C2 -= rb2 + B[11]
            } else {
                C0 -= b0;
                C1 -= b1;
                C2 -= b2
            }
            var scale = -force / timeStep;
            data[43] = C0 * scale;
            data[44] = C1 * scale;
            data[45] = C2 * scale;
            data[40] *= timeStepRatio;
            data[41] *= timeStepRatio;
            data[42] *= timeStepRatio
        };
        WebGLPhysicsPrivatePoint2PointConstraint.prototype.applyCachedImpulses = function() {
            var data = this.data;
            var j0 = data[40];
            var j1 = data[41];
            var j2 = data[42];
            var bodyA = this.bodyA;
            var vel = bodyA.velocity;
            var imass = bodyA.inverseMass;
            vel[0] += j0 * imass;
            vel[1] += j1 * imass;
            vel[2] += j2 * imass;
            vel[3] -= data[12] * j0 + data[15] * j1 + data[18] * j2;
            vel[4] -= data[13] * j0 + data[16] * j1 + data[19] * j2;
            vel[5] -= data[14] * j0 + data[17] * j1 + data[20] * j2;
            var bodyB = this.bodyB;
            if (bodyB) {
                vel = bodyB.velocity;
                imass = bodyB.inverseMass;
                vel[0] -= j0 * imass;
                vel[1] -= j1 * imass;
                vel[2] -= j2 * imass;
                vel[3] += data[21] * j0 + data[24] * j1 + data[27] * j2;
                vel[4] += data[22] * j0 + data[25] * j1 + data[28] * j2;
                vel[5] += data[23] * j0 + data[26] * j1 + data[29] * j2
            }
        };
        WebGLPhysicsPrivatePoint2PointConstraint.prototype.computeAndApplyImpulses = function() {
            var bodyA = this.bodyA;
            var bodyB = this.bodyB;
            var data = this.data;
            var jAcc0 = data[40];
            var jAcc1 = data[41];
            var jAcc2 = data[42];
            var vel1 = bodyA.velocity;
            var l0 = data[43] - (vel1[0] + vel1[4] * data[8] - vel1[5] * data[7]);
            var l1 = data[44] - (vel1[1] + vel1[5] * data[6] - vel1[3] * data[8]);
            var l2 = data[45] - (vel1[2] + vel1[3] * data[7] - vel1[4] * data[6]);
            var vel2;
            if (bodyB) {
                vel2 = bodyB.velocity;
                l0 += vel2[0] + vel2[4] * data[11] - vel2[5] * data[10];
                l1 += vel2[1] + vel2[5] * data[9] - vel2[3] * data[11];
                l2 += vel2[2] + vel2[3] * data[10] - vel2[4] * data[9]
            }
            var gamma = data[33];
            jAcc0 = jAcc0 * gamma + data[34] * l0 + data[35] * l1 + data[36] * l2;
            jAcc1 = jAcc1 * gamma + data[35] * l0 + data[37] * l1 + data[38] * l2;
            jAcc2 = jAcc2 * gamma + data[36] * l0 + data[38] * l1 + data[39] * l2;
            var clamp = data[32];
            if (clamp !== 0) {
                var jlsq = jAcc0 * jAcc0 + jAcc1 * jAcc1 + jAcc2 * jAcc2;
                if (jlsq > clamp * clamp) {
                    jlsq = clamp / Math.sqrt(jlsq);
                    jAcc0 *= jlsq;
                    jAcc1 *= jlsq;
                    jAcc2 *= jlsq
                }
            }
            var j0 = jAcc0 - data[40];
            var j1 = jAcc1 - data[41];
            var j2 = jAcc2 - data[42];
            data[40] = jAcc0;
            data[41] = jAcc1;
            data[42] = jAcc2;
            var imass = bodyA.inverseMass;
            vel1[0] += j0 * imass;
            vel1[1] += j1 * imass;
            vel1[2] += j2 * imass;
            vel1[3] -= data[12] * j0 + data[15] * j1 + data[18] * j2;
            vel1[4] -= data[13] * j0 + data[16] * j1 + data[19] * j2;
            vel1[5] -= data[14] * j0 + data[17] * j1 + data[20] * j2;
            if (bodyB) {
                imass = bodyB.inverseMass;
                vel2[0] -= j0 * imass;
                vel2[1] -= j1 * imass;
                vel2[2] -= j2 * imass;
                vel2[3] += data[21] * j0 + data[24] * j1 + data[27] * j2;
                vel2[4] += data[22] * j0 + data[25] * j1 + data[28] * j2;
                vel2[5] += data[23] * j0 + data[26] * j1 + data[29] * j2
            }
        };
        return WebGLPhysicsPrivatePoint2PointConstraint
    }();
    var WebGLPhysicsCharacter = function() {
        function WebGLPhysicsCharacter() {}
        WebGLPhysicsCharacter.prototype.jump = function() {
            var pc = this._private;
            var rigidBody = pc.rigidBody._private;
            var world = rigidBody.world;
            if (world) {
                rigidBody.velocity[1] = Math.sqrt(-2 * (this.maxJumpHeight - this.stepHeight) * world.gravity[1]);
                rigidBody.transform[10] += this.stepHeight;
                world.wakeBody(rigidBody)
            }
        };
        WebGLPhysicsCharacter.prototype.calculateExtents = function(extents) {
            this._private.rigidBody.calculateExtents(extents)
        };
        WebGLPhysicsCharacter.prototype.calculateTransform = function(transform, origin) {
            this._private.rigidBody.calculateTransform(transform, origin)
        };
        WebGLPhysicsCharacter.create = function(params) {
            var c = new WebGLPhysicsCharacter;
            var pc = new WebGLPhysicsPrivateCharacter;
            c._private = pc;
            c.userData = params.userData !== undefined ? params.userData : null;
            Object.defineProperty(c, "crouch", {
                get: function getCharacterCrouchFn() {
                    return this._private.crouch
                },
                set: function setCharacterCrouchFn(crouch) {
                    var pc = this._private;
                    if (!pc.dead && crouch !== pc.crouch) {
                        var rigidBody = pc.rigidBody._private;
                        var capsule = rigidBody.shape;
                        pc.crouch = crouch;
                        if (crouch) {
                            capsule.halfHeight = this.crouchHeight * .5 - this.radius;
                            rigidBody.transform[10] -= (this.height - this.crouchHeight) * .5
                        } else {
                            capsule.halfHeight = this.height * .5 - this.radius;
                            rigidBody.transform[10] += (this.height - this.crouchHeight) * .5
                        }
                        if (rigidBody.world) {
                            rigidBody.world.wakeBody(rigidBody)
                        }
                    }
                },
                enumerable: true
            });
            Object.defineProperty(c, "dead", {
                get: function getCharacterDeadFn() {
                    return this._private.dead
                },
                set: function setCharacterDead(dead) {
                    var pc = this._private;
                    if (pc.dead !== dead) {
                        var rigidBody = pc.rigidBody._private;
                        var capsule = rigidBody.shape;
                        pc.dead = dead;
                        if (dead) {
                            capsule.halfHeight = 0;
                            rigidBody.transform[10] -= (this.height - this.radius) * .5
                        } else {
                            capsule.halfHeight = this.height * .5 - this.radius;
                            rigidBody.transform[10] += (this.height - this.radius) * .5
                        }
                        if (rigidBody.world) {
                            rigidBody.world.wakeBody(rigidBody)
                        }
                    }
                },
                enumerable: true
            });
            Object.defineProperty(c, "height", {
                value: params.height,
                enumerable: true
            });
            Object.defineProperty(c, "radius", {
                value: params.radius,
                enumerable: true
            });
            Object.defineProperty(c, "stepHeight", {
                value: params.stepHeight !== undefined ? params.stepHeight : .35,
                enumerable: true
            });
            c.maxJumpHeight = params.maxJumpHeight !== undefined ? params.maxJumpHeight : 1;
            Object.defineProperty(c, "crouchHeight", {
                value: params.crouchHeight !== undefined ? params.crouchHeight : .5 * params.height,
                enumerable: true
            });
            Object.defineProperty(c, "onGround", {
                get: function getCharacterOnGround() {
                    var pc = this._private;
                    var rigidBody = pc.rigidBody._private;
                    if (rigidBody.world) {
                        var pos = rigidBody.transform;
                        var start = pc.start;
                        var end = pc.end;
                        start[9] = pos[9];
                        start[10] = pos[10];
                        start[11] = pos[11];
                        end[9] = pos[9];
                        end[10] = pos[10] - this.stepHeight * .5;
                        end[11] = pos[11];
                        var result = rigidBody.world.convexSweepTest({
                            shape: rigidBody.shape._public,
                            from: start,
                            to: end,
                            group: WebGLPhysicsDevice.prototype.FILTER_CHARACTER
                        }, pc.onGroundConvexCallback);
                        return result !== null
                    } else {
                        return false
                    }
                },
                enumerable: true
            });
            Object.defineProperty(c, "position", {
                get: function getCharacterPosition() {
                    var rigidBody = this._private.rigidBody;
                    return VMath.m43Pos(rigidBody._private.transform)
                },
                set: function setCharacterPosition(position) {
                    var rigidBody = this._private.rigidBody;
                    var transform = rigidBody._private.transform;
                    transform[9] = position[0];
                    transform[10] = position[1];
                    transform[11] = position[2];
                    rigidBody.transform = rigidBody._private.transform;
                    rigidBody.active = true
                },
                enumerable: true
            });
            Object.defineProperty(c, "velocity", {
                get: function getCharacterVelocity() {
                    var rigidBody = this._private.rigidBody;
                    return rigidBody.linearVelocity
                },
                set: function setCharacterVelocity(velocity) {
                    var rigidBody = this._private.rigidBody;
                    rigidBody.linearVelocity = velocity;
                    rigidBody.active = true
                },
                enumerable: true
            });
            var group = params.group !== undefined ? params.group : WebGLPhysicsDevice.prototype.FILTER_CHARACTER;
            Object.defineProperty(c, "group", {
                value: group,
                enumerable: true
            });
            var mask = params.mask !== undefined ? params.mask : WebGLPhysicsDevice.prototype.FILTER_ALL;
            Object.defineProperty(c, "mask", {
                value: mask,
                enumerable: true
            });
            var capsule = WebGLPhysicsCapsuleShape.create({
                radius: c.radius,
                height: 2 * (c.height * .5 - c.radius),
                margin: 0
            });
            var rigidBody = WebGLPhysicsRigidBody.create({
                shape: capsule,
                mass: params.mass,
                transform: params.transform,
                linearVelocity: params.velocity,
                group: group,
                mask: mask,
                friction: params.friction,
                restitution: params.restitution,
                linearDamping: params.linearDamping,
                angularDamping: params.angularDamping,
                fixedRotation: true
            });
            pc.rigidBody = rigidBody;
            rigidBody._private._public = c;
            return c
        };
        WebGLPhysicsCharacter.version = 1;
        return WebGLPhysicsCharacter
    }();
    var WebGLPhysicsPrivateCharacter = function() {
        function WebGLPhysicsPrivateCharacter() {
            this.crouch = false;
            this.dead = false;
            this.start = VMath.m43BuildIdentity();
            this.end = VMath.m43BuildIdentity();
            this.rigidBody = null;
            return this
        }
        WebGLPhysicsPrivateCharacter.prototype.onGroundConvexCallback = function(hitResult) {
            return hitResult.hitNormal[1] >= .26
        };
        WebGLPhysicsPrivateCharacter.version = 1;
        return WebGLPhysicsPrivateCharacter
    }();
    var WebGLGJKContactSolver = function() {
        function WebGLGJKContactSolver() {}
        WebGLGJKContactSolver.prototype.removeVertex = function(index) {
            this.numVertices -= 1;
            var simplex = this.simplex;
            var replace = index * 9;
            var withv = this.numVertices * 9;
            simplex[replace] = simplex[withv];
            simplex[replace + 1] = simplex[withv + 1];
            simplex[replace + 2] = simplex[withv + 2];
            simplex[replace + 3] = simplex[withv + 3];
            simplex[replace + 4] = simplex[withv + 4];
            simplex[replace + 5] = simplex[withv + 5];
            simplex[replace + 6] = simplex[withv + 6];
            simplex[replace + 7] = simplex[withv + 7];
            simplex[replace + 8] = simplex[withv + 8]
        };
        WebGLGJKContactSolver.prototype.reduceVertices = function(coords) {
            if (this.numVertices >= 4 && coords[3] === 0) {
                this.numVertices -= 1
            }
            var simplex = this.simplex;
            var withv;
            if (this.numVertices >= 3 && coords[2] === 0) {
                this.numVertices -= 1;
                withv = this.numVertices * 9;
                simplex[18] = simplex[withv];
                simplex[19] = simplex[withv + 1];
                simplex[20] = simplex[withv + 2];
                simplex[21] = simplex[withv + 3];
                simplex[22] = simplex[withv + 4];
                simplex[23] = simplex[withv + 5];
                simplex[24] = simplex[withv + 6];
                simplex[25] = simplex[withv + 7];
                simplex[26] = simplex[withv + 8]
            }
            if (this.numVertices >= 2 && coords[1] === 0) {
                this.numVertices -= 1;
                withv = this.numVertices * 9;
                simplex[9] = simplex[withv];
                simplex[10] = simplex[withv + 1];
                simplex[11] = simplex[withv + 2];
                simplex[12] = simplex[withv + 3];
                simplex[13] = simplex[withv + 4];
                simplex[14] = simplex[withv + 5];
                simplex[15] = simplex[withv + 6];
                simplex[16] = simplex[withv + 7];
                simplex[17] = simplex[withv + 8]
            }
            if (this.numVertices >= 1 && coords[0] === 0) {
                this.numVertices -= 1;
                withv = this.numVertices * 9;
                simplex[0] = simplex[withv];
                simplex[1] = simplex[withv + 1];
                simplex[2] = simplex[withv + 2];
                simplex[3] = simplex[withv + 3];
                simplex[4] = simplex[withv + 4];
                simplex[5] = simplex[withv + 5];
                simplex[6] = simplex[withv + 6];
                simplex[7] = simplex[withv + 7];
                simplex[8] = simplex[withv + 8]
            }
        };
        WebGLGJKContactSolver.prototype.updateClosestPoints = function() {
            var numVertices = this.numVertices;
            if (numVertices === 0) {
                return false
            }
            var simplex = this.simplex;
            var closest = this.closest;
            var i;
            if (numVertices === 1) {
                closest[0] = simplex[3];
                closest[1] = simplex[4];
                closest[2] = simplex[5];
                closest[3] = simplex[6];
                closest[4] = simplex[7];
                closest[5] = simplex[8];
                return true
            }
            var a0 = simplex[0];
            var a1 = simplex[1];
            var a2 = simplex[2];
            var b0 = simplex[9];
            var b1 = simplex[10];
            var b2 = simplex[11];
            if (numVertices === 2) {
                var w0 = a0 - b0;
                var w1 = a1 - b1;
                var w2 = a2 - b2;
                var dot = a0 * w0 + a1 * w1 + a2 * w2;
                if (dot > 0) {
                    var wlsq = w0 * w0 + w1 * w1 + w2 * w2;
                    if (dot < wlsq) {
                        dot /= wlsq;
                        var dot1 = 1 - dot;
                        closest[0] = simplex[3] * dot1 + simplex[12] * dot;
                        closest[1] = simplex[4] * dot1 + simplex[13] * dot;
                        closest[2] = simplex[5] * dot1 + simplex[14] * dot;
                        closest[3] = simplex[6] * dot1 + simplex[15] * dot;
                        closest[4] = simplex[7] * dot1 + simplex[16] * dot;
                        closest[5] = simplex[8] * dot1 + simplex[17] * dot;
                        return true
                    } else {
                        this.removeVertex(0)
                    }
                } else {
                    this.removeVertex(1)
                }
                for (i = 0; i < 6; i += 1) {
                    closest[i] = simplex[i + 3]
                }
                return true
            }
            var coords = this.cachedCoords;
            var alpha, beta, gamma;
            if (numVertices === 3) {
                this.closestPointTriangle(0, 9, 18, coords);
                this.reduceVertices(coords);
                alpha = coords[0];
                beta = coords[1];
                gamma = coords[2];
                closest[0] = alpha * simplex[3] + beta * simplex[12] + gamma * simplex[21];
                closest[1] = alpha * simplex[4] + beta * simplex[13] + gamma * simplex[22];
                closest[2] = alpha * simplex[5] + beta * simplex[14] + gamma * simplex[23];
                closest[3] = alpha * simplex[6] + beta * simplex[15] + gamma * simplex[24];
                closest[4] = alpha * simplex[7] + beta * simplex[16] + gamma * simplex[25];
                closest[5] = alpha * simplex[8] + beta * simplex[17] + gamma * simplex[26];
                return true
            }
            if (numVertices === 4) {
                var outside = this.closestPointTetrahedron(coords);
                if (outside) {
                    this.reduceVertices(coords);
                    alpha = coords[0];
                    beta = coords[1];
                    gamma = coords[2];
                    var delta = coords[3];
                    closest[0] = alpha * simplex[3] + beta * simplex[12] + gamma * simplex[21] + delta * simplex[30];
                    closest[1] = alpha * simplex[4] + beta * simplex[13] + gamma * simplex[22] + delta * simplex[31];
                    closest[2] = alpha * simplex[5] + beta * simplex[14] + gamma * simplex[23] + delta * simplex[32];
                    closest[3] = alpha * simplex[6] + beta * simplex[15] + gamma * simplex[24] + delta * simplex[33];
                    closest[4] = alpha * simplex[7] + beta * simplex[16] + gamma * simplex[25] + delta * simplex[34];
                    closest[5] = alpha * simplex[8] + beta * simplex[17] + gamma * simplex[26] + delta * simplex[35];
                    return true
                } else {
                    return false
                }
            }
            return false
        };
        WebGLGJKContactSolver.prototype.closestPointTetrahedron = function(coords) {
            var simplex = this.simplex;
            var a0 = simplex[0];
            var a1 = simplex[1];
            var a2 = simplex[2];
            var b0 = simplex[9];
            var b1 = simplex[10];
            var b2 = simplex[11];
            var c0 = simplex[18];
            var c1 = simplex[19];
            var c2 = simplex[20];
            var d0 = simplex[27];
            var d1 = simplex[28];
            var d2 = simplex[29];
            var ab0 = b0 - a0;
            var ab1 = b1 - a1;
            var ab2 = b2 - a2;
            var ac0 = c0 - a0;
            var ac1 = c1 - a1;
            var ac2 = c2 - a2;
            var ad0 = d0 - a0;
            var ad1 = d1 - a1;
            var ad2 = d2 - a2;
            var bc0 = c0 - b0;
            var bc1 = c1 - b1;
            var bc2 = c2 - b2;
            var bd0 = d0 - b0;
            var bd1 = d1 - b1;
            var bd2 = d2 - b2;
            var n0, n1, n2, signD, signOrigin;
            n0 = ab1 * ac2 - ab2 * ac1;
            n1 = ab2 * ac0 - ab0 * ac2;
            n2 = ab0 * ac1 - ab1 * ac0;
            signD = ad0 * n0 + ad1 * n1 + ad2 * n2;
            signOrigin = -(a0 * n0 + a1 * n1 + a2 * n2);
            var sideABC = signOrigin * signD <= 0;
            n0 = ac1 * ad2 - ac2 * ad1;
            n1 = ac2 * ad0 - ac0 * ad2;
            n2 = ac0 * ad1 - ac1 * ad0;
            signD = ab0 * n0 + ab1 * n1 + ab2 * n2;
            signOrigin = -(a0 * n0 + a1 * n1 + a2 * n2);
            var sideACD = signOrigin * signD <= 0;
            n0 = ad1 * ab2 - ad2 * ab1;
            n1 = ad2 * ab0 - ad0 * ab2;
            n2 = ad0 * ab1 - ad1 * ab0;
            signD = ac0 * n0 + ac1 * n1 + ac2 * n2;
            signOrigin = -(a0 * n0 + a1 * n1 + a2 * n2);
            var sideADB = signOrigin * signD <= 0;
            n0 = bd1 * bc2 - bd2 * bc1;
            n1 = bd2 * bc0 - bd0 * bc2;
            n2 = bd0 * bc1 - bd1 * bc0;
            signD = ab0 * n0 + ab1 * n1 + ab2 * n2;
            signOrigin = b0 * n0 + b1 * n1 + b2 * n2;
            var sideBDC = signOrigin * signD <= 0;
            coords[0] = coords[1] = coords[2] = coords[3] = 0;
            if (!sideABC && !sideACD && !sideADB && !sideBDC) {
                return false
            }
            var tempCoords = this.tempCoords;
            var minSqDist = Number.MAX_VALUE;
            var sqDist;
            if (sideABC) {
                sqDist = this.closestPointTriangle(0, 9, 18, tempCoords, true);
                if (sqDist < minSqDist) {
                    minSqDist = sqDist;
                    coords[0] = tempCoords[0];
                    coords[1] = tempCoords[1];
                    coords[2] = tempCoords[2];
                    coords[3] = 0
                }
            }
            if (sideACD) {
                sqDist = this.closestPointTriangle(0, 18, 27, tempCoords, true);
                if (sqDist < minSqDist) {
                    minSqDist = sqDist;
                    coords[0] = tempCoords[0];
                    coords[1] = 0;
                    coords[2] = tempCoords[1];
                    coords[3] = tempCoords[2]
                }
            }
            if (sideADB) {
                sqDist = this.closestPointTriangle(0, 27, 9, tempCoords, true);
                if (sqDist < minSqDist) {
                    minSqDist = sqDist;
                    coords[0] = tempCoords[0];
                    coords[1] = tempCoords[2];
                    coords[2] = 0;
                    coords[3] = tempCoords[1]
                }
            }
            if (sideBDC) {
                sqDist = this.closestPointTriangle(9, 27, 18, tempCoords, true);
                if (sqDist < minSqDist) {
                    minSqDist = sqDist;
                    coords[0] = 0;
                    coords[1] = tempCoords[0];
                    coords[2] = tempCoords[2];
                    coords[3] = tempCoords[1]
                }
            }
            return true
        };
        WebGLGJKContactSolver.prototype.closestPointTriangle = function(a, b, c, coords, computeDistance) {
            var simplex = this.simplex;
            var a0 = simplex[a];
            var a1 = simplex[a + 1];
            var a2 = simplex[a + 2];
            var b0 = simplex[b];
            var b1 = simplex[b + 1];
            var b2 = simplex[b + 2];
            var c0 = simplex[c];
            var c1 = simplex[c + 1];
            var c2 = simplex[c + 2];
            var ba0 = a0 - b0;
            var ba1 = a1 - b1;
            var ba2 = a2 - b2;
            var ca0 = a0 - c0;
            var ca1 = a1 - c1;
            var ca2 = a2 - c2;
            var dot1 = a0 * ba0 + a1 * ba1 + a2 * ba2;
            var dot2 = a0 * ca0 + a1 * ca1 + a2 * ca2;
            if (dot1 <= 0 && dot2 <= 0) {
                coords[0] = 1;
                coords[1] = coords[2] = 0;
                if (computeDistance) {
                    return a0 * a0 + a1 * a1 + a2 * a2
                } else {
                    return undefined
                }
            }
            var dot3 = b0 * ba0 + b1 * ba1 + b2 * ba2;
            var dot4 = b0 * ca0 + b1 * ca1 + b2 * ca2;
            if (dot3 >= 0 && dot4 <= dot3) {
                coords[1] = 1;
                coords[0] = coords[2] = 0;
                if (computeDistance) {
                    return b0 * b0 + b1 * b1 + b2 * b2
                } else {
                    return undefined
                }
            }
            var v;
            var d0, d1, d2;
            var vc = dot1 * dot4 - dot3 * dot2;
            if (vc <= 0 && dot1 >= 0 && dot3 <= 0) {
                v = dot1 / (dot1 - dot3);
                coords[0] = 1 - v;
                coords[1] = v;
                coords[2] = 0;
                if (computeDistance) {
                    d0 = a0 - v * ba0;
                    d1 = a1 - v * ba1;
                    d2 = a2 - v * ba2;
                    return d0 * d0 + d1 * d1 + d2 * d2
                } else {
                    return undefined
                }
            }
            var dot5 = c0 * ba0 + c1 * ba1 + c2 * ba2;
            var dot6 = c0 * ca0 + c1 * ca1 + c2 * ca2;
            if (dot6 >= 0 && dot5 <= dot6) {
                coords[0] = coords[1] = 0;
                coords[2] = 1;
                if (computeDistance) {
                    return c0 * c0 + c1 * c1 + c2 * c2
                } else {
                    return undefined
                }
            }
            var vb = dot5 * dot2 - dot1 * dot6;
            if (vb <= 0 && dot2 >= 0 && dot6 <= 0) {
                v = dot2 / (dot2 - dot6);
                coords[0] = 1 - v;
                coords[1] = 0;
                coords[2] = v;
                if (computeDistance) {
                    d0 = a0 - v * ca0;
                    d1 = a1 - v * ca1;
                    d2 = a2 - v * ca2;
                    return d0 * d0 + d1 * d1 + d2 * d2
                } else {
                    return undefined
                }
            }
            var va = dot3 * dot6 - dot5 * dot4;
            if (va <= 0 && dot4 - dot3 >= 0 && dot5 - dot6 >= 0) {
                v = (dot4 - dot3) / (dot4 - dot3 + (dot5 - dot6));
                coords[0] = 0;
                coords[1] = 1 - v;
                coords[2] = v;
                if (computeDistance) {
                    d0 = b0 * (1 - v) + c0 * v;
                    d1 = b1 * (1 - v) + c1 * v;
                    d2 = b2 * (1 - v) + c2 * v;
                    return d0 * d0 + d1 * d1 + d2 * d2
                } else {
                    return undefined
                }
            }
            var denom = 1 / (va + vb + vc);
            v = vb * denom;
            var w = vc * denom;
            coords[0] = 1 - v - w;
            coords[1] = v;
            coords[2] = w;
            if (computeDistance) {
                d0 = a0 - ba0 * v - ca0 * w;
                d1 = a1 - ba1 * v - ca1 * w;
                d2 = a2 - ba2 * v - ca2 * w;
                return d0 * d0 + d1 * d1 + d2 * d2
            } else {
                return undefined
            }
        };
        WebGLGJKContactSolver.prototype.evaluate = function(cache, xformA, xformB) {
            var axis = cache.axis;
            var shapeA = cache.shapeA;
            var shapeB = cache.shapeB;
            this.numVertices = 0;
            var lastW0, lastW1, lastW2;
            lastW0 = lastW1 = lastW2 = Number.MAX_VALUE;
            var curIter = 0;
            var maxIter = 100;
            var seperated = false;
            var squaredDistance = Number.MAX_VALUE;
            var A0 = xformA[0];
            var A1 = xformA[1];
            var A2 = xformA[2];
            var A3 = xformA[3];
            var A4 = xformA[4];
            var A5 = xformA[5];
            var A6 = xformA[6];
            var A7 = xformA[7];
            var A8 = xformA[8];
            var A9 = xformA[9];
            var A10 = xformA[10];
            var A11 = xformA[11];
            var B0 = xformB[0];
            var B1 = xformB[1];
            var B2 = xformB[2];
            var B3 = xformB[3];
            var B4 = xformB[4];
            var B5 = xformB[5];
            var B6 = xformB[6];
            var B7 = xformB[7];
            var B8 = xformB[8];
            var B9 = xformB[9];
            var B10 = xformB[10];
            var B11 = xformB[11];
            var axis0 = axis[0];
            var axis1 = axis[1];
            var axis2 = axis[2];
            var axislsq;
            var supportA = cache.closestA;
            var supportB = cache.closestB;
            var closest = this.closest;
            var simplex = this.simplex;
            var equalVertexThreshold = 1e-4;
            for (;;) {
                curIter += 1;
                supportA[0] = -(A0 * axis0 + A1 * axis1 + A2 * axis2);
                supportA[1] = -(A3 * axis0 + A4 * axis1 + A5 * axis2);
                supportA[2] = -(A6 * axis0 + A7 * axis1 + A8 * axis2);
                supportB[0] = B0 * axis0 + B1 * axis1 + B2 * axis2;
                supportB[1] = B3 * axis0 + B4 * axis1 + B5 * axis2;
                supportB[2] = B6 * axis0 + B7 * axis1 + B8 * axis2;
                shapeA.localSupportWithoutMargin(supportA, supportA);
                shapeB.localSupportWithoutMargin(supportB, supportB);
                var d0 = supportA[0];
                var d1 = supportA[1];
                var d2 = supportA[2];
                var sa0 = supportA[0] = A0 * d0 + A3 * d1 + A6 * d2 + A9;
                var sa1 = supportA[1] = A1 * d0 + A4 * d1 + A7 * d2 + A10;
                var sa2 = supportA[2] = A2 * d0 + A5 * d1 + A8 * d2 + A11;
                d0 = supportB[0];
                d1 = supportB[1];
                d2 = supportB[2];
                var sb0 = supportB[0] = B0 * d0 + B3 * d1 + B6 * d2 + B9;
                var sb1 = supportB[1] = B1 * d0 + B4 * d1 + B7 * d2 + B10;
                var sb2 = supportB[2] = B2 * d0 + B5 * d1 + B8 * d2 + B11;
                var w0 = sa0 - sb0;
                var w1 = sa1 - sb1;
                var w2 = sa2 - sb2;
                var inSimplex = false;
                var index = this.numVertices * 9;
                var i;
                for (i = 0; i < index; i += 9) {
                    d0 = w0 - simplex[i];
                    d1 = w1 - simplex[i + 1];
                    d2 = w2 - simplex[i + 2];
                    if (d0 * d0 + d1 * d1 + d2 * d2 < equalVertexThreshold) {
                        inSimplex = true
                    }
                }
                if (!inSimplex) {
                    d0 = w0 - lastW0;
                    d1 = w1 - lastW1;
                    d2 = w2 - lastW2;
                    inSimplex = d0 * d0 + d1 * d1 + d2 * d2 < equalVertexThreshold
                }
                if (inSimplex) {
                    seperated = true;
                    break
                }
                var delta = axis0 * w0 + axis1 * w1 + axis2 * w2;
                if (squaredDistance - delta <= squaredDistance * WebGLPhysicsConfig.GJK_FRACTIONAL_THRESHOLD) {
                    seperated = true;
                    break
                }
                lastW0 = simplex[index] = w0;
                lastW1 = simplex[index + 1] = w1;
                lastW2 = simplex[index + 2] = w2;
                simplex[index + 3] = sa0;
                simplex[index + 4] = sa1;
                simplex[index + 5] = sa2;
                simplex[index + 6] = sb0;
                simplex[index + 7] = sb1;
                simplex[index + 8] = sb2;
                this.numVertices += 1;
                if (!this.updateClosestPoints()) {
                    seperated = false;
                    break
                }
                d0 = closest[0] - closest[3];
                d1 = closest[1] - closest[4];
                d2 = closest[2] - closest[5];
                axislsq = d0 * d0 + d1 * d1 + d2 * d2;
                if (axislsq <= WebGLPhysicsConfig.GJK_EPA_DISTANCE_THRESHOLD) {
                    seperated = true;
                    break
                }
                axis0 = d0;
                axis1 = d1;
                axis2 = d2;
                var previousSqDistance = squaredDistance;
                squaredDistance = axislsq;
                if (previousSqDistance - squaredDistance <= WebGLPhysicsConfig.GJK_FRACTIONAL_THRESHOLD * previousSqDistance) {
                    seperated = true;
                    break
                }
                if (curIter >= maxIter) {
                    seperated = true;
                    break
                }
                if (this.numVertices === 4) {
                    break
                }
            }
            axislsq = axis0 * axis0 + axis1 * axis1 + axis2 * axis2;
            if (axislsq < WebGLPhysicsConfig.DONT_NORMALIZE_THRESHOLD) {
                axis[0] = axis0;
                axis[1] = axis1;
                axis[2] = axis2;
                return undefined
            }
            var scale = 1 / Math.sqrt(axislsq);
            axis[0] = axis0 * scale;
            axis[1] = axis1 * scale;
            axis[2] = axis2 * scale;
            if (seperated) {
                supportA[0] = closest[0];
                supportA[1] = closest[1];
                supportA[2] = closest[2];
                supportB[0] = closest[3];
                supportB[1] = closest[4];
                supportB[2] = closest[5];
                return Math.sqrt(squaredDistance)
            } else {
                return undefined
            }
        };
        WebGLGJKContactSolver.create = function() {
            var solver = new WebGLGJKContactSolver;
            solver.simplex = new Float32Array(36);
            solver.numVertices = 0;
            solver.closest = new Float32Array(6);
            solver.cachedCoords = new Float32Array(4);
            solver.tempCoords = new Float32Array(4);
            return solver
        };
        WebGLGJKContactSolver.version = 1;
        return WebGLGJKContactSolver
    }();
    var WebGLContactEPA = function() {
        function WebGLContactEPA() {}
        WebGLContactEPA.prototype.bind = function(faceA, edgeA, faceB, edgeB) {
            faceA.edge[edgeA] = edgeB;
            faceA.adjFace[edgeA] = faceB;
            faceB.edge[edgeB] = edgeA;
            faceB.adjFace[edgeB] = faceA
        };
        WebGLContactEPA.prototype.append = function(list, face) {
            face.leaf0 = null;
            face.leaf1 = list.root;
            if (list.root) {
                list.root.leaf0 = face
            }
            list.root = face;
            list.count += 1
        };
        WebGLContactEPA.prototype.remove = function(list, face) {
            var leaf0 = face.leaf0;
            var leaf1 = face.leaf1;
            if (leaf1) {
                leaf1.leaf0 = leaf0
            }
            if (leaf0) {
                leaf0.leaf1 = leaf1
            }
            if (face === list.root) {
                list.root = leaf1
            }
            list.count -= 1
        };
        WebGLContactEPA.prototype.findBest = function() {
            var minFace = this.hull.root;
            var minDistance = minFace.distance * minFace.distance;
            var f;
            for (f = minFace.leaf1; f !== null; f = f.leaf1) {
                var sqDistance = f.distance * f.distance;
                if (sqDistance < minDistance) {
                    minFace = f;
                    minDistance = sqDistance
                }
            }
            return minFace
        };
        WebGLContactEPA.prototype.getEdgeDistance = function(face, a, b) {
            var vertices = this.vertex_store;
            var a0 = vertices[a];
            var a1 = vertices[a + 1];
            var a2 = vertices[a + 2];
            var b0 = vertices[b];
            var b1 = vertices[b + 1];
            var b2 = vertices[b + 2];
            var ba0 = b0 - a0;
            var ba1 = b1 - a1;
            var ba2 = b2 - a2;
            var fn = face.normal;
            var fn0 = fn[0];
            var fn1 = fn[1];
            var fn2 = fn[2];
            var n0 = ba1 * fn2 - ba2 * fn1;
            var n1 = ba2 * fn0 - ba0 * fn2;
            var n2 = ba0 * fn1 - ba1 * fn0;
            var dot = a0 * n0 + a1 * n1 + a2 * n2;
            if (dot <= 0) {
                var lengthSqBA = ba0 * ba0 + ba1 * ba1 + ba2 * ba2;
                var dotA = a0 * ba0 + a1 * ba1 + a2 * ba2;
                var dotB = b0 * ba0 + b1 * ba2 + b2 * ba2;
                if (dotA >= 0) {
                    return Math.sqrt(a0 * a0 + a1 * a1 + a2 * a2)
                } else if (dotB <= 0) {
                    return Math.sqrt(b0 * b0 + b1 * b1 + b2 * b2)
                } else {
                    var dotAB = a0 * b0 + a1 * b1 + a2 * b2;
                    var dSq = (a0 * a0 + a1 * a1 + a2 * a2) * (b0 * b0 + b1 * b1 + b2 * b2) - dotAB * dotAB;
                    return dSq >= 0 ? Math.sqrt(dSq / lengthSqBA) : 0
                }
            } else {
                return undefined
            }
        };
        WebGLContactEPA.prototype.buildNewFace = function(a, b, c, forced) {
            var face = this.stock.root;
            if (face === null) {
                return null
            }
            face.pass = 0;
            face.vertex[0] = a;
            face.vertex[1] = b;
            face.vertex[2] = c;
            var vertices = this.vertex_store;
            var a0 = vertices[a];
            var a1 = vertices[a + 1];
            var a2 = vertices[a + 2];
            var b0 = vertices[b];
            var b1 = vertices[b + 1];
            var b2 = vertices[b + 2];
            var c0 = vertices[c];
            var c1 = vertices[c + 1];
            var c2 = vertices[c + 2];
            var ba0 = b0 - a0;
            var ba1 = b1 - a1;
            var ba2 = b2 - a2;
            var ca0 = c0 - a0;
            var ca1 = c1 - a1;
            var ca2 = c2 - a2;
            var fn = face.normal;
            var fn0 = fn[0] = ba1 * ca2 - ba2 * ca1;
            var fn1 = fn[1] = ba2 * ca0 - ba0 * ca2;
            var fn2 = fn[2] = ba0 * ca1 - ba1 * ca0;
            var length = fn0 * fn0 + fn1 * fn1 + fn2 * fn2;
            if (length > WebGLPhysicsConfig.DONT_NORMALIZE_THRESHOLD) {
                face.distance = this.getEdgeDistance(face, a, b);
                if (face.distance === undefined) {
                    face.distance = this.getEdgeDistance(face, b, c)
                }
                if (face.distance === undefined) {
                    face.distance = this.getEdgeDistance(face, c, a)
                }
                var scale = 1 / Math.sqrt(length);
                if (face.distance === undefined) {
                    face.distance = (a0 * fn0 + a1 * fn1 + a2 * fn2) * scale
                }
                if (forced || face.distance >= -1e-6) {
                    fn[0] *= scale;
                    fn[1] *= scale;
                    fn[2] *= scale;
                    this.remove(this.stock, face);
                    this.append(this.hull, face);
                    return face
                }
            }
            return null
        };
        WebGLContactEPA.prototype.expandFace = function(pass, w, face, edge, horizon) {
            if (face.pass !== pass) {
                var fn = face.normal;
                var fn0 = fn[0];
                var fn1 = fn[1];
                var fn2 = fn[2];
                var vertices = this.vertex_store;
                var w0 = vertices[w];
                var w1 = vertices[w + 1];
                var w2 = vertices[w + 2];
                var edge1 = (edge + 1) % 3;
                if (fn0 * w0 + fn1 * w1 + fn2 * w2 - face.distance < -1e-6) {
                    var newFace = this.buildNewFace(face.vertex[edge1], face.vertex[edge], w, false);
                    if (newFace) {
                        this.bind(newFace, 0, face, edge);
                        if (horizon.cf) {
                            this.bind(horizon.cf, 1, newFace, 2)
                        } else {
                            horizon.ff = newFace
                        }
                        horizon.cf = newFace;
                        horizon.numFaces += 1;
                        return true
                    }
                } else {
                    var edge2 = (edge + 2) % 3;
                    face.pass = pass;
                    if (this.expandFace(pass, w, face.adjFace[edge1], face.edge[edge1], horizon) && this.expandFace(pass, w, face.adjFace[edge2], face.edge[edge2], horizon)) {
                        this.remove(this.hull, face);
                        this.append(this.stock, face);
                        return true
                    }
                }
            }
            return false
        };
        WebGLContactEPA.prototype.evaluate = function(gjkSimplex, cache, xformA, xformB) {
            var shapeA = cache.shapeA;
            var shapeB = cache.shapeB;
            var hull = this.hull;
            var stock = this.stock;
            while (hull.root) {
                var face = hull.root;
                this.remove(hull, face);
                this.append(stock, face)
            }
            var d0 = gjkSimplex[27];
            var d1 = gjkSimplex[28];
            var d2 = gjkSimplex[29];
            var ind0, ind1;
            var a0 = gjkSimplex[0] - d0;
            var a1 = gjkSimplex[1] - d1;
            var a2 = gjkSimplex[2] - d2;
            var b0 = gjkSimplex[9] - d0;
            var b1 = gjkSimplex[10] - d1;
            var b2 = gjkSimplex[11] - d2;
            var c0 = gjkSimplex[18] - d0;
            var c1 = gjkSimplex[19] - d1;
            var c2 = gjkSimplex[20] - d2;
            if (a0 * (b1 * c2 - b2 * c1) + a1 * (b2 * c0 - b0 * c2) + a2 * (b0 * c1 - b1 * c0) < 0) {
                ind0 = 9;
                ind1 = 0
            } else {
                ind0 = 0;
                ind1 = 9
            }
            var vertices = this.vertex_store;
            var i;
            for (i = 0; i < 9; i += 1) {
                vertices[i] = gjkSimplex[ind0 + i];
                vertices[9 + i] = gjkSimplex[ind1 + i];
                vertices[18 + i] = gjkSimplex[18 + i];
                vertices[27 + i] = gjkSimplex[27 + i]
            }
            var t0 = this.buildNewFace(0, 9, 18, true);
            var t1 = this.buildNewFace(9, 0, 27, true);
            var t2 = this.buildNewFace(18, 9, 27, true);
            var t3 = this.buildNewFace(0, 18, 27, true);
            var nextVertex = 36;
            if (hull.count !== 4) {
                VMath.v3Build(gjkSimplex[3], gjkSimplex[4], gjkSimplex[5], cache.closestA);
                VMath.v3Build(gjkSimplex[6], gjkSimplex[7], gjkSimplex[8], cache.closestB);
                return 0
            }
            var best = this.findBest();
            var pass = 0;
            var iterations = 0;
            this.bind(t0, 0, t1, 0);
            this.bind(t0, 1, t2, 0);
            this.bind(t0, 2, t3, 0);
            this.bind(t1, 1, t3, 2);
            this.bind(t1, 2, t2, 1);
            this.bind(t2, 2, t3, 1);
            var A0 = xformA[0];
            var A1 = xformA[1];
            var A2 = xformA[2];
            var A3 = xformA[3];
            var A4 = xformA[4];
            var A5 = xformA[5];
            var A6 = xformA[6];
            var A7 = xformA[7];
            var A8 = xformA[8];
            var A9 = xformA[9];
            var A10 = xformA[10];
            var A11 = xformA[11];
            var B0 = xformB[0];
            var B1 = xformB[1];
            var B2 = xformB[2];
            var B3 = xformB[3];
            var B4 = xformB[4];
            var B5 = xformB[5];
            var B6 = xformB[6];
            var B7 = xformB[7];
            var B8 = xformB[8];
            var B9 = xformB[9];
            var B10 = xformB[10];
            var B11 = xformB[11];
            var supportA = cache.closestA;
            var supportB = cache.closestB;
            var horizon = this.horizon;
            var bn, n0, n1, n2;
            for (; iterations < 100; iterations += 1) {
                if (nextVertex >= this.MAX_VERTICES * 9) {
                    break
                }
                horizon.cf = horizon.ff = null;
                horizon.numFaces = 0;
                var w = nextVertex;
                nextVertex += 9;
                pass += 1;
                best.pass = pass;
                bn = best.normal;
                n0 = bn[0];
                n1 = bn[1];
                n2 = bn[2];
                supportA[0] = A0 * n0 + A1 * n1 + A2 * n2;
                supportA[1] = A3 * n0 + A4 * n1 + A5 * n2;
                supportA[2] = A6 * n0 + A7 * n1 + A8 * n2;
                supportB[0] = -(B0 * n0 + B1 * n1 + B2 * n2);
                supportB[1] = -(B3 * n0 + B4 * n1 + B5 * n2);
                supportB[2] = -(B6 * n0 + B7 * n1 + B8 * n2);
                shapeA.localSupportWithoutMargin(supportA, supportA);
                shapeB.localSupportWithoutMargin(supportB, supportB);
                d0 = supportA[0];
                d1 = supportA[1];
                d2 = supportA[2];
                a0 = A0 * d0 + A3 * d1 + A6 * d2 + A9;
                a1 = A1 * d0 + A4 * d1 + A7 * d2 + A10;
                a2 = A2 * d0 + A5 * d1 + A8 * d2 + A11;
                d0 = supportB[0];
                d1 = supportB[1];
                d2 = supportB[2];
                b0 = B0 * d0 + B3 * d1 + B6 * d2 + B9;
                b1 = B1 * d0 + B4 * d1 + B7 * d2 + B10;
                b2 = B2 * d0 + B5 * d1 + B8 * d2 + B11;
                var w0, w1, w2;
                vertices[w + 3] = a0;
                vertices[w + 4] = a1;
                vertices[w + 5] = a2;
                vertices[w + 6] = b0;
                vertices[w + 7] = b1;
                vertices[w + 8] = b2;
                vertices[w] = w0 = a0 - b0;
                vertices[w + 1] = w1 = a1 - b1;
                vertices[w + 2] = w2 = a2 - b2;
                var wDist = n0 * w0 + n1 * w1 + n2 * w2 - best.distance;
                if (wDist > WebGLPhysicsConfig.GJK_EPA_DISTANCE_THRESHOLD) {
                    var j;
                    var valid = true;
                    for (j = 0; j < 3 && valid; j += 1) {
                        valid = valid && this.expandFace(pass, w, best.adjFace[j], best.edge[j], horizon)
                    }
                    if (valid && horizon.numFaces >= 3) {
                        this.bind(horizon.cf, 1, horizon.ff, 2);
                        this.remove(hull, best);
                        this.append(stock, best);
                        best = this.findBest()
                    } else {
                        break
                    }
                } else {
                    break
                }
            }
            bn = best.normal;
            n0 = bn[0];
            n1 = bn[1];
            n2 = bn[2];
            var bd = best.distance;
            var p0 = n0 * bd;
            var p1 = n1 * bd;
            var p2 = n2 * bd;
            c0 = best.vertex[0];
            c1 = best.vertex[1];
            c2 = best.vertex[2];
            var x0 = vertices[c0] - p0;
            var x1 = vertices[c0 + 1] - p1;
            var x2 = vertices[c0 + 2] - p2;
            var y0 = vertices[c1] - p0;
            var y1 = vertices[c1 + 1] - p1;
            var y2 = vertices[c1 + 2] - p2;
            var z0 = vertices[c2] - p0;
            var z1 = vertices[c2 + 1] - p1;
            var z2 = vertices[c2 + 2] - p2;
            d0 = y1 * z2 - y2 * z1;
            d1 = y2 * z0 - y0 * z2;
            d2 = y0 * z1 - y1 * z0;
            var alpha = Math.sqrt(d0 * d0 + d1 * d1 + d2 * d2);
            d0 = z1 * x2 - z2 * x1;
            d1 = z2 * x0 - z0 * x2;
            d2 = z0 * x1 - z1 * x0;
            var beta = Math.sqrt(d0 * d0 + d1 * d1 + d2 * d2);
            d0 = x1 * y2 - x2 * y1;
            d1 = x2 * y0 - x0 * y2;
            d2 = x0 * y1 - x1 * y0;
            var gamma = Math.sqrt(d0 * d0 + d1 * d1 + d2 * d2);
            var scale = 1 / (alpha + beta + gamma);
            alpha *= scale;
            beta *= scale;
            gamma *= scale;
            supportA[0] = supportA[1] = supportA[2] = 0;
            supportB[0] = supportB[1] = supportB[2] = 0;
            for (i = 0; i < 3; i += 1) {
                supportA[i] += alpha * vertices[c0 + 3 + i] + beta * vertices[c1 + 3 + i] + gamma * vertices[c2 + 3 + i];
                supportB[i] += alpha * vertices[c0 + 6 + i] + beta * vertices[c1 + 6 + i] + gamma * vertices[c2 + 6 + i]
            }
            var axis = cache.axis;
            axis[0] = -n0;
            axis[1] = -n1;
            axis[2] = -n2;
            return -best.distance
        };
        WebGLContactEPA.create = function() {
            var epa = new WebGLContactEPA;
            var i;
            epa.vertex_store = new Float32Array(epa.MAX_VERTICES * 9);
            var face_store = [];
            for (i = 0; i < epa.MAX_FACES; i += 1) {
                face_store[i] = {
                    normal: VMath.v3BuildZero(),
                    distance: 0,
                    vertex: new Int16Array(3),
                    adjFace: [null, null, null],
                    edge: new Int16Array(3),
                    leaf0: null,
                    leaf1: null,
                    pass: 0
                }
            }
            epa.hull = {
                root: null,
                count: 0
            };
            epa.stock = {
                root: null,
                count: 0
            };
            epa.horizon = {
                cf: null,
                ff: null,
                numFaces: 0
            };
            for (i = 0; i < epa.MAX_FACES; i += 1) {
                epa.append(epa.stock, face_store[epa.MAX_FACES - i - 1])
            }
            return epa
        };
        WebGLContactEPA.version = 1;
        return WebGLContactEPA
    }();
    WebGLContactEPA.prototype.MAX_VERTICES = 64;
    WebGLContactEPA.prototype.MAX_FACES = 128;
    var WebGLPhysicsPublicContact = function() {
        function WebGLPhysicsPublicContact() {
            this._private = null;
            return this
        }
        WebGLPhysicsPublicContact.create = function() {
            var p = new WebGLPhysicsPublicContact;
            Object.defineProperty(p, "localPointOnA", {
                get: function getLocalPointOnA() {
                    var pr = this._private;
                    return VMath.v3Build(pr[0], pr[1], pr[2])
                },
                set: function setLocalPointOnA(point) {
                    var pr = this._private;
                    pr[0] = point[0];
                    pr[1] = point[1];
                    pr[2] = point[2]
                },
                enumerable: true
            });
            Object.defineProperty(p, "localPointOnB", {
                get: function getLocalPointOnB() {
                    var pr = this._private;
                    return VMath.v3Build(pr[3], pr[4], pr[5])
                },
                set: function setLocalPointOnB(point) {
                    var pr = this._private;
                    pr[3] = point[0];
                    pr[4] = point[1];
                    pr[5] = point[2]
                },
                enumerable: true
            });
            Object.defineProperty(p, "worldNormalOnB", {
                get: function getWorldNormalOnB() {
                    var pr = this._private;
                    return VMath.v3Build(pr[12], pr[13], pr[14])
                },
                set: function setWorldNormalOnB(normal) {
                    var pr = this._private;
                    pr[12] = normal[0];
                    pr[13] = normal[1];
                    pr[14] = normal[2]
                },
                enumerable: true
            });
            Object.defineProperty(p, "added", {
                get: function getAdded() {
                    var pr = this._private;
                    return 0 < pr[51]
                },
                enumerable: true
            });
            Object.defineProperty(p, "distance", {
                get: function getDistance() {
                    var pr = this._private;
                    return pr[21]
                },
                enumerable: true
            });
            return p
        };
        return WebGLPhysicsPublicContact
    }();
    var WebGLPhysicsContact = {
        contactPool: [],
        contactPoolSize: 0,
        contactPoolAllocationSize: 128,
        publicContacts: [WebGLPhysicsPublicContact.create(), WebGLPhysicsPublicContact.create(), WebGLPhysicsPublicContact.create()],
        callbackContacts: [],
        allocate: function webglPhyssicsContactAllocateFn() {
            var contactPool = this.contactPool;
            if (this.contactPoolSize === 0) {
                var allocationSize = this.contactPoolAllocationSize;
                var buffer = new Float32Array(52 * allocationSize);
                var bufferIndex = buffer.length;
                var n;
                for (n = 0; n < allocationSize; n += 1) {
                    bufferIndex -= 52;
                    contactPool[n] = buffer.subarray(bufferIndex, bufferIndex + 52)
                }
                this.contactPoolSize = allocationSize
            }
            this.contactPoolSize -= 1;
            var contact = contactPool[this.contactPoolSize];
            contact[51] = 1;
            return contact
        },
        deallocate: function webglPhyssicsContactDeallocateFn(contact) {
            this.contactPool[this.contactPoolSize] = contact;
            this.contactPoolSize += 1;
            contact[40] = 0
        }
    };
    var WebGLPhysicsArbiter = function() {
        function WebGLPhysicsArbiter() {
            this.objectA = null;
            this.objectB = null;
            this.shapeA = null;
            this.shapeB = null;
            this.friction = 0;
            this.restitution = 0;
            this.contacts = [];
            this.activeContacts = [];
            this.active = true;
            this.skipDiscreteCollisions = false;
            this.contactFlags = 0;
            this.trigger = false;
            return this
        }
        WebGLPhysicsArbiter.prototype.insertContact = function(worldA, worldB, normal, distance, concave) {
            var cn0 = normal[0];
            var cn1 = normal[1];
            var cn2 = normal[2];
            var clsq = cn0 * cn0 + cn1 * cn1 + cn2 * cn2;
            if (clsq < WebGLPhysicsConfig.DONT_NORMALIZE_THRESHOLD) {
                return
            }
            var scale = 1 / Math.sqrt(clsq);
            cn0 *= scale;
            cn1 *= scale;
            cn2 *= scale;
            var objectA = this.objectA;
            var objectB = this.objectB;
            var xformA = objectA.transform;
            var xformB = objectB.transform;
            var r0 = worldA[0] - xformA[9];
            var r1 = worldA[1] - xformA[10];
            var r2 = worldA[2] - xformA[11];
            var ca0 = xformA[0] * r0 + xformA[1] * r1 + xformA[2] * r2;
            var ca1 = xformA[3] * r0 + xformA[4] * r1 + xformA[5] * r2;
            var ca2 = xformA[6] * r0 + xformA[7] * r1 + xformA[8] * r2;
            var jAccN = 0;
            var i = 0;
            var min = Number.MAX_VALUE;
            var contacts = this.contacts;
            var d0, d1, d2;
            while (i < contacts.length) {
                var datad = contacts[i];
                if (!concave && cn0 * datad[12] + cn1 * datad[13] + cn2 * datad[14] < .9) {
                    contacts[i] = contacts[contacts.length - 1];
                    contacts.pop();
                    WebGLPhysicsContact.deallocate(datad);
                    this.contactFlags |= 4;
                    continue
                }
                d0 = ca0 - datad[0];
                d1 = ca1 - datad[1];
                d2 = ca2 - datad[2];
                var sep = d0 * d0 + d1 * d1 + d2 * d2;
                if (sep < WebGLPhysicsConfig.CONTACT_EQUAL_SQ_SEPERATION) {
                    jAccN = datad[40];
                    contacts[i] = contacts[contacts.length - 1];
                    contacts.pop();
                    WebGLPhysicsContact.deallocate(datad);
                    this.contactFlags |= 4;
                    min = sep;
                    continue
                }
                if (sep < WebGLPhysicsConfig.CONTACT_INHERIT_SQ_SEPERATION && sep < min) {
                    jAccN = datad[40];
                    min = sep
                }
                i += 1
            }
            var data = WebGLPhysicsContact.allocate();
            data[0] = ca0;
            data[1] = ca1;
            data[2] = ca2;
            data[6] = r0;
            data[7] = r1;
            data[8] = r2;
            data[9] = r0 = worldB[0] - xformB[9];
            data[10] = r1 = worldB[1] - xformB[10];
            data[11] = r2 = worldB[2] - xformB[11];
            data[3] = xformB[0] * r0 + xformB[1] * r1 + xformB[2] * r2;
            data[4] = xformB[3] * r0 + xformB[4] * r1 + xformB[5] * r2;
            data[5] = xformB[6] * r0 + xformB[7] * r1 + xformB[8] * r2;
            data[21] = distance;
            data[12] = cn0;
            data[13] = cn1;
            data[14] = cn2;
            var ct0, ct2;
            clsq = cn0 * cn0 + cn2 * cn2;
            if (clsq < WebGLPhysicsConfig.DONT_NORMALIZE_THRESHOLD) {
                data[15] = ct0 = 1;
                data[16] = 0;
                data[17] = ct2 = 0
            } else {
                scale = 1 / Math.sqrt(clsq);
                data[15] = ct0 = -cn2 * scale;
                data[16] = 0;
                data[17] = ct2 = cn0 * scale
            }
            data[18] = cn1 * ct2;
            data[19] = cn2 * ct0 - cn0 * ct2;
            data[20] = -(cn1 * ct0);
            data[40] = jAccN;
            var contactCallbacks, publicContact;
            contactCallbacks = objectA.contactCallbacks;
            if (null !== contactCallbacks && 0 !== (contactCallbacks.mask & objectB.group)) {
                if (contactCallbacks.onPreSolveContact) {
                    publicContact = WebGLPhysicsContact.publicContacts[0];
                    publicContact._private = data;
                    contactCallbacks.onPreSolveContact(objectA._public, objectB._public, publicContact)
                }
                if (!contactCallbacks.added && contactCallbacks.deferred) {
                    contactCallbacks.added = true;
                    objectA.world.contactCallbackObjects.push(objectA)
                }
                if (contactCallbacks.trigger) {
                    this.trigger = true;
                    objectA.sweepFrozen = false;
                    objectB.sweepFrozen = false
                }
            }
            contactCallbacks = objectB.contactCallbacks;
            if (null !== contactCallbacks && 0 !== (contactCallbacks.mask & objectA.group)) {
                if (contactCallbacks.onPreSolveContact) {
                    publicContact = WebGLPhysicsContact.publicContacts[0];
                    publicContact._private = data;
                    contactCallbacks.onPreSolveContact(objectA._public, objectB._public, publicContact)
                }
                if (!contactCallbacks.added && contactCallbacks.deferred) {
                    contactCallbacks.added = true;
                    objectB.world.contactCallbackObjects.push(objectB)
                }
                if (contactCallbacks.trigger) {
                    this.trigger = true;
                    objectA.sweepFrozen = false;
                    objectB.sweepFrozen = false
                }
            }
            this.contactFlags |= 1;
            contacts.push(data);
            if (contacts.length === 4) {
                var minDistance = contacts[0][21];
                var minimum = 0;
                for (i = 1; i < 4; i += 1) {
                    data = contacts[i];
                    if (data[21] < minDistance) {
                        minDistance = data[21];
                        minimum = i
                    }
                }
                var discard;
                var maxArea = -Number.MAX_VALUE;
                var con0 = contacts[0];
                var con1 = contacts[1];
                var con2 = contacts[2];
                var con3 = contacts[3];
                var a0 = con0[6] + con0[9];
                var a1 = con0[7] + con0[10];
                var a2 = con0[8] + con0[11];
                var b0 = con1[6] + con1[9];
                var b1 = con1[7] + con1[10];
                var b2 = con1[8] + con1[11];
                var c0 = con2[6] + con2[9];
                var c1 = con2[7] + con2[10];
                var c2 = con2[8] + con2[11];
                d0 = con3[6] + con3[9];
                d1 = con3[7] + con3[10];
                d2 = con3[8] + con3[11];
                var ab0 = b0 - a0;
                var ab1 = b1 - a1;
                var ab2 = b2 - a2;
                var ac0 = c0 - a0;
                var ac1 = c1 - a1;
                var ac2 = c2 - a2;
                var ad0 = d0 - a0;
                var ad1 = d1 - a1;
                var ad2 = d2 - a2;
                var n0, n1, n2;
                var area;
                if (minimum !== 1) {
                    n0 = ac1 * ad2 - ac2 * ad1;
                    n1 = ac2 * ad0 - ac0 * ad2;
                    n2 = ac0 * ad1 - ac1 * ad0;
                    area = n0 * n0 + n1 * n1 + n2 * n2;
                    if (area > maxArea) {
                        maxArea = area;
                        discard = 1
                    }
                }
                if (minimum !== 2) {
                    n0 = ab1 * ad2 - ab2 * ad1;
                    n1 = ab2 * ad0 - ab0 * ad2;
                    n2 = ab0 * ad1 - ab1 * ad0;
                    area = n0 * n0 + n1 * n1 + n2 * n2;
                    if (area > maxArea) {
                        maxArea = area;
                        discard = 2
                    }
                }
                if (minimum !== 3) {
                    n0 = ab1 * ac2 - ab2 * ac1;
                    n1 = ab2 * ac0 - ab0 * ac2;
                    n2 = ab0 * ac1 - ab1 * ac0;
                    area = n0 * n0 + n1 * n1 + n2 * n2;
                    if (area > maxArea) {
                        maxArea = area;
                        discard = 3
                    }
                }
                if (minimum !== 0) {
                    var bc0 = c0 - b0;
                    var bc1 = c1 - b1;
                    var bc2 = c2 - b2;
                    var bd0 = d0 - b0;
                    var bd1 = d1 - b1;
                    var bd2 = d2 - b2;
                    n0 = bc1 * bd2 - bc2 * bd1;
                    n1 = bc2 * bd0 - bc0 * bd2;
                    n2 = bc0 * bd1 - bc1 * bd0;
                    area = n0 * n0 + n1 * n1 + n2 * n2;
                    if (area > maxArea) {
                        maxArea = area;
                        discard = 0
                    }
                }
                data = contacts[discard];
                contacts[discard] = contacts[3];
                contacts.pop();
                WebGLPhysicsContact.deallocate(data);
                this.contactFlags |= 4
            }
        };
        WebGLPhysicsArbiter.prototype.refreshContacts = function() {
            var contacts = this.contacts;
            var objectA = this.objectA;
            var objectB = this.objectB;
            var xformA = objectA.transform;
            var xformB = objectB.transform;
            var A0 = xformA[0];
            var A1 = xformA[1];
            var A2 = xformA[2];
            var A3 = xformA[3];
            var A4 = xformA[4];
            var A5 = xformA[5];
            var A6 = xformA[6];
            var A7 = xformA[7];
            var A8 = xformA[8];
            var A9 = xformA[9];
            var A10 = xformA[10];
            var A11 = xformA[11];
            var B0 = xformB[0];
            var B1 = xformB[1];
            var B2 = xformB[2];
            var B3 = xformB[3];
            var B4 = xformB[4];
            var B5 = xformB[5];
            var B6 = xformB[6];
            var B7 = xformB[7];
            var B8 = xformB[8];
            var B9 = xformB[9];
            var B10 = xformB[10];
            var B11 = xformB[11];
            var data;
            var i = 0;
            while (i < contacts.length) {
                data = contacts[i];
                var v0 = data[0];
                var v1 = data[1];
                var v2 = data[2];
                var ra0 = data[6] = A0 * v0 + A3 * v1 + A6 * v2;
                var ra1 = data[7] = A1 * v0 + A4 * v1 + A7 * v2;
                var ra2 = data[8] = A2 * v0 + A5 * v1 + A8 * v2;
                v0 = data[3];
                v1 = data[4];
                v2 = data[5];
                var rb0 = data[9] = B0 * v0 + B3 * v1 + B6 * v2;
                var rb1 = data[10] = B1 * v0 + B4 * v1 + B7 * v2;
                var rb2 = data[11] = B2 * v0 + B5 * v1 + B8 * v2;
                v0 = ra0 + A9 - (rb0 + B9);
                v1 = ra1 + A10 - (rb1 + B10);
                v2 = ra2 + A11 - (rb2 + B11);
                var n0 = data[12];
                var n1 = data[13];
                var n2 = data[14];
                var sep = data[21] = n0 * v0 + n1 * v1 + n2 * v2;
                if (sep > WebGLPhysicsConfig.CONTACT_MAX_Y_SEPERATION) {
                    contacts[i] = contacts[contacts.length - 1];
                    contacts.pop();
                    WebGLPhysicsContact.deallocate(data);
                    this.contactFlags |= 4;
                    continue
                }
                v0 -= n0 * sep;
                v1 -= n1 * sep;
                v2 -= n2 * sep;
                if (v0 * v0 + v1 * v1 + v2 * v2 > WebGLPhysicsConfig.CONTACT_MAX_SQ_XZ_SEPERATION) {
                    contacts[i] = contacts[contacts.length - 1];
                    contacts.pop();
                    WebGLPhysicsContact.deallocate(data);
                    this.contactFlags |= 4;
                    continue
                }
                i += 1
            }
            this.contactFlags |= 2;
            return contacts.length === 0
        };
        WebGLPhysicsArbiter.prototype.preStep = function(timeStepRatio, timeStep) {
            if (this.trigger) {
                this.activeContacts.length = 0;
                return
            }
            var objectA = this.objectA;
            var objectB = this.objectB;
            var mass_sum = objectA.inverseMass + objectB.inverseMass;
            var velA = objectA.velocity;
            var velB = objectB.velocity;
            var I = objectA.inverseInertia;
            var A0 = I[0];
            var A1 = I[1];
            var A2 = I[2];
            var A3 = I[3];
            var A4 = I[4];
            var A5 = I[5];
            var A6 = I[6];
            var A7 = I[7];
            var A8 = I[8];
            I = objectB.inverseInertia;
            var B0 = I[0];
            var B1 = I[1];
            var B2 = I[2];
            var B3 = I[3];
            var B4 = I[4];
            var B5 = I[5];
            var B6 = I[6];
            var B7 = I[7];
            var B8 = I[8];
            var activeContacts = this.activeContacts;
            activeContacts.length = 0;
            var baum = objectA.collisionObject || objectB.collisionObject ? WebGLPhysicsConfig.CONTACT_STATIC_BAUMGRAUTE : WebGLPhysicsConfig.CONTACT_BAUMGRAUTE;
            var contacts = this.contacts;
            var i;
            var limit = contacts.length;
            for (i = 0; i < limit; i += 1) {
                var data = contacts[i];
                if (data[21] > 0) {
                    continue
                }
                activeContacts[activeContacts.length] = data;
                data[41] = data[42] = 0;
                var ca0, ca1, ca2;
                var cb0, cb1, cb2;
                var n0 = data[12];
                var n1 = data[13];
                var n2 = data[14];
                var ra0 = data[6];
                var ra1 = data[7];
                var ra2 = data[8];
                var rb0 = data[9];
                var rb1 = data[10];
                var rb2 = data[11];
                var k0, k1, k2;
                var kN = mass_sum;
                ca0 = ra1 * n2 - ra2 * n1;
                ca1 = ra2 * n0 - ra0 * n2;
                ca2 = ra0 * n1 - ra1 * n0;
                data[22] = k0 = A0 * ca0 + A3 * ca1 + A6 * ca2;
                data[23] = k1 = A1 * ca0 + A4 * ca1 + A7 * ca2;
                data[24] = k2 = A2 * ca0 + A5 * ca1 + A8 * ca2;
                kN += ca0 * k0 + ca1 * k1 + ca2 * k2;
                cb0 = rb1 * n2 - rb2 * n1;
                cb1 = rb2 * n0 - rb0 * n2;
                cb2 = rb0 * n1 - rb1 * n0;
                data[25] = k0 = -(B0 * cb0 + B3 * cb1 + B6 * cb2);
                data[26] = k1 = -(B1 * cb0 + B4 * cb1 + B7 * cb2);
                data[27] = k2 = -(B2 * cb0 + B5 * cb1 + B8 * cb2);
                kN -= cb0 * k0 + cb1 * k1 + cb2 * k2;
                data[45] = 1 / kN;
                data[43] = baum * Math.min(0, data[21] + WebGLPhysicsConfig.CONTACT_SLOP) / timeStep;
                data[44] = 0;
                var vel0 = velA[0] - velB[0];
                var vel1 = velA[1] - velB[1];
                var vel2 = velA[2] - velB[2];
                vel0 += velA[4] * ra2 - velA[5] * ra1;
                vel1 += velA[5] * ra0 - velA[3] * ra2;
                vel2 += velA[3] * ra1 - velA[4] * ra0;
                vel0 -= velB[4] * rb2 - velB[5] * rb1;
                vel1 -= velB[5] * rb0 - velB[3] * rb2;
                vel2 -= velB[3] * rb1 - velB[4] * rb0;
                var bounce = (vel0 * n0 + vel1 * n1 + vel2 * n2) * this.restitution;
                if (bounce * bounce < .01) {
                    bounce = 0
                }
                data[50] = bounce;
                var kU = mass_sum;
                n0 = data[15];
                n1 = data[16];
                n2 = data[17];
                ca0 = ra1 * n2 - ra2 * n1;
                ca1 = ra2 * n0 - ra0 * n2;
                ca2 = ra0 * n1 - ra1 * n0;
                data[28] = k0 = A0 * ca0 + A3 * ca1 + A6 * ca2;
                data[29] = k1 = A1 * ca0 + A4 * ca1 + A7 * ca2;
                data[30] = k2 = A2 * ca0 + A5 * ca1 + A8 * ca2;
                kU += ca0 * k0 + ca1 * k1 + ca2 * k2;
                cb0 = rb1 * n2 - rb2 * n1;
                cb1 = rb2 * n0 - rb0 * n2;
                cb2 = rb0 * n1 - rb1 * n0;
                data[31] = k0 = -(B0 * cb0 + B3 * cb1 + B6 * cb2);
                data[32] = k1 = -(B1 * cb0 + B4 * cb1 + B7 * cb2);
                data[33] = k2 = -(B2 * cb0 + B5 * cb1 + B8 * cb2);
                kU -= cb0 * k0 + cb1 * k1 + cb2 * k2;
                var kV = mass_sum;
                n0 = data[18];
                n1 = data[19];
                n2 = data[20];
                ca0 = ra1 * n2 - ra2 * n1;
                ca1 = ra2 * n0 - ra0 * n2;
                ca2 = ra0 * n1 - ra1 * n0;
                data[34] = k0 = A0 * ca0 + A3 * ca1 + A6 * ca2;
                data[35] = k1 = A1 * ca0 + A4 * ca1 + A7 * ca2;
                data[36] = k2 = A2 * ca0 + A5 * ca1 + A8 * ca2;
                kV += ca0 * k0 + ca1 * k1 + ca2 * k2;
                cb0 = rb1 * n2 - rb2 * n1;
                cb1 = rb2 * n0 - rb0 * n2;
                cb2 = rb0 * n1 - rb1 * n0;
                data[37] = k0 = -(B0 * cb0 + B3 * cb1 + B6 * cb2);
                data[38] = k1 = -(B1 * cb0 + B4 * cb1 + B7 * cb2);
                data[39] = k2 = -(B2 * cb0 + B5 * cb1 + B8 * cb2);
                kV -= cb0 * k0 + cb1 * k1 + cb2 * k2;
                var kUV = 0;
                kUV += ca0 * data[28] + ca1 * data[29] + ca2 * data[30];
                kUV -= cb0 * data[31] + cb1 * data[32] + cb2 * data[33];
                var idet = 1 / (kU * kV - kUV * kUV);
                data[46] = kV * idet;
                data[47] = -kUV * idet;
                data[48] = kU * idet;
                data[40] *= timeStepRatio
            }
        };
        WebGLPhysicsArbiter.prototype.applyCachedImpulses = function() {
            if (this.trigger) {
                return
            }
            var objectA = this.objectA;
            var objectB = this.objectB;
            var velA = objectA.velocity;
            var velB = objectB.velocity;
            var imA = objectA.inverseMass;
            var imB = objectB.inverseMass;
            var contacts = this.activeContacts;
            var i;
            for (i = 0; i < contacts.length; i += 1) {
                var data = contacts[i];
                var jn = data[40];
                var n0 = data[12] * jn;
                var n1 = data[13] * jn;
                var n2 = data[14] * jn;
                velA[0] += n0 * imA;
                velA[1] += n1 * imA;
                velA[2] += n2 * imA;
                velB[0] -= n0 * imB;
                velB[1] -= n1 * imB;
                velB[2] -= n2 * imB;
                velA[3] += data[22] * jn;
                velA[4] += data[23] * jn;
                velA[5] += data[24] * jn;
                velB[3] += data[25] * jn;
                velB[4] += data[26] * jn;
                velB[5] += data[27] * jn
            }
        };
        WebGLPhysicsArbiter.prototype.computeAndApplyBiasImpulses = function() {
            if (this.trigger) {
                return
            }
            var objectA = this.objectA;
            var objectB = this.objectB;
            var vec = objectA.velocity;
            var va0 = vec[6];
            var va1 = vec[7];
            var va2 = vec[8];
            var wa0 = vec[9];
            var wa1 = vec[10];
            var wa2 = vec[11];
            vec = objectB.velocity;
            var vb0 = vec[6];
            var vb1 = vec[7];
            var vb2 = vec[8];
            var wb0 = vec[9];
            var wb1 = vec[10];
            var wb2 = vec[11];
            var imA = objectA.inverseMass;
            var imB = objectB.inverseMass;
            var contacts = this.activeContacts;
            var limit = contacts.length;
            var data;
            var i;
            for (i = 0; i < limit; i += 1) {
                data = contacts[i];
                var n0 = data[12];
                var n1 = data[13];
                var n2 = data[14];
                var ra0 = data[6];
                var ra1 = data[7];
                var ra2 = data[8];
                var rb0 = data[9];
                var rb1 = data[10];
                var rb2 = data[11];
                var j1 = data[45] * (n0 * (vb0 + (wb1 * rb2 - wb2 * rb1) - (va0 + (wa1 * ra2 - wa2 * ra1))) + n1 * (vb1 + (wb2 * rb0 - wb0 * rb2) - (va1 + (wa2 * ra0 - wa0 * ra2))) + n2 * (vb2 + (wb0 * rb1 - wb1 * rb0) - (va2 + (wa0 * ra1 - wa1 * ra0))) - data[43]);
                var jOld1 = data[44];
                var cjAcc1 = jOld1 + j1;
                if (cjAcc1 < 0) {
                    cjAcc1 = 0
                }
                j1 = cjAcc1 - jOld1;
                data[44] = cjAcc1;
                n0 *= j1;
                n1 *= j1;
                n2 *= j1;
                va0 += n0 * imA;
                va1 += n1 * imA;
                va2 += n2 * imA;
                vb0 -= n0 * imB;
                vb1 -= n1 * imB;
                vb2 -= n2 * imB;
                wa0 += data[22] * j1;
                wa1 += data[23] * j1;
                wa2 += data[24] * j1;
                wb0 += data[25] * j1;
                wb1 += data[26] * j1;
                wb2 += data[27] * j1
            }
            vec = objectA.velocity;
            vec[6] = va0;
            vec[7] = va1;
            vec[8] = va2;
            vec[9] = wa0;
            vec[10] = wa1;
            vec[11] = wa2;
            vec = objectB.velocity;
            vec[6] = vb0;
            vec[7] = vb1;
            vec[8] = vb2;
            vec[9] = wb0;
            vec[10] = wb1;
            vec[11] = wb2
        };
        WebGLPhysicsArbiter.prototype.computeAndApplyImpulses = function() {
            if (this.trigger) {
                return
            }
            var objectA = this.objectA;
            var objectB = this.objectB;
            var vec = objectA.velocity;
            var va0 = vec[0];
            var va1 = vec[1];
            var va2 = vec[2];
            var wa0 = vec[3];
            var wa1 = vec[4];
            var wa2 = vec[5];
            vec = objectB.velocity;
            var vb0 = vec[0];
            var vb1 = vec[1];
            var vb2 = vec[2];
            var wb0 = vec[3];
            var wb1 = vec[4];
            var wb2 = vec[5];
            var imA = objectA.inverseMass;
            var imB = objectB.inverseMass;
            var friction = this.friction;
            var contacts = this.activeContacts;
            var limit = contacts.length;
            var data;
            var i;
            for (i = 0; i < limit; i += 1) {
                data = contacts[i];
                var n0 = data[12];
                var n1 = data[13];
                var n2 = data[14];
                var u0 = data[15];
                var u1 = data[16];
                var u2 = data[17];
                var v0 = data[18];
                var v1 = data[19];
                var v2 = data[20];
                var ra0 = data[6];
                var ra1 = data[7];
                var ra2 = data[8];
                var rb0 = data[9];
                var rb1 = data[10];
                var rb2 = data[11];
                var j1 = data[45] * (n0 * (vb0 + (wb1 * rb2 - wb2 * rb1) - (va0 + (wa1 * ra2 - wa2 * ra1))) + n1 * (vb1 + (wb2 * rb0 - wb0 * rb2) - (va1 + (wa2 * ra0 - wa0 * ra2))) + n2 * (vb2 + (wb0 * rb1 - wb1 * rb0) - (va2 + (wa0 * ra1 - wa1 * ra0))) - data[50]);
                var jOld1 = data[40];
                var cjAcc1 = jOld1 + j1;
                if (cjAcc1 < 0) {
                    cjAcc1 = 0;
                    j1 = -jOld1
                }
                data[40] = cjAcc1;
                n0 *= j1;
                n1 *= j1;
                n2 *= j1;
                va0 += n0 * imA;
                va1 += n1 * imA;
                va2 += n2 * imA;
                vb0 -= n0 * imB;
                vb1 -= n1 * imB;
                vb2 -= n2 * imB;
                wa0 += data[22] * j1;
                wa1 += data[23] * j1;
                wa2 += data[24] * j1;
                wb0 += data[25] * j1;
                wb1 += data[26] * j1;
                wb2 += data[27] * j1;
                n0 = vb0 - va0 + (wb1 * rb2 - wb2 * rb1) - (wa1 * ra2 - wa2 * ra1);
                n1 = vb1 - va1 + (wb2 * rb0 - wb0 * rb2) - (wa2 * ra0 - wa0 * ra2);
                n2 = vb2 - va2 + (wb0 * rb1 - wb1 * rb0) - (wa0 * ra1 - wa1 * ra0);
                var lambdau = u0 * n0 + u1 * n1 + u2 * n2;
                var lambdav = v0 * n0 + v1 * n1 + v2 * n2;
                j1 = lambdau * data[46] + lambdav * data[47];
                var j2 = lambdau * data[47] + lambdav * data[48];
                jOld1 = data[41];
                var jOld2 = data[42];
                cjAcc1 = jOld1 + j1;
                var cjAcc2 = jOld2 + j2;
                var jMax = friction * data[40];
                var fsq = cjAcc1 * cjAcc1 + cjAcc2 * cjAcc2;
                if (fsq > jMax * jMax) {
                    fsq = jMax / Math.sqrt(fsq);
                    cjAcc1 *= fsq;
                    cjAcc2 *= fsq;
                    j1 = cjAcc1 - jOld1;
                    j2 = cjAcc2 - jOld2
                }
                data[41] = cjAcc1;
                data[42] = cjAcc2;
                n0 = u0 * j1 + v0 * j2;
                n1 = u1 * j1 + v1 * j2;
                n2 = u2 * j1 + v2 * j2;
                va0 += n0 * imA;
                va1 += n1 * imA;
                va2 += n2 * imA;
                vb0 -= n0 * imB;
                vb1 -= n1 * imB;
                vb2 -= n2 * imB;
                wa0 += data[28] * j1 + data[34] * j2;
                wa1 += data[29] * j1 + data[35] * j2;
                wa2 += data[30] * j1 + data[36] * j2;
                wb0 += data[31] * j1 + data[37] * j2;
                wb1 += data[32] * j1 + data[38] * j2;
                wb2 += data[33] * j1 + data[39] * j2
            }
            vec = objectA.velocity;
            vec[0] = va0;
            vec[1] = va1;
            vec[2] = va2;
            vec[3] = wa0;
            vec[4] = wa1;
            vec[5] = wa2;
            vec = objectB.velocity;
            vec[0] = vb0;
            vec[1] = vb1;
            vec[2] = vb2;
            vec[3] = wb0;
            vec[4] = wb1;
            vec[5] = wb2
        };
        WebGLPhysicsArbiter.prototype.invalidateParameters = function() {
            this.restitution = this.objectA.restitution * this.objectB.restitution;
            this.friction = this.objectA.friction * this.objectB.friction
        };
        WebGLPhysicsArbiter.allocate = function(shapeA, shapeB, objectA, objectB) {
            var arbiter;
            if (this.arbiterPoolSize === 0) {
                arbiter = new WebGLPhysicsArbiter
            } else {
                arbiter = this.arbiterPool[this.arbiterPoolSize - 1];
                this.arbiterPoolSize -= 1
            }
            arbiter.active = true;
            arbiter.shapeA = shapeA;
            arbiter.shapeB = shapeB;
            arbiter.objectA = objectA;
            arbiter.objectB = objectB;
            arbiter.invalidateParameters();
            return arbiter
        };
        WebGLPhysicsArbiter.deallocate = function(arbiter) {
            arbiter.shapeA = null;
            arbiter.shapeB = null;
            arbiter.objectA = null;
            arbiter.objectB = null;
            arbiter.skipDiscreteCollisions = false;
            arbiter.activeContacts.length = 0;
            arbiter.contactFlags = 0;
            arbiter.trigger = false;
            this.arbiterPool[this.arbiterPoolSize] = arbiter;
            this.arbiterPoolSize += 1
        };
        WebGLPhysicsArbiter.version = 1;
        WebGLPhysicsArbiter.arbiterPool = [];
        WebGLPhysicsArbiter.arbiterPoolSize = 0;
        return WebGLPhysicsArbiter
    }();
    var WebGLPhysicsIsland = function() {
        function WebGLPhysicsIsland() {
            this.bodies = [];
            this.constraints = [];
            this.wakeTimeStamp = 0;
            this.active = false;
            return this
        }
        WebGLPhysicsIsland.allocate = function() {
            var island;
            if (this.islandPoolSize === 0) {
                island = new WebGLPhysicsIsland
            } else {
                island = this.islandPool[this.islandPoolSize - 1];
                this.islandPoolSize -= 1
            }
            return island
        };
        WebGLPhysicsIsland.deallocate = function(island) {
            this.islandPool[this.islandPoolSize] = island;
            this.islandPoolSize += 1;
            island.wakeTimeStamp = 0
        };
        WebGLPhysicsIsland.version = 1;
        WebGLPhysicsIsland.islandPool = [];
        WebGLPhysicsIsland.islandPoolSize = 0;
        return WebGLPhysicsIsland
    }();
    var WebGLPhysicsTriangleShape = function() {
        function WebGLPhysicsTriangleShape() {
            this.index = 0;
            this.collisionRadius = 0;
            this.triangleArray = null;
            return this
        }
        WebGLPhysicsTriangleShape.prototype.localSupportWithoutMargin = function(vec, dst) {
            var vec0 = vec[0];
            var vec1 = vec[1];
            var vec2 = vec[2];
            var triangles = this.triangleArray.triangles;
            var triangle = this.index;
            var v00 = triangles[triangle + 3];
            var v01 = triangles[triangle + 4];
            var v02 = triangles[triangle + 5];
            var u0 = triangles[triangle + 6];
            var u1 = triangles[triangle + 7];
            var u2 = triangles[triangle + 8];
            var v0 = triangles[triangle + 9];
            var v1 = triangles[triangle + 10];
            var v2 = triangles[triangle + 11];
            var dotu = vec0 * u0 + vec1 * u1 + vec2 * u2;
            var dotv = vec0 * v0 + vec1 * v1 + vec2 * v2;
            if (dotu <= 0 && dotv <= 0) {
                dst[0] = v00;
                dst[1] = v01;
                dst[2] = v02
            } else if (dotu >= dotv) {
                dst[0] = v00 + u0;
                dst[1] = v01 + u1;
                dst[2] = v02 + u2
            } else {
                dst[0] = v00 + v0;
                dst[1] = v01 + v1;
                dst[2] = v02 + v2
            }
        };
        WebGLPhysicsTriangleShape.allocate = function() {
            var triangle;
            if (this.trianglePoolSize === 0) {
                triangle = new WebGLPhysicsTriangleShape
            } else {
                triangle = this.trianglePool[this.trianglePoolSize - 1];
                this.trianglePoolSize -= 1
            }
            return triangle
        };
        WebGLPhysicsTriangleShape.deallocate = function(triangle) {
            this.trianglePool[this.trianglePoolSize] = triangle;
            this.trianglePoolSize += 1;
            triangle.triangleArray = null
        };
        WebGLPhysicsTriangleShape.version = 1;
        WebGLPhysicsTriangleShape.trianglePool = [];
        WebGLPhysicsTriangleShape.trianglePoolSize = 0;
        return WebGLPhysicsTriangleShape
    }();
    WebGLPhysicsTriangleShape.prototype.type = "TRIANGLE_MESH_TRIANGLE";
    var WebGLPhysicsTOIEvent = function() {
        function WebGLPhysicsTOIEvent() {
            this.objectA = null;
            this.objectB = null;
            this.shapeA = null;
            this.shapeB = null;
            this.closestA = VMath.v3BuildZero();
            this.closestB = VMath.v3BuildZero();
            this.axis = VMath.v3BuildZero();
            this.distance = 0;
            this.toi = 0;
            this.frozenA = false;
            this.frozenB = false;
            this.concave = false;
            return this
        }
        WebGLPhysicsTOIEvent.allocate = function() {
            var toi;
            if (this.eventPoolSize === 0) {
                toi = new WebGLPhysicsTOIEvent
            } else {
                toi = this.eventPool[this.eventPoolSize - 1];
                this.eventPoolSize -= 1
            }
            return toi
        };
        WebGLPhysicsTOIEvent.deallocate = function(toi) {
            this.eventPool[this.eventPoolSize] = toi;
            this.eventPoolSize += 1;
            if (toi.concave) {
                WebGLPhysicsTriangleShape.deallocate(toi.shapeB);
                toi.concave = false
            }
            toi.objectA = null;
            toi.objectB = null;
            toi.shapeA = null;
            toi.shapeB = null
        };
        WebGLPhysicsTOIEvent.version = 1;
        WebGLPhysicsTOIEvent.eventPool = [];
        WebGLPhysicsTOIEvent.eventPoolSize = 0;
        return WebGLPhysicsTOIEvent
    }();
    var WebGLPhysicsWorld = function() {
        function WebGLPhysicsWorld() {}
        WebGLPhysicsWorld.prototype.update = function() {
            this._private.update()
        };
        WebGLPhysicsWorld.prototype.rayTest = function(ray) {
            return this._private.rayTest(ray)
        };
        WebGLPhysicsWorld.prototype.convexSweepTest = function(params) {
            return this._private.convexSweepTest(params)
        };
        WebGLPhysicsWorld.prototype.addCollisionObject = function(collisionObject) {
            return this._private.addBody(collisionObject._private)
        };
        WebGLPhysicsWorld.prototype.removeCollisionObject = function(collisionObject) {
            return this._private.removeBody(collisionObject._private)
        };
        WebGLPhysicsWorld.prototype.addRigidBody = function(rigidBody) {
            return this._private.addBody(rigidBody._private)
        };
        WebGLPhysicsWorld.prototype.removeRigidBody = function(rigidBody) {
            return this._private.removeBody(rigidBody._private)
        };
        WebGLPhysicsWorld.prototype.addConstraint = function(constraint) {
            return this._private.addConstraint(constraint._private)
        };
        WebGLPhysicsWorld.prototype.removeConstraint = function(constraint) {
            return this._private.removeConstraint(constraint._private)
        };
        WebGLPhysicsWorld.prototype.addCharacter = function(character) {
            return this._private.addBody(character._private.rigidBody._private)
        };
        WebGLPhysicsWorld.prototype.removeCharacter = function(character) {
            return this._private.removeBody(character._private.rigidBody._private)
        };
        WebGLPhysicsWorld.prototype.wakeBody = function(body) {
            this._private.wakeBody(body)
        };
        WebGLPhysicsWorld.prototype.flush = function() {
            this._private.flush()
        };
        WebGLPhysicsWorld.create = function(params) {
            var rets = new WebGLPhysicsWorld;
            var s = new WebGLPrivatePhysicsWorld;
            rets._private = s;
            s._public = rets;
            s.gravity = params.gravity !== undefined ? VMath.v3Copy(params.gravity) : VMath.v3Build(0, -10, 0);
            s.maxSubSteps = params.maxSubSteps !== undefined ? params.maxSubSteps : 10;
            s.fixedTimeStep = params.fixedTimeStep !== undefined ? params.fixedTimeStep : 1 / 60;
            s.variableMinStep = params.minimumTimeStep !== undefined ? params.minimumTimeStep : 1 / 70;
            s.variableMaxStep = params.maximumTimeStep !== undefined ? params.maximumTimeStep : 1 / 50;
            s.variableStep = params.variableTimeSteps !== undefined ? params.variableTimeSteps : false;
            s.maxGiveUpTimeStep = params.maxGiveUpTimeStep !== undefined ? params.maxGiveUpTimeStep : 1 / 20;
            Object.defineProperty(rets, "maxSubSteps", {
                value: s.maxSubSteps,
                enumerable: true
            });
            Object.defineProperty(rets, "maxGiveUpTimeStep", {
                value: s.maxGiveUpTimeStep,
                enumerable: true
            });
            if (!s.variableStep) {
                Object.defineProperty(rets, "fixedTimeStep", {
                    value: s.fixedTimeStep,
                    enumerable: true
                })
            } else {
                Object.defineProperty(rets, "minimumTimeStep", {
                    value: s.variableMinStep,
                    enumerable: true
                });
                Object.defineProperty(rets, "maximumTimeStep", {
                    value: s.variableMaxStep,
                    enumerable: true
                })
            }
            Object.defineProperty(rets, "gravity", {
                get: function physicsWorldGetGravity() {
                    return VMath.v3Copy(this._private.gravity)
                },
                enumerable: true
            });
            s.staticSpatialMap = AABBTree.create(true);
            s.dynamicSpatialMap = AABBTree.create();
            s.sleepingSpatialMap = AABBTree.create();
            s.collisionObjects = [];
            s.rigidBodies = [];
            s.constraints = [];
            s.kinematicBodies = [];
            s.activeArbiters = [];
            s.activeBodies = [];
            s.activeKinematics = [];
            s.activeConstraints = [];
            s.persistantObjectsList = [];
            s.persistantObjectsList2 = [];
            s.persistantTrianglesList = [];
            s.persistantTOIEventList = [];
            s.timeStamp = 0;
            s.performanceData = {
                discrete: 0,
                sleepComputation: 0,
                prestepContacts: 0,
                prestepConstraints: 0,
                integrateVelocities: 0,
                warmstartContacts: 0,
                warmstartConstraints: 0,
                physicsIterations: 0,
                integratePositions: 0,
                continuous: 0
            };
            Object.defineProperty(rets, "performanceData", {
                value: s.performanceData,
                enumerable: true
            });
            s.syncExtents = new Float32Array(6);
            s.contactCallbackObjects = [];
            s.contactCallbackRemovedArbiters = [];
            return rets
        };
        WebGLPhysicsWorld.version = 1;
        return WebGLPhysicsWorld
    }();
    var WebGLPrivatePhysicsWorld = function() {
        function WebGLPrivatePhysicsWorld() {}
        WebGLPrivatePhysicsWorld.prototype.m43InverseOrthonormalTransformVector = function(m, v, dst) {
            if (dst === undefined) {
                dst = new Float32Array(3)
            }
            var v0 = v[0];
            var v1 = v[1];
            var v2 = v[2];
            dst[0] = m[0] * v0 + m[1] * v1 + m[2] * v2;
            dst[1] = m[3] * v0 + m[4] * v1 + m[5] * v2;
            dst[2] = m[6] * v0 + m[7] * v1 + m[8] * v2;
            return dst
        };
        WebGLPrivatePhysicsWorld.prototype.m43InverseOrthonormalTransformPoint = function(m, v, dst) {
            if (dst === undefined) {
                dst = new Float32Array(3)
            }
            var v0 = v[0] - m[9];
            var v1 = v[1] - m[10];
            var v2 = v[2] - m[11];
            dst[0] = m[0] * v0 + m[1] * v1 + m[2] * v2;
            dst[1] = m[3] * v0 + m[4] * v1 + m[5] * v2;
            dst[2] = m[6] * v0 + m[7] * v1 + m[8] * v2;
            return dst
        };
        WebGLPrivatePhysicsWorld.prototype.trianglePlaneDiscard = function(shape, xform, triangleArray, index, txform) {
            if (this.planeAxis === undefined) {
                this.planeAxis = VMath.v3BuildZero();
                this.planeSA = VMath.v3BuildZero();
                this.planeSB = VMath.v3BuildZero()
            }
            var axis = this.planeAxis;
            var supportA = this.planeSA;
            var supportB = this.planeSB;
            var triangles = triangleArray.triangles;
            var n0 = triangles[index];
            var n1 = triangles[index + 1];
            var n2 = triangles[index + 2];
            var nd = triangles[index + 16];
            var A0 = txform[0];
            var A1 = txform[1];
            var A2 = txform[2];
            var A3 = txform[3];
            var A4 = txform[4];
            var A5 = txform[5];
            var A6 = txform[6];
            var A7 = txform[7];
            var A8 = txform[8];
            var A9 = txform[9];
            var A10 = txform[10];
            var A11 = txform[11];
            var w0 = n0 * A0 + n1 * A3 + n2 * A6;
            var w1 = n0 * A1 + n1 * A4 + n2 * A7;
            var w2 = n0 * A2 + n1 * A5 + n2 * A8;
            A0 = xform[0];
            A1 = xform[1];
            A2 = xform[2];
            A3 = xform[3];
            A4 = xform[4];
            A5 = xform[5];
            A6 = xform[6];
            A7 = xform[7];
            A8 = xform[8];
            A9 -= xform[9];
            A10 -= xform[10];
            A11 -= xform[11];
            n0 = A0 * w0 + A1 * w1 + A2 * w2;
            n1 = A3 * w0 + A4 * w1 + A5 * w2;
            n2 = A6 * w0 + A7 * w1 + A8 * w2;
            nd += w0 * A9 + w1 * A10 + w2 * A11;
            axis[0] = n0;
            axis[1] = n1;
            axis[2] = n2;
            shape.localSupportWithoutMargin(axis, supportA);
            axis[0] = -n0;
            axis[1] = -n1;
            axis[2] = -n2;
            shape.localSupportWithoutMargin(axis, supportB);
            var dot1 = supportA[0] * n0 + supportA[1] * n1 + supportA[2] * n2 - nd;
            var dot2 = supportB[0] * n0 + supportB[1] * n1 + supportB[2] * n2 - nd;
            if (dot1 * dot2 <= 0) {
                return false
            }
            var seperation;
            if (dot1 * dot1 < dot2 * dot2) {
                seperation = dot1
            } else {
                seperation = dot2
            }
            if (seperation < 0 !== dot1 * dot2 < 0) {
                seperation = -seperation
            }
            return seperation - shape.collisionRadius > 0
        };
        WebGLPrivatePhysicsWorld.prototype.filtered = function(objectA, objectB) {
            if (objectA === objectB) {
                return true
            }
            if ((objectA.collisionObject || objectA.kinematic) && (objectB.collisionObject || objectB.kinematic)) {
                return true
            }
            if ((objectA.mask & objectB.group) === 0 || (objectB.mask & objectA.group) === 0) {
                return true
            }
            return false
        };
        WebGLPrivatePhysicsWorld.prototype.narrowPhase = function(shapeA, shapeB, objectA, objectB) {
            if (this.narrowTriangle === undefined) {
                this.narrowTriangle = WebGLPhysicsTriangleShape.allocate();
                this.narrowCache = {
                    axis: VMath.v3Build(1, 0, 0),
                    shapeA: null,
                    shapeB: null,
                    closestA: VMath.v3BuildZero(),
                    closestB: VMath.v3BuildZero()
                };
                this.narrowCache2 = {
                    axis: this.narrowCache.axis,
                    shapeA: null,
                    shapeB: null,
                    closestA: this.narrowCache.closestA,
                    closestB: this.narrowCache.closestB
                };
                this.narrowFakeBody = {
                    transform: VMath.m43BuildIdentity(),
                    shape: null
                };
                this.narrowTransform = VMath.m43BuildIdentity();
                this.narrowExtents = new Float32Array(6)
            }
            var arb = null;
            var arbitersA = objectA.arbiters;
            var arbitersB = objectB.arbiters;
            var arbiters = arbitersA.length <= arbitersB.length ? arbitersA : arbitersB;
            var i = 0;
            var numArbiters = arbiters.length;
            for (i = 0; i < numArbiters; i += 1) {
                var carb = arbiters[i];
                if (carb.shapeA === shapeA && carb.shapeB === shapeB && carb.objectA === objectA && carb.objectB === objectB) {
                    arb = carb;
                    break
                }
            }
            if (arb !== null && arb.skipDiscreteCollisions) {
                arb.skipDiscreteCollisions = false;
                return
            }
            var fresh = arb === null;
            if (fresh) {
                arb = WebGLPhysicsArbiter.allocate(shapeA, shapeB, objectA, objectB)
            }
            var cache = this.narrowCache;
            cache.shapeA = shapeA;
            cache.shapeB = shapeB;
            if (arb.contacts.length !== 0) {
                var data = arb.contacts[0];
                cache.axis[0] = data[12];
                cache.axis[1] = data[13];
                cache.axis[2] = data[14]
            }
            var contact;
            var collided = false;
            if (shapeA.type === "TRIANGLE_MESH" || shapeB.type === "TRIANGLE_MESH") {
                var meshShape, otherShape;
                var meshXForm, otherXForm;
                var triangle = this.narrowTriangle;
                var cache2 = this.narrowCache2;
                if (shapeA.type === "TRIANGLE_MESH") {
                    meshShape = shapeA;
                    meshXForm = objectA.transform;
                    otherShape = shapeB;
                    otherXForm = objectB.transform;
                    cache2.shapeA = triangle;
                    cache2.shapeB = cache.shapeB
                } else {
                    meshShape = shapeB;
                    meshXForm = objectB.transform;
                    otherShape = shapeA;
                    otherXForm = objectA.transform;
                    cache2.shapeA = cache.shapeA;
                    cache2.shapeB = triangle
                }
                var triangleArray = meshShape.triangleArray;
                triangle.triangleArray = triangleArray;
                triangle.collisionRadius = meshShape.collisionRadius;
                var numTriangles;
                if (triangleArray.spatialMap) {
                    var transform = this.narrowTransform;
                    var fakeBody = this.narrowFakeBody;
                    var extents = this.narrowExtents;
                    VMath.m43InverseOrthonormal(meshXForm, transform);
                    VMath.m43Mul(otherXForm, transform, fakeBody.transform);
                    fakeBody.shape = otherShape;
                    WebGLPhysicsPrivateBody.prototype.calculateExtents.call(fakeBody, extents);
                    var triangles = this.persistantTrianglesList;
                    numTriangles = triangleArray.spatialMap.getOverlappingNodes(extents, triangles, 0);
                    for (i = 0; i < numTriangles; i += 1) {
                        var index = triangles[i].index;
                        triangle.index = index;
                        triangles[i] = undefined;
                        if (!this.trianglePlaneDiscard(otherShape, otherXForm, triangleArray, index, meshXForm)) {
                            contact = this.contactPairTest(cache2, objectA.transform, objectB.transform);
                            if (contact < 0) {
                                arb.insertContact(cache2.closestA, cache2.closestB, cache2.axis, contact, true);
                                collided = true
                            }
                        }
                    }
                } else {
                    numTriangles = triangleArray.numTriangles;
                    for (i = 0; i < numTriangles; i += 1) {
                        triangle.index = i * WebGLPhysicsPrivateTriangleArray.prototype.TRIANGLE_SIZE;
                        if (!this.trianglePlaneDiscard(otherShape, otherXForm, triangleArray, triangle.index, meshXForm)) {
                            contact = this.contactPairTest(cache2, objectA.transform, objectB.transform);
                            if (contact < 0) {
                                arb.insertContact(cache2.closestA, cache2.closestB, cache2.axis, contact, true);
                                collided = true
                            }
                        }
                    }
                }
            } else {
                contact = this.contactPairTest(cache, objectA.transform, objectB.transform);
                if (contact < 0) {
                    arb.insertContact(cache.closestA, cache.closestB, cache.axis, contact, false);
                    collided = true
                }
            }
            if (collided) {
                if (fresh) {
                    this.activeArbiters.push(arb);
                    arb.active = true;
                    objectA.arbiters.push(arb);
                    objectB.arbiters.push(arb)
                }
                if (objectA.permitSleep && !objectA.active) {
                    this.wakeBody(objectA)
                }
                if (objectB.permitSleep && !objectB.active) {
                    this.wakeBody(objectB)
                }
                if (!arb.active) {
                    arb.active = true;
                    this.activeArbiters.push(arb)
                }
            } else if (fresh) {
                WebGLPhysicsArbiter.deallocate(arb)
            }
        };
        WebGLPrivatePhysicsWorld.prototype.computeSleeping = function(timeStep) {
            function _unify(x, y) {
                var xr = _find(x);
                var yr = _find(y);
                if (xr !== yr) {
                    if (xr.islandRank < yr.islandRank) {
                        xr.islandRoot = yr
                    } else if (xr.islandRank > yr.islandRank) {
                        yr.islandRoot = xr
                    } else {
                        yr.islandRoot = xr;
                        xr.islandRank += 1
                    }
                }
            }

            function _find(x) {
                if (x === x.islandRoot) {
                    return x
                }
                var root = x;
                var stack = null;
                var next;
                while (root !== root.islandRoot) {
                    next = root.islandRoot;
                    root.islandRoot = stack;
                    stack = root;
                    root = next
                }
                while (stack !== null) {
                    next = stack.islandRoot;
                    stack.islandRoot = root;
                    stack = next
                }
                return root
            }
            var objectA, objectB;
            var arbiters = this.activeArbiters;
            var bodies = this.activeBodies;
            var constraints = this.activeConstraints;
            var n;
            var maxN = arbiters.length;
            for (n = 0; n < maxN; n += 1) {
                var arb = arbiters[n];
                objectA = arb.objectA;
                objectB = arb.objectB;
                if (objectA.permitSleep && objectB.permitSleep) {
                    _unify(objectA, objectB)
                }
            }
            maxN = constraints.length;
            var con;
            for (n = 0; n < maxN; n += 1) {
                con = constraints[n];
                objectA = con.bodyA;
                objectB = con.bodyB;
                if (objectA && objectA.permitSleep) {
                    _unify(objectA, con)
                }
                if (objectB && objectB.permitSleep) {
                    _unify(objectB, con)
                }
            }
            var islands = [];
            var island, body, root;
            while (bodies.length > 0) {
                body = bodies.pop();
                root = _find(body);
                island = root.island;
                if (!island) {
                    island = root.island = WebGLPhysicsIsland.allocate();
                    islands.push(island);
                    island.active = false
                }
                body.island = island;
                island.bodies.push(body);
                island.active = island.active || body.isActive(timeStep);
                if (body.wakeTimeStamp > island.wakeTimeStamp) {
                    island.wakeTimeStamp = body.wakeTimeStamp
                }
            }
            while (constraints.length > 0) {
                con = constraints.pop();
                root = _find(con);
                island = root.island;
                if (!island) {
                    island = root.island = WebGLPhysicsIsland.allocate();
                    islands.push(island);
                    island.active = true
                }
                con.island = island;
                island.constraints.push(con);
                if (con.wakeTimeStamp > island.wakeTimeStamp) {
                    island.wakeTimeStamp = con.wakeTimeStamp
                }
            }
            while (islands.length > 0) {
                island = islands.pop();
                if (island.active) {
                    while (island.bodies.length > 0) {
                        body = island.bodies.pop();
                        body.wakeTimeStamp = island.wakeTimeStamp;
                        bodies.push(body);
                        body.islandRoot = body;
                        body.islandRank = 0;
                        body.island = null
                    }
                    while (island.constraints.length > 0) {
                        con = island.constraints.pop();
                        con.wakeTimeStamp = island.wakeTimeStamp;
                        constraints.push(con);
                        con.islandRoot = con;
                        con.islandRank = 0;
                        con.island = null
                    }
                    WebGLPhysicsIsland.deallocate(island)
                } else {
                    maxN = island.bodies.length;
                    for (n = 0; n < maxN; n += 1) {
                        body = island.bodies[n];
                        body.velocity[0] = body.velocity[1] = body.velocity[2] = 0;
                        body.velocity[3] = body.velocity[4] = body.velocity[5] = 0;
                        body.active = false;
                        this.syncBody(body);
                        body.islandRoot = body;
                        body.islandRank = 0
                    }
                    maxN = island.constraints.length;
                    for (n = 0; n < maxN; n += 1) {
                        con = island.constraints[n];
                        con.active = false;
                        con.islandRoot = con;
                        con.islandRank = 0
                    }
                }
            }
        };
        WebGLPrivatePhysicsWorld.prototype.wakeIsland = function(island) {
            while (island.bodies.length > 0) {
                var body = island.bodies.pop();
                body.wakeTimeStamp = this.timeStamp + (this.midStep ? 0 : 1);
                this.activeBodies.push(body);
                var n;
                var arbiters = body.arbiters;
                var maxN = arbiters.length;
                for (n = 0; n < maxN; n += 1) {
                    var arb = arbiters[n];
                    if (!arb.active) {
                        arb.active = true;
                        this.activeArbiters.push(arb)
                    }
                }
                body.active = true;
                body.island = null;
                this.syncBody(body)
            }
            while (island.constraints.length > 0) {
                var constraint = island.constraints.pop();
                constraint.wakeTimeStamp = this.timeStamp + (this.midStep ? 0 : 1);
                this.activeConstraints.push(constraint);
                constraint.active = true;
                constraint.island = null
            }
            WebGLPhysicsIsland.deallocate(island)
        };
        WebGLPrivatePhysicsWorld.prototype.wakeRelated = function(body) {
            var constraints = body.constraints;
            var n;
            var maxN = constraints.length;
            for (n = 0; n < maxN; n += 1) {
                this.wakeConstraint(constraints[n])
            }
            var arbiters = body.arbiters;
            maxN = arbiters.length;
            for (n = 0; n < maxN; n += 1) {
                var arb = arbiters[n];
                if (!arb.active) {
                    arb.active = true;
                    this.activeArbiters.push(arb)
                }
                if (arb.objectA.permitSleep && !arb.objectA.active) {
                    this.wakeBody(arb.objectA)
                }
                if (arb.objectB.permitSleep && !arb.objectB.active) {
                    this.wakeBody(arb.objectB)
                }
            }
        };
        WebGLPrivatePhysicsWorld.prototype.wakeBody = function(body) {
            if (body.collisionObject && !body.kinematic) {
                this.wakeRelated(body);
                this.syncBody(body)
            } else if (body.kinematic) {
                body.delaySleep = true;
                if (!body.active) {
                    body.active = true;
                    this.activeKinematics.push(body);
                    this.wakeRelated(body);
                    this.syncBody(body)
                }
            } else {
                body.wakeTimeStamp = this.timeStamp + (this.midStep ? 0 : 1);
                if (!body.active) {
                    if (!body.island) {
                        body.active = true;
                        this.activeBodies.push(body);
                        this.wakeRelated(body);
                        this.syncBody(body)
                    } else {
                        this.wakeIsland(body.island)
                    }
                    this.syncBody(body)
                }
            }
        };
        WebGLPrivatePhysicsWorld.prototype.syncBody = function(body) {
            var extents = this.syncExtents;
            body.calculateExtents(extents);
            if (body.collisionObject && !body.kinematic) {
                this.staticSpatialMap.update(body, extents)
            } else {
                if (body.active) {
                    if (!body.previouslyActive) {
                        this.sleepingSpatialMap.remove(body);
                        this.dynamicSpatialMap.add(body, extents)
                    } else {
                        this.dynamicSpatialMap.update(body, extents)
                    }
                } else {
                    if (body.previouslyActive) {
                        this.dynamicSpatialMap.remove(body);
                        this.sleepingSpatialMap.add(body, extents)
                    } else {
                        this.sleepingSpatialMap.update(body, extents)
                    }
                }
                body.previouslyActive = body.active
            }
        };
        WebGLPrivatePhysicsWorld.prototype.wakeConstraint = function(constraint) {
            constraint.wakeTimeStamp = this.timeStamp + (this.midStep ? 0 : 1);
            if (!constraint.active) {
                if (!constraint.island) {
                    constraint.active = true;
                    this.activeConstraints.push(constraint);
                    if (constraint.bodyA) {
                        this.wakeBody(constraint.bodyA)
                    }
                    if (constraint.bodyB) {
                        this.wakeBody(constraint.bodyB)
                    }
                } else {
                    this.wakeIsland(constraint.island)
                }
            }
        };
        WebGLPrivatePhysicsWorld.prototype.dynamicSweep = function(toi, timeStep, lowerBound, negRadius) {
            var objectA = toi.objectA;
            var objectB = toi.objectB;
            var axis = toi.axis;
            var vel1 = objectA.velocity;
            var axis0 = -vel1[0];
            var axis1 = -vel1[1];
            var axis2 = -vel1[2];
            var vel2 = objectB.velocity;
            axis0 += vel2[0];
            axis1 += vel2[1];
            axis2 += vel2[2];
            if (axis0 * axis0 + axis1 * axis1 + axis2 * axis2 < WebGLPhysicsConfig.DONT_NORMALIZE_THRESHOLD) {
                toi.toi = undefined;
                return
            }
            axis[0] = axis0;
            axis[1] = axis1;
            axis[2] = axis2;
            var delta0 = -axis0;
            var delta1 = -axis1;
            var delta2 = -axis2;
            var angBias = 0;
            var radiusA, radiusB;
            if (!objectA.fixedRotation) {
                radiusA = objectA.shape.radius;
                angBias += radiusA * Math.sqrt(vel1[3] * vel1[3] + vel1[4] * vel1[4] + vel1[5] * vel1[5])
            }
            if (!objectB.fixedRotation) {
                radiusB = objectB.shape.radius;
                angBias += radiusB * Math.sqrt(vel2[3] * vel2[3] + vel2[4] * vel2[4] + vel2[5] * vel2[5])
            }
            if (angBias < WebGLPhysicsConfig.CONTINUOUS_ANGULAR_BULLET / timeStep) {
                var radius = radiusA < radiusB ? radiusA : radiusB;
                radius *= WebGLPhysicsConfig.CONTINUOUS_LINEAR_BULLET / timeStep;
                if (delta0 * delta0 + delta1 * delta1 + delta2 * delta2 < radius * radius) {
                    toi.toi = undefined;
                    return
                }
            }
            var curIter = 0;
            var maxIter = 100;
            var curTOI = lowerBound;
            for (;;) {
                objectA.integratePosition(curTOI * timeStep);
                objectB.integratePosition(curTOI * timeStep);
                var nextContact = this.contactPairTest(toi, objectA.transform, objectB.transform);
                var seperation = nextContact;
                if (nextContact !== undefined) {
                    seperation += negRadius
                }
                if (seperation === undefined || seperation < WebGLPhysicsConfig.GJK_EPA_DISTANCE_THRESHOLD) {
                    if (!this.seperatingTOI(toi)) {
                        toi.distance = nextContact
                    } else {
                        curTOI = undefined
                    }
                    break
                }
                var dot = axis[0] * delta0 + axis[1] * delta1 + axis[2] * delta2;
                var denom = (angBias - dot) * timeStep;
                if (denom <= 0) {
                    curTOI = undefined;
                    break
                }
                curTOI += seperation / denom;
                if (curTOI >= 1) {
                    curTOI = undefined;
                    break
                }
                curIter += 1;
                if (curIter > maxIter) {
                    curTOI = undefined;
                    break
                }
            }
            toi.toi = curTOI
        };
        WebGLPrivatePhysicsWorld.prototype.seperatingTOI = function(toi) {
            var objectA = toi.objectA;
            var objectB = toi.objectB;
            var supportA = toi.closestA;
            var supportB = toi.closestB;
            var velA = objectA.velocity;
            var velB = objectB.velocity;
            var vrel0 = velA[0] - velB[0];
            var vrel1 = velA[1] - velB[1];
            var vrel2 = velA[2] - velB[2];
            if (!objectA.fixedRotation) {
                var relA0 = supportA[0] - objectA.transform[9];
                var relA1 = supportA[1] - objectA.transform[10];
                var relA2 = supportA[2] - objectA.transform[11];
                vrel0 += velA[4] * relA2 - velA[5] * relA1;
                vrel1 += velA[5] * relA0 - velA[3] * relA2;
                vrel2 += velA[3] * relA1 - velA[4] * relA0
            }
            if (!objectB.fixedRotation) {
                var relB0 = supportB[0] - objectB.transform[9];
                var relB1 = supportB[1] - objectB.transform[10];
                var relB2 = supportB[2] - objectB.transform[11];
                vrel0 -= velB[4] * relB2 - velB[5] * relB1;
                vrel1 -= velB[5] * relB0 - velB[3] * relB2;
                vrel2 -= velB[3] * relB1 - velB[4] * relB0
            }
            var axis = toi.axis;
            var dot = vrel0 * axis[0] + vrel1 * axis[1] + vrel2 * axis[2];
            return dot >= 0
        };
        WebGLPrivatePhysicsWorld.prototype.staticSweep = function(toi, timeStep, lowerBound, negRadius) {
            var objectA = toi.objectA;
            var objectB = toi.objectB;
            var axis = toi.axis;
            var vel = objectA.velocity;
            var axis0 = -vel[0];
            var axis1 = -vel[1];
            var axis2 = -vel[2];
            if (axis0 * axis0 + axis1 * axis1 + axis2 * axis2 < WebGLPhysicsConfig.DONT_NORMALIZE_THRESHOLD) {
                toi.toi = undefined;
                return
            }
            axis[0] = axis0;
            axis[1] = axis1;
            axis[2] = axis2;
            var delta0 = -axis0;
            var delta1 = -axis1;
            var delta2 = -axis2;
            var angBias = 0;
            if (!objectA.fixedRotationtype) {
                angBias += objectA.shape.radius * Math.sqrt(vel[3] * vel[3] + vel[4] * vel[4] + vel[5] * vel[5])
            }
            var curIter = 0;
            var maxIter = 100;
            var curTOI = lowerBound;
            for (;;) {
                objectA.integratePosition(curTOI * timeStep);
                var nextContact = this.contactPairTest(toi, objectA.transform, objectB.transform);
                var seperation = nextContact;
                if (nextContact !== undefined) {
                    seperation += negRadius
                }
                if (seperation === undefined || seperation < WebGLPhysicsConfig.GJK_EPA_DISTANCE_THRESHOLD) {
                    if (!this.seperatingTOI(toi)) {
                        toi.distance = nextContact
                    } else {
                        curTOI = undefined
                    }
                    break
                }
                var dot = axis[0] * delta0 + axis[1] * delta1 + axis[2] * delta2;
                var denom = (angBias - dot) * timeStep;
                if (denom <= 0) {
                    curTOI = undefined;
                    break
                }
                curTOI += seperation / denom;
                if (curTOI >= 1) {
                    curTOI = undefined;
                    break
                }
                curIter += 1;
                if (curIter > maxIter) {
                    curTOI = undefined;
                    break
                }
            }
            toi.toi = curTOI
        };
        WebGLPrivatePhysicsWorld.prototype.performStaticTOIBase = function(slop, timeStep, events, numEvents, objectA, objectB) {
            var triangles = this.persistantTrianglesList;
            if (this.continuousFakeBody === undefined) {
                this.continuousFakeBody = {
                    shape: null,
                    transform: VMath.m43BuildIdentity(),
                    startTransform: VMath.m43BuildIdentity()
                };
                this.continuousInvTransform = VMath.m43BuildIdentity();
                this.continuousExtents = new Float32Array(6)
            }
            var fakeBody = this.continuousFakeBody;
            var invTransform = this.continuousInvTransform;
            var extents = this.continuousExtents;
            var toi;
            if (objectB.shape.type === "TRIANGLE_MESH") {
                var triangleArray = objectB.shape.triangleArray;
                var numTriangles, k;
                if (triangleArray.spatialMap) {
                    fakeBody.shape = objectA.shape;
                    VMath.m43InverseOrthonormal(objectB.transform, invTransform);
                    VMath.m43Mul(objectA.startTransform, invTransform, fakeBody.startTransform);
                    VMath.m43Mul(objectA.endTransform, invTransform, fakeBody.transform);
                    WebGLPhysicsPrivateBody.prototype.calculateSweptExtents.call(fakeBody, extents);
                    numTriangles = triangleArray.spatialMap.getOverlappingNodes(extents, triangles, 0);
                    for (k = 0; k < numTriangles; k += 1) {
                        toi = WebGLPhysicsTOIEvent.allocate();
                        toi.objectA = objectA;
                        toi.objectB = objectB;
                        toi.shapeA = objectA.shape;
                        toi.shapeB = WebGLPhysicsTriangleShape.allocate();
                        toi.shapeB.index = triangles[k].index;
                        triangles[k] = undefined;
                        toi.shapeB.triangleArray = objectB.shape.triangleArray;
                        toi.shapeB.collisionRadius = objectB.shape.collisionRadius;
                        toi.concave = true;
                        this.staticSweep(toi, timeStep, 0, slop);
                        if (toi.toi === undefined) {
                            WebGLPhysicsTOIEvent.deallocate(toi);
                            continue
                        }
                        toi.frozenA = false;
                        toi.frozenB = true;
                        events[numEvents] = toi;
                        numEvents += 1
                    }
                } else {
                    numTriangles = triangleArray.numTriangles;
                    for (k = 0; k < numTriangles; k += 1) {
                        toi = WebGLPhysicsTOIEvent.allocate();
                        toi.objectA = objectA;
                        toi.objectB = objectB;
                        toi.shapeA = objectA.shape;
                        toi.shapeB = WebGLPhysicsTriangleShape.allocate();
                        toi.shapeB.index = k * WebGLPhysicsPrivateTriangleArray.prototype.TRIANGLE_SIZE;
                        toi.shapeB.triangleArray = objectB.shape.triangleArray;
                        toi.shapeB.collisionRadius = objectB.shape.collisionRadius;
                        toi.concave = true;
                        this.staticSweep(toi, timeStep, 0, slop);
                        if (toi.toi === undefined) {
                            WebGLPhysicsTOIEvent.deallocate(toi);
                            continue
                        }
                        toi.frozenA = false;
                        toi.frozenB = true;
                        events[numEvents] = toi;
                        numEvents += 1
                    }
                }
            } else {
                toi = WebGLPhysicsTOIEvent.allocate();
                toi.objectA = objectA;
                toi.objectB = objectB;
                toi.shapeA = objectA.shape;
                toi.shapeB = objectB.shape;
                this.staticSweep(toi, timeStep, 0, slop);
                if (toi.toi === undefined) {
                    WebGLPhysicsTOIEvent.deallocate(toi);
                    return numEvents
                }
                toi.frozenA = false;
                toi.frozenB = true;
                events[numEvents] = toi;
                numEvents += 1
            }
            return numEvents
        };
        WebGLPrivatePhysicsWorld.prototype.update = function() {
            var dynamicMap = this.dynamicSpatialMap;
            var staticMap = this.staticSpatialMap;
            var sleepingMap = this.sleepingSpatialMap;
            var rigidBodies = this.activeBodies;
            var kinematics = this.activeKinematics;
            var constraints = this.activeConstraints;
            var arbiters = this.activeArbiters;
            var gravity = this.gravity;
            var performance = this.performanceData;
            performance.discrete = 0;
            performance.sleepComputation = 0;
            performance.prestepContacts = 0;
            performance.prestepConstraints = 0;
            performance.integrateVelocities = 0;
            performance.warmstartContacts = 0;
            performance.warmstartConstraints = 0;
            performance.physicsIterations = 0;
            performance.integratePositions = 0;
            performance.continuous = 0;
            var prevTime = this.prevTimeStamp;
            if (prevTime === undefined) {
                this.prevTimeStamp = TurbulenzEngine.getTime() * .001;
                return
            }
            var curTime = TurbulenzEngine.getTime() * .001;
            var timeDelta = curTime - prevTime;
            var numSteps, timeStep;
            if (this.variableStep) {
                var minTimeStep = this.variableMinStep;
                var maxTimeStep = this.variableMaxStep;
                numSteps = Math.ceil(timeDelta / maxTimeStep);
                timeStep = timeDelta / numSteps;
                if (timeStep < minTimeStep) {
                    timeStep = minTimeStep;
                    numSteps = Math.floor(timeDelta / timeStep)
                }
                if (numSteps > this.maxSubSteps && this.maxGiveUpTimeStep !== 0) {
                    numSteps = Math.ceil(timeDelta / this.maxGiveUpTimeStep);
                    timeStep = timeDelta / numSteps
                }
            } else {
                timeStep = this.fixedTimeStep;
                numSteps = Math.floor(timeDelta / timeStep);
                if (numSteps > this.maxSubSteps && this.maxGiveUpTimeStep !== 0) {
                    numSteps = Math.ceil(timeDelta / this.maxGiveUpTimeStep);
                    timeStep = timeDelta / numSteps
                }
            }
            if (numSteps <= 0) {
                return
            }
            this.prevTimeStamp += timeStep * numSteps;
            if (numSteps > this.maxSubSteps) {
                numSteps = this.maxSubSteps
            }
            this.midStep = true;
            var limit, i;
            var body;
            limit = kinematics.length;
            for (i = 0; i < limit;) {
                body = kinematics[i];
                if (!body.computeDeltaVelocity(timeStep * numSteps, body.prevTransform, body.transform) && !body.delaySleep) {
                    body.active = false;
                    limit -= 1;
                    kinematics[i] = kinematics[limit];
                    kinematics.pop();
                    this.syncBody(body)
                } else {
                    VMath.m43Copy(body.transform, body.newTransform);
                    VMath.m43Copy(body.prevTransform, body.transform);
                    i += 1
                }
                body.delaySleep = false
            }
            var substep;
            for (substep = 0; substep < numSteps; substep += 1) {
                var j, extents;
                this.timeStamp += 1;
                var preTime;
                if (this.prevTimeStep === undefined) {
                    this.prevTimeStep = timeStep
                }
                var timeStepRatio = timeStep / this.prevTimeStep;
                this.prevTimeStep = timeStep;
                limit = rigidBodies.length;
                for (i = 0; i < limit; i += 1) {
                    body = rigidBodies[i];
                    extents = body.extents;
                    body.calculateExtents(extents);
                    dynamicMap.update(body, extents);
                    body.refreshInertiaTensor()
                }
                limit = kinematics.length;
                for (i = 0; i < limit; i += 1) {
                    body = kinematics[i];
                    extents = body.extents;
                    body.calculateExtents(extents);
                    dynamicMap.update(body, extents)
                }
                preTime = TurbulenzEngine.getTime() * .001;
                staticMap.finalize();
                dynamicMap.finalize();
                sleepingMap.finalize();
                var objects = this.persistantObjectsList;
                var numDynDyn = dynamicMap.getOverlappingPairs(objects, 0);
                var storageIndex = numDynDyn;
                var numPairs;
                limit = rigidBodies.length;
                for (i = 0; i < limit; i += 1) {
                    body = rigidBodies[i];
                    numPairs = staticMap.getOverlappingNodes(body.extents, objects, storageIndex + 1);
                    numPairs += sleepingMap.getOverlappingNodes(body.extents, objects, storageIndex + 1 + numPairs);
                    if (numPairs !== 0) {
                        objects[storageIndex] = body;
                        storageIndex += 1 + numPairs;
                        objects[storageIndex] = body;
                        storageIndex += 1
                    }
                }
                limit = kinematics.length;
                for (i = 0; i < limit; i += 1) {
                    body = kinematics[i];
                    numPairs = sleepingMap.getOverlappingNodes(body.extents, objects, storageIndex + 1);
                    if (numPairs !== 0) {
                        objects[storageIndex] = body;
                        storageIndex += 1 + numPairs;
                        objects[storageIndex] = body;
                        storageIndex += 1
                    }
                }
                var objectA, objectB;
                for (i = 0; i < numDynDyn; i += 2) {
                    objectA = objects[i];
                    objectB = objects[i + 1];
                    objects[i] = undefined;
                    objects[i + 1] = undefined;
                    if (!this.filtered(objectA, objectB)) {
                        if (objectA.id < objectB.id) {
                            this.narrowPhase(objectA.shape, objectB.shape, objectA, objectB)
                        } else {
                            this.narrowPhase(objectB.shape, objectA.shape, objectB, objectA)
                        }
                    }
                }
                for (i = numDynDyn; i < storageIndex;) {
                    objectA = objects[i];
                    objects[i] = undefined;
                    i += 1;
                    for (;;) {
                        objectB = objects[i];
                        objects[i] = undefined;
                        i += 1;
                        if (objectA === objectB) {
                            break
                        }
                        if (!this.filtered(objectA, objectB)) {
                            if (objectA.id < objectB.id) {
                                this.narrowPhase(objectA.shape, objectB.shape, objectA, objectB)
                            } else {
                                this.narrowPhase(objectB.shape, objectA.shape, objectB, objectA)
                            }
                        }
                    }
                }
                performance.discrete += TurbulenzEngine.getTime() * .001 - preTime;
                preTime = TurbulenzEngine.getTime() * .001;
                this.computeSleeping(timeStep);
                performance.sleepComputation += TurbulenzEngine.getTime() * .001 - preTime;
                preTime = TurbulenzEngine.getTime() * .001;
                i = 0;
                var arb;
                while (i < arbiters.length) {
                    arb = arbiters[i];
                    if (!arb.objectA.active && !arb.objectB.active) {
                        arb.active = false;
                        arbiters[i] = arbiters[arbiters.length - 1];
                        arbiters.pop();
                        continue
                    }
                    if (arb.refreshContacts()) {
                        arbiters[i] = arbiters[arbiters.length - 1];
                        arbiters.pop();
                        objectA = arb.objectA;
                        objectB = arb.objectB;
                        var bodyArbiters = objectA.arbiters;
                        bodyArbiters[bodyArbiters.indexOf(arb)] = bodyArbiters[bodyArbiters.length - 1];
                        bodyArbiters.pop();
                        bodyArbiters = objectB.arbiters;
                        bodyArbiters[bodyArbiters.indexOf(arb)] = bodyArbiters[bodyArbiters.length - 1];
                        bodyArbiters.pop();
                        if (objectA.contactCallbacks && objectA.contactCallbacks.onRemovedContacts || objectB.contactCallbacks && objectB.contactCallbacks.onRemovedContacts) {
                            this.contactCallbackRemovedArbiters.push(arb)
                        } else {
                            WebGLPhysicsArbiter.deallocate(arb)
                        }
                        continue
                    }
                    arb.preStep(timeStepRatio, timeStep);
                    i += 1
                }
                performance.prestepContacts += TurbulenzEngine.getTime() * .001 - preTime;
                preTime = TurbulenzEngine.getTime() * .001;
                limit = constraints.length;
                for (i = 0; i < limit; i += 1) {
                    constraints[i].preStep(timeStepRatio, timeStep)
                }
                performance.prestepConstraints += TurbulenzEngine.getTime() * .001 - preTime;
                preTime = TurbulenzEngine.getTime() * .001;
                limit = rigidBodies.length;
                for (i = 0; i < limit; i += 1) {
                    body = rigidBodies[i];
                    body.integrateVelocity(gravity, timeStep)
                }
                performance.integrateVelocities += TurbulenzEngine.getTime() * .001 - preTime;
                preTime = TurbulenzEngine.getTime() * .001;
                limit = arbiters.length;
                for (i = 0; i < limit; i += 1) {
                    arbiters[i].applyCachedImpulses()
                }
                performance.warmstartContacts += TurbulenzEngine.getTime() * .001 - preTime;
                preTime = TurbulenzEngine.getTime() * .001;
                limit = constraints.length;
                for (i = 0; i < limit; i += 1) {
                    constraints[i].applyCachedImpulses()
                }
                performance.warmstartConstraints += TurbulenzEngine.getTime() * .001 - preTime;
                preTime = TurbulenzEngine.getTime() * .001;
                var numIterations = 10;
                for (i = 0; i < numIterations; i += 1) {
                    limit = arbiters.length;
                    for (j = 0; j < limit; j += 1) {
                        arbiters[j].computeAndApplyImpulses()
                    }
                    limit = constraints.length;
                    for (j = 0; j < limit; j += 1) {
                        constraints[j].computeAndApplyImpulses()
                    }
                }
                numIterations = 3;
                limit = arbiters.length;
                for (i = 0; i < numIterations; i += 1) {
                    for (j = 0; j < limit; j += 1) {
                        arbiters[j].computeAndApplyBiasImpulses()
                    }
                }
                performance.physicsIterations += TurbulenzEngine.getTime() * .001 - preTime;
                var unfrozen = this.persistantObjectsList2;
                var numUnfrozen = 0;
                preTime = TurbulenzEngine.getTime() * .001;
                limit = rigidBodies.length;
                var radius;
                var timeStepSq = timeStep * timeStep;
                var xform0, xform1;
                for (i = 0; i < limit; i += 1) {
                    body = rigidBodies[i];
                    body.applyBiasVelocities(timeStep);
                    body.integratePosition(timeStep);
                    if (!body.isActiveVelocity(WebGLPhysicsConfig.CONTINUOUS_LINEAR_SQ / timeStep, WebGLPhysicsConfig.CONTINUOUS_ANGULAR_SQ / timeStep)) {
                        body.sweepFrozen = true;
                        body.bullet = false;
                        continue
                    }
                    xform0 = body.transform;
                    xform1 = body.endTransform;
                    xform1[0] = xform0[0];
                    xform1[1] = xform0[1];
                    xform1[2] = xform0[2];
                    xform1[3] = xform0[3];
                    xform1[4] = xform0[4];
                    xform1[5] = xform0[5];
                    xform1[6] = xform0[6];
                    xform1[7] = xform0[7];
                    xform1[8] = xform0[8];
                    xform1[9] = xform0[9];
                    xform1[10] = xform0[10];
                    xform1[11] = xform0[11];
                    radius = body.shape.radius * WebGLPhysicsConfig.CONTINUOUS_LINEAR_BULLET;
                    var vel = body.velocity;
                    var vlsq = (vel[0] * vel[0] + vel[1] * vel[1] + vel[2] * vel[2]) * timeStepSq;
                    var wlsq = (vel[3] * vel[3] + vel[4] * vel[4] + vel[5] * vel[5]) * timeStepSq;
                    body.bullet = vlsq > radius * radius || wlsq > WebGLPhysicsConfig.CONTINUOUS_ANGULAR_BULLET;
                    extents = body.extents;
                    body.calculateSweptExtents(extents);
                    dynamicMap.update(body, extents);
                    body.sweepFrozen = false;
                    unfrozen[numUnfrozen] = body;
                    numUnfrozen += 1
                }
                limit = kinematics.length;
                for (i = 0; i < limit; i += 1) {
                    body = kinematics[i];
                    VMath.m43Copy(body.transform, body.startTransform);
                    body.integratePosition(timeStep);
                    extents = body.extents;
                    body.calculateSweptExtents(extents);
                    dynamicMap.update(body, extents)
                }
                performance.integratePositions += TurbulenzEngine.getTime() * .001 - preTime;
                preTime = TurbulenzEngine.getTime() * .001;
                staticMap.finalize();
                dynamicMap.finalize();
                sleepingMap.finalize();
                var slop = WebGLPhysicsConfig.CONTINUOUS_SLOP + WebGLPhysicsConfig.CONTACT_SLOP;
                var events = this.persistantTOIEventList;
                var numEvents = 0;
                var toi;
                numDynDyn = dynamicMap.getOverlappingPairs(objects, 0);
                for (i = 0; i < numDynDyn; i += 2) {
                    objectA = objects[i];
                    objectB = objects[i + 1];
                    objects[i] = undefined;
                    objects[i + 1] = undefined;
                    if (!(objectA.bullet || objectA.kinematic || (objectB.bullet || objectB.kinematic)) || objectA.sweepFrozen && objectB.sweepFrozen || this.filtered(objectA, objectB)) {
                        continue
                    }
                    if (objectA.kinematic || objectB.kinematic) {
                        if (objectA.kinematic) {
                            numEvents = this.performStaticTOIBase(slop, timeStep, events, numEvents, objectB, objectA)
                        } else {
                            numEvents = this.performStaticTOIBase(slop, timeStep, events, numEvents, objectA, objectB)
                        }
                    } else {
                        toi = WebGLPhysicsTOIEvent.allocate();
                        toi.objectA = objectA;
                        toi.objectB = objectB;
                        toi.shapeA = objectA.shape;
                        toi.shapeB = objectB.shape;
                        this.dynamicSweep(toi, timeStep, 0, slop);
                        toi.frozenA = objectA.sweepFrozen;
                        toi.frozenB = objectB.sweepFrozen;
                        events[numEvents] = toi;
                        numEvents += 1
                    }
                }
                for (i = 0; i < numUnfrozen; i += 1) {
                    objectA = unfrozen[i];
                    numPairs = staticMap.getOverlappingNodes(objectA.extents, objects, 0);
                    numPairs += sleepingMap.getOverlappingNodes(objectA.extents, objects, numPairs);
                    for (j = 0; j < numPairs; j += 1) {
                        objectB = objects[j];
                        objects[j] = undefined;
                        if (this.filtered(objectA, objectB)) {
                            continue
                        }
                        numEvents = this.performStaticTOIBase(slop, timeStep, events, numEvents, objectA, objectB)
                    }
                }
                var curTimeAlpha = 0;
                while (curTimeAlpha < 1 && numEvents > 0) {
                    var minTOI = null;
                    var minIndex;
                    for (i = 0; i < numEvents;) {
                        toi = events[i];
                        objectA = toi.objectA;
                        objectB = toi.objectB;
                        if (objectA.sweepFrozen && objectB.sweepFrozen) {
                            numEvents -= 1;
                            if (i !== numEvents) {
                                events[i] = events[numEvents];
                                events[numEvents] = undefined
                            }
                            WebGLPhysicsTOIEvent.deallocate(toi);
                            continue
                        }
                        if (toi.frozenA !== objectA.sweepFrozen || toi.frozenB !== objectB.sweepFrozen) {
                            toi.frozenA = objectA.sweepFrozen;
                            toi.frozenB = objectB.sweepFrozen;
                            if (toi.frozenA) {
                                toi.objectA = objectB;
                                toi.objectB = objectA;
                                toi.shapeA = objectB.shape;
                                toi.shapeB = objectA.shape;
                                toi.frozenA = false;
                                toi.frozenB = true
                            }
                            this.staticSweep(toi, timeStep, curTimeAlpha, slop);
                            if (toi.toi === undefined) {
                                numEvents -= 1;
                                if (i !== numEvents) {
                                    events[i] = events[numEvents];
                                    events[numEvents] = undefined
                                }
                                WebGLPhysicsTOIEvent.deallocate(toi);
                                continue
                            }
                        }
                        if (toi.toi !== undefined && (minTOI === null || toi.toi < minTOI.toi)) {
                            minTOI = toi;
                            minIndex = i
                        }
                        i += 1
                    }
                    if (minTOI === null) {
                        break
                    }
                    numEvents -= 1;
                    if (minIndex !== numEvents) {
                        events[minIndex] = events[numEvents];
                        events[numEvents] = undefined
                    }
                    curTimeAlpha = minTOI.toi;
                    objectA = minTOI.objectA;
                    objectB = minTOI.objectB;
                    if (!objectA.collisionObject) {
                        if (!objectA.sweepFrozen) {
                            objectA.integratePosition(timeStep * curTimeAlpha);
                            objectA.sweepFrozen = true
                        }
                        if (objectA.permitSleep && !objectA.active) {
                            this.wakeBody(objectA)
                        }
                    }
                    if (!objectB.collisionObject) {
                        if (!objectB.sweepFrozen) {
                            objectB.integratePosition(timeStep * curTimeAlpha);
                            objectB.sweepFrozen = true
                        }
                        if (objectB.permitSleep && !objectB.active) {
                            this.wakeBody(objectB)
                        }
                    }
                    if (objectA.id > objectB.id) {
                        var tmp = objectA;
                        objectA = objectB;
                        objectB = tmp;
                        var tmpv = minTOI.closestA;
                        minTOI.closestA = minTOI.closestB;
                        minTOI.closestB = tmpv;
                        tmpv = minTOI.axis;
                        tmpv[0] = -tmpv[0];
                        tmpv[1] = -tmpv[1];
                        tmpv[2] = -tmpv[2]
                    }
                    var shapeA = objectA.shape;
                    var shapeB = objectB.shape;
                    arb = null;
                    var arbitersA = objectA.arbiters;
                    var arbitersB = objectB.arbiters;
                    var arbs = arbitersA.length <= arbitersB.length ? arbitersA : arbitersB;
                    var numArbiters = arbs.length;
                    for (i = 0; i < numArbiters; i += 1) {
                        var carb = arbs[i];
                        if (carb.shapeA === shapeA && carb.shapeB === shapeB && carb.objectA === objectA && carb.objectB === objectB) {
                            arb = carb;
                            break
                        }
                    }
                    var fresh = arb === null;
                    if (fresh) {
                        arb = WebGLPhysicsArbiter.allocate(shapeA, shapeB, objectA, objectB)
                    }
                    arb.insertContact(minTOI.closestA, minTOI.closestB, minTOI.axis, minTOI.distance, minTOI.concave);
                    if (fresh) {
                        arbiters.push(arb);
                        arb.active = true;
                        objectA.arbiters.push(arb);
                        objectB.arbiters.push(arb)
                    }
                    if (!(objectA.kinematic && objectA.active || objectB.kinematic && objectB.active)) {
                        arb.skipDiscreteCollisions = true
                    }
                    WebGLPhysicsTOIEvent.deallocate(minTOI)
                }
                while (numEvents > 0) {
                    numEvents -= 1;
                    WebGLPhysicsTOIEvent.deallocate(events[numEvents]);
                    events[numEvents] = undefined
                }
                while (numUnfrozen > 0) {
                    numUnfrozen -= 1;
                    objectA = unfrozen[numUnfrozen];
                    unfrozen[numUnfrozen] = undefined;
                    if (!objectA.sweepFrozen) {
                        objectA.integratePosition(timeStep)
                    }
                }
                performance.continuous += TurbulenzEngine.getTime() * .001 - preTime
            }
            limit = kinematics.length;
            for (i = 0; i < limit; i += 1) {
                body = kinematics[i];
                VMath.m43Copy(body.newTransform, body.transform);
                VMath.m43Copy(body.newTransform, body.prevTransform)
            }
            this.updateContactCallbacks();
            this.midStep = false
        };
        WebGLPrivatePhysicsWorld.prototype.rayTest = function(ray) {
            var group = ray.group;
            var mask = ray.mask;
            if (group === undefined) {
                group = WebGLPhysicsDevice.prototype.FILTER_DYNAMIC
            }
            if (mask === undefined) {
                mask = WebGLPhysicsDevice.prototype.FILTER_ALL
            }
            var exclude = ray.exclude;
            var pRay = {
                origin: ray.from,
                direction: VMath.v3Sub(ray.to, ray.from),
                maxFactor: 1
            };
            this.staticSpatialMap.finalize();
            this.dynamicSpatialMap.finalize();
            this.sleepingSpatialMap.finalize();

            function rayCallback(tree, obj, pRay, unusedAABBDistance, upperBound) {
                var actual_obj = obj._public;
                if (actual_obj === exclude || (obj.mask & group) === 0 || (obj.group & mask) === 0) {
                    return null
                }
                pRay.maxFactor = upperBound;
                var resultObj = obj.rayTest(pRay);
                if (resultObj !== null) {
                    if (obj.collisionObject) {
                        resultObj.collisionObject = actual_obj;
                        resultObj.body = null
                    } else {
                        resultObj.collisionObject = null;
                        resultObj.body = actual_obj
                    }
                }
                return resultObj
            }
            var ret = AABBTree.rayTest([this.staticSpatialMap, this.dynamicSpatialMap, this.sleepingSpatialMap], pRay, rayCallback);
            if (ret !== null) {
                delete ret.factor
            }
            return ret
        };
        WebGLPrivatePhysicsWorld.prototype.contactPairTest = function(cache, xformA, xformB) {
            var axis = cache.axis;
            var shapeA = cache.shapeA;
            var shapeB = cache.shapeB;
            var supportA = cache.closestA;
            var supportB = cache.closestB;
            if (this.contactGJK === undefined) {
                this.contactGJK = WebGLGJKContactSolver.create();
                this.contactEPA = WebGLContactEPA.create()
            }
            if (shapeA.type === "PLANE" || shapeB.type === "PLANE") {
                var planeShape, otherShape;
                var planeXForm, otherXForm;
                if (shapeA.type === "PLANE") {
                    planeShape = shapeA;
                    planeXForm = xformA;
                    otherShape = shapeB;
                    otherXForm = xformB
                } else {
                    planeShape = shapeB;
                    planeXForm = xformB;
                    otherShape = shapeA;
                    otherXForm = xformA
                }
                var A0 = planeXForm[0];
                var A1 = planeXForm[1];
                var A2 = planeXForm[2];
                var A3 = planeXForm[3];
                var A4 = planeXForm[4];
                var A5 = planeXForm[5];
                var A6 = planeXForm[6];
                var A7 = planeXForm[7];
                var A8 = planeXForm[8];
                var A9 = planeXForm[9];
                var A10 = planeXForm[10];
                var A11 = planeXForm[11];
                var n = planeShape.normal;
                var n0 = n[0];
                var n1 = n[1];
                var n2 = n[2];
                var nd = planeShape.distance;
                var w0 = n0 * A0 + n1 * A3 + n2 * A6;
                var w1 = n0 * A1 + n1 * A4 + n2 * A7;
                var w2 = n0 * A2 + n1 * A5 + n2 * A8;
                A0 = otherXForm[0];
                A1 = otherXForm[1];
                A2 = otherXForm[2];
                A3 = otherXForm[3];
                A4 = otherXForm[4];
                A5 = otherXForm[5];
                A6 = otherXForm[6];
                A7 = otherXForm[7];
                A8 = otherXForm[8];
                var B9 = otherXForm[9];
                var B10 = otherXForm[10];
                var B11 = otherXForm[11];
                n0 = A0 * w0 + A1 * w1 + A2 * w2;
                n1 = A3 * w0 + A4 * w1 + A5 * w2;
                n2 = A6 * w0 + A7 * w1 + A8 * w2;
                nd += w0 * (A9 - B9) + w1 * (A10 - B10) + w2 * (A11 - B11);
                axis[0] = n0;
                axis[1] = n1;
                axis[2] = n2;
                otherShape.localSupportWithoutMargin(axis, supportA);
                axis[0] = -n0;
                axis[1] = -n1;
                axis[2] = -n2;
                otherShape.localSupportWithoutMargin(axis, supportB);
                var dot1 = supportA[0] * n0 + supportA[1] * n1 + supportA[2] * n2 - nd;
                var dot2 = supportB[0] * n0 + supportB[1] * n1 + supportB[2] * n2 - nd;
                var seperation, c0, c1, c2;
                if (dot1 * dot1 < dot2 * dot2) {
                    c0 = supportA[0];
                    c1 = supportA[1];
                    c2 = supportA[2];
                    seperation = dot1
                } else {
                    c0 = supportB[0];
                    c1 = supportB[1];
                    c2 = supportB[2];
                    seperation = dot2
                }
                if (seperation < 0 !== dot1 * dot2 < 0) {
                    seperation = -seperation;
                    w0 = -w0;
                    w1 = -w1;
                    w2 = -w2
                }
                var rad = otherShape.collisionRadius;
                var prad = planeShape.collisionRadius;
                var a0 = A0 * c0 + A3 * c1 + A6 * c2 + B9;
                var a1 = A1 * c0 + A4 * c1 + A7 * c2 + B10;
                var a2 = A2 * c0 + A5 * c1 + A8 * c2 + B11;
                var rsep = prad - seperation;
                var p0 = a0 + w0 * rsep;
                var p1 = a1 + w1 * rsep;
                var p2 = a2 + w2 * rsep;
                a0 -= w0 * rad;
                a1 -= w1 * rad;
                a2 -= w2 * rad;
                seperation -= rad + prad;
                if (shapeA.type === "PLANE") {
                    axis[0] = -w0;
                    axis[1] = -w1;
                    axis[2] = -w2;
                    supportA[0] = p0;
                    supportA[1] = p1;
                    supportA[2] = p2;
                    supportB[0] = a0;
                    supportB[1] = a1;
                    supportB[2] = a2
                } else {
                    axis[0] = w0;
                    axis[1] = w1;
                    axis[2] = w2;
                    supportA[0] = a0;
                    supportA[1] = a1;
                    supportA[2] = a2;
                    supportB[0] = p0;
                    supportB[1] = p1;
                    supportB[2] = p2
                }
                return seperation
            } else {
                var gjk = this.contactGJK;
                var distance = gjk.evaluate(cache, xformA, xformB);
                if (distance === undefined) {
                    distance = this.contactEPA.evaluate(gjk.simplex, cache, xformA, xformB)
                }
                if (distance !== undefined) {
                    var axis0 = axis[0];
                    var axis1 = axis[1];
                    var axis2 = axis[2];
                    var radiusA = shapeA.collisionRadius;
                    var radiusB = shapeB.collisionRadius;
                    supportA[0] -= axis0 * radiusA;
                    supportA[1] -= axis1 * radiusA;
                    supportA[2] -= axis2 * radiusA;
                    supportB[0] += axis0 * radiusB;
                    supportB[1] += axis1 * radiusB;
                    supportB[2] += axis2 * radiusB;
                    return distance - radiusA - radiusB
                } else {
                    return undefined
                }
            }
        };
        WebGLPrivatePhysicsWorld.prototype.convexSweepTest = function(params, callback) {
            if (this.sweepCache === undefined) {
                this.sweepCache = {
                    axis: VMath.v3BuildZero(),
                    shapeA: null,
                    shapeB: null,
                    closestA: VMath.v3BuildZero(),
                    closestB: VMath.v3BuildZero()
                };
                this.sweepTriangle = WebGLPhysicsTriangleShape.allocate();
                this.sweepDelta = VMath.v3BuildZero();
                this.sweepFromExtents = new Float32Array(6);
                this.sweepToExtents = new Float32Array(6);
                this.sweepExtents = new Float32Array(6);
                this.sweepFakeBody = {
                    shape: null,
                    transform: null
                };
                this.sweepTransform = VMath.m43BuildIdentity();
                this.sweepTransform2 = VMath.m43BuildIdentity()
            }
            var cache = this.sweepCache;
            var triangle = this.sweepTriangle;
            var delta = this.sweepDelta;
            var fromExtents = this.sweepFromExtents;
            var toExtents = this.sweepToExtents;
            var extents = this.sweepExtents;
            var fakeBody = this.sweepFakeBody;
            var transform = this.sweepTransform;
            var transform2 = this.sweepTransform2;
            var that = this;

            function staticSweep(shapeA, cpos, delta, shapeB, transform, upperBound) {
                var delta0 = delta[0];
                var delta1 = delta[1];
                var delta2 = delta[2];
                var axis = cache.axis;
                var supportA = cache.closestA;
                var supportB = cache.closestB;
                axis[0] = -delta0;
                axis[1] = -delta1;
                axis[2] = -delta2;
                cache.shapeA = shapeA;
                cache.shapeB = shapeB;
                var distance = 0;
                var curIter = 0;
                var maxIter = 100;
                var contactDistance;
                var previousDistance = Number.MAX_VALUE;
                var intersected = false;
                for (;;) {
                    var nextContact = that.contactPairTest(cache, cpos, transform);
                    if (nextContact === undefined || nextContact < WebGLPhysicsConfig.GJK_EPA_DISTANCE_THRESHOLD) {
                        if (contactDistance !== undefined || nextContact !== undefined) {
                            if (contactDistance === undefined) {
                                contactDistance = nextContact
                            }
                            intersected = true
                        }
                        break
                    }
                    if (nextContact - previousDistance >= 1) {
                        break
                    }
                    previousDistance = nextContact;
                    var d0 = supportB[0] - supportA[0];
                    var d1 = supportB[1] - supportA[1];
                    var d2 = supportB[2] - supportA[2];
                    var dot = delta0 * d0 + delta1 * d1 + delta2 * d2;
                    if (dot <= WebGLPhysicsConfig.COPLANAR_THRESHOLD) {
                        break
                    }
                    var gap = nextContact * nextContact / dot;
                    distance += gap;
                    if (distance >= upperBound) {
                        contactDistance = undefined;
                        break
                    }
                    contactDistance = nextContact;
                    cpos[9] += delta0 * gap;
                    cpos[10] += delta1 * gap;
                    cpos[11] += delta2 * gap;
                    if (contactDistance <= WebGLPhysicsConfig.GJK_EPA_DISTANCE_THRESHOLD) {
                        intersected = true;
                        break
                    }
                    curIter += 1;
                    if (curIter > maxIter) {
                        break
                    }
                }
                if (contactDistance === undefined || !intersected) {
                    return null
                } else {
                    return {
                        hitPoint: VMath.v3Copy(supportB),
                        hitNormal: VMath.v3Copy(axis),
                        distance: distance
                    }
                }
            }
            var shape = params.shape._private;
            var from = params.from;
            var to = params.to;
            var d0 = to[9] - from[9];
            var d1 = to[10] - from[10];
            var d2 = to[11] - from[11];
            var upperBound = Math.sqrt(d0 * d0 + d1 * d1 + d2 * d2);
            var scale = 1 / upperBound;
            delta[0] = d0 * scale;
            delta[1] = d1 * scale;
            delta[2] = d2 * scale;
            var group = params.group === undefined ? WebGLPhysicsDevice.prototype.FILTER_DYNAMIC : params.group;
            var mask = params.mask === undefined ? WebGLPhysicsDevice.prototype.FILTER_ALL : params.mask;
            var exclude = params.exclude;
            fakeBody.shape = shape;
            fakeBody.transform = from;
            WebGLPhysicsPrivateBody.prototype.calculateExtents.call(fakeBody, fromExtents);
            fakeBody.transform = to;
            WebGLPhysicsPrivateBody.prototype.calculateExtents.call(fakeBody, toExtents);
            extents[0] = fromExtents[0] < toExtents[0] ? fromExtents[0] : toExtents[0];
            extents[1] = fromExtents[1] < toExtents[1] ? fromExtents[1] : toExtents[1];
            extents[2] = fromExtents[2] < toExtents[2] ? fromExtents[2] : toExtents[2];
            extents[3] = fromExtents[3] > toExtents[3] ? fromExtents[3] : toExtents[3];
            extents[4] = fromExtents[4] > toExtents[4] ? fromExtents[4] : toExtents[4];
            extents[5] = fromExtents[5] > toExtents[5] ? fromExtents[5] : toExtents[5];
            this.staticSpatialMap.finalize();
            this.dynamicSpatialMap.finalize();
            this.sleepingSpatialMap.finalize();
            var objects = this.persistantObjectsList;
            var triangles = this.persistantTrianglesList;
            var staticCount = this.staticSpatialMap.getOverlappingNodes(extents, objects, 0);
            staticCount += this.dynamicSpatialMap.getOverlappingNodes(extents, objects, staticCount);
            var limit = staticCount + this.sleepingSpatialMap.getOverlappingNodes(extents, objects, staticCount);
            var minResult = null;
            var i, j;
            for (i = 0; i < limit; i += 1) {
                var object = objects[i];
                objects[i] = undefined;
                var actual_object = object._public;
                if (actual_object === exclude || object.shape === shape || (object.mask & group) === 0 || (object.group & mask) === 0) {
                    continue
                }
                var result;
                var collisionShape = object.shape;
                if (collisionShape.type === "TRIANGLE_MESH") {
                    var triangleArray = collisionShape.triangleArray;
                    triangle.triangleArray = triangleArray;
                    triangle.collisionRadius = collisionShape.collisionRadius;
                    var numTriangles;
                    if (triangleArray.spatialMap) {
                        VMath.m43InverseOrthonormal(object.transform, transform2);
                        VMath.m43Mul(from, transform2, transform);
                        fakeBody.transform = transform;
                        WebGLPhysicsPrivateBody.prototype.calculateExtents.call(fakeBody, fromExtents);
                        VMath.m43Mul(to, transform2, transform);
                        WebGLPhysicsPrivateBody.prototype.calculateExtents.call(fakeBody, toExtents);
                        extents[0] = fromExtents[0] < toExtents[0] ? fromExtents[0] : toExtents[0];
                        extents[1] = fromExtents[1] < toExtents[1] ? fromExtents[1] : toExtents[1];
                        extents[2] = fromExtents[2] < toExtents[2] ? fromExtents[2] : toExtents[2];
                        extents[3] = fromExtents[3] > toExtents[3] ? fromExtents[3] : toExtents[3];
                        extents[4] = fromExtents[4] > toExtents[4] ? fromExtents[4] : toExtents[4];
                        extents[5] = fromExtents[5] > toExtents[5] ? fromExtents[5] : toExtents[5];
                        numTriangles = triangleArray.spatialMap.getOverlappingNodes(extents, triangles, 0);
                        for (j = 0; j < numTriangles; j += 1) {
                            triangle.index = triangles[j].index;
                            triangles[j] = undefined;
                            VMath.m43Copy(from, transform2);
                            result = staticSweep(shape, transform2, delta, triangle, object.transform, upperBound);
                            if (result) {
                                result.collisionObject = actual_object;
                                result.body = null;
                                if (!callback || callback(result)) {
                                    minResult = result;
                                    upperBound = result.distance
                                }
                            }
                        }
                    } else {
                        numTriangles = triangleArray.numTriangles;
                        for (j = 0; j < numTriangles; j += 1) {
                            triangle.index = j * WebGLPhysicsPrivateTriangleArray.prototype.TRIANGLE_SIZE;
                            VMath.m43Copy(from, transform2);
                            result = staticSweep(shape, transform2, delta, triangle, object.transform, upperBound);
                            if (result) {
                                result.collisionObject = actual_object;
                                result.body = null;
                                if (!callback || callback(result)) {
                                    minResult = result;
                                    upperBound = result.distance
                                }
                            }
                        }
                    }
                } else {
                    VMath.m43Copy(from, transform2);
                    result = staticSweep(shape, transform2, delta, collisionShape, object.transform, upperBound);
                    if (result) {
                        if (object.collisionObject) {
                            result.collisionObject = actual_object;
                            result.body = null
                        } else {
                            result.collisionObject = null;
                            result.body = actual_object
                        }
                        if (!callback || callback(result)) {
                            minResult = result;
                            upperBound = result.distance
                        }
                    }
                }
                if (upperBound < 1e-4) {
                    for (j = i; j < limit; j += 1) {
                        objects[j] = undefined
                    }
                    break
                }
            }
            if (minResult) {
                delete minResult.distance
            }
            return minResult
        };
        WebGLPrivatePhysicsWorld.prototype.addBody = function(body) {
            if (body.world) {
                return false
            }
            body.world = this;
            if (body.collisionObject && !body.kinematic) {
                this.collisionObjects.push(body);
                this.syncBody(body);
                return true
            }
            if (body.kinematic) {
                this.kinematicBodies.push(body)
            } else {
                this.rigidBodies.push(body)
            }
            var addSleeping = !body.active;
            body.previouslyActive = true;
            body.active = false;
            body.islandRoot = body;
            body.islandRank = 0;
            if (!addSleeping) {
                this.wakeBody(body)
            } else {
                this.syncBody(body)
            }
            return true
        };
        WebGLPrivatePhysicsWorld.prototype.removeBody = function(body) {
            if (body.world !== this) {
                return false
            }
            var list, activeList;
            if (body.collisionObject && !body.kinematic) {
                list = this.collisionObjects
            } else if (body.kinematic) {
                list = this.kinematicBodies;
                activeList = this.activeKinematics
            } else {
                list = this.rigidBodies;
                activeList = this.activeBodies
            }
            body.world = null;
            list[list.indexOf(body)] = list[list.length - 1];
            list.pop();
            if (activeList && body.active) {
                activeList[activeList.indexOf(body)] = activeList[activeList.length - 1];
                activeList.pop();
                this.dynamicSpatialMap.remove(body)
            } else if (body.collisionObject && !body.kinematic) {
                this.staticSpatialMap.remove(body)
            } else {
                this.sleepingSpatialMap.remove(body)
            }
            this.removeArbitersFromObject(body);
            this.removeFromContactCallbacks(body);
            var island = body.island;
            if (island) {
                var bodies = island.bodies;
                var bodyIndex = bodies.indexOf(body);
                if (bodyIndex !== -1) {
                    bodies[bodyIndex] = bodies[bodies.length - 1];
                    bodies.pop()
                }
                body.island = null
            }
            return true
        };
        WebGLPrivatePhysicsWorld.prototype.addConstraint = function(constraint) {
            if (constraint.world) {
                return false
            }
            constraint.world = this;
            this.constraints.push(constraint);
            if (constraint.bodyA) {
                constraint.bodyA.constraints.push(constraint)
            }
            if (constraint.bodyB) {
                constraint.bodyB.constraints.push(constraint)
            }
            var addSleeping = !constraint.active;
            constraint.active = false;
            constraint.islandRoot = constraint;
            constraint.islandRank = 0;
            if (!addSleeping) {
                this.wakeConstraint(constraint)
            }
            return true
        };
        WebGLPrivatePhysicsWorld.prototype.removeConstraint = function(constraint) {
            if (constraint.world !== this) {
                return false
            }
            constraint.world = null;
            var list = this.constraints;
            list[list.indexOf(constraint)] = list[list.length - 1];
            list.pop();
            if (constraint.bodyA) {
                list = constraint.bodyA.constraints;
                list[list.indexOf(constraint)] = list[list.length - 1];
                list.pop()
            }
            if (constraint.bodyB) {
                list = constraint.bodyA.constraints;
                list[list.indexOf(constraint)] = list[list.length - 1];
                list.pop()
            }
            if (constraint.active) {
                list = this.activeConstraints;
                list[list.indexOf(constraint)] = list[list.length - 1];
                list.pop()
            }
            var island = constraint.island;
            if (island) {
                var constraints = island.constraints;
                var constraintIndex = constraints.indexOf(constraint);
                if (constraintIndex !== -1) {
                    constraints[constraintIndex] = constraints[constraints.length - 1];
                    constraints.pop()
                }
                constraint.island = null
            }
            return true
        };
        WebGLPrivatePhysicsWorld.prototype.flush = function() {
            while (this.rigidBodies.length > 0) {
                this.removeBody(this.rigidBodies[0])
            }
            while (this.collisionObjects.length > 0) {
                this.removeBody(this.collisionObjects[0])
            }
            while (this.kinematicBodies.length > 0) {
                this.removeBody(this.kinematicBodies[0])
            }
            while (this.constraints.length > 0) {
                this.removeConstraint(this.constraints[0])
            }
            this.timeStamp = 0
        };
        WebGLPrivatePhysicsWorld.prototype.removeArbitersFromObject = function(object) {
            var arbiters = object.arbiters;
            var worldArbiters = this.activeArbiters;
            while (arbiters.length > 0) {
                var arb = arbiters.pop();
                var bodyArbiters = arb.objectA === object ? arb.objectB.arbiters : arb.objectA.arbiters;
                bodyArbiters[bodyArbiters.indexOf(arb)] = bodyArbiters[bodyArbiters.length - 1];
                bodyArbiters.pop();
                if (arb.active) {
                    worldArbiters[worldArbiters.indexOf(arb)] = worldArbiters[worldArbiters.length - 1];
                    worldArbiters.pop()
                }
                while (arb.contacts.length > 0) {
                    var contact = arb.contacts.pop();
                    WebGLPhysicsContact.deallocate(contact)
                }
                WebGLPhysicsArbiter.deallocate(arb)
            }
        };
        WebGLPrivatePhysicsWorld.prototype.removeFromContactCallbacks = function(object) {
            var contactCallbackObjects = this.contactCallbackObjects;
            var numObjects = contactCallbackObjects.length;
            var n;
            for (n = 0; n < numObjects; n += 1) {
                if (contactCallbackObjects[n] === object) {
                    numObjects -= 1;
                    if (n < numObjects) {
                        contactCallbackObjects[n] = contactCallbackObjects[numObjects]
                    }
                    contactCallbackObjects.length = numObjects;
                    break
                }
            }
            object.addedToContactCallbacks = false
        };
        WebGLPrivatePhysicsWorld.prototype.updateContactCallbacks = function() {
            var contactCallbackObjects = this.contactCallbackObjects;
            var numObjects = contactCallbackObjects.length;
            var publicContacts = WebGLPhysicsContact.publicContacts;
            var callbackContacts = WebGLPhysicsContact.callbackContacts;
            var arbiter, objectA, objectB, contactCallbacksA, contactCallbacksB;
            var n = 0;
            while (n < numObjects) {
                var object = contactCallbackObjects[n];
                var arbiters = object.arbiters;
                var numArbiters = arbiters.length;
                if (0 === numArbiters) {
                    object.contactCallbacks.added = false;
                    numObjects -= 1;
                    if (n < numObjects) {
                        contactCallbackObjects[n] = contactCallbackObjects[numObjects]
                    }
                    contactCallbackObjects.length = numObjects
                } else {
                    var i, j;
                    for (i = 0; i < numArbiters; i += 1) {
                        arbiter = arbiters[i];
                        if (0 !== arbiter.contactFlags) {
                            var contacts = arbiter.contacts;
                            var numContacts = contacts.length;
                            while (publicContacts.length < numContacts) {
                                publicContacts[publicContacts.length] = WebGLPhysicsPublicContact.create()
                            }
                            callbackContacts.length = numContacts;
                            for (j = 0; j < numContacts; j += 1) {
                                var publicContact = publicContacts[j];
                                publicContact._private = contacts[j];
                                callbackContacts[j] = publicContact
                            }
                            objectA = arbiter.objectA;
                            objectB = arbiter.objectB;
                            contactCallbacksA = objectA.contactCallbacks;
                            contactCallbacksB = objectB.contactCallbacks;
                            if (arbiter.contactFlags & 1) {
                                if (null !== contactCallbacksA && contactCallbacksA.onAddedContacts) {
                                    contactCallbacksA.onAddedContacts(objectA._public, objectB._public, callbackContacts)
                                }
                                if (null !== contactCallbacksB && contactCallbacksB.onAddedContacts) {
                                    contactCallbacksB.onAddedContacts(objectA._public, objectB._public, callbackContacts)
                                }
                            }
                            if (arbiter.contactFlags & 2) {
                                if (null !== contactCallbacksA && contactCallbacksA.onProcessedContacts) {
                                    contactCallbacksA.onProcessedContacts(objectA._public, objectB._public, callbackContacts)
                                }
                                if (null !== contactCallbacksB && contactCallbacksB.onProcessedContacts) {
                                    contactCallbacksB.onProcessedContacts(objectA._public, objectB._public, callbackContacts)
                                }
                            }
                            if (arbiter.contactFlags & 4) {
                                if (null !== contactCallbacksA && contactCallbacksA.onRemovedContacts) {
                                    contactCallbacksA.onRemovedContacts(objectA._public, objectB._public, callbackContacts)
                                }
                                if (null !== contactCallbacksB && contactCallbacksB.onRemovedContacts) {
                                    contactCallbacksB.onRemovedContacts(objectA._public, objectB._public, callbackContacts)
                                }
                            }
                            arbiter.contactFlags = 0;
                            for (j = 0; j < numContacts; j += 1) {
                                contacts[j][51] = 0
                            }
                        }
                    }
                    n += 1
                }
            }
            var contactCallbackRemovedArbiters = this.contactCallbackRemovedArbiters;
            numObjects = contactCallbackRemovedArbiters.length;
            callbackContacts.length = 0;
            for (n = 0; n < numObjects; n += 1) {
                arbiter = contactCallbackRemovedArbiters[n];
                objectA = arbiter.objectA;
                objectB = arbiter.objectB;
                contactCallbacksA = objectA.contactCallbacks;
                contactCallbacksB = objectB.contactCallbacks;
                if (null !== contactCallbacksA && contactCallbacksA.onRemovedContacts) {
                    contactCallbacksA.onRemovedContacts(objectA._public, objectB._public, callbackContacts)
                }
                if (null !== contactCallbacksB && contactCallbacksB.onRemovedContacts) {
                    contactCallbacksB.onRemovedContacts(objectA._public, objectB._public, callbackContacts)
                }
                WebGLPhysicsArbiter.deallocate(arbiter)
            }
            contactCallbackRemovedArbiters.length = 0
        };
        WebGLPrivatePhysicsWorld.version = 1;
        return WebGLPrivatePhysicsWorld
    }();
    var WebGLPhysicsDevice = function() {
        function WebGLPhysicsDevice() {
            this.vendor = "Turbulenz";
            this.genObjectId = 0
        }
        WebGLPhysicsDevice.create = function() {
            return new WebGLPhysicsDevice
        };
        WebGLPhysicsDevice.prototype.createDynamicsWorld = function(params) {
            return WebGLPhysicsWorld.create(params)
        };
        WebGLPhysicsDevice.prototype.createPlaneShape = function(params) {
            return WebGLPhysicsPlaneShape.create(params)
        };
        WebGLPhysicsDevice.prototype.createBoxShape = function(params) {
            return WebGLPhysicsBoxShape.create(params)
        };
        WebGLPhysicsDevice.prototype.createSphereShape = function(params) {
            return WebGLPhysicsSphereShape.create(params)
        };
        WebGLPhysicsDevice.prototype.createCapsuleShape = function(params) {
            return WebGLPhysicsCapsuleShape.create(params)
        };
        WebGLPhysicsDevice.prototype.createCylinderShape = function(params) {
            return WebGLPhysicsCylinderShape.create(params)
        };
        WebGLPhysicsDevice.prototype.createConeShape = function(params) {
            return WebGLPhysicsConeShape.create(params)
        };
        WebGLPhysicsDevice.prototype.createTriangleMeshShape = function(params) {
            return WebGLPhysicsTriangleMeshShape.create(params)
        };
        WebGLPhysicsDevice.prototype.createConvexHullShape = function(params) {
            return WebGLPhysicsConvexHullShape.create(params)
        };
        WebGLPhysicsDevice.prototype.createTriangleArray = function(params) {
            return WebGLPhysicsTriangleArray.create(params)
        };
        WebGLPhysicsDevice.prototype.createCollisionObject = function(params) {
            return WebGLPhysicsCollisionObject.create(params)
        };
        WebGLPhysicsDevice.prototype.createRigidBody = function(params) {
            return WebGLPhysicsRigidBody.create(params)
        };
        WebGLPhysicsDevice.prototype.createPoint2PointConstraint = function(params) {
            return WebGLPhysicsPoint2PointConstraint.create(params)
        };
        WebGLPhysicsDevice.prototype.createHingeConstraint = function(params) {
            return WebGLPhysicsConstraint.create("HINGE", params)
        };
        WebGLPhysicsDevice.prototype.createConeTwistConstraint = function(params) {
            return WebGLPhysicsConstraint.create("CONETWIST", params)
        };
        WebGLPhysicsDevice.prototype.create6DOFConstraint = function(params) {
            return WebGLPhysicsConstraint.create("D6", params)
        };
        WebGLPhysicsDevice.prototype.createSliderConstraint = function(params) {
            return WebGLPhysicsConstraint.create("SLIDER", params)
        };
        WebGLPhysicsDevice.prototype.createCharacter = function(params) {
            return WebGLPhysicsCharacter.create(params)
        };
        WebGLPhysicsDevice.version = 1;
        return WebGLPhysicsDevice
    }();
    WebGLPhysicsDevice.prototype.FILTER_DYNAMIC = 1;
    WebGLPhysicsDevice.prototype.FILTER_STATIC = 2;
    WebGLPhysicsDevice.prototype.FILTER_KINEMATIC = 4;
    WebGLPhysicsDevice.prototype.FILTER_DEBRIS = 8;
    WebGLPhysicsDevice.prototype.FILTER_TRIGGER = 16;
    WebGLPhysicsDevice.prototype.FILTER_CHARACTER = 32;
    WebGLPhysicsDevice.prototype.FILTER_PROJECTILE = 64;
    WebGLPhysicsDevice.prototype.FILTER_USER_MIN = 128;
    WebGLPhysicsDevice.prototype.FILTER_USER_MAX = 32768;
    WebGLPhysicsDevice.prototype.FILTER_ALL = 65535;
    var __extends = this.__extends || function(d, b) {
        for (var p in b)
            if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() {
            this.constructor = d
        }
        __.prototype = b.prototype;
        d.prototype = new __
    };
    var WebGLSound = function() {
        function WebGLSound() {}
        WebGLSound.prototype.destroy = function() {
            if (this.buffer) {
                this.buffer = null
            } else if (this.audio) {
                var src = this.audio.src;
                if (src.indexOf("blob:") === 0) {
                    URL.revokeObjectURL(src)
                }
                this.audio = null
            }
            if (this.blob) {
                this.blob = null
            }
        };
        WebGLSound.audioLoaded = function(sound, onload) {
            var audio = sound.audio;
            sound.frequency = audio.sampleRate || audio.mozSampleRate || 0;
            sound.channels = audio.channels || audio.mozChannels || 0;
            sound.bitrate = sound.frequency * sound.channels * 2 * 8;
            sound.length = audio.duration;
            if (audio.buffered && audio.buffered.length) {
                if (isNaN(sound.length) || sound.length === Number.POSITIVE_INFINITY) {
                    sound.length = audio.buffered.end(0)
                }
                if (onload) {
                    if (sound.length) {
                        onload(sound, 200)
                    } else {
                        onload(null, 0)
                    }
                    onload = null
                }
            } else {
                var forceLoading = function forceLoadingFn() {
                    audio.pause();
                    audio.removeEventListener("play", forceLoading, false);
                    audio.volume = 1;
                    if (onload) {
                        onload(sound, 200);
                        onload = null
                    }
                };
                audio.addEventListener("play", forceLoading, false);
                audio.volume = 0;
                audio.play()
            }
        };
        WebGLSound.create = function(sd, params) {
            var sound = new WebGLSound;
            var soundPath = params.src;
            sound.name = params.name || soundPath;
            sound.frequency = 0;
            sound.channels = 0;
            sound.bitrate = 0;
            sound.length = 0;
            sound.compressed = !params.uncompress;
            var onload = params.onload;
            var data = params.data;
            var numSamples, numChannels, samplerRate;
            var audioContext = sd.audioContext;
            var xhr;
            if (audioContext && (sound.forceUncompress || params.uncompress)) {
                var buffer;
                if (soundPath) {
                    if (!sd.isResourceSupported(soundPath)) {
                        if (onload) {
                            onload(null, 0)
                        }
                        return null
                    }
                    var bufferCreated = function bufferCreatedFn(buffer) {
                        if (buffer) {
                            sound.buffer = buffer;
                            sound.frequency = buffer.sampleRate;
                            sound.channels = buffer.numberOfChannels;
                            sound.bitrate = sound.frequency * sound.channels * 2 * 8;
                            sound.length = buffer.duration;
                            if (onload) {
                                onload(sound, 200)
                            }
                        } else {
                            if (onload) {
                                onload(null, 0)
                            }
                        }
                    };
                    var bufferFailed = function bufferFailedFn() {
                        if (onload) {
                            onload(null, 0)
                        }
                    };
                    if (data) {
                        if (audioContext.decodeAudioData) {
                            audioContext.decodeAudioData(data, bufferCreated, bufferFailed)
                        } else {
                            buffer = audioContext.createBuffer(data, false);
                            bufferCreated(buffer)
                        }
                    } else {
                        if (window.XMLHttpRequest) {
                            xhr = new window.XMLHttpRequest
                        } else if (window.ActiveXObject) {
                            xhr = new window.ActiveXObject("Microsoft.XMLHTTP")
                        } else {
                            if (onload) {
                                onload(null, 0)
                            }
                            return null
                        }
                        xhr.onreadystatechange = function() {
                            if (xhr.readyState === 4) {
                                if (!TurbulenzEngine || !TurbulenzEngine.isUnloading()) {
                                    var xhrStatus = xhr.status;
                                    var response = xhr.response;
                                    if (xhr.getAllResponseHeaders() === "" && !response) {
                                        if (onload) {
                                            onload(null, 0)
                                        }
                                    } else if (xhrStatus === 200 || xhrStatus === 0) {
                                        if (audioContext.decodeAudioData) {
                                            audioContext.decodeAudioData(response, bufferCreated, bufferFailed)
                                        } else {
                                            var buffer = audioContext.createBuffer(response, false);
                                            bufferCreated(buffer)
                                        }
                                    } else {
                                        if (onload) {
                                            onload(null, xhrStatus)
                                        }
                                    }
                                }
                                xhr.onreadystatechange = null;
                                xhr = null
                            }
                        };
                        xhr.open("GET", soundPath, true);
                        xhr.responseType = "arraybuffer";
                        xhr.setRequestHeader("Content-Type", "text/plain");
                        xhr.send(null)
                    }
                    return sound
                } else {
                    if (data) {
                        numSamples = data.length;
                        numChannels = params.channels || 1;
                        samplerRate = params.frequency;
                        var contextSampleRate = Math.min(audioContext.sampleRate, 96e3);
                        var c, channel, i, j;
                        if (contextSampleRate === samplerRate) {
                            buffer = audioContext.createBuffer(numChannels, numSamples / numChannels, samplerRate);
                            for (c = 0; c < numChannels; c += 1) {
                                channel = buffer.getChannelData(c);
                                for (i = c, j = 0; i < numSamples; i += numChannels, j += 1) {
                                    channel[j] = data[i]
                                }
                            }
                        } else {
                            var ratio = samplerRate / contextSampleRate;
                            var bufferLength = numSamples / (ratio * numChannels) | 0;
                            buffer = audioContext.createBuffer(numChannels, bufferLength, contextSampleRate);
                            for (c = 0; c < numChannels; c += 1) {
                                channel = buffer.getChannelData(c);
                                for (j = 0; j < bufferLength; j += 1) {
                                    channel[j] = data[c + (j * ratio | 0) * numChannels]
                                }
                            }
                        }
                        if (buffer) {
                            sound.buffer = buffer;
                            sound.frequency = samplerRate;
                            sound.channels = numChannels;
                            sound.bitrate = samplerRate * numChannels * 2 * 8;
                            sound.length = numSamples / (samplerRate * numChannels);
                            if (onload) {
                                onload(sound, 200)
                            }
                            return sound
                        }
                    }
                }
            } else {
                var audio;
                if (soundPath) {
                    var extension = soundPath.slice(-3);
                    audio = new Audio;
                    audio.preload = "auto";
                    audio.autobuffer = true;
                    audio.onerror = function loadingSoundFailedFn() {
                        if (onload) {
                            onload(null, 0);
                            onload = null
                        }
                    };
                    sound.audio = audio;
                    var checkLoaded = function checkLoadedFn() {
                        if (3 <= audio.readyState) {
                            WebGLSound.audioLoaded(sound, onload);
                            return true
                        }
                        return false
                    };
                    if (data) {
                        var dataArray;
                        if (data instanceof Uint8Array) {
                            dataArray = data
                        } else {
                            dataArray = new Uint8Array(data)
                        }
                        if (typeof Blob !== "undefined" && typeof URL !== "undefined" && URL.createObjectURL) {
                            var dataBlob;
                            if (dataArray[0] === 79 && dataArray[1] === 103 && dataArray[2] === 103 && dataArray[3] === 83) {
                                extension = "ogg";
                                dataBlob = new Blob([dataArray], {
                                    type: "audio/ogg"
                                })
                            } else if (dataArray[0] === 82 && dataArray[1] === 73 && dataArray[2] === 70 && dataArray[3] === 70) {
                                extension = "wav";
                                dataBlob = new Blob([dataArray], {
                                    type: "audio/wav"
                                })
                            } else {
                                extension = "mp3";
                                dataBlob = new Blob([dataArray], {
                                    type: "audio/mpeg"
                                })
                            }
                            sound.blob = dataBlob;
                            soundPath = URL.createObjectURL(dataBlob)
                        } else {
                            if (dataArray[0] === 79 && dataArray[1] === 103 && dataArray[2] === 103 && dataArray[3] === 83) {
                                extension = "ogg";
                                soundPath = "data:audio/ogg;base64,"
                            } else if (dataArray[0] === 82 && dataArray[1] === 73 && dataArray[2] === 70 && dataArray[3] === 70) {
                                extension = "wav";
                                soundPath = "data:audio/wav;base64,"
                            } else {
                                extension = "mp3";
                                soundPath = "data:audio/mpeg;base64,"
                            }
                            soundPath = soundPath + TurbulenzEngine.base64Encode(dataArray)
                        }
                    } else if (typeof URL !== "undefined" && URL.createObjectURL) {
                        if (!sd.supportedExtensions[extension]) {
                            if (onload) {
                                onload(null, 0)
                            }
                            return null
                        }
                        xhr = new XMLHttpRequest;
                        xhr.onreadystatechange = function() {
                            if (xhr.readyState === 4) {
                                if (!TurbulenzEngine || !TurbulenzEngine.isUnloading()) {
                                    var xhrStatus = xhr.status;
                                    if (xhrStatus === 0 && (window.location.protocol === "file:" || window.location.protocol === "chrome-extension:")) {
                                        xhrStatus = 200
                                    }
                                    if (xhr.getAllResponseHeaders() === "" && !xhr.response) {
                                        if (onload) {
                                            onload(null, 0)
                                        }
                                    } else {
                                        if (xhrStatus === 200 || xhrStatus === 0) {
                                            sound.blob = xhr.response;
                                            if (sound.blob.type === "audio/x-mpg") {
                                                sound.blob = sound.blob.slice(0, sound.blob.size, "audio/mpeg")
                                            }
                                            audio.src = URL.createObjectURL(sound.blob);
                                            sd.addLoadingSound(checkLoaded)
                                        } else if (onload) {
                                            onload(null, xhrStatus)
                                        }
                                    }
                                    xhr.onreadystatechange = null;
                                    xhr = null
                                }
                            }
                        };
                        xhr.open("GET", soundPath, true);
                        xhr.responseType = "blob";
                        xhr.send();
                        return sound
                    }
                    if (!sd.supportedExtensions[extension]) {
                        if (onload) {
                            onload(null, 0)
                        }
                        return null
                    }
                    audio.src = soundPath;
                    sd.addLoadingSound(checkLoaded);
                    return sound
                } else {
                    if (data) {
                        audio = new Audio;
                        if (audio.mozSetup) {
                            numSamples = data.length;
                            numChannels = params.channels || 1;
                            samplerRate = params.frequency;
                            audio.mozSetup(numChannels, samplerRate);
                            sound.data = data;
                            sound.frequency = samplerRate;
                            sound.channels = numChannels;
                            sound.bitrate = samplerRate * numChannels * 2 * 8;
                            sound.length = numSamples / (samplerRate * numChannels);
                            sound.audio = audio;
                            if (onload) {
                                onload(sound, 200)
                            }
                            return sound
                        } else {
                            audio = null
                        }
                    }
                }
            }
            if (onload) {
                onload(null, 0)
            }
            return null
        };
        WebGLSound.version = 1;
        return WebGLSound
    }();
    var WebGLSoundGlobalSource = function() {
        function WebGLSoundGlobalSource() {}
        WebGLSoundGlobalSource.prototype.play = function(sound, seek) {
            if (seek === undefined) {
                seek = 0
            }
            if (this.sound === sound) {
                return this.seek(seek)
            }
            if (this.playing) {
                this._stop()
            }
            this.sound = sound;
            var soundAudio = sound.audio;
            if (soundAudio) {
                if (sound.data) {
                    soundAudio = new Audio;
                    soundAudio.mozSetup(sound.channels, sound.frequency)
                } else {
                    soundAudio = soundAudio.cloneNode(true)
                }
                this.audio = soundAudio;
                soundAudio.loop = this._looping;
                soundAudio.addEventListener("ended", this.loopAudio, false);
                if (.05 < seek) {
                    try {
                        soundAudio.currentTime = seek
                    } catch (e) {}
                }
            }
            var audioContext = this.audioContext;
            if (audioContext) {
                if (soundAudio) {
                    this._createMediaNode(sound, soundAudio)
                } else {
                    var bufferNode = this._createBufferNode(sound);
                    if (0 < seek) {
                        var buffer = sound.buffer;
                        if (bufferNode.loop) {
                            bufferNode.start(0, seek, buffer.duration)
                        } else {
                            bufferNode.start(0, seek, buffer.duration - seek)
                        }
                        this.playStart = audioContext.currentTime - seek
                    } else {
                        bufferNode.start(0);
                        this.playStart = audioContext.currentTime
                    }
                }
            }
            if (soundAudio) {
                if (sound.data) {
                    soundAudio.mozWriteAudio(sound.data)
                } else {
                    if (this.updateAudioVolume) {
                        this.updateAudioVolume()
                    }
                    soundAudio.play()
                }
            }
            this.playing = true;
            this.paused = false;
            this.sd.addPlayingSource(this);
            return true
        };
        WebGLSoundGlobalSource.prototype._stop = function() {
            this.playing = false;
            this.paused = false;
            this.sound = null;
            var audio = this.audio;
            if (audio) {
                this.audio = null;
                var mediaNode = this.mediaNode;
                if (mediaNode) {
                    this.mediaNode = null;
                    mediaNode.disconnect()
                }
                audio.pause();
                audio.removeEventListener("ended", this.loopAudio, false)
            } else {
                var bufferNode = this.bufferNode;
                if (bufferNode) {
                    this.bufferNode = null;
                    bufferNode.stop(0);
                    bufferNode.disconnect()
                }
            }
        };
        WebGLSoundGlobalSource.prototype.stop = function() {
            var playing = this.playing;
            if (playing) {
                this._stop();
                this.sd.removePlayingSource(this)
            }
            return playing
        };
        WebGLSoundGlobalSource.prototype.pause = function() {
            if (this.playing) {
                if (!this.paused) {
                    this.paused = true;
                    var audio = this.audio;
                    if (audio) {
                        audio.pause()
                    } else {
                        var bufferNode = this.bufferNode;
                        if (bufferNode) {
                            this.bufferNode = null;
                            this.playPaused = this.audioContext.currentTime;
                            bufferNode.stop(0);
                            bufferNode.disconnect()
                        }
                    }
                    this.sd.removePlayingSource(this)
                }
                return true
            }
            return false
        };
        WebGLSoundGlobalSource.prototype.resume = function(seek) {
            if (this.paused) {
                this.paused = false;
                var audio = this.audio;
                if (audio) {
                    if (seek !== undefined) {
                        if (.05 < Math.abs(audio.currentTime - seek)) {
                            try {
                                audio.currentTime = seek
                            } catch (e) {}
                        }
                    }
                    audio.play()
                } else {
                    var audioContext = this.audioContext;
                    if (audioContext) {
                        if (seek === undefined) {
                            seek = this.playPaused - this.playStart
                        }
                        var bufferNode = this._createBufferNode(this.sound);
                        if (0 < seek) {
                            var buffer = this.sound.buffer;
                            if (bufferNode.loop) {
                                bufferNode.start(0, seek, buffer.duration)
                            } else {
                                bufferNode.start(0, seek, buffer.duration - seek)
                            }
                            this.playStart = audioContext.currentTime - seek
                        } else {
                            bufferNode.start(0);
                            this.playStart = audioContext.currentTime
                        }
                    }
                }
                this.sd.addPlayingSource(this);
                return true
            }
            return false
        };
        WebGLSoundGlobalSource.prototype.rewind = function() {
            if (this.playing) {
                var audio = this.audio;
                if (audio) {
                    audio.currentTime = 0;
                    return true
                } else {
                    var audioContext = this.audioContext;
                    if (audioContext) {
                        var bufferNode = this.bufferNode;
                        if (bufferNode) {
                            bufferNode.stop(0);
                            bufferNode.disconnect()
                        }
                        bufferNode = this._createBufferNode(this.sound);
                        bufferNode.start(0);
                        this.playStart = audioContext.currentTime;
                        return true
                    }
                }
            }
            return false
        };
        WebGLSoundGlobalSource.prototype.seek = function(seek) {
            if (this.playing) {
                var tell = this.tell;
                var delta = Math.abs(tell - seek);
                if (this._looping) {
                    delta = Math.min(Math.abs(tell - (this.sound.length + seek)), delta)
                }
                if (.05 < delta) {
                    var audio = this.audio;
                    if (audio) {
                        try {
                            audio.currentTime = seek
                        } catch (e) {}
                    } else {
                        var audioContext = this.audioContext;
                        if (audioContext) {
                            var bufferNode = this.bufferNode;
                            if (bufferNode) {
                                bufferNode.stop(0);
                                bufferNode.disconnect()
                            }
                            bufferNode = this._createBufferNode(this.sound);
                            if (0 < seek) {
                                var buffer = this.sound.buffer;
                                if (bufferNode.loop) {
                                    bufferNode.start(0, seek, buffer.duration)
                                } else {
                                    bufferNode.start(0, seek, buffer.duration - seek)
                                }
                                this.playStart = audioContext.currentTime - seek
                            } else {
                                bufferNode.start(0);
                                this.playStart = audioContext.currentTime
                            }
                        }
                    }
                }
                return true
            }
            return false
        };
        WebGLSoundGlobalSource.prototype.clear = function() {
            this.stop()
        };
        WebGLSoundGlobalSource.prototype.setAuxiliarySendFilter = function(index, effectSlot, filter) {
            return false
        };
        WebGLSoundGlobalSource.prototype.setDirectFilter = function(filter) {
            return false
        };
        WebGLSoundGlobalSource.prototype.destroy = function() {
            this.stop();
            var gainNode = this._gainNode;
            if (gainNode) {
                this._gainNode = null;
                gainNode.disconnect()
            }
        };
        WebGLSoundGlobalSource.prototype._createBufferNode = function(sound) {
            var buffer = sound.buffer;
            var bufferNode = this.audioContext.createBufferSource();
            bufferNode.buffer = buffer;
            bufferNode.loop = this._looping;
            if (bufferNode.playbackRate) {
                bufferNode.playbackRate.value = this._pitch
            }
            bufferNode.connect(this._gainNode);
            if (!bufferNode.start) {
                bufferNode.start = function audioStart(when, offset, duration) {
                    if (arguments.length <= 1) {
                        this.noteOn(when)
                    } else {
                        this.noteGrainOn(when, offset, duration)
                    }
                }
            }
            if (!bufferNode.stop) {
                bufferNode.stop = function audioStop(when) {
                    this.noteOff(when)
                }
            }
            this.bufferNode = bufferNode;
            return bufferNode
        };
        WebGLSoundGlobalSource.prototype._checkBufferNode = function(currentTime) {
            var bufferNode = this.bufferNode;
            if (bufferNode) {
                var tell = currentTime - this.playStart;
                var duration = bufferNode.buffer.duration;
                if (duration < tell) {
                    if (this._looping) {
                        this.playStart = currentTime - (tell - duration)
                    } else {
                        bufferNode.disconnect();
                        this.playing = false;
                        this.sound = null;
                        this.bufferNode = null;
                        return false
                    }
                }
            }
            return true
        };
        WebGLSoundGlobalSource.prototype._createMediaNode = function(sound, audio) {
            var mediaNode = this.audioContext.createMediaElementSource(audio);
            mediaNode.connect(this._gainNode);
            this.mediaNode = mediaNode
        };
        WebGLSoundGlobalSource.create = function(sd, id, params) {
            var source = new WebGLSoundGlobalSource;
            source.sd = sd;
            source.id = id;
            source.sound = null;
            source.audio = null;
            source.playing = false;
            source.paused = false;
            source._gain = typeof params.gain === "number" ? params.gain : 1;
            source._looping = params.looping || false;
            source._pitch = params.pitch || 1;
            var audioContext = sd.audioContext;
            if (audioContext) {
                source.bufferNode = null;
                source.mediaNode = null;
                source.playStart = -1;
                source.playPaused = -1;
                var masterGainNode = sd._gainNode;
                var gainNode = audioContext.createGain ? audioContext.createGain() : audioContext.createGainNode();
                gainNode.gain.value = source._gain;
                source._gainNode = gainNode;
                gainNode.connect(masterGainNode);
                Object.defineProperty(source, "gain", {
                    get: function getGainFn() {
                        return this._gain
                    },
                    set: function setGainFn(newGain) {
                        if (this._gain !== newGain) {
                            this._gain = newGain;
                            this._gainNode.gain.value = newGain
                        }
                    },
                    enumerable: true,
                    configurable: false
                });
                Object.defineProperty(source, "looping", {
                    get: function getLoopingFn() {
                        return this._looping
                    },
                    set: function setLoopingFn(newLooping) {
                        this._looping = newLooping;
                        var audio = this.audio;
                        if (audio) {
                            audio.loop = newLooping
                        } else {
                            var bufferNode = this.bufferNode;
                            if (bufferNode) {
                                bufferNode.loop = newLooping
                            }
                        }
                    },
                    enumerable: true,
                    configurable: false
                });
                Object.defineProperty(source, "pitch", {
                    get: function getPitchFn() {
                        return this._pitch
                    },
                    set: function setPitchFn(newPitch) {
                        this._pitch = newPitch;
                        var audio = this.audio;
                        if (audio) {
                            audio.playbackRate = newPitch
                        } else {
                            var bufferNode = this.bufferNode;
                            if (bufferNode) {
                                if (bufferNode.playbackRate) {
                                    bufferNode.playbackRate.value = newPitch
                                }
                            }
                        }
                    },
                    enumerable: true,
                    configurable: false
                });
                Object.defineProperty(source, "tell", {
                    get: function tellFn() {
                        if (this.playing) {
                            var audio = this.audio;
                            if (audio) {
                                return audio.currentTime
                            } else {
                                if (this.paused) {
                                    return this.playPaused - this.playStart
                                } else {
                                    return audioContext.currentTime - this.playStart
                                }
                            }
                        } else {
                            return 0
                        }
                    },
                    enumerable: true,
                    configurable: false
                });
                source.loopAudio = function loopAudioFn() {
                    source.stop()
                }
            } else {
                source.updateAudioVolume = function updateAudioVolumeFn() {
                    var audio = this.audio;
                    if (audio) {
                        var volume = Math.min(this._gain, 1);
                        audio.volume = volume;
                        if (0 >= volume) {
                            audio.muted = true
                        } else {
                            audio.muted = false
                        }
                    }
                };
                Object.defineProperty(source, "gain", {
                    get: function getGainFn() {
                        return this._gain
                    },
                    set: function setGainFn(newGain) {
                        if (this._gain !== newGain) {
                            this._gain = newGain;
                            this.updateAudioVolume()
                        }
                    },
                    enumerable: true,
                    configurable: false
                });
                if (sd.loopingSupported) {
                    Object.defineProperty(source, "looping", {
                        get: function getLoopingFn() {
                            return this._looping
                        },
                        set: function setLoopingFn(newLooping) {
                            this._looping = newLooping;
                            var audio = this.audio;
                            if (audio) {
                                audio.loop = newLooping
                            }
                        },
                        enumerable: true,
                        configurable: false
                    });
                    source.loopAudio = function loopAudioFn() {
                        source.stop()
                    }
                } else {
                    source.looping = source._looping;
                    source.loopAudio = function loopAudioFn() {
                        var audio = source.audio;
                        if (audio) {
                            if (this.looping) {
                                audio.currentTime = 0;
                                audio.play()
                            } else {
                                source.stop()
                            }
                        }
                    }
                }
                Object.defineProperty(source, "pitch", {
                    get: function getPitchFn() {
                        return this._pitch
                    },
                    set: function setPitchFn(newPitch) {
                        this._pitch = newPitch;
                        var audio = this.audio;
                        if (audio) {
                            audio.playbackRate = newPitch
                        }
                    },
                    enumerable: true,
                    configurable: false
                });
                Object.defineProperty(source, "tell", {
                    get: function tellFn() {
                        if (this.playing) {
                            var audio = this.audio;
                            if (audio) {
                                return audio.currentTime
                            }
                        }
                        return 0
                    },
                    enumerable: true,
                    configurable: false
                })
            }
            return source
        };
        WebGLSoundGlobalSource.version = 1;
        return WebGLSoundGlobalSource
    }();
    var WebGLSoundSource = function(_super) {
        __extends(WebGLSoundSource, _super);

        function WebGLSoundSource() {
            _super.apply(this, arguments)
        }
        WebGLSoundSource.prototype._updateRelativePositionWebAudio = function(listenerPosition0, listenerPosition1, listenerPosition2) {
            var position = this._position;
            this._pannerNode.setPosition(position[0] + listenerPosition0, position[1] + listenerPosition1, position[2] + listenerPosition2)
        };
        WebGLSoundSource.prototype._updateRelativePositionHTML5 = function(listenerPosition0, listenerPosition1, listenerPosition2) {
            var minDistance = this.minDistance;
            var maxDistance = this.maxDistance;
            var position = this._position;
            var position0 = position[0];
            var position1 = position[1];
            var position2 = position[2];
            var distanceSq;
            if (this.relative) {
                distanceSq = position0 * position0 + position1 * position1 + position2 * position2
            } else {
                var delta0 = listenerPosition0 - position0;
                var delta1 = listenerPosition1 - position1;
                var delta2 = listenerPosition2 - position2;
                distanceSq = delta0 * delta0 + delta1 * delta1 + delta2 * delta2
            }
            var gainFactor;
            if (distanceSq <= minDistance * minDistance) {
                gainFactor = 1
            } else if (distanceSq >= maxDistance * maxDistance) {
                gainFactor = 0
            } else {
                var distance = Math.sqrt(distanceSq);
                if (this.sd.linearDistance) {
                    gainFactor = (maxDistance - distance) / (maxDistance - minDistance)
                } else {
                    gainFactor = minDistance / (minDistance + this.rollOff * (distance - minDistance))
                }
            }
            gainFactor *= this.sd.listenerGain;
            if (this._gainFactor !== gainFactor) {
                this._gainFactor = gainFactor;
                this.updateAudioVolume()
            }
        };
        WebGLSoundSource.prototype.destroy = function() {
            this.stop();
            var gainNode = this._gainNode;
            if (gainNode) {
                this._gainNode = null;
                gainNode.disconnect()
            }
            var pannerNode = this._pannerNode;
            if (pannerNode) {
                this._pannerNode = null;
                pannerNode.disconnect()
            }
        };
        WebGLSoundSource.create = function(sd, id, params) {
            var source = new WebGLSoundSource;
            source.sd = sd;
            source.id = id;
            source.sound = null;
            source.audio = null;
            source.playing = false;
            source.paused = false;
            var buffer = new Float32Array(9);
            source._position = buffer.subarray(0, 3);
            source._velocity = buffer.subarray(3, 6);
            source._direction = buffer.subarray(6, 9);
            source._gain = typeof params.gain === "number" ? params.gain : 1;
            source._looping = params.looping || false;
            source._pitch = params.pitch || 1;
            var audioContext = sd.audioContext;
            if (audioContext) {
                source.bufferNode = null;
                source.mediaNode = null;
                source.playStart = -1;
                source.playPaused = -1;
                var masterGainNode = sd._gainNode;
                var pannerNode = audioContext.createPanner();
                source._pannerNode = pannerNode;
                pannerNode.connect(masterGainNode);
                var gainNode = audioContext.createGain ? audioContext.createGain() : audioContext.createGainNode();
                gainNode.gain.value = source._gain;
                source._gainNode = gainNode;
                gainNode.connect(pannerNode);
                if (sd.linearDistance) {
                    if (typeof pannerNode.distanceModel === "string") {
                        pannerNode.distanceModel = "linear"
                    } else if (typeof pannerNode.LINEAR_DISTANCE === "number") {
                        pannerNode.distanceModel = pannerNode.LINEAR_DISTANCE
                    }
                }
                if (typeof pannerNode.panningModel === "string") {
                    pannerNode.panningModel = "equalpower"
                } else {
                    pannerNode.panningModel = pannerNode.EQUALPOWER
                }
                source.updateRelativePosition = source._updateRelativePositionWebAudio;
                Object.defineProperty(source, "position", {
                    get: function getPositionFn() {
                        return this._position.slice()
                    },
                    set: function setPositionFn(newPosition) {
                        var oldPosition = this._position;
                        if (oldPosition[0] !== newPosition[0] || oldPosition[1] !== newPosition[1] || oldPosition[2] !== newPosition[2]) {
                            oldPosition[0] = newPosition[0];
                            oldPosition[1] = newPosition[1];
                            oldPosition[2] = newPosition[2];
                            if (!this.relative) {
                                this._pannerNode.setPosition(newPosition[0], newPosition[1], newPosition[2])
                            }
                        }
                    },
                    enumerable: true,
                    configurable: false
                });
                Object.defineProperty(source, "direction", {
                    get: function getDirectionFn() {
                        return this._direction.slice()
                    },
                    set: function setDirectionFn(newDirection) {
                        this._direction = VMath.v3Copy(newDirection, this._direction);
                        this._pannerNode.setOrientation(newDirection[0], newDirection[1], newDirection[2])
                    },
                    enumerable: true,
                    configurable: false
                });
                Object.defineProperty(source, "velocity", {
                    get: function getVelocityFn() {
                        return this._velocity.slice()
                    },
                    set: function setVelocityFn(newVelocity) {
                        this._velocity = VMath.v3Copy(newVelocity, this._velocity);
                        this._pannerNode.setVelocity(newVelocity[0], newVelocity[1], newVelocity[2])
                    },
                    enumerable: true,
                    configurable: false
                });
                Object.defineProperty(source, "gain", {
                    get: function getGainFn() {
                        return this._gain
                    },
                    set: function setGainFn(newGain) {
                        if (this._gain !== newGain) {
                            this._gain = newGain;
                            this._gainNode.gain.value = newGain
                        }
                    },
                    enumerable: true,
                    configurable: false
                });
                Object.defineProperty(source, "looping", {
                    get: function getLoopingFn() {
                        return this._looping
                    },
                    set: function setLoopingFn(newLooping) {
                        this._looping = newLooping;
                        var audio = this.audio;
                        if (audio) {
                            audio.loop = newLooping
                        } else {
                            var bufferNode = this.bufferNode;
                            if (bufferNode) {
                                bufferNode.loop = newLooping
                            }
                        }
                    },
                    enumerable: true,
                    configurable: false
                });
                Object.defineProperty(source, "pitch", {
                    get: function getPitchFn() {
                        return this._pitch
                    },
                    set: function setPitchFn(newPitch) {
                        this._pitch = newPitch;
                        var audio = this.audio;
                        if (audio) {
                            audio.playbackRate = newPitch
                        } else {
                            var bufferNode = this.bufferNode;
                            if (bufferNode) {
                                if (bufferNode.playbackRate) {
                                    bufferNode.playbackRate.value = newPitch
                                }
                            }
                        }
                    },
                    enumerable: true,
                    configurable: false
                });
                Object.defineProperty(source, "tell", {
                    get: function tellFn() {
                        if (this.playing) {
                            var audio = this.audio;
                            if (audio) {
                                return audio.currentTime
                            } else {
                                if (this.paused) {
                                    return this.playPaused - this.playStart
                                } else {
                                    return audioContext.currentTime - this.playStart
                                }
                            }
                        } else {
                            return 0
                        }
                    },
                    enumerable: true,
                    configurable: false
                });
                Object.defineProperty(source, "minDistance", {
                    get: function getMinDistanceFn() {
                        return this._pannerNode.refDistance
                    },
                    set: function setMinDistanceFn(minDistance) {
                        if (this._pannerNode.maxDistance === minDistance) {
                            minDistance = this._pannerNode.maxDistance * .999
                        }
                        this._pannerNode.refDistance = minDistance
                    },
                    enumerable: true,
                    configurable: false
                });
                Object.defineProperty(source, "maxDistance", {
                    get: function getMaxDistanceFn() {
                        return this._pannerNode.maxDistance
                    },
                    set: function setMaxDistanceFn(maxDistance) {
                        if (this._pannerNode.refDistance === maxDistance) {
                            maxDistance = this._pannerNode.refDistance * 1.001
                        }
                        this._pannerNode.maxDistance = maxDistance
                    },
                    enumerable: true,
                    configurable: false
                });
                Object.defineProperty(source, "rollOff", {
                    get: function getRolloffFactorFn() {
                        return this._pannerNode.rolloffFactor
                    },
                    set: function setRolloffFactorFn(rollOff) {
                        this._pannerNode.rolloffFactor = rollOff
                    },
                    enumerable: true,
                    configurable: false
                });
                source.loopAudio = function loopAudioFn() {
                    source.stop()
                }
            } else {
                source._gainFactor = 1;
                source.updateAudioVolume = function updateAudioVolumeFn() {
                    var audio = this.audio;
                    if (audio) {
                        var volume = Math.min(this._gainFactor * this._gain, 1);
                        audio.volume = volume;
                        if (0 >= volume) {
                            audio.muted = true
                        } else {
                            audio.muted = false
                        }
                    }
                };
                source.updateRelativePosition = source._updateRelativePositionHTML5;
                Object.defineProperty(source, "position", {
                    get: function getPositionFn() {
                        return this._position.slice()
                    },
                    set: function setPositionFn(newPosition) {
                        this._position = VMath.v3Copy(newPosition, this._position)
                    },
                    enumerable: true,
                    configurable: false
                });
                Object.defineProperty(source, "direction", {
                    get: function getDirectionFn() {
                        return this._direction.slice()
                    },
                    set: function setDirectionFn(newDirection) {
                        this._direction = VMath.v3Copy(newDirection, this._direction)
                    },
                    enumerable: true,
                    configurable: false
                });
                Object.defineProperty(source, "velocity", {
                    get: function getVelocityFn() {
                        return this._velocity.slice()
                    },
                    set: function setVelocityFn(newVelocity) {
                        this._velocity = VMath.v3Copy(newVelocity, this._velocity)
                    },
                    enumerable: true,
                    configurable: false
                });
                Object.defineProperty(source, "gain", {
                    get: function getGainFn() {
                        return this._gain
                    },
                    set: function setGainFn(newGain) {
                        if (this._gain !== newGain) {
                            this._gain = newGain;
                            this.updateAudioVolume()
                        }
                    },
                    enumerable: true,
                    configurable: false
                });
                if (sd.loopingSupported) {
                    Object.defineProperty(source, "looping", {
                        get: function getLoopingFn() {
                            return this._looping
                        },
                        set: function setLoopingFn(newLooping) {
                            this._looping = newLooping;
                            var audio = this.audio;
                            if (audio) {
                                audio.loop = newLooping
                            }
                        },
                        enumerable: true,
                        configurable: false
                    });
                    source.loopAudio = function loopAudioFn() {
                        source.stop()
                    }
                } else {
                    source.looping = source._looping;
                    source.loopAudio = function loopAudioFn() {
                        var audio = source.audio;
                        if (audio) {
                            if (this.looping) {
                                audio.currentTime = 0;
                                audio.play()
                            } else {
                                source.stop()
                            }
                        }
                    }
                }
                Object.defineProperty(source, "pitch", {
                    get: function getPitchFn() {
                        return this._pitch
                    },
                    set: function setPitchFn(newPitch) {
                        this._pitch = newPitch;
                        var audio = this.audio;
                        if (audio) {
                            audio.playbackRate = newPitch
                        }
                    },
                    enumerable: true,
                    configurable: false
                });
                Object.defineProperty(source, "tell", {
                    get: function tellFn() {
                        if (this.playing) {
                            var audio = this.audio;
                            if (audio) {
                                return audio.currentTime
                            }
                        }
                        return 0
                    },
                    enumerable: true,
                    configurable: false
                })
            }
            source.relative = params.relative || false;
            source.minDistance = params.minDistance || 1;
            source.maxDistance = params.maxDistance || 3.402823466e38;
            source.rollOff = params.rollOff || 1;
            if (params.position) {
                source.position = params.position
            }
            if (params.velocity) {
                source.velocity = params.velocity
            }
            if (params.direction) {
                source.direction = params.direction
            }
            return source
        };
        WebGLSoundSource.version = 1;
        return WebGLSoundSource
    }(WebGLSoundGlobalSource);
    var WebGLSoundDevice = function() {
        function WebGLSoundDevice() {}
        WebGLSoundDevice.prototype.createSource = function(params) {
            this.lastSourceID += 1;
            return WebGLSoundSource.create(this, this.lastSourceID, params)
        };
        WebGLSoundDevice.prototype.createGlobalSource = function(params) {
            this.lastSourceID += 1;
            return WebGLSoundGlobalSource.create(this, this.lastSourceID, params)
        };
        WebGLSoundDevice.prototype.createSound = function(params) {
            return WebGLSound.create(this, params)
        };
        WebGLSoundDevice.prototype.loadSoundsArchive = function(params) {
            var src = params.src;
            if (typeof SoundTARLoader !== "undefined") {
                SoundTARLoader.create({
                    sd: this,
                    src: src,
                    uncompress: params.uncompress,
                    onsoundload: function tarSoundLoadedFn(texture) {
                        params.onsoundload(texture)
                    },
                    onload: function soundTarLoadedFn(success, status) {
                        if (params.onload) {
                            params.onload(success, status)
                        }
                    },
                    onerror: function soundTarFailedFn(status) {
                        if (params.onload) {
                            params.onload(false, status)
                        }
                    }
                });
                return true
            } else {
                TurbulenzEngine.callOnError("Missing archive loader required for " + src);
                return false
            }
        };
        WebGLSoundDevice.prototype.createEffect = function(params) {
            return null
        };
        WebGLSoundDevice.prototype.createEffectSlot = function(params) {
            return null
        };
        WebGLSoundDevice.prototype.createFilter = function(params) {
            return null
        };
        WebGLSoundDevice.prototype._updateHTML5 = function() {
            var listenerTransform = this._listenerTransform;
            var listenerPosition0 = listenerTransform[9];
            var listenerPosition1 = listenerTransform[10];
            var listenerPosition2 = listenerTransform[11];
            var numPlayingSources = this.numPlayingSources;
            var playingSources = this.playingSources;
            var n;
            for (n = 0; n < numPlayingSources; n += 1) {
                var source = playingSources[n];
                if (source.updateRelativePosition) {
                    source.updateRelativePosition(listenerPosition0, listenerPosition1, listenerPosition2)
                }
            }
        };
        WebGLSoundDevice.prototype._updateWebAudio = function() {
            this._gainNode.gain.value = this.listenerGain;
            var listenerTransform = this._listenerTransform;
            var listenerPosition0 = listenerTransform[9];
            var listenerPosition1 = listenerTransform[10];
            var listenerPosition2 = listenerTransform[11];
            var numPlayingSources = this.numPlayingSources;
            var playingSources = this.playingSources;
            var playingSourcesMap = this.playingSourcesMap;
            var currentTime = this.audioContext.currentTime;
            var n = 0;
            while (n < numPlayingSources) {
                var source = playingSources[n];
                if (!source._checkBufferNode(currentTime)) {
                    numPlayingSources -= 1;
                    playingSources[n] = playingSources[numPlayingSources];
                    playingSources[numPlayingSources] = null;
                    delete playingSourcesMap[source.id];
                    continue
                }
                if (source.relative) {
                    source.updateRelativePosition(listenerPosition0, listenerPosition1, listenerPosition2)
                }
                n += 1
            }
            this.numPlayingSources = numPlayingSources;
            if (numPlayingSources < playingSources.length >> 1) {
                playingSources.length = numPlayingSources
            }
        };
        WebGLSoundDevice.prototype.isSupported = function(name) {
            if ("FILEFORMAT_OGG" === name) {
                return this.supportedExtensions.ogg
            } else if ("FILEFORMAT_MP3" === name) {
                return this.supportedExtensions.mp3
            } else if ("FILEFORMAT_WAV" === name) {
                return this.supportedExtensions.wav
            }
            return false
        };
        WebGLSoundDevice.prototype.addLoadingSound = function(soundCheckCall) {
            var loadingSounds = this.loadingSounds;
            loadingSounds[loadingSounds.length] = soundCheckCall;
            var loadingInterval = this.loadingInterval;
            var that = this;
            if (loadingInterval === null) {
                this.loadingInterval = loadingInterval = window.setInterval(function checkLoadingSources() {
                    var numLoadingSounds = loadingSounds.length;
                    var n = 0;
                    do {
                        var soundCheck = loadingSounds[n];
                        if (soundCheck()) {
                            numLoadingSounds -= 1;
                            if (n < numLoadingSounds) {
                                loadingSounds[n] = loadingSounds[numLoadingSounds]
                            }
                            loadingSounds.length = numLoadingSounds
                        } else {
                            n += 1
                        }
                    } while (n < numLoadingSounds);
                    if (numLoadingSounds === 0) {
                        window.clearInterval(loadingInterval);
                        that.loadingInterval = null
                    }
                }, 100)
            }
        };
        WebGLSoundDevice.prototype.addPlayingSource = function(source) {
            var id = source.id;
            if (!this.playingSourcesMap[id]) {
                this.playingSourcesMap[id] = true;
                var numPlayingSources = this.numPlayingSources;
                this.playingSources[numPlayingSources] = source;
                this.numPlayingSources = numPlayingSources + 1
            }
        };
        WebGLSoundDevice.prototype.removePlayingSource = function(source) {
            delete this.playingSourcesMap[source.id];
            var numPlayingSources = this.numPlayingSources;
            var playingSources = this.playingSources;
            var n;
            for (n = 0; n < numPlayingSources; n += 1) {
                if (playingSources[n] === source) {
                    numPlayingSources -= 1;
                    playingSources[n] = playingSources[numPlayingSources];
                    playingSources[numPlayingSources] = null;
                    this.numPlayingSources = numPlayingSources;
                    break
                }
            }
        };
        WebGLSoundDevice.prototype.isResourceSupported = function(soundPath) {
            var extension = soundPath.slice(-3).toLowerCase();
            return this.supportedExtensions[extension]
        };
        WebGLSoundDevice.prototype.destroy = function() {
            var loadingInterval = this.loadingInterval;
            if (loadingInterval !== null) {
                window.clearInterval(loadingInterval);
                this.loadingInterval = null
            }
            var loadingSounds = this.loadingSounds;
            if (loadingSounds) {
                loadingSounds.length = 0;
                this.loadingSounds = null
            }
            var numPlayingSources = this.numPlayingSources;
            var playingSources = this.playingSources;
            var n;
            for (n = 0; n < numPlayingSources; n += 1) {
                playingSources[n]._stop()
            }
            this.numPlayingSources = 0;
            this.playingSources = null;
            this.playingSourcesMap = null;
            WebGLSound.prototype.audioContext = null;
            WebGLSoundSource.prototype.audioContext = null;
            WebGLSoundGlobalSource.prototype.audioContext = null
        };
        WebGLSoundDevice.create = function(params) {
            var sd = new WebGLSoundDevice;
            sd.extensions = "";
            sd.renderer = "HTML5 Audio";
            sd.alcVersion = "0";
            sd.alcExtensions = "";
            sd.alcEfxVersion = "0";
            sd.alcMaxAuxiliarySends = 0;
            sd.deviceSpecifier = params.deviceSpecifier || null;
            sd.frequency = params.frequency || 44100;
            sd.dopplerFactor = params.dopplerFactor || 1;
            sd.dopplerVelocity = params.dopplerVelocity || 1;
            sd.speedOfSound = params.speedOfSound || 343.29998779296875;
            sd.linearDistance = params.linearDistance !== undefined ? params.linearDistance : true;
            sd.loadingSounds = [];
            sd.loadingInterval = null;
            sd.numPlayingSources = 0;
            sd.playingSources = [];
            sd.playingSourcesMap = {};
            sd.lastSourceID = 0;
            var AudioContextConstructor;
            if (sd.deviceSpecifier !== "audioelement") {
                AudioContextConstructor = window.AudioContext || window.webkitAudioContext
            }
            var listener = null;
            if (AudioContextConstructor) {
                var audioContext;
                try {
                    audioContext = new AudioContextConstructor
                } catch (error) {
                    TurbulenzEngine.callOnError("Failed to create AudioContext:" + error);
                    return null
                }
                if (audioContext.sampleRate === 0) {
                    return null
                }
                WebGLSound.prototype.forceUncompress = true;
                WebGLSound.prototype.audioContext = audioContext;
                WebGLSoundSource.prototype.audioContext = audioContext;
                WebGLSoundGlobalSource.prototype.audioContext = audioContext;
                sd.renderer = "WebAudio";
                sd.audioContext = audioContext;
                sd.frequency = audioContext.sampleRate;
                sd._gainNode = audioContext.createGain ? audioContext.createGain() : audioContext.createGainNode();
                sd._gainNode.connect(audioContext.destination);
                listener = audioContext.listener;
                listener.dopplerFactor = sd.dopplerFactor;
                listener.speedOfSound = sd.speedOfSound;
                sd.update = sd._updateWebAudio
            } else {
                sd.update = sd._updateHTML5;
                WebGLSound.prototype.forceUncompress = false
            }
            sd._listenerTransform = params.listenerTransform ? VMath.m43Copy(params.listenerTransform) : VMath.m43BuildIdentity();
            sd._listenerVelocity = params.listenerVelocity ? VMath.v3Copy(params.listenerVelocity) : VMath.v3BuildZero();
            Object.defineProperty(sd, "listenerTransform", {
                get: function getListenerTransformFn() {
                    return this._listenerTransform.slice()
                },
                set: function setListenerTransformFn(transform) {
                    this._listenerTransform = VMath.m43Copy(transform, this._listenerTransform);
                    if (listener) {
                        var position0 = transform[9];
                        var position1 = transform[10];
                        var position2 = transform[11];
                        listener.setPosition(position0, position1, position2);
                        listener.setOrientation(-transform[6], -transform[7], -transform[8], transform[3], transform[4], transform[5])
                    }
                },
                enumerable: true,
                configurable: false
            });
            Object.defineProperty(sd, "listenerVelocity", {
                get: function getListenerVelocityFn() {
                    return this._listenerVelocity.slice()
                },
                set: function setListenerVelocityFn(velocity) {
                    this._listenerVelocity = VMath.v3Copy(velocity, this._listenerVelocity);
                    if (listener) {
                        listener.setVelocity(velocity[0], velocity[1], velocity[2])
                    }
                },
                enumerable: true,
                configurable: false
            });
            sd.listenerGain = typeof params.listenerGain === "number" ? params.listenerGain : 1;
            var audio;
            try {
                audio = new Audio
            } catch (error) {
                TurbulenzEngine.callOnError("Failed to create Audio:" + error);
                return null
            }
            if (sd.audioContext) {
                sd.loopingSupported = true
            } else {
                if (audio.mozSetup) {
                    try {
                        audio.mozSetup(1, 22050)
                    } catch (e) {
                        return null
                    }
                }
                sd.loopingSupported = typeof audio.loop === "boolean"
            }
            var supportedExtensions = {
                ogg: false,
                mp3: false,
                wav: false
            };
            if (audio.canPlayType("application/ogg")) {
                supportedExtensions.ogg = true
            }
            if (audio.canPlayType("audio/mp3")) {
                supportedExtensions.mp3 = true
            }
            if (audio.canPlayType("audio/wav")) {
                supportedExtensions.wav = true
            }
            sd.supportedExtensions = supportedExtensions;
            audio = null;
            return sd
        };
        WebGLSoundDevice.version = 1;
        return WebGLSoundDevice
    }();
    WebGLSoundDevice.prototype.vendor = "Turbulenz";
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.prototype !== undefined && ArrayBuffer.prototype.slice === undefined) {
        ArrayBuffer.prototype.slice = function ArrayBufferSlice(s, e) {
            var length = this.byteLength;
            if (s === undefined) {
                s = 0
            } else if (s < 0) {
                s += length
            }
            if (e === undefined) {
                e = length
            } else if (e < 0) {
                e += length
            }
            length = e - s;
            if (0 < length) {
                var src = new Uint8Array(this, s, length);
                var dst = new Uint8Array(src);
                return dst.buffer
            } else {
                return new ArrayBuffer(0)
            }
        }
    }
    var SoundTARLoader = function() {
        function SoundTARLoader() {}
        SoundTARLoader.prototype.processBytes = function(bytes) {
            var offset = 0;
            var totalSize = bytes.length;

            function skip(limit) {
                offset += limit
            }

            function getString(limit) {
                var index = offset;
                var nextOffset = index + limit;
                var c = bytes[index];
                var ret;
                if (c && 0 < limit) {
                    index += 1;
                    var s = new Array(limit);
                    var n = 0;
                    do {
                        s[n] = c;
                        n += 1;
                        c = bytes[index];
                        index += 1
                    } while (c && n < limit);
                    while (s[n - 1] === 32) {
                        n -= 1
                    }
                    s.length = n;
                    ret = String.fromCharCode.apply(null, s)
                } else {
                    ret = ""
                }
                offset = nextOffset;
                return ret
            }

            function getNumber(text) {
                text = text.replace(/[^\d]/g, "");
                return parseInt("0" + text, 8)
            }
            var header = {
                fileName: null,
                length: 0,
                fileType: null,
                ustarSignature: null,
                fileNamePrefix: null
            };

            function parseHeader(header) {
                header.fileName = getString(100);
                skip(8);
                skip(8);
                skip(8);
                header.length = getNumber(getString(12));
                skip(12);
                skip(8);
                header.fileType = getString(1);
                skip(100);
                header.ustarSignature = getString(6);
                skip(2);
                skip(32);
                skip(32);
                skip(8);
                skip(8);
                header.fileNamePrefix = getString(155);
                offset += 12
            }
            var sd = this.sd;
            var uncompress = this.uncompress;
            var onsoundload = this.onsoundload;
            var result = true;
            this.soundsLoading = 0;
            var that = this;

            function onload(sound) {
                that.soundsLoading -= 1;
                if (sound) {
                    onsoundload(sound)
                } else {
                    result = false
                }
            }
            while (offset + 512 <= totalSize) {
                parseHeader(header);
                if (0 < header.length) {
                    var fileName;
                    if (header.fileName === "././@LongLink") {
                        fileName = getString(256);
                        offset += 256;
                        parseHeader(header)
                    } else {
                        if (header.fileNamePrefix && header.ustarSignature === "ustar") {
                            fileName = header.fileNamePrefix + header.fileName
                        } else {
                            fileName = header.fileName
                        }
                    }
                    if ("" === header.fileType || "0" === header.fileType) {
                        this.soundsLoading += 1;
                        sd.createSound({
                            src: fileName,
                            data: sd.audioContext ? bytes.buffer.slice(offset, offset + header.length) : bytes.subarray(offset, offset + header.length),
                            uncompress: uncompress,
                            onload: onload
                        })
                    }
                    offset += Math.floor((header.length + 511) / 512) * 512
                }
            }
            bytes = null;
            return result
        };
        SoundTARLoader.prototype.isValidHeader = function(header) {
            return true
        };
        SoundTARLoader.create = function(params) {
            var loader = new SoundTARLoader;
            loader.sd = params.sd;
            loader.uncompress = params.uncompress;
            loader.onsoundload = params.onsoundload;
            loader.onload = params.onload;
            loader.onerror = params.onerror;
            loader.soundsLoading = 0;
            var src = params.src;
            if (src) {
                loader.src = src;
                var xhr;
                if (window.XMLHttpRequest) {
                    xhr = new window.XMLHttpRequest
                } else if (window.ActiveXObject) {
                    xhr = new window.ActiveXObject("Microsoft.XMLHTTP")
                } else {
                    if (params.onerror) {
                        params.onerror(0)
                    }
                    return null
                }
                xhr.onreadystatechange = function() {
                    if (xhr.readyState === 4) {
                        if (!TurbulenzEngine || !TurbulenzEngine.isUnloading()) {
                            var xhrStatus = xhr.status;
                            var xhrStatusText = xhr.status !== 0 && xhr.statusText || "No connection";
                            if (xhrStatus === 0 && (window.location.protocol === "file:" || window.location.protocol === "chrome-extension:")) {
                                xhrStatus = 200
                            }
                            if (xhr.getAllResponseHeaders() === "") {
                                var noBody;
                                if (xhr.responseType === "arraybuffer") {
                                    noBody = !xhr.response
                                } else if (xhr.mozResponseArrayBuffer) {
                                    noBody = !xhr.mozResponseArrayBuffer
                                } else {
                                    noBody = !xhr.responseText
                                }
                                if (noBody) {
                                    if (loader.onerror) {
                                        loader.onerror(0)
                                    }
                                    xhr.onreadystatechange = null;
                                    xhr = null;
                                    return
                                }
                            }
                            if (xhrStatus === 200 || xhrStatus === 0) {
                                var buffer;
                                if (xhr.responseType === "arraybuffer") {
                                    buffer = xhr.response
                                } else if (xhr.mozResponseArrayBuffer) {
                                    buffer = xhr.mozResponseArrayBuffer
                                } else {
                                    var text = xhr.responseText;
                                    var numChars = text.length;
                                    var i;
                                    buffer = [];
                                    buffer.length = numChars;
                                    for (i = 0; i < numChars; i += 1) {
                                        buffer[i] = text.charCodeAt(i) & 255
                                    }
                                }
                                var archiveResult = loader.processBytes(new Uint8Array(buffer));
                                if (loader.onload) {
                                    var callOnload = function callOnloadFn() {
                                        if (0 < loader.soundsLoading) {
                                            if (!TurbulenzEngine || !TurbulenzEngine.isUnloading()) {
                                                window.setTimeout(callOnload, 100)
                                            }
                                        } else {
                                            loader.onload(archiveResult, xhrStatus)
                                        }
                                    };
                                    callOnload()
                                }
                            } else {
                                if (loader.onerror) {
                                    loader.onerror(xhrStatus)
                                }
                            }
                        }
                        xhr.onreadystatechange = null;
                        xhr = null
                    }
                };
                xhr.open("GET", params.src, true);
                if (typeof xhr.responseType === "string" || xhr.hasOwnProperty && xhr.hasOwnProperty("responseType")) {
                    xhr.responseType = "arraybuffer"
                } else if (xhr.overrideMimeType) {
                    xhr.overrideMimeType("text/plain; charset=x-user-defined")
                } else {
                    xhr.setRequestHeader("Content-Type", "text/plain; charset=x-user-defined")
                }
                xhr.send(null)
            }
            return loader
        };
        SoundTARLoader.version = 1;
        return SoundTARLoader
    }();
    var TARLoader = function() {
        function TARLoader() {}
        TARLoader.prototype.processBytes = function(bytes) {
            var offset = 0;
            var totalSize = bytes.length;

            function skip(limit) {
                offset += limit
            }

            function getString(limit) {
                var index = offset;
                var nextOffset = index + limit;
                var c = bytes[index];
                var ret;
                if (c && 0 < limit) {
                    index += 1;
                    var s = new Array(limit);
                    var n = 0;
                    do {
                        s[n] = c;
                        n += 1;
                        c = bytes[index];
                        index += 1
                    } while (c && n < limit);
                    while (s[n - 1] === 32) {
                        n -= 1
                    }
                    s.length = n;
                    ret = String.fromCharCode.apply(null, s)
                } else {
                    ret = ""
                }
                offset = nextOffset;
                return ret
            }

            function getNumber(text) {
                text = text.replace(/[^\d]/g, "");
                return parseInt("0" + text, 8)
            }
            var header = {
                fileName: null,
                length: 0,
                fileType: null,
                ustarSignature: null,
                fileNamePrefix: null
            };

            function parseHeader(header) {
                header.fileName = getString(100);
                skip(8);
                skip(8);
                skip(8);
                header.length = getNumber(getString(12));
                skip(12);
                skip(8);
                header.fileType = getString(1);
                skip(100);
                header.ustarSignature = getString(6);
                skip(2);
                skip(32);
                skip(32);
                skip(8);
                skip(8);
                header.fileNamePrefix = getString(155);
                offset += 12
            }
            var gd = this.gd;
            var mipmaps = this.mipmaps;
            var ontextureload = this.ontextureload;
            var result = true;
            this.texturesLoading = 0;
            var that = this;

            function onload(texture) {
                that.texturesLoading -= 1;
                if (texture) {
                    ontextureload(texture)
                } else {
                    offset = totalSize;
                    result = false
                }
            }
            while (offset + 512 <= totalSize) {
                parseHeader(header);
                if (0 < header.length) {
                    var fileName;
                    if (header.fileName === "././@LongLink") {
                        fileName = getString(256);
                        offset += 256;
                        parseHeader(header)
                    } else {
                        if (header.fileNamePrefix && header.ustarSignature === "ustar") {
                            fileName = header.fileNamePrefix + header.fileName
                        } else {
                            fileName = header.fileName
                        }
                    }
                    if ("" === header.fileType || "0" === header.fileType) {
                        this.texturesLoading += 1;
                        gd.createTexture({
                            src: fileName,
                            data: bytes.subarray(offset, offset + header.length),
                            mipmaps: mipmaps,
                            onload: onload
                        })
                    }
                    offset += Math.floor((header.length + 511) / 512) * 512
                }
            }
            bytes = null;
            return result
        };
        TARLoader.prototype.isValidHeader = function() {
            return true
        };
        TARLoader.create = function(params) {
            var loader = new TARLoader;
            loader.gd = params.gd;
            loader.mipmaps = params.mipmaps;
            loader.ontextureload = params.ontextureload;
            loader.onload = params.onload;
            loader.onerror = params.onerror;
            loader.texturesLoading = 0;
            var src = params.src;
            if (src) {
                loader.src = src;
                var xhr;
                if (window.XMLHttpRequest) {
                    xhr = new window.XMLHttpRequest
                } else if (window.ActiveXObject) {
                    xhr = new window.ActiveXObject("Microsoft.XMLHTTP")
                } else {
                    if (params.onerror) {
                        params.onerror(0)
                    }
                    return null
                }
                xhr.onreadystatechange = function() {
                    if (xhr.readyState === 4) {
                        if (!TurbulenzEngine || !TurbulenzEngine.isUnloading()) {
                            var xhrStatus = xhr.status;
                            var xhrStatusText = xhr.status !== 0 && xhr.statusText || "No connection";
                            if (xhrStatus === 0 && (window.location.protocol === "file:" || window.location.protocol === "chrome-extension:")) {
                                xhrStatus = 200
                            }
                            if (xhr.getAllResponseHeaders() === "") {
                                var noBody;
                                if (xhr.responseType === "arraybuffer") {
                                    noBody = !xhr.response
                                } else if (xhr.mozResponseArrayBuffer) {
                                    noBody = !xhr.mozResponseArrayBuffer
                                } else {
                                    noBody = !xhr.responseText
                                }
                                if (noBody) {
                                    if (loader.onerror) {
                                        loader.onerror(0)
                                    }
                                    xhr.onreadystatechange = null;
                                    xhr = null;
                                    return
                                }
                            }
                            if (xhrStatus === 200 || xhrStatus === 0) {
                                var buffer;
                                if (xhr.responseType === "arraybuffer") {
                                    buffer = xhr.response
                                } else if (xhr.mozResponseArrayBuffer) {
                                    buffer = xhr.mozResponseArrayBuffer
                                } else {
                                    var text = xhr.responseText;
                                    var numChars = text.length;
                                    buffer = [];
                                    buffer.length = numChars;
                                    for (var i = 0; i < numChars; i += 1) {
                                        buffer[i] = text.charCodeAt(i) & 255
                                    }
                                }
                                if (loader.processBytes(new Uint8Array(buffer))) {
                                    if (loader.onload) {
                                        var callOnload = function callOnloadFn() {
                                            if (0 < loader.texturesLoading) {
                                                if (!TurbulenzEngine || !TurbulenzEngine.isUnloading()) {
                                                    window.setTimeout(callOnload, 100)
                                                }
                                            } else {
                                                loader.onload(true, xhrStatus)
                                            }
                                        };
                                        callOnload()
                                    }
                                } else {
                                    if (loader.onerror) {
                                        loader.onerror(xhrStatus)
                                    }
                                }
                            } else {
                                if (loader.onerror) {
                                    loader.onerror(xhrStatus)
                                }
                            }
                        }
                        xhr.onreadystatechange = null;
                        xhr = null
                    }
                };
                xhr.open("GET", params.src, true);
                if (typeof xhr.responseType === "string" || xhr.hasOwnProperty && xhr.hasOwnProperty("responseType")) {
                    xhr.responseType = "arraybuffer"
                } else if (xhr.overrideMimeType) {
                    xhr.overrideMimeType("text/plain; charset=x-user-defined")
                } else {
                    xhr.setRequestHeader("Content-Type", "text/plain; charset=x-user-defined")
                }
                xhr.send(null)
            }
            return loader
        };
        TARLoader.version = 1;
        return TARLoader
    }();
    var TGALoader = function() {
        function TGALoader() {}
        TGALoader.prototype.processBytes = function(bytes) {
            var header = this.parseHeader(bytes);
            if (!this.isValidHeader(header)) {
                return
            }
            var offset = 18;
            this.width = header.width;
            this.height = header.height;
            this.bytesPerPixel = Math.floor(header.bpp / 8);
            this.horzRev = header.descriptor & this.DESC_HORIZONTAL;
            this.vertRev = !(header.descriptor & this.DESC_VERTICAL);
            var rle = false;
            var gd = this.gd;
            switch (header.imageType) {
                case this.TYPE_MAPPED_RLE:
                    rle = true;
                    if (header.colorMapSize > 24) {
                        this.format = gd.PIXELFORMAT_R8G8B8A8
                    } else if (header.colorMapSize > 16) {
                        this.format = gd.PIXELFORMAT_R8G8B8
                    } else {
                        this.format = gd.PIXELFORMAT_R5G5B5A1
                    }
                    break;
                case this.TYPE_MAPPED:
                    if (header.colorMapSize > 24) {
                        this.format = gd.PIXELFORMAT_R8G8B8A8
                    } else if (header.colorMapSize > 16) {
                        this.format = gd.PIXELFORMAT_R8G8B8
                    } else {
                        this.format = gd.PIXELFORMAT_R5G5B5A1
                    }
                    break;
                case this.TYPE_GRAY_RLE:
                    rle = true;
                    this.format = gd.PIXELFORMAT_L8;
                    break;
                case this.TYPE_GRAY:
                    this.format = gd.PIXELFORMAT_L8;
                    break;
                case this.TYPE_COLOR_RLE:
                    rle = true;
                    switch (this.bytesPerPixel) {
                        case 4:
                            this.format = gd.PIXELFORMAT_R8G8B8A8;
                            break;
                        case 3:
                            this.format = gd.PIXELFORMAT_R8G8B8;
                            break;
                        case 2:
                            this.format = gd.PIXELFORMAT_R5G5B5A1;
                            break;
                        default:
                            return
                    }
                    break;
                case this.TYPE_COLOR:
                    switch (this.bytesPerPixel) {
                        case 4:
                            this.format = gd.PIXELFORMAT_R8G8B8A8;
                            break;
                        case 3:
                            this.format = gd.PIXELFORMAT_R8G8B8;
                            break;
                        case 2:
                            this.format = gd.PIXELFORMAT_R5G5B5A1;
                            break;
                        default:
                            return
                    }
                    break;
                default:
                    return
            }
            if (header.idLength) {
                offset += header.idLength;
                if (offset > bytes.length) {
                    return
                }
            }
            if (this.TYPE_MAPPED_RLE === header.imageType || this.TYPE_MAPPED === header.imageType) {
                if (header.colorMapType !== 1) {
                    return
                }
            } else if (header.colorMapType !== 0) {
                return
            }
            if (header.colorMapType === 1) {
                var index = header.colorMapIndex;
                var length = header.colorMapLength;
                if (length === 0) {
                    return
                }
                var pelbytes = Math.floor(header.colorMapSize / 8);
                var numColors = length + index;
                var colorMap = [];
                colorMap.length = numColors * pelbytes;
                this.colorMap = colorMap;
                this.colorMapBytesPerPixel = pelbytes;
                var j;
                for (j = 0; j < index * pelbytes; j += 1) {
                    colorMap[j] = 0
                }
                for (j = index * pelbytes; j < index * pelbytes; j += 1, offset += 1) {
                    colorMap[j] = bytes[offset]
                }
                offset += length * pelbytes;
                if (offset > bytes.length) {
                    return
                }
                if (pelbytes >= 3) {
                    for (j = index * pelbytes; j < length * pelbytes; j += pelbytes) {
                        var tmp = colorMap[j];
                        colorMap[j] = colorMap[j + 2];
                        colorMap[j + 2] = tmp
                    }
                }
            }
            var data = bytes.subarray(offset);
            bytes = null;
            if (rle) {
                data = this.expandRLE(data)
            }
            var size = this.width * this.height * this.bytesPerPixel;
            if (data.length < size) {
                return
            }
            if (this.horzRev) {
                this.flipHorz(data)
            }
            if (this.vertRev) {
                this.flipVert(data)
            }
            if (this.colorMap) {
                data = this.expandColorMap(data)
            } else if (2 < this.bytesPerPixel) {
                this.convertBGR2RGB(data)
            } else if (2 === this.bytesPerPixel) {
                data = this.convertARGB2RGBA(data)
            }
            this.data = data
        };
        TGALoader.prototype.parseHeader = function(bytes) {
            var header = {
                idLength: bytes[0],
                colorMapType: bytes[1],
                imageType: bytes[2],
                colorMapIndex: bytes[4] << 8 | bytes[3],
                colorMapLength: bytes[6] << 8 | bytes[5],
                colorMapSize: bytes[7],
                xOrigin: bytes[9] << 8 | bytes[8],
                yOrigin: bytes[11] << 8 | bytes[10],
                width: bytes[13] << 8 | bytes[12],
                height: bytes[15] << 8 | bytes[14],
                bpp: bytes[16],
                descriptor: bytes[17]
            };
            return header
        };
        TGALoader.prototype.isValidHeader = function(header) {
            if (this.TYPE_MAPPED_RLE === header.imageType || this.TYPE_MAPPED === header.imageType) {
                if (header.colorMapType !== 1) {
                    return false
                }
            } else if (header.colorMapType !== 0) {
                return false
            }
            if (header.colorMapType === 1) {
                if (header.colorMapLength === 0) {
                    return false
                }
            }
            switch (header.imageType) {
                case this.TYPE_MAPPED_RLE:
                case this.TYPE_MAPPED:
                    break;
                case this.TYPE_GRAY_RLE:
                case this.TYPE_GRAY:
                    break;
                case this.TYPE_COLOR_RLE:
                case this.TYPE_COLOR:
                    switch (Math.floor(header.bpp / 8)) {
                        case 4:
                        case 3:
                        case 2:
                            break;
                        default:
                            return false
                    }
                    break;
                default:
                    return false
            }
            if (16384 < header.width) {
                return false
            }
            if (16384 < header.height) {
                return false
            }
            return true
        };
        TGALoader.prototype.expandRLE = function(data) {
            var pelbytes = this.bytesPerPixel;
            var width = this.width;
            var height = this.height;
            var datasize = pelbytes;
            var size = width * height * pelbytes;
            var RLE_PACKETSIZE = this.RLE_PACKETSIZE;
            var dst = new Uint8Array(size);
            var src = 0,
                dest = 0,
                n, k;
            do {
                var count = data[src];
                src += 1;
                var bytes = ((count & ~RLE_PACKETSIZE) + 1) * datasize;
                if (count & RLE_PACKETSIZE) {
                    if (datasize === 1) {
                        var r = data[src];
                        src += 1;
                        for (n = 0; n < bytes; n += 1) {
                            dst[dest + k] = r
                        }
                    } else {
                        for (n = 0; n < datasize; n += 1) {
                            dst[dest + n] = data[src + n]
                        }
                        src += datasize;
                        for (k = datasize; k < bytes; k += datasize) {
                            for (n = 0; n < datasize; n += 1) {
                                dst[dest + k + n] = dst[dest + n]
                            }
                        }
                    }
                } else {
                    for (n = 0; n < bytes; n += 1) {
                        dst[dest + n] = data[src + n]
                    }
                    src += bytes
                }
                dest += bytes
            } while (dest < size);
            return dst
        };
        TGALoader.prototype.expandColorMap = function(data) {
            var pelbytes = this.bytesPerPixel;
            var width = this.width;
            var height = this.height;
            var size = width * height * pelbytes;
            var dst = new Uint8Array(size);
            var dest = 0,
                src = 0;
            var palette = this.colorMap;
            delete this.colorMap;
            if (pelbytes === 2 || pelbytes === 3 || pelbytes === 4) {
                do {
                    var index = data[src] * pelbytes;
                    src += 1;
                    for (var n = 0; n < pelbytes; n += 1) {
                        dst[dest] = palette[index + n];
                        dest += 1
                    }
                } while (dest < size)
            }
            if (pelbytes === 2) {
                dst = this.convertARGB2RGBA(dst)
            }
            return dst
        };
        TGALoader.prototype.flipHorz = function(data) {
            var pelbytes = this.bytesPerPixel;
            var width = this.width;
            var height = this.height;
            var halfWidth = Math.floor(width / 2);
            var pitch = width * pelbytes;
            for (var i = 0; i < height; i += 1) {
                for (var j = 0; j < halfWidth; j += 1) {
                    for (var k = 0; k < pelbytes; k += 1) {
                        var tmp = data[j * pelbytes + k];
                        data[j * pelbytes + k] = data[(width - j - 1) * pelbytes + k];
                        data[(width - j - 1) * pelbytes + k] = tmp
                    }
                }
                data += pitch
            }
        };
        TGALoader.prototype.flipVert = function(data) {
            var pelbytes = this.bytesPerPixel;
            var width = this.width;
            var height = this.height;
            var halfHeight = Math.floor(height / 2);
            var pitch = width * pelbytes;
            for (var i = 0; i < halfHeight; i += 1) {
                var srcRow = i * pitch;
                var destRow = (height - i - 1) * pitch;
                for (var j = 0; j < pitch; j += 1) {
                    var tmp = data[srcRow + j];
                    data[srcRow + j] = data[destRow + j];
                    data[destRow + j] = tmp
                }
            }
        };
        TGALoader.prototype.convertBGR2RGB = function(data) {
            var bytesPerPixel = this.bytesPerPixel;
            var width = this.width;
            var height = this.height;
            var size = width * height * bytesPerPixel;
            var offset = 0;
            do {
                var tmp = data[offset];
                data[offset] = data[offset + 2];
                data[offset + 2] = tmp;
                offset += bytesPerPixel
            } while (offset < size)
        };
        TGALoader.prototype.convertARGB2RGBA = function(data) {
            var bytesPerPixel = this.bytesPerPixel;
            if (bytesPerPixel === 2) {
                var width = this.width;
                var height = this.height;
                var size = width * height * bytesPerPixel;
                var dst = new Uint16Array(width * height);
                var src = 0,
                    dest = 0;
                var r, g, b, a;
                var mask = (1 << 5) - 1;
                var blueMask = mask;
                var greenMask = mask << 5;
                var redMask = mask << 10;
                do {
                    var value = src[1] << 8 | src[0];
                    src += 2;
                    b = (value & blueMask) << 1;
                    g = (value & greenMask) << 1;
                    r = (value & redMask) << 1;
                    a = value >> 15;
                    dst[dest] = r | g | b | a;
                    dest += 1
                } while (src < size);
                return dst
            } else {
                return data
            }
        };
        TGALoader.create = function(params) {
            var loader = new TGALoader;
            loader.gd = params.gd;
            loader.onload = params.onload;
            loader.onerror = params.onerror;
            var src = params.src;
            if (src) {
                loader.src = src;
                var xhr;
                if (window.XMLHttpRequest) {
                    xhr = new window.XMLHttpRequest
                } else if (window.ActiveXObject) {
                    xhr = new window.ActiveXObject("Microsoft.XMLHTTP")
                } else {
                    if (params.onerror) {
                        params.onerror(0)
                    }
                    return null
                }
                xhr.onreadystatechange = function() {
                    if (xhr.readyState === 4) {
                        if (!TurbulenzEngine || !TurbulenzEngine.isUnloading()) {
                            var xhrStatus = xhr.status;
                            var xhrStatusText = xhr.status !== 0 && xhr.statusText || "No connection";
                            if (xhrStatus === 0 && (window.location.protocol === "file:" || window.location.protocol === "chrome-extension:")) {
                                xhrStatus = 200
                            }
                            if (xhr.getAllResponseHeaders() === "") {
                                var noBody;
                                if (xhr.responseType === "arraybuffer") {
                                    noBody = !xhr.response
                                } else if (xhr.mozResponseArrayBuffer) {
                                    noBody = !xhr.mozResponseArrayBuffer
                                } else {
                                    noBody = !xhr.responseText
                                }
                                if (noBody) {
                                    if (loader.onerror) {
                                        loader.onerror(0)
                                    }
                                    xhr.onreadystatechange = null;
                                    xhr = null;
                                    return
                                }
                            }
                            if (xhrStatus === 200 || xhrStatus === 0) {
                                var buffer;
                                if (xhr.responseType === "arraybuffer") {
                                    buffer = xhr.response
                                } else if (xhr.mozResponseArrayBuffer) {
                                    buffer = xhr.mozResponseArrayBuffer
                                } else {
                                    var text = xhr.responseText;
                                    var numChars = text.length;
                                    buffer = [];
                                    buffer.length = numChars;
                                    for (var i = 0; i < numChars; i += 1) {
                                        buffer[i] = text.charCodeAt(i) & 255
                                    }
                                }
                                loader.processBytes(new Uint8Array(buffer));
                                if (loader.data) {
                                    if (loader.onload) {
                                        loader.onload(loader.data, loader.width, loader.height, loader.format, xhrStatus)
                                    }
                                } else {
                                    if (loader.onerror) {
                                        loader.onerror(xhrStatus)
                                    }
                                }
                            } else {
                                if (loader.onerror) {
                                    loader.onerror(xhrStatus)
                                }
                            }
                        }
                        xhr.onreadystatechange = null;
                        xhr = null
                    }
                };
                xhr.open("GET", params.src, true);
                if (typeof xhr.responseType === "string" || xhr.hasOwnProperty && xhr.hasOwnProperty("responseType")) {
                    xhr.responseType = "arraybuffer"
                } else if (xhr.overrideMimeType) {
                    xhr.overrideMimeType("text/plain; charset=x-user-defined")
                } else {
                    xhr.setRequestHeader("Content-Type", "text/plain; charset=x-user-defined")
                }
                xhr.send(null)
            } else {
                loader.processBytes(params.data);
                if (loader.data) {
                    if (loader.onload) {
                        loader.onload(loader.data, loader.width, loader.height, loader.format, 200)
                    }
                } else {
                    if (loader.onerror) {
                        loader.onerror(0)
                    }
                }
            }
            return loader
        };
        TGALoader.version = 1;
        return TGALoader
    }();
    TGALoader.prototype.TYPE_MAPPED = 1;
    TGALoader.prototype.TYPE_COLOR = 2;
    TGALoader.prototype.TYPE_GRAY = 3;
    TGALoader.prototype.TYPE_MAPPED_RLE = 9;
    TGALoader.prototype.TYPE_COLOR_RLE = 10;
    TGALoader.prototype.TYPE_GRAY_RLE = 11;
    TGALoader.prototype.DESC_ABITS = 15;
    TGALoader.prototype.DESC_HORIZONTAL = 16;
    TGALoader.prototype.DESC_VERTICAL = 32;
    TGALoader.prototype.SIGNATURE = "TRUEVISION-XFILE";
    TGALoader.prototype.RLE_PACKETSIZE = 128;
    var Touch = function() {
        function Touch() {}
        Touch.create = function(params) {
            var touch = new Touch;
            touch.force = params.force;
            touch.identifier = params.identifier;
            touch.isGameTouch = params.isGameTouch;
            touch.positionX = params.positionX;
            touch.positionY = params.positionY;
            touch.radiusX = params.radiusX;
            touch.radiusY = params.radiusY;
            touch.rotationAngle = params.rotationAngle;
            return touch
        };
        return Touch
    }();
    var WebGLTouchEvent = function() {
        function WebGLTouchEvent() {}
        WebGLTouchEvent.create = function(params) {
            var touchEvent = new WebGLTouchEvent;
            touchEvent.changedTouches = params.changedTouches;
            touchEvent.gameTouches = params.gameTouches;
            touchEvent.touches = params.touches;
            return touchEvent
        };
        return WebGLTouchEvent
    }();
    var WebGLTurbulenzEngine = function() {
        function WebGLTurbulenzEngine() {
            this.version = "0.28.0.0"
        }
        WebGLTurbulenzEngine.prototype.setInterval = function(f, t) {
            var that = this;
            return window.setInterval(function() {
                that.updateTime();
                f()
            }, t)
        };
        WebGLTurbulenzEngine.prototype.clearInterval = function(i) {
            window.clearInterval(i)
        };
        WebGLTurbulenzEngine.prototype.createGraphicsDevice = function(params) {
            if (this.graphicsDevice) {
                this.callOnError("GraphicsDevice already created");
                return null
            } else {
                var graphicsDevice = WebGLGraphicsDevice.create(this.canvas, params);
                this.graphicsDevice = graphicsDevice;
                return graphicsDevice
            }
        };
        WebGLTurbulenzEngine.prototype.createPhysicsDevice = function(params) {
            if (this.physicsDevice) {
                this.callOnError("PhysicsDevice already created");
                return null
            } else {
                var physicsDevice;
                var plugin = this.getPluginObject();
                if (plugin) {
                    physicsDevice = plugin.createPhysicsDevice(params)
                } else {
                    physicsDevice = WebGLPhysicsDevice.create()
                }
                this.physicsDevice = physicsDevice;
                return physicsDevice
            }
        };
        WebGLTurbulenzEngine.prototype.createSoundDevice = function(params) {
            if (this.soundDevice) {
                this.callOnError("SoundDevice already created");
                return null
            } else {
                var soundDevice;
                var plugin = this.getPluginObject();
                if (plugin) {
                    soundDevice = plugin.createSoundDevice(params)
                } else {
                    soundDevice = WebGLSoundDevice.create(params)
                }
                this.soundDevice = soundDevice;
                return soundDevice
            }
        };
        WebGLTurbulenzEngine.prototype.createInputDevice = function(params) {
            if (this.inputDevice) {
                this.callOnError("InputDevice already created");
                return null
            } else {
                var inputDevice = WebGLInputDevice.create(this.canvas);
                this.inputDevice = inputDevice;
                return inputDevice
            }
        };
        WebGLTurbulenzEngine.prototype.createNetworkDevice = function(params) {
            if (this.networkDevice) {
                throw "NetworkDevice already created"
            } else {
                var networkDevice = WebGLNetworkDevice.create(params);
                this.networkDevice = networkDevice;
                return networkDevice
            }
        };
        WebGLTurbulenzEngine.prototype.createMathDevice = function(params) {
            try {
                var testVector = new Float32Array([1, 2, 3]);
                VMath.v3Build.apply(VMath, testVector);
                testVector[0] = VMath.FLOAT_MAX;
                VMath.FLOAT_MAX = testVector[0]
            } catch (e) {}
            return WebGLMathDevice
        };
        WebGLTurbulenzEngine.prototype.createNativeMathDevice = function(params) {
            return WebGLMathDevice
        };
        WebGLTurbulenzEngine.prototype.getGraphicsDevice = function() {
            var graphicsDevice = this.graphicsDevice;
            if (graphicsDevice === null) {
                this.callOnError("GraphicsDevice not created yet.")
            }
            return graphicsDevice
        };
        WebGLTurbulenzEngine.prototype.getPhysicsDevice = function() {
            return this.physicsDevice
        };
        WebGLTurbulenzEngine.prototype.getSoundDevice = function() {
            return this.soundDevice
        };
        WebGLTurbulenzEngine.prototype.getInputDevice = function() {
            return this.inputDevice
        };
        WebGLTurbulenzEngine.prototype.getNetworkDevice = function() {
            return this.networkDevice
        };
        WebGLTurbulenzEngine.prototype.getMathDevice = function() {
            return WebGLMathDevice
        };
        WebGLTurbulenzEngine.prototype.getNativeMathDevice = function() {
            return WebGLMathDevice
        };
        WebGLTurbulenzEngine.prototype.getObjectStats = function() {
            return null
        };
        WebGLTurbulenzEngine.prototype.flush = function() {};
        WebGLTurbulenzEngine.prototype.run = function() {};
        WebGLTurbulenzEngine.prototype.encrypt = function(msg) {
            return msg
        };
        WebGLTurbulenzEngine.prototype.decrypt = function(msg) {
            return msg
        };
        WebGLTurbulenzEngine.prototype.generateSignature = function(msg) {
            return null
        };
        WebGLTurbulenzEngine.prototype.verifySignature = function(msg, sig) {
            return true
        };
        WebGLTurbulenzEngine.prototype.onerror = function(msg) {
            console.error(msg)
        };
        WebGLTurbulenzEngine.prototype.onwarning = function(msg) {
            console.warn(msg)
        };
        WebGLTurbulenzEngine.prototype.onperformancewarning = function(msg) {};
        WebGLTurbulenzEngine.prototype.getSystemInfo = function() {
            return this.systemInfo
        };
        WebGLTurbulenzEngine.prototype.request = function(url, callback) {
            var that = this;
            var xhr;
            if (window.XMLHttpRequest) {
                xhr = new window.XMLHttpRequest
            } else if (window.ActiveXObject) {
                xhr = new window.ActiveXObject("Microsoft.XMLHTTP")
            } else {
                that.callOnError("No XMLHTTPRequest object could be created");
                return
            }
            var httpRequestCallback = function httpRequestCallbackFn() {
                if (xhr.readyState === 4) {
                    if (!that.isUnloading()) {
                        var xhrResponseText = xhr.responseText;
                        var xhrStatus = xhr.status;
                        if ("" === xhrResponseText) {
                            xhrResponseText = null
                        }
                        if (xhrStatus === 0 && xhrResponseText && window.location.protocol === "file:") {
                            xhrStatus = 200
                        } else if (null === xhr.getResponseHeader("Content-Type") && "" === xhr.getAllResponseHeaders()) {
                            callback(null, 0);
                            return
                        }
                        if (xhrStatus !== 0) {
                            if (404 === xhrStatus) {
                                xhrResponseText = null
                            }
                            callback(xhrResponseText, xhrStatus)
                        } else {
                            callback(xhrResponseText, 0)
                        }
                    }
                    xhr.onreadystatechange = null;
                    xhr = null;
                    callback = null
                }
            };
            xhr.open("GET", url, true);
            if (callback) {
                xhr.onreadystatechange = httpRequestCallback
            }
            xhr.send()
        };
        WebGLTurbulenzEngine.prototype.destroy = function() {
            if (this.networkDevice) {
                delete this.networkDevice
            }
            if (this.inputDevice) {
                this.inputDevice.destroy();
                delete this.inputDevice
            }
            if (this.physicsDevice) {
                delete this.physicsDevice
            }
            if (this.soundDevice) {
                if (this.soundDevice.destroy) {
                    this.soundDevice.destroy()
                }
                delete this.soundDevice
            }
            if (this.graphicsDevice) {
                this.graphicsDevice.destroy();
                delete this.graphicsDevice
            }
            if (this.canvas) {
                delete this.canvas
            }
            if (this.resizeCanvas) {
                window.removeEventListener("resize", this.resizeCanvas, false);
                delete this.resizeCanvas
            }
            if (this.handleZeroTimeoutMessages) {
                window.removeEventListener("message", this.handleZeroTimeoutMessages, true);
                delete this.handleZeroTimeoutMessages
            }
        };
        WebGLTurbulenzEngine.prototype.getPluginObject = function() {
            if (!this.plugin && this.pluginId) {
                this.plugin = document.getElementById(this.pluginId)
            }
            return this.plugin
        };
        WebGLTurbulenzEngine.prototype.unload = function() {
            if (!this.unloading) {
                this.unloading = true;
                if (this.onunload) {
                    this.onunload()
                }
                if (this.destroy) {
                    this.destroy()
                }
            }
        };
        WebGLTurbulenzEngine.prototype.isUnloading = function() {
            return this.unloading
        };
        WebGLTurbulenzEngine.prototype.enableProfiling = function() {};
        WebGLTurbulenzEngine.prototype.startProfiling = function() {
            if (console && console.profile && console.profileEnd) {
                console.profile("turbulenz")
            }
        };
        WebGLTurbulenzEngine.prototype.stopProfiling = function() {
            var result;
            if (console && console.profile && console.profileEnd) {
                console.profileEnd();
                if (console.profiles) {
                    result = console.profiles[console.profiles.length - 1]
                }
            }
            return result
        };
        WebGLTurbulenzEngine.prototype.callOnError = function(msg) {
            var onerror = this.onerror;
            if (onerror) {
                onerror(msg)
            }
        };
        WebGLTurbulenzEngine.create = function(params) {
            var tz = new WebGLTurbulenzEngine;
            var canvas = params.canvas;
            var fillParent = params.fillParent;
            window.TurbulenzEngineCanvas = tz;
            tz.pluginId = params.pluginId;
            tz.plugin = null;
            var getTime = Date.now;
            var performance = window.performance;
            if (performance) {
                if (performance.now) {
                    getTime = function getTimeFn() {
                        return performance.now()
                    }
                } else if (performance.webkitNow) {
                    getTime = function getTimeFn() {
                        return performance.webkitNow()
                    }
                }
            }
            tz.getTime = getTime;
            var baseTime = getTime();
            var canUseDefineProperty = true;
            var navStr = navigator.userAgent;
            var navVersionIdx = navStr.indexOf("Version/6.0");
            if (-1 !== navVersionIdx) {
                if (-1 !== navStr.substring(navVersionIdx).indexOf("Safari/")) {
                    canUseDefineProperty = false
                }
            }
            if (canUseDefineProperty && Object.defineProperty) {
                Object.defineProperty(tz, "time", {
                    get: function() {
                        return (getTime() - baseTime) * .001
                    },
                    set: function(newValue) {
                        if (typeof newValue === "number") {
                            baseTime = getTime() - newValue * 1e3
                        } else {
                            tz.callOnError("Must set 'time' attribute to a number")
                        }
                    },
                    enumerable: false,
                    configurable: false
                });
                tz.updateTime = function() {}
            } else {
                tz.updateTime = function() {
                    this.time = (getTime() - baseTime) * .001
                }
            }
            if (window.postMessage) {
                var zeroTimeoutMessageName = "0-timeout-message";
                var timeouts = [];
                var timeId = 0;
                var setZeroTimeout = function setZeroTimeoutFn(fn) {
                    timeId += 1;
                    var timeout = {
                        id: timeId,
                        fn: fn
                    };
                    timeouts.push(timeout);
                    window.postMessage(zeroTimeoutMessageName, "*");
                    return timeout
                };
                var clearZeroTimeout = function clearZeroTimeoutFn(timeout) {
                    var id = timeout.id;
                    var numTimeouts = timeouts.length;
                    for (var n = 0; n < numTimeouts; n += 1) {
                        if (timeouts[n].id === id) {
                            timeouts.splice(n, 1);
                            return
                        }
                    }
                };
                var handleZeroTimeoutMessages = function handleZeroTimeoutMessagesFn(event) {
                    if (event.source === window && event.data === zeroTimeoutMessageName) {
                        event.stopPropagation();
                        if (timeouts.length && !tz.isUnloading()) {
                            var timeout = timeouts.shift();
                            var fn = timeout.fn;
                            fn()
                        }
                    }
                };
                tz.handleZeroTimeoutMessages = handleZeroTimeoutMessages;
                window.addEventListener("message", handleZeroTimeoutMessages, true);
                tz.setTimeout = function(f, t) {
                    if (t < 1) {
                        return setZeroTimeout(f)
                    } else {
                        var that = this;
                        return window.setTimeout(function() {
                            that.updateTime();
                            if (!that.isUnloading()) {
                                f()
                            }
                        }, t)
                    }
                };
                tz.clearTimeout = function(i) {
                    if (typeof i === "object") {
                        return clearZeroTimeout(i)
                    } else {
                        return window.clearTimeout(i)
                    }
                }
            } else {
                tz.setTimeout = function(f, t) {
                    var that = this;
                    return window.setTimeout(function() {
                        that.updateTime();
                        if (!that.isUnloading()) {
                            f()
                        }
                    }, t)
                };
                tz.clearTimeout = function(i) {
                    return window.clearTimeout(i)
                }
            }
            var requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || window.mozRequestAnimationFrame;
            if (requestAnimationFrame) {
                tz.setInterval = function(f, t) {
                    var that = this;
                    if (Math.abs(t - 1e3 / 60) <= 1) {
                        var interval = {
                            enabled: true
                        };
                        var nextFrameTime = getTime() + 16.6;
                        var wrap1 = function wrap1() {
                            if (interval.enabled) {
                                var currentTime = getTime();
                                var diff = currentTime - nextFrameTime;
                                if (0 <= diff) {
                                    if (diff > 50) {
                                        nextFrameTime = currentTime + 16.6
                                    } else {
                                        nextFrameTime += 16.6
                                    }
                                    that.updateTime();
                                    if (!that.isUnloading()) {
                                        f()
                                    }
                                }
                                requestAnimationFrame(wrap1, that.canvas)
                            }
                        };
                        requestAnimationFrame(wrap1, that.canvas);
                        return interval
                    } else {
                        var wrap2 = function wrap2() {
                            that.updateTime();
                            if (!that.isUnloading()) {
                                f()
                            }
                        };
                        return window.setInterval(wrap2, t)
                    }
                };
                tz.clearInterval = function(i) {
                    if (typeof i === "object") {
                        i.enabled = false
                    } else {
                        window.clearInterval(i)
                    }
                }
            }
            tz.canvas = canvas;
            tz.networkDevice = null;
            tz.inputDevice = null;
            tz.physicsDevice = null;
            tz.soundDevice = null;
            tz.graphicsDevice = null;
            if (fillParent) {
                tz.resizeCanvas = function() {
                    if (document.fullscreenElement === canvas || document.mozFullScreenElement === canvas || document.webkitFullscreenElement === canvas || document.msFullscreenElement === canvas) {
                        canvas.width = window.innerWidth;
                        canvas.height = window.innerHeight
                    } else {
                        var parentNode = canvas.parentNode;
                        canvas.width = parentNode.clientWidth;
                        canvas.height = parentNode.clientHeight
                    }
                };
                tz.resizeCanvas();
                window.addEventListener("resize", tz.resizeCanvas, false)
            }
            try {
                var previousOnBeforeUnload = window.onbeforeunload;
                window.onbeforeunload = function() {
                    tz.unload();
                    if (previousOnBeforeUnload) {
                        previousOnBeforeUnload.call(this)
                    }
                }
            } catch (e) {}
            tz.time = 0;
            var systemInfo = {
                architecture: "",
                cpuDescription: "",
                cpuVendor: "",
                numPhysicalCores: 1,
                numLogicalCores: 1,
                ramInMegabytes: 0,
                frequencyInMegaHZ: 0,
                osVersionMajor: 0,
                osVersionMinor: 0,
                osVersionBuild: 0,
                osName: navigator.platform,
                platformProfile: "desktop",
                userLocale: (navigator.language || navigator.userLanguage).replace("-", "_")
            };

            function looksLikeNetbook() {
                var minScreenDim = Math.min(window.screen.height, window.screen.width);
                return minScreenDim < 900
            }
            var userAgent = navigator.userAgent;
            var osIndex = userAgent.indexOf("Windows");
            if (osIndex !== -1) {
                systemInfo.osName = "Windows";
                if (navigator.platform === "Win64") {
                    systemInfo.architecture = "x86_64"
                } else if (navigator.platform === "Win32") {
                    systemInfo.architecture = "x86"
                }
                osIndex += 7;
                if (userAgent.slice(osIndex, osIndex + 4) === " NT ") {
                    osIndex += 4;
                    systemInfo.osVersionMajor = parseInt(userAgent.slice(osIndex, osIndex + 1), 10);
                    systemInfo.osVersionMinor = parseInt(userAgent.slice(osIndex + 2, osIndex + 4), 10)
                }
                if (looksLikeNetbook()) {
                    systemInfo.platformProfile = "tablet"
                }
            } else {
                osIndex = userAgent.indexOf("Mac OS X");
                if (osIndex !== -1) {
                    systemInfo.osName = "Darwin";
                    if (navigator.platform.indexOf("Intel") !== -1) {
                        systemInfo.architecture = "x86"
                    }
                    osIndex += 9;
                    systemInfo.osVersionMajor = parseInt(userAgent.slice(osIndex, osIndex + 2), 10);
                    systemInfo.osVersionMinor = parseInt(userAgent.slice(osIndex + 3, osIndex + 4), 10);
                    systemInfo.osVersionBuild = parseInt(userAgent.slice(osIndex + 5, osIndex + 6), 10) || 0
                } else {
                    osIndex = userAgent.indexOf("Tizen");
                    if (osIndex !== -1) {
                        systemInfo.osName = "Tizen";
                        if (navigator.platform.indexOf("arm")) {
                            systemInfo.architecture = "arm"
                        }
                        if (-1 !== userAgent.indexOf("Mobile")) {
                            systemInfo.platformProfile = "smartphone"
                        } else {
                            systemInfo.platformProfile = "tablet"
                        }
                    } else {
                        osIndex = userAgent.indexOf("Linux");
                        if (osIndex !== -1) {
                            systemInfo.osName = "Linux";
                            if (navigator.platform.indexOf("64") !== -1) {
                                systemInfo.architecture = "x86_64"
                            } else if (navigator.platform.indexOf("x86") !== -1) {
                                systemInfo.architecture = "x86"
                            }
                            if (looksLikeNetbook()) {
                                systemInfo.platformProfile = "tablet"
                            }
                        } else {
                            osIndex = userAgent.indexOf("Android");
                            if (-1 !== osIndex) {
                                systemInfo.osName = "Android";
                                if (navigator.platform.indexOf("arm")) {
                                    systemInfo.architecture = "arm"
                                } else if (navigator.platform.indexOf("x86")) {
                                    systemInfo.architecture = "x86"
                                }
                                if (-1 !== userAgent.indexOf("Mobile")) {
                                    systemInfo.platformProfile = "smartphone"
                                } else {
                                    systemInfo.platformProfile = "tablet"
                                }
                            } else {
                                if (-1 !== userAgent.indexOf("iPhone") || -1 !== userAgent.indexOf("iPod")) {
                                    systemInfo.osName = "iOS";
                                    systemInfo.architecture = "arm";
                                    systemInfo.platformProfile = "smartphone"
                                } else if (-1 !== userAgent.indexOf("iPad")) {
                                    systemInfo.osName = "iOS";
                                    systemInfo.architecture = "arm";
                                    systemInfo.platformProfile = "tablet"
                                }
                            }
                        }
                    }
                }
            }
            tz.systemInfo = systemInfo;
            var b64ConversionTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".split("");
            tz.base64Encode = function base64EncodeFn(bytes) {
                var output = "";
                var numBytes = bytes.length;
                var valueToChar = b64ConversionTable;
                var n, chr1, chr2, chr3, enc1, enc2, enc3, enc4;
                n = 0;
                while (n < numBytes) {
                    chr1 = bytes[n];
                    n += 1;
                    enc1 = chr1 >> 2;
                    if (n < numBytes) {
                        chr2 = bytes[n];
                        n += 1;
                        if (n < numBytes) {
                            chr3 = bytes[n];
                            n += 1;
                            enc2 = (chr1 & 3) << 4 | chr2 >> 4;
                            enc3 = (chr2 & 15) << 2 | chr3 >> 6;
                            enc4 = chr3 & 63
                        } else {
                            enc2 = (chr1 & 3) << 4 | chr2 >> 4;
                            enc3 = (chr2 & 15) << 2;
                            enc4 = 64
                        }
                    } else {
                        enc2 = (chr1 & 3) << 4;
                        enc3 = 64;
                        enc4 = 64
                    }
                    output += valueToChar[enc1];
                    output += valueToChar[enc2];
                    output += valueToChar[enc3];
                    output += valueToChar[enc4]
                }
                return output
            };
            return tz
        };
        return WebGLTurbulenzEngine
    }();
    window.WebGLTurbulenzEngine = WebGLTurbulenzEngine;

    function testEngineVersion(requiredVersion, errorCallback) {
        var engineVersion = TurbulenzEngine.version;
        var versionDigitCount = 4;
        var engineArray, requiredArray;
        if (engineVersion && requiredVersion) {
            engineArray = engineVersion.split(".", versionDigitCount);
            requiredArray = requiredVersion.split(".", versionDigitCount);
            if (engineArray && requiredArray && engineArray.length > 1 && requiredArray.length > 1) {
                var i, length;
                var addEngineDigits = versionDigitCount - engineArray.length;
                var addRequiredDigits = versionDigitCount - requiredArray.length;
                length = versionDigitCount;
                for (i = 0; i < length; i += 1) {
                    if (addEngineDigits > 0) {
                        engineArray.push("0");
                        addEngineDigits -= 1
                    }
                    if (addRequiredDigits > 0) {
                        requiredArray.push("0");
                        addRequiredDigits -= 1
                    }
                }
                length = engineArray.length;
                for (i = 0; i < length; i += 1) {
                    var pi = parseInt(engineArray[i], 10);
                    var si = parseInt(requiredArray[i], 10);
                    if (isNaN(pi) || isNaN(si)) {
                        errorCallback("Invalid engine version string encountered.\nPlease try updating the Turbulenz Engine.");
                        return false
                    }
                    if (pi < si) {
                        errorCallback("This application needs a newer version of the Turbulenz Engine to run.\nPlease update the Turbulenz Engine.");
                        return false
                    } else if (pi > si) {
                        return true
                    }
                }
                return true
            }
        }
        errorCallback("Invalid engine version string encountered.\nPlease try updating the Turbulenz Engine.");
        return false
    }
    var ShaderManager = function() {
        function ShaderManager() {}
        ShaderManager.prototype.get = function(path) {
            return null
        };
        ShaderManager.create = function(gd, rh, ds, errorCallback, log) {
            if (!errorCallback) {
                errorCallback = function() {}
            }
            var defaultShaderName = "default";
            var defaultShader;
            if (ds) {
                defaultShader = ds
            } else {
                var shaderParams = {
                    version: 1,
                    name: "default.cgfx",
                    parameters: {
                        worldViewProjection: {
                            type: "float",
                            rows: 4,
                            columns: 4
                        },
                        diffuse: {
                            type: "sampler2D"
                        }
                    },
                    techniques: {
                        textured3D: [{
                            parameters: ["worldViewProjection", "diffuse"],
                            semantics: ["POSITION", "TEXCOORD0"],
                            states: {
                                DepthTestEnable: true,
                                DepthFunc: 515,
                                DepthMask: true,
                                CullFaceEnable: true,
                                CullFace: 1029,
                                BlendEnable: false
                            },
                            programs: ["vp", "fp"]
                        }]
                    },
                    programs: {
                        fp: {
                            type: "fragment",
                            code: "#ifdef GL_ES\nprecision mediump float;precision mediump int;\n#endif\nvarying vec4 tz_TexCoord[1];vec4 _ret_0;uniform sampler2D diffuse;void main()\n{_ret_0=texture2D(diffuse,tz_TexCoord[0].xy);gl_FragColor=_ret_0;}"
                        },
                        vp: {
                            type: "vertex",
                            code: "#ifdef GL_ES\nprecision mediump float;precision mediump int;\n#endif\nvarying vec4 tz_TexCoord[1];attribute vec4 ATTR0;attribute vec4 ATTR8;\nvec4 _OUTpos1;vec2 _OUTuv1;uniform vec4 worldViewProjection[4];void main()\n{_OUTpos1=ATTR0.xxxx*worldViewProjection[0]+ATTR0.yyyy*worldViewProjection[1]+ATTR0.zzzz*worldViewProjection[2]+worldViewProjection[3];_OUTuv1=ATTR8.xy;tz_TexCoord[0].xy=ATTR8.xy;gl_Position=_OUTpos1;}"
                        }
                    }
                };
                defaultShader = gd.createShader(shaderParams);
                if (!defaultShader) {
                    errorCallback("Default shader not created.")
                }
            }
            var shaders = {};
            var loadingShader = {};
            var loadedObservers = {};
            var numLoadingShaders = 0;
            var pathRemapping = null;
            var pathPrefix = "";
            var doPreprocess = false;
            var resizeParameters = {};
            shaders[defaultShaderName] = defaultShader;

            function preprocessShader(shader) {
                var parameters = shader.parameters;
                var techniques = shader.techniques;
                var programs = shader.programs;
                var p, resize, programsToUpdate, t;
                var passes, numPasses, a, pass, passPrograms;
                var length, n, reg, rep, u, program;
                for (p in parameters) {
                    if (parameters.hasOwnProperty(p)) {
                        resize = resizeParameters[p];
                        if (resize !== undefined) {
                            parameters[p].rows = resize;
                            programsToUpdate = {};
                            for (t in techniques) {
                                if (techniques.hasOwnProperty(t)) {
                                    passes = techniques[t];
                                    numPasses = passes.length;
                                    for (a = 0; a < numPasses; a += 1) {
                                        pass = passes[a];
                                        if (pass.parameters.indexOf(p) !== -1) {
                                            passPrograms = pass.programs;
                                            length = passPrograms.length;
                                            for (n = 0; n < length; n += 1) {
                                                programsToUpdate[passPrograms[n]] = true
                                            }
                                        }
                                    }
                                }
                            }
                            reg = new RegExp("uniform\\s+(\\w+)\\s+" + p + "\\s*\\[[^\\]]+\\]", "mg");
                            rep = "uniform $1 " + p + "[" + resize + "]";
                            for (u in programsToUpdate) {
                                if (programsToUpdate.hasOwnProperty(u)) {
                                    program = programs[u];
                                    program.code = program.code.replace(reg, rep)
                                }
                            }
                        }
                    }
                }
            }
            var loadShader = function loadShaderFn(path, onShaderLoaded) {
                if (path === undefined) {
                    errorCallback("Invalid texture path passed to ShaderManager.Load")
                }
                var shader = shaders[path];
                if (!shader) {
                    if (!loadingShader[path]) {
                        loadingShader[path] = true;
                        numLoadingShaders += 1;
                        var observer = Observer.create();
                        loadedObservers[path] = observer;
                        if (onShaderLoaded) {
                            observer.subscribe(onShaderLoaded)
                        }
                        var shaderLoaded = function shaderLoadedFn(shaderText) {
                            if (shaderText) {
                                var shaderParameters = JSON.parse(shaderText);
                                if (doPreprocess) {
                                    preprocessShader(shaderParameters)
                                }
                                var s = gd.createShader(shaderParameters);
                                if (s) {
                                    shaders[path] = s
                                } else {
                                    delete shaders[path]
                                }
                                observer.notify(s);
                                delete loadedObservers[path]
                            } else {
                                if (log) {
                                    log.innerHTML += "ShaderManager.load:&nbsp;'" + path + "' failed to load<br>"
                                }
                                delete shaders[path]
                            }
                            delete loadingShader[path];
                            numLoadingShaders -= 1
                        };
                        rh.request({
                            src: pathRemapping && pathRemapping[path] || pathPrefix + path,
                            onload: shaderLoaded
                        })
                    } else if (onShaderLoaded) {
                        loadedObservers[path].subscribe(onShaderLoaded)
                    }
                    return defaultShader
                } else if (onShaderLoaded) {
                    TurbulenzEngine.setTimeout(function shaderAlreadyLoadedFn() {
                        onShaderLoaded(shader)
                    }, 0)
                }
                return shader
            };
            var mapShader = function mapShaderFn(dst, src) {
                shaders[dst] = shaders[src]
            };
            var getShader = function getShaderFn(path) {
                var shader = shaders[path];
                if (!shader) {
                    return defaultShader
                }
                return shader
            };
            var removeShader = function removeShaderFn(path) {
                if (typeof shaders[path] !== "undefined") {
                    delete shaders[path]
                }
            };
            var reloadShader = function reloadShaderFn(path, callback) {
                removeShader(path);
                loadShader(path, callback)
            };
            var sm = new ShaderManager;
            if (log) {
                sm.load = function loadShaderLogFn(path, callback) {
                    log.innerHTML += "ShaderManager.load:&nbsp;'" + path + "'<br>";
                    return loadShader(path, callback)
                };
                sm.map = function mapShaderLogFn(dst, src) {
                    log.innerHTML += "ShaderManager.map:&nbsp;'" + src + "' -> '" + dst + "'<br>";
                    mapShader(dst, src)
                };
                sm.get = function getShaderLogFn(path) {
                    log.innerHTML += "ShaderManager.get:&nbsp;'" + path + "'<br>";
                    return getShader(path)
                };
                sm.remove = function removeShaderLogFn(path) {
                    log.innerHTML += "ShaderManager.remove:&nbsp;'" + path + "'<br>";
                    removeShader(path)
                };
                sm.reload = function reloadShaderLogFn(path, callback) {
                    log.innerHTML += "ShaderManager. reload:&nbsp;'" + path + "'<br>";
                    reloadShader(path, callback)
                }
            } else {
                sm.load = loadShader;
                sm.map = mapShader;
                sm.get = getShader;
                sm.remove = removeShader;
                sm.reload = reloadShader
            }
            sm.reloadAll = function reloadAllShadersFn() {
                for (var t in shaders) {
                    if (shaders.hasOwnProperty(t) && t !== defaultShaderName) {
                        reloadShader(t)
                    }
                }
            };
            sm.getAll = function getAllShadersFn() {
                return shaders
            };
            sm.getNumPendingShaders = function getNumPendingShadersFn() {
                return numLoadingShaders
            };
            sm.isShaderLoaded = function isShaderLoadedFn(path) {
                return !loadingShader[path]
            };
            sm.isShaderMissing = function isShaderMissingFn(path) {
                return !shaders[path]
            };
            sm.setPathRemapping = function setPathRemappingFn(prm, assetUrl) {
                pathRemapping = prm;
                pathPrefix = assetUrl
            };
            sm.setAutomaticParameterResize = function setAutomaticParameterResizeFn(name, size) {
                doPreprocess = true;
                resizeParameters[name] = size
            };
            sm.destroy = function shaderManagerDestroyFn() {
                if (shaders) {
                    var p;
                    for (p in shaders) {
                        if (shaders.hasOwnProperty(p)) {
                            var shader = shaders[p];
                            if (shader) {
                                shader.destroy()
                            }
                        }
                    }
                    shaders = null
                }
                defaultShader = null;
                loadingShader = null;
                loadedObservers = null;
                numLoadingShaders = 0;
                pathRemapping = null;
                pathPrefix = null;
                rh = null;
                gd = null
            };
            return sm
        };
        ShaderManager.version = 1;
        return ShaderManager
    }();
    var TextureInstance = function() {
        function TextureInstance() {}
        TextureInstance.prototype.setTexture = function(texture) {
            this.texture = texture;
            if (this.textureChangedObserver) {
                this.textureChangedObserver.notify(this)
            }
        };
        TextureInstance.prototype.getTexture = function() {
            return this.texture
        };
        TextureInstance.prototype.subscribeTextureChanged = function(observerFunction) {
            if (!this.textureChangedObserver) {
                this.textureChangedObserver = Observer.create()
            }
            this.textureChangedObserver.subscribe(observerFunction)
        };
        TextureInstance.prototype.unsubscribeTextureChanged = function(observerFunction) {
            this.textureChangedObserver.unsubscribe(observerFunction)
        };
        TextureInstance.prototype.destroy = function() {
            if (this.texture.name !== "default") {
                this.texture.destroy()
            }
            delete this.texture;
            delete this.textureChangedObserver
        };
        TextureInstance.create = function(name, texture) {
            var textureInstance = new TextureInstance;
            textureInstance.name = name;
            textureInstance.texture = texture;
            textureInstance.reference = Reference.create(textureInstance);
            return textureInstance
        };
        TextureInstance.version = 1;
        return TextureInstance
    }();
    var TextureManager = function() {
        function TextureManager() {}
        TextureManager.prototype.add = function(name, texture, internal) {
            var textureInstance = this.textureInstances[name];
            if (!textureInstance) {
                this.textureInstances[name] = TextureInstance.create(name, texture);
                this.textureInstances[name].reference.subscribeDestroyed(this.onTextureInstanceDestroyed)
            } else {
                textureInstance.setTexture(texture)
            }
            if (internal) {
                this.internalTexture[name] = true;
                this.textureInstances[name].reference.add()
            }
        };
        TextureManager.prototype.get = function(path) {
            var instance = this.textureInstances[path];
            if (!instance) {
                return this.defaultTexture
            }
            return instance.getTexture()
        };
        TextureManager.prototype.getInstance = function(path) {
            return this.textureInstances[path]
        };
        TextureManager.prototype.load = function(path, nomipmaps, onTextureLoaded) {
            var that = this;
            if (path === undefined) {
                this.errorCallback("Invalid texture path passed to TextureManager.Load")
            }
            var textureInstance = this.textureInstances[path];
            if (!textureInstance || textureInstance.texture === this.defaultTexture && path !== "default") {
                if (!textureInstance) {
                    this.add(path, this.defaultTexture, false)
                }
                if (!(path in this.loadingTexture)) {
                    if (0 === this.numLoadingArchives) {
                        this.loadingTexture[path] = true;
                        this.numLoadingTextures += 1;
                        var mipmaps = true;
                        if (nomipmaps) {
                            mipmaps = false
                        }
                        var loadedObserver = Observer.create();
                        this.loadedTextureObservers[path] = loadedObserver;
                        if (onTextureLoaded) {
                            loadedObserver.subscribe(onTextureLoaded)
                        }
                        var textureLoaded = function textureLoadedFn(texture, status) {
                            if (status === 200 && texture) {
                                that.add(path, texture, false)
                            }
                            loadedObserver.notify(texture);
                            delete that.loadedTextureObservers[path];
                            delete that.loadingTexture[path];
                            that.numLoadingTextures -= 1
                        };
                        var textureRequest = function textureRequestFn(url, onload) {
                            var texture = that.graphicsDevice.createTexture({
                                src: url,
                                mipmaps: mipmaps,
                                onload: onload
                            });
                            if (!texture) {
                                that.errorCallback("Texture '" + url + "' not created.")
                            }
                        };
                        this.requestHandler.request({
                            src: this.pathRemapping && this.pathRemapping[path] || this.pathPrefix + path,
                            requestFn: textureRequest,
                            onload: textureLoaded
                        })
                    } else {
                        this.delayedTextures[path] = {
                            nomipmaps: nomipmaps,
                            onload: onTextureLoaded
                        };
                        return this.get(path)
                    }
                } else if (onTextureLoaded) {
                    this.loadedTextureObservers[path].subscribe(onTextureLoaded)
                }
                return this.get(path)
            } else {
                var texture = this.get(path);
                if (onTextureLoaded) {
                    TurbulenzEngine.setTimeout(function textureAlreadyLoadedFn() {
                        onTextureLoaded(texture)
                    }, 0)
                }
                return texture
            }
        };
        TextureManager.prototype.map = function(dst, src) {
            if (!this.textureInstances[dst]) {
                this.textureInstances[dst] = TextureInstance.create(dst, this.textureInstances[src].getTexture());
                this.textureInstances[dst].reference.subscribeDestroyed(this.onTextureInstanceDestroyed)
            } else {
                this.textureInstances[dst].setTexture(this.textureInstances[src].getTexture())
            }
            this.internalTexture[dst] = true
        };
        TextureManager.prototype.remove = function(path) {
            if (!this.internalTexture[path]) {
                if (path in this.textureInstances) {
                    this.textureInstances[path].reference.unsubscribeDestroyed(this.onTextureInstanceDestroyed);
                    delete this.textureInstances[path]
                }
            }
        };
        TextureManager.prototype.loadArchive = function(path, nomipmaps, onTextureLoaded, onArchiveLoaded) {
            var that = this;
            var archive = this.archivesLoaded[path];
            if (!archive) {
                if (!(path in this.loadingArchives)) {
                    var mipmaps = true;
                    if (nomipmaps) {
                        mipmaps = false
                    }
                    this.loadingArchives[path] = {
                        textures: {}
                    };
                    this.numLoadingArchives += 1;
                    var observer = Observer.create();
                    this.loadedArchiveObservers[path] = observer;
                    if (onArchiveLoaded) {
                        observer.subscribe(onArchiveLoaded)
                    }
                    var textureArchiveLoaded = function textureArchiveLoadedFn(success, status) {
                        var loadedArchive;
                        if (status === 200 && success) {
                            loadedArchive = {
                                textures: that.loadingArchives[path].textures
                            };
                            that.archivesLoaded[path] = loadedArchive
                        }
                        observer.notify(loadedArchive);
                        delete that.loadedArchiveObservers[path];
                        delete that.loadingArchives[path];
                        that.numLoadingArchives -= 1;
                        if (0 === that.numLoadingArchives) {
                            var name;
                            for (name in that.delayedTextures) {
                                if (that.delayedTextures.hasOwnProperty(name)) {
                                    var delayedTexture = that.delayedTextures[name];
                                    that.load(name, delayedTexture.nomipmaps, delayedTexture.onload)
                                }
                            }
                            that.delayedTextures = {}
                        }
                    };
                    var requestTextureArchive = function requestTextureArchiveFn(url, onload) {
                        var ontextureload = function ontextureloadFn(texture) {
                            var name = texture.name;
                            if (!(name in that.textureInstances) || that.textureInstances[name].texture === that.defaultTexture) {
                                that.add(name, texture, false);
                                that.loadingArchives[path].textures[name] = texture
                            }
                            if (onTextureLoaded) {
                                onTextureLoaded(texture)
                            }
                            delete that.delayedTextures[name];
                            if (path in that.loadingTexture) {
                                delete that.loadingTexture[path];
                                that.numLoadingTextures -= 1
                            }
                        };
                        if (!that.graphicsDevice.loadTexturesArchive({
                                src: url,
                                mipmaps: mipmaps,
                                ontextureload: ontextureload,
                                onload: onload
                            })) {
                            that.errorCallback("Archive '" + path + "' not loaded.")
                        }
                    };
                    that.requestHandler.request({
                        src: that.pathRemapping && that.pathRemapping[path] || that.pathPrefix + path,
                        requestFn: requestTextureArchive,
                        onload: textureArchiveLoaded
                    })
                } else if (onTextureLoaded) {
                    this.loadedArchiveObservers[path].subscribe(function textureArchiveLoadedFn() {
                        var archive = that.archivesLoaded[path];
                        var texturesInArchive = archive.textures;
                        var t;
                        for (t in texturesInArchive) {
                            if (texturesInArchive.hasOwnProperty(t)) {
                                onTextureLoaded(texturesInArchive[t])
                            }
                        }
                        if (onArchiveLoaded) {
                            onArchiveLoaded(archive)
                        }
                    })
                }
            } else {
                if (onTextureLoaded) {
                    var texturesInArchive = archive.textures;
                    var numTexturesLoading = 0;
                    var textureAlreadyLoadedWrapper = function textureAlreadyLoadedWrapper(texture) {
                        return function textureAlreadyLoadedFn() {
                            onTextureLoaded(texture);
                            numTexturesLoading -= 1;
                            if (numTexturesLoading === 0 && onArchiveLoaded) {
                                onArchiveLoaded(archive)
                            }
                        }
                    };
                    var t;
                    for (t in texturesInArchive) {
                        if (texturesInArchive.hasOwnProperty(t)) {
                            numTexturesLoading += 1;
                            TurbulenzEngine.setTimeout(textureAlreadyLoadedWrapper(texturesInArchive[t]), 0)
                        }
                    }
                }
            }
        };
        TextureManager.prototype.isArchiveLoaded = function(path) {
            return path in this.archivesLoaded
        };
        TextureManager.prototype.removeArchive = function(path) {
            if (path in this.archivesLoaded) {
                var archiveTextures = this.archivesLoaded[path].textures;
                var texture;
                for (texture in archiveTextures) {
                    if (archiveTextures.hasOwnProperty(texture)) {
                        this.remove(texture)
                    }
                }
                delete this.archivesLoaded[path]
            }
        };
        TextureManager.prototype.getAll = function() {
            return this.textureInstances
        };
        TextureManager.prototype.getNumPendingTextures = function() {
            return this.numLoadingTextures + this.numLoadingArchives
        };
        TextureManager.prototype.isTextureLoaded = function(path) {
            return !(path in this.loadingTexture) && !(path in this.delayedTextures)
        };
        TextureManager.prototype.isTextureMissing = function(path) {
            return !(path in this.textureInstances)
        };
        TextureManager.prototype.setPathRemapping = function(prm, assetUrl) {
            this.pathRemapping = prm;
            this.pathPrefix = assetUrl
        };
        TextureManager.prototype.addProceduralTexture = function(params) {
            var name = params.name;
            var procTexture = this.graphicsDevice.createTexture(params);
            if (!procTexture) {
                this.errorCallback("Failed to create '" + name + "' texture.")
            } else {
                this.add(name, procTexture, true)
            }
        };
        TextureManager.prototype.destroy = function() {
            if (this.textureInstances) {
                var p;
                for (p in this.textureInstances) {
                    if (this.textureInstances.hasOwnProperty(p)) {
                        var textureInstance = this.textureInstances[p];
                        if (textureInstance) {
                            textureInstance.destroy()
                        }
                    }
                }
                this.textureInstances = null
            }
            if (this.defaultTexture) {
                this.defaultTexture.destroy();
                this.defaultTexture = null
            }
            this.loadingTexture = null;
            this.loadedTextureObservers = null;
            this.delayedTextures = null;
            this.numLoadingTextures = 0;
            this.archivesLoaded = null;
            this.loadingArchives = null;
            this.loadedArchiveObservers = null;
            this.numLoadingArchives = 0;
            this.internalTexture = null;
            this.pathRemapping = null;
            this.pathPrefix = null;
            this.requestHandler = null;
            this.graphicsDevice = null
        };
        TextureManager.create = function(graphicsDevice, requestHandler, dt, errorCallback, log) {
            var textureManager = new TextureManager;
            if (!errorCallback) {
                errorCallback = function() {}
            }
            var defaultTextureName = "default";
            var defaultTexture;
            if (dt) {
                defaultTexture = dt
            } else {
                defaultTexture = graphicsDevice.createTexture({
                    name: defaultTextureName,
                    width: 2,
                    height: 2,
                    depth: 1,
                    format: "R8G8B8A8",
                    cubemap: false,
                    mipmaps: true,
                    dynamic: false,
                    data: [255, 20, 147, 255, 255, 0, 0, 255, 255, 255, 255, 255, 255, 20, 147, 255]
                });
                if (!defaultTexture) {
                    errorCallback("Default texture not created.")
                }
            }
            textureManager.textureInstances = {};
            textureManager.loadingTexture = {};
            textureManager.loadedTextureObservers = {};
            textureManager.delayedTextures = {};
            textureManager.numLoadingTextures = 0;
            textureManager.archivesLoaded = {};
            textureManager.loadingArchives = {};
            textureManager.loadedArchiveObservers = {};
            textureManager.numLoadingArchives = 0;
            textureManager.internalTexture = {};
            textureManager.pathRemapping = null;
            textureManager.pathPrefix = "";
            textureManager.graphicsDevice = graphicsDevice;
            textureManager.requestHandler = requestHandler;
            textureManager.defaultTexture = defaultTexture;
            textureManager.errorCallback = errorCallback;
            var onTextureInstanceDestroyed = function onTextureInstanceDestroyedFn(textureInstance) {
                textureInstance.reference.unsubscribeDestroyed(onTextureInstanceDestroyed);
                delete textureManager.textureInstances[textureInstance.name]
            };
            textureManager.onTextureInstanceDestroyed = onTextureInstanceDestroyed;
            if (log) {
                textureManager.add = function addTextureLogFn(name, tex) {
                    log.innerHTML += "TextureManager.add:&nbsp;'" + name + "'";
                    return TextureManager.prototype.add.call(textureManager, name, tex)
                };
                textureManager.load = function loadTextureLogFn(path, nomipmaps) {
                    log.innerHTML += "TextureManager.load:&nbsp;'" + path + "'";
                    return TextureManager.prototype.load.call(textureManager, path, nomipmaps)
                };
                textureManager.loadArchive = function loadArchiveLogFn(path, nomipmaps) {
                    log.innerHTML += "TextureManager.loadArchive:&nbsp;'" + path + "'";
                    return TextureManager.prototype.loadArchive.call(textureManager, path, nomipmaps)
                };
                textureManager.isArchiveLoaded = function isArchiveLoadedLogFn(path) {
                    log.innerHTML += "TextureManager.isArchiveLoaded:&nbsp;'" + path + "'";
                    return TextureManager.prototype.isArchiveLoaded.call(textureManager, path)
                };
                textureManager.removeArchive = function removeArchiveLogFn(path) {
                    log.innerHTML += "TextureManager.removeArchive:&nbsp;'" + path + "'";
                    return TextureManager.prototype.removeArchive.call(textureManager, path)
                };
                textureManager.map = function mapTextureLogFn(dst, src) {
                    log.innerHTML += "TextureManager.map:&nbsp;'" + src + "' -> '" + dst + "'";
                    TextureManager.prototype.map.call(textureManager, dst, src)
                };
                textureManager.get = function getTextureLogFn(path) {
                    log.innerHTML += "TextureManager.get:&nbsp;'" + path + "'";
                    return TextureManager.prototype.get.call(textureManager, path)
                };
                textureManager.getInstance = function getTextureInstanceLogFn(path) {
                    log.innerHTML += "TextureManager.getInstance:&nbsp;'" + path + "'";
                    return TextureManager.prototype.getInstance.call(textureManager, path)
                };
                textureManager.remove = function removeTextureLogFn(path) {
                    log.innerHTML += "TextureManager.remove:&nbsp;'" + path + "'";
                    TextureManager.prototype.remove.call(textureManager, path)
                }
            }
            textureManager.add(defaultTextureName, defaultTexture, true);
            textureManager.addProceduralTexture({
                name: "white",
                width: 2,
                height: 2,
                depth: 1,
                format: "R8G8B8A8",
                cubemap: false,
                mipmaps: true,
                dynamic: false,
                data: [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]
            });
            textureManager.addProceduralTexture({
                name: "black",
                width: 2,
                height: 2,
                depth: 1,
                format: "R8G8B8A8",
                cubemap: false,
                mipmaps: true,
                dynamic: false,
                data: [0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255, 0, 0, 0, 255]
            });
            textureManager.addProceduralTexture({
                name: "flat",
                width: 2,
                height: 2,
                depth: 1,
                format: "R8G8B8A8",
                cubemap: false,
                mipmaps: true,
                dynamic: false,
                data: [128, 128, 255, 255, 128, 128, 255, 255, 128, 128, 255, 255, 128, 128, 255, 255]
            });
            var abs = Math.abs;
            var x, y;
            var quadraticData = [];
            for (y = 0; y < 4; y += 1) {
                for (x = 0; x < 32; x += 1) {
                    var s = (x + .5) * (2 / 32) - 1;
                    s = abs(s) - 1 / 32;
                    var value = 1 - s * 2 + s * s;
                    if (value <= 0) {
                        quadraticData.push(0)
                    } else if (value >= 1) {
                        quadraticData.push(255)
                    } else {
                        quadraticData.push(value * 255)
                    }
                }
            }
            textureManager.addProceduralTexture({
                name: "quadratic",
                width: 32,
                height: 4,
                depth: 1,
                format: "L8",
                cubemap: false,
                mipmaps: true,
                dynamic: false,
                data: quadraticData
            });
            quadraticData = null;
            var nofalloffData = [];
            for (y = 0; y < 4; y += 1) {
                nofalloffData.push(0);
                for (x = 1; x < 31; x += 1) {
                    nofalloffData.push(255)
                }
                nofalloffData.push(0)
            }
            textureManager.addProceduralTexture({
                name: "nofalloff",
                width: 32,
                height: 4,
                depth: 1,
                format: "L8",
                cubemap: false,
                mipmaps: true,
                dynamic: false,
                data: nofalloffData
            });
            nofalloffData = null;
            return textureManager
        };
        TextureManager.version = 1;
        return TextureManager
    }();
    var DefaultRendering = function() {
        function DefaultRendering() {}
        DefaultRendering.prototype.updateShader = function() {};
        DefaultRendering.prototype.sortRenderablesAndLights = function(camera, scene) {
            var opaque = DefaultRendering.passIndex.opaque;
            var decal = DefaultRendering.passIndex.decal;
            var transparent = DefaultRendering.passIndex.transparent;
            var passes = this.passes;
            var opaquePass = passes[opaque];
            var decalPass = passes[decal];
            var transparentPass = passes[transparent];
            var numOpaque = 0;
            var numDecal = 0;
            var numTransparent = 0;
            var drawParametersArray;
            var numDrawParameters;
            var drawParameters;
            var drawParametersIndex;
            var visibleRenderables = scene.getCurrentVisibleRenderables();
            var numVisibleRenderables = visibleRenderables.length;
            if (numVisibleRenderables > 0) {
                var renderable, passIndex;
                var n = 0;
                do {
                    renderable = visibleRenderables[n];
                    if (!renderable.renderUpdate) {
                        var effect = renderable.sharedMaterial.effect;
                        if (effect.prepare) {
                            effect.prepare(renderable)
                        }
                    }
                    renderable.renderUpdate(camera);
                    drawParametersArray = renderable.drawParameters;
                    numDrawParameters = drawParametersArray.length;
                    for (drawParametersIndex = 0; drawParametersIndex < numDrawParameters; drawParametersIndex += 1) {
                        drawParameters = drawParametersArray[drawParametersIndex];
                        passIndex = drawParameters.userData.passIndex;
                        if (passIndex === opaque) {
                            opaquePass[numOpaque] = drawParameters;
                            numOpaque += 1
                        } else if (passIndex === transparent) {
                            if (renderable.sharedMaterial.meta.far) {
                                drawParameters.sortKey = 1e38
                            } else {
                                drawParameters.sortKey = renderable.distance
                            }
                            transparentPass[numTransparent] = drawParameters;
                            numTransparent += 1
                        } else if (passIndex === decal) {
                            decalPass[numDecal] = drawParameters;
                            numDecal += 1
                        }
                    }
                    n += 1
                } while (n < numVisibleRenderables)
            }
            opaquePass.length = numOpaque;
            decalPass.length = numDecal;
            transparentPass.length = numTransparent
        };
        DefaultRendering.prototype.update = function(gd, camera, scene, currentTime) {
            scene.updateVisibleNodes(camera);
            this.sortRenderablesAndLights(camera, scene);
            var matrix = camera.matrix;
            if (matrix[9] !== this.eyePosition[0] || matrix[10] !== this.eyePosition[1] || matrix[11] !== this.eyePosition[2]) {
                this.eyePositionUpdated = true;
                this.eyePosition[0] = matrix[9];
                this.eyePosition[1] = matrix[10];
                this.eyePosition[2] = matrix[11]
            } else {
                this.eyePositionUpdated = false
            }
            this.globalTechniqueParameters["time"] = currentTime;
            this.camera = camera;
            this.scene = scene
        };
        DefaultRendering.prototype.updateBuffers = function(gd, deviceWidth, deviceHeight) {
            return true
        };
        DefaultRendering.prototype.draw = function(gd, clearColor, drawDecalsFn, drawTransparentFn, drawDebugFn) {
            gd.clear(clearColor, 1, 0);
            if (this.wireframe) {
                this.scene.drawWireframe(gd, this.sm, this.camera, this.wireframeInfo);
                if (drawDecalsFn) {
                    drawDecalsFn()
                }
                if (drawTransparentFn) {
                    drawTransparentFn()
                }
            } else {
                var globalTechniqueParametersArray = this.globalTechniqueParametersArray;
                var passes = this.passes;
                gd.drawArray(passes[DefaultRendering.passIndex.opaque], globalTechniqueParametersArray, -1);
                gd.drawArray(passes[DefaultRendering.passIndex.decal], globalTechniqueParametersArray, -1);
                if (drawDecalsFn) {
                    drawDecalsFn()
                }
                gd.drawArray(passes[DefaultRendering.passIndex.transparent], globalTechniqueParametersArray, 1);
                if (drawTransparentFn) {
                    drawTransparentFn()
                }
            }
            if (drawDebugFn) {
                drawDebugFn()
            }
            this.lightPositionUpdated = false
        };
        DefaultRendering.prototype.setGlobalLightPosition = function(pos) {
            this.lightPositionUpdated = true;
            this.lightPosition[0] = pos[0];
            this.lightPosition[1] = pos[1];
            this.lightPosition[2] = pos[2]
        };
        DefaultRendering.prototype.setGlobalLightColor = function(color) {
            this.globalTechniqueParameters["lightColor"] = color
        };
        DefaultRendering.prototype.setAmbientColor = function(color) {
            this.globalTechniqueParameters["ambientColor"] = color
        };
        DefaultRendering.prototype.setDefaultTexture = function(tex) {
            this.globalTechniqueParameters["diffuse"] = tex
        };
        DefaultRendering.prototype.setWireframe = function(wireframeEnabled, wireframeInfo) {
            this.wireframeInfo = wireframeInfo;
            this.wireframe = wireframeEnabled
        };
        DefaultRendering.prototype.getDefaultSkinBufferSize = function() {
            return this.defaultSkinBufferSize
        };
        DefaultRendering.prototype.destroy = function() {
            delete this.globalTechniqueParametersArray;
            delete this.globalTechniqueParameters;
            delete this.lightPosition;
            delete this.eyePosition;
            delete this.passes
        };
        DefaultRendering.defaultPrepareFn = function(geometryInstance) {
            var drawParameters = TurbulenzEngine.getGraphicsDevice().createDrawParameters();
            drawParameters.userData = {};
            geometryInstance.drawParameters = [drawParameters];
            geometryInstance.prepareDrawParameters(drawParameters);
            var sharedMaterial = geometryInstance.sharedMaterial;
            var techniqueParameters = geometryInstance.techniqueParameters;
            if (!sharedMaterial.techniqueParameters.materialColor && !techniqueParameters.materialColor) {
                sharedMaterial.techniqueParameters.materialColor = DefaultRendering.v4One
            }
            if (!sharedMaterial.techniqueParameters.uvTransform && !techniqueParameters.uvTransform) {
                sharedMaterial.techniqueParameters.uvTransform = DefaultRendering.identityUVTransform
            }
            drawParameters.technique = this.technique;
            drawParameters.setTechniqueParameters(0, sharedMaterial.techniqueParameters);
            drawParameters.setTechniqueParameters(1, techniqueParameters);
            if (sharedMaterial.meta.decal) {
                drawParameters.userData.passIndex = DefaultRendering.passIndex.decal
            } else if (sharedMaterial.meta.transparent) {
                drawParameters.userData.passIndex = DefaultRendering.passIndex.transparent
            } else {
                drawParameters.userData.passIndex = DefaultRendering.passIndex.opaque
            }
            var node = geometryInstance.node;
            if (!node.rendererInfo) {
                var md = TurbulenzEngine.getMathDevice();
                node.rendererInfo = {
                    id: DefaultRendering.nextRenderinfoID,
                    frameVisible: -1,
                    worldUpdate: -1,
                    worldViewProjection: md.m44BuildIdentity(),
                    worldInverse: md.m43BuildIdentity(),
                    eyePosition: md.v3BuildZero(),
                    lightPosition: md.v3BuildZero()
                };
                DefaultRendering.nextRenderinfoID += 1
            }
            var rendererInfo = node.rendererInfo;
            techniqueParameters.worldViewProjection = rendererInfo.worldViewProjection;
            techniqueParameters.lightPosition = rendererInfo.lightPosition;
            var techniqueName = this.technique.name;
            if (techniqueName.indexOf("flat") === -1 && techniqueName.indexOf("lambert") === -1) {
                techniqueParameters.eyePosition = rendererInfo.eyePosition
            }
            var skinController = geometryInstance.skinController;
            if (skinController) {
                techniqueParameters.skinBones = skinController.output;
                if (skinController.index === undefined) {
                    skinController.index = DefaultRendering.nextSkinID;
                    DefaultRendering.nextSkinID += 1
                }
                drawParameters.sortKey = -renderingCommonSortKeyFn(this.techniqueIndex, skinController.index, sharedMaterial.meta.materialIndex)
            } else {
                drawParameters.sortKey = renderingCommonSortKeyFn(this.techniqueIndex, sharedMaterial.meta.materialIndex, rendererInfo.id)
            }
            geometryInstance.renderUpdate = this.update
        };
        DefaultRendering.create = function(gd, md, shaderManager, effectsManager) {
            var dr = new DefaultRendering;
            dr.md = md;
            dr.sm = shaderManager;
            dr.lightPositionUpdated = true;
            dr.lightPosition = md.v3Build(1e3, 1e3, 0);
            dr.eyePositionUpdated = true;
            dr.eyePosition = md.v3BuildZero();
            dr.globalTechniqueParameters = gd.createTechniqueParameters({
                lightColor: md.v3BuildOne(),
                ambientColor: md.v3Build(.2, .2, .3),
                time: 0
            });
            dr.globalTechniqueParametersArray = [dr.globalTechniqueParameters];
            dr.passes = [
                [],
                [],
                []
            ];
            var onShaderLoaded = function onShaderLoadedFn(shader) {
                var skinBones = shader.getParameter("skinBones");
                dr.defaultSkinBufferSize = skinBones.rows * skinBones.columns
            };
            shaderManager.load("shaders/defaultrendering.cgfx", onShaderLoaded);
            shaderManager.load("shaders/debug.cgfx");
            var updateNodeRendererInfo = function updateNodeRendererInfoFn(node, rendererInfo, camera) {
                var lightPositionUpdated = dr.lightPositionUpdated;
                var eyePositionUpdated = dr.eyePositionUpdated;
                var matrix = node.world;
                if (rendererInfo.worldUpdate !== node.worldUpdate) {
                    rendererInfo.worldUpdate = node.worldUpdate;
                    lightPositionUpdated = true;
                    eyePositionUpdated = true;
                    rendererInfo.worldInverse = md.m43Inverse(matrix, rendererInfo.worldInverse)
                }
                if (lightPositionUpdated) {
                    rendererInfo.lightPosition = md.m43TransformPoint(rendererInfo.worldInverse, dr.lightPosition, rendererInfo.lightPosition)
                }
                if (eyePositionUpdated) {
                    rendererInfo.eyePosition = md.m43TransformPoint(rendererInfo.worldInverse, dr.eyePosition, rendererInfo.eyePosition)
                }
                rendererInfo.worldViewProjection = md.m43MulM44(matrix, camera.viewProjectionMatrix, rendererInfo.worldViewProjection)
            };
            var defaultUpdate = function defaultUpdateFn(camera) {
                var node = this.node;
                var rendererInfo = node.rendererInfo;
                if (rendererInfo.frameVisible !== node.frameVisible) {
                    rendererInfo.frameVisible = node.frameVisible;
                    updateNodeRendererInfo(node, rendererInfo, camera)
                }
            };
            var defaultSkinnedUpdate = function defaultSkinnedUpdateFn(camera) {
                var node = this.node;
                var rendererInfo = node.rendererInfo;
                if (rendererInfo.frameVisible !== node.frameVisible) {
                    rendererInfo.frameVisible = node.frameVisible;
                    updateNodeRendererInfo(node, rendererInfo, camera)
                }
                var skinController = this.skinController;
                if (skinController) {
                    skinController.update()
                }
            };
            var debugUpdate = function debugUpdateFn(camera) {
                var matrix = this.node.world;
                var tp = this.techniqueParameters;
                tp.worldViewProjection = md.m43MulM44(matrix, camera.viewProjectionMatrix, tp.worldViewProjection);
                tp.worldInverseTranspose = md.m33InverseTranspose(matrix, tp.worldInverseTranspose)
            };
            var debugSkinnedUpdate = function debugSkinnedUpdateFn(camera) {
                var matrix = this.node.world;
                var tp = this.techniqueParameters;
                tp.worldViewProjection = md.m43MulM44(matrix, camera.viewProjectionMatrix, tp.worldViewProjection);
                tp.worldInverseTranspose = md.m33InverseTranspose(matrix, tp.worldInverseTranspose);
                var skinController = this.skinController;
                if (skinController) {
                    skinController.update()
                }
            };
            var defaultEnvUpdate = function defaultEnvUpdateFn(camera) {
                var node = this.node;
                var rendererInfo = node.rendererInfo;
                if (rendererInfo.frameVisible !== node.frameVisible) {
                    rendererInfo.frameVisible = node.frameVisible;
                    updateNodeRendererInfo(node, rendererInfo, camera)
                }
                if (rendererInfo.worldUpdateEnv !== node.worldUpdate) {
                    rendererInfo.worldUpdateEnv = node.worldUpdate;
                    var matrix = node.world;
                    rendererInfo.worldInverseTranspose = md.m33InverseTranspose(matrix, rendererInfo.worldInverseTranspose)
                }
                var techniqueParameters = this.techniqueParameters;
                techniqueParameters.worldInverseTranspose = rendererInfo.worldInverseTranspose
            };
            var defaultEnvSkinnedUpdate = function defaultEnvSkinnedUpdateFn(camera) {
                defaultEnvUpdate.call(this, camera);
                var skinController = this.skinController;
                if (skinController) {
                    skinController.update()
                }
            };
            var debugLinesPrepare = function debugLinesPrepareFn(geometryInstance) {
                DefaultRendering.defaultPrepareFn.call(this, geometryInstance);
                var techniqueParameters = geometryInstance.techniqueParameters;
                techniqueParameters.constantColor = geometryInstance.sharedMaterial.meta.constantColor
            };
            var defaultPrepare = function defaultPrepareFn(geometryInstance) {
                DefaultRendering.defaultPrepareFn.call(this, geometryInstance);
                var techniqueParameters = geometryInstance.sharedMaterial.techniqueParameters;
                var diffuse = techniqueParameters.diffuse;
                if (diffuse === undefined) {
                    if (!techniqueParameters.materialColor) {
                        techniqueParameters.materialColor = md.v4BuildOne()
                    }
                } else if (diffuse.length === 4) {
                    techniqueParameters.materialColor = md.v4Build.apply(md, diffuse);
                    diffuse = techniqueParameters.diffuse_map;
                    techniqueParameters.diffuse = diffuse
                }
                if (!diffuse) {
                    var shader = shaderManager.get("shaders/defaultrendering.cgfx");
                    if (geometryInstance.geometryType === "skinned") {
                        geometryInstance.drawParameters[0].technique = shader.getTechnique("flat_skinned")
                    } else {
                        geometryInstance.drawParameters[0].technique = shader.getTechnique("flat")
                    }
                }
            };
            var noDiffusePrepare = function noDiffusePrepareFn(geometryInstance) {
                DefaultRendering.defaultPrepareFn.call(this, geometryInstance);
                var techniqueParameters = geometryInstance.sharedMaterial.techniqueParameters;
                var diffuse = techniqueParameters.diffuse;
                if (diffuse === undefined) {
                    if (!techniqueParameters.materialColor) {
                        techniqueParameters.materialColor = md.v4BuildOne()
                    }
                } else if (diffuse.length === 4) {
                    techniqueParameters.materialColor = md.v4Build.apply(md, diffuse);
                    techniqueParameters.diffuse = undefined
                }
            };
            var loadTechniques = function loadTechniquesFn(shaderManager) {
                var that = this;
                var callback = function shaderLoadedCallbackFn(shader) {
                    that.shader = shader;
                    that.technique = shader.getTechnique(that.techniqueName);
                    that.techniqueIndex = that.technique.id
                };
                shaderManager.load(this.shaderName, callback)
            };
            dr.defaultPrepareFn = defaultPrepare;
            dr.defaultUpdateFn = defaultUpdate;
            dr.defaultSkinnedUpdateFn = defaultSkinnedUpdate;
            dr.loadTechniquesFn = loadTechniques;
            var effect;
            var effectTypeData;
            var skinned = "skinned";
            var rigid = "rigid";
            effect = Effect.create("constant");
            effectsManager.add(effect);
            effectTypeData = {
                prepare: noDiffusePrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "flat",
                update: defaultUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(rigid, effectTypeData);
            effectTypeData = {
                prepare: noDiffusePrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "flat_skinned",
                update: defaultSkinnedUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(skinned, effectTypeData);
            effect = Effect.create("constant_nocull");
            effectsManager.add(effect);
            effectTypeData = {
                prepare: noDiffusePrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "flat_nocull",
                update: defaultUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(rigid, effectTypeData);
            effectTypeData = {
                prepare: noDiffusePrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "flat_skinned_nocull",
                update: defaultSkinnedUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(skinned, effectTypeData);
            effect = Effect.create("lambert");
            effectsManager.add(effect);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "lambert",
                update: defaultUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(rigid, effectTypeData);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "lambert_skinned",
                update: defaultSkinnedUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(skinned, effectTypeData);
            effect = Effect.create("blinn");
            effectsManager.add(effect);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "blinn",
                update: defaultUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(rigid, effectTypeData);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "blinn_skinned",
                update: defaultSkinnedUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(skinned, effectTypeData);
            effect = Effect.create("blinn_nocull");
            effectsManager.add(effect);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "blinn_nocull",
                update: defaultUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(rigid, effectTypeData);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "blinn_skinned_nocull",
                update: defaultSkinnedUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(skinned, effectTypeData);
            effect = Effect.create("phong");
            effectsManager.add(effect);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "phong",
                update: defaultUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(rigid, effectTypeData);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "phong_skinned",
                update: defaultSkinnedUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(skinned, effectTypeData);
            effect = Effect.create("debug_lines_constant");
            effectsManager.add(effect);
            effectTypeData = {
                prepare: debugLinesPrepare,
                shaderName: "shaders/debug.cgfx",
                techniqueName: "debug_lines_constant",
                update: debugUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(rigid, effectTypeData);
            effect = Effect.create("debug_normals");
            effectsManager.add(effect);
            effectTypeData = {
                prepare: DefaultRendering.defaultPrepareFn,
                shaderName: "shaders/debug.cgfx",
                techniqueName: "debug_normals",
                update: debugUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(rigid, effectTypeData);
            effectTypeData = {
                prepare: DefaultRendering.defaultPrepareFn,
                shaderName: "shaders/debug.cgfx",
                techniqueName: "debug_normals_skinned",
                update: debugSkinnedUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(skinned, effectTypeData);
            effect = Effect.create("debug_tangents");
            effectsManager.add(effect);
            effectTypeData = {
                prepare: DefaultRendering.defaultPrepareFn,
                shaderName: "shaders/debug.cgfx",
                techniqueName: "debug_tangents",
                update: debugUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(rigid, effectTypeData);
            effectTypeData = {
                prepare: DefaultRendering.defaultPrepareFn,
                shaderName: "shaders/debug.cgfx",
                techniqueName: "debug_tangents_skinned",
                update: debugSkinnedUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(skinned, effectTypeData);
            effect = Effect.create("debug_binormals");
            effectsManager.add(effect);
            effectTypeData = {
                prepare: DefaultRendering.defaultPrepareFn,
                shaderName: "shaders/debug.cgfx",
                techniqueName: "debug_binormals",
                update: debugUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(rigid, effectTypeData);
            effectTypeData = {
                prepare: DefaultRendering.defaultPrepareFn,
                shaderName: "shaders/debug.cgfx",
                techniqueName: "debug_binormals_skinned",
                update: debugSkinnedUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(skinned, effectTypeData);
            effect = Effect.create("normalmap");
            effectsManager.add(effect);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "normalmap",
                update: defaultUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(rigid, effectTypeData);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "normalmap_skinned",
                update: defaultSkinnedUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(skinned, effectTypeData);
            effect = Effect.create("normalmap_specularmap");
            effectsManager.add(effect);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "normalmap_specularmap",
                update: defaultUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(rigid, effectTypeData);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "normalmap_specularmap_skinned",
                update: defaultSkinnedUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(skinned, effectTypeData);
            effect = Effect.create("normalmap_specularmap_alphamap");
            effectsManager.add(effect);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "normalmap_specularmap_alphamap",
                update: defaultUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(rigid, effectTypeData);
            effect = Effect.create("normalmap_alphatest");
            effectsManager.add(effect);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "normalmap_alphatest",
                update: defaultUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(rigid, effectTypeData);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "normalmap_alphatest_skinned",
                update: defaultSkinnedUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(skinned, effectTypeData);
            effect = Effect.create("normalmap_specularmap_alphatest");
            effectsManager.add(effect);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "normalmap_specularmap_alphatest",
                update: defaultUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(rigid, effectTypeData);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "normalmap_specularmap_alphatest_skinned",
                update: defaultSkinnedUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(skinned, effectTypeData);
            effect = Effect.create("normalmap_glowmap");
            effectsManager.add(effect);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "normalmap_glowmap",
                update: defaultUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(rigid, effectTypeData);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "normalmap_glowmap_skinned",
                update: defaultSkinnedUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(skinned, effectTypeData);
            effect = Effect.create("normalmap_specularmap_glowmap");
            effectsManager.add(effect);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "normalmap_specularmap_glowmap",
                update: defaultUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(rigid, effectTypeData);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "normalmap_specularmap_glowmap_skinned",
                update: defaultSkinnedUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(skinned, effectTypeData);
            effect = Effect.create("rxgb_normalmap");
            effectsManager.add(effect);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "rxgb_normalmap",
                update: defaultUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(rigid, effectTypeData);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "rxgb_normalmap_skinned",
                update: defaultSkinnedUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(skinned, effectTypeData);
            effect = Effect.create("rxgb_normalmap_specularmap");
            effectsManager.add(effect);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "rxgb_normalmap_specularmap",
                update: defaultUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(rigid, effectTypeData);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "rxgb_normalmap_specularmap_skinned",
                update: defaultSkinnedUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(skinned, effectTypeData);
            effect = Effect.create("rxgb_normalmap_alphatest");
            effectsManager.add(effect);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "rxgb_normalmap_alphatest",
                update: defaultUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(rigid, effectTypeData);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "rxgb_normalmap_alphatest_skinned",
                update: defaultSkinnedUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(skinned, effectTypeData);
            effect = Effect.create("rxgb_normalmap_specularmap_alphatest");
            effectsManager.add(effect);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "rxgb_normalmap_specularmap_alphatest",
                update: defaultUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(rigid, effectTypeData);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "rxgb_normalmap_specularmap_alphatest_skinned",
                update: defaultSkinnedUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(skinned, effectTypeData);
            effect = Effect.create("rxgb_normalmap_glowmap");
            effectsManager.add(effect);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "rxgb_normalmap_glowmap",
                update: defaultUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(rigid, effectTypeData);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "rxgb_normalmap_glowmap_skinned",
                update: defaultSkinnedUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(skinned, effectTypeData);
            effect = Effect.create("rxgb_normalmap_specularmap_glowmap");
            effectsManager.add(effect);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "rxgb_normalmap_specularmap_glowmap",
                update: defaultUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(rigid, effectTypeData);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "rxgb_normalmap_specularmap_glowmap_skinned",
                update: defaultSkinnedUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(skinned, effectTypeData);
            effect = Effect.create("add");
            effectsManager.add(effect);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "add",
                update: defaultUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(rigid, effectTypeData);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "add_skinned",
                update: defaultSkinnedUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(skinned, effectTypeData);
            effect = Effect.create("add_particle");
            effectsManager.add(effect);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "add_particle",
                update: defaultUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(rigid, effectTypeData);
            effect = Effect.create("blend");
            effectsManager.add(effect);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "blend",
                update: defaultUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(rigid, effectTypeData);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "blend_skinned",
                update: defaultSkinnedUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(skinned, effectTypeData);
            effect = Effect.create("blend_particle");
            effectsManager.add(effect);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "blend_particle",
                update: defaultUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(rigid, effectTypeData);
            effect = Effect.create("translucent");
            effectsManager.add(effect);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "translucent",
                update: defaultUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(rigid, effectTypeData);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "translucent_skinned",
                update: defaultSkinnedUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(skinned, effectTypeData);
            effect = Effect.create("translucent_particle");
            effectsManager.add(effect);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "translucent_particle",
                update: defaultUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(rigid, effectTypeData);
            effect = Effect.create("filter");
            effectsManager.add(effect);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "filter",
                update: defaultUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(rigid, effectTypeData);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "filter_skinned",
                update: defaultSkinnedUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(skinned, effectTypeData);
            effect = Effect.create("invfilter");
            effectsManager.add(effect);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "invfilter",
                update: defaultUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(rigid, effectTypeData);
            effect = Effect.create("invfilter_particle");
            effectsManager.add(effect);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "invfilter_particle",
                update: defaultUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(rigid, effectTypeData);
            effect = Effect.create("glass");
            effectsManager.add(effect);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "glass",
                update: defaultUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(rigid, effectTypeData);
            effect = Effect.create("glass_env");
            effectsManager.add(effect);
            effectTypeData = {
                prepare: noDiffusePrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "glass_env",
                update: defaultEnvUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(rigid, effectTypeData);
            effect = Effect.create("modulate2");
            effectsManager.add(effect);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "modulate2",
                update: defaultUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(rigid, effectTypeData);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "modulate2_skinned",
                update: defaultSkinnedUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(skinned, effectTypeData);
            effect = Effect.create("skybox");
            effectsManager.add(effect);
            effectTypeData = {
                prepare: noDiffusePrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "skybox",
                update: defaultEnvUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(rigid, effectTypeData);
            effect = Effect.create("env");
            effectsManager.add(effect);
            effectTypeData = {
                prepare: noDiffusePrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "env",
                update: defaultEnvUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(rigid, effectTypeData);
            effectTypeData = {
                prepare: noDiffusePrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "env_skinned",
                update: defaultEnvSkinnedUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(skinned, effectTypeData);
            effect = Effect.create("flare");
            effectsManager.add(effect);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "add",
                update: defaultUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(rigid, effectTypeData);
            effectsManager.map("default", "blinn");
            effect = Effect.create("glowmap");
            effectsManager.add(effect);
            effectTypeData = {
                prepare: noDiffusePrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "glowmap",
                update: defaultUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(rigid, effectTypeData);
            effectTypeData = {
                prepare: noDiffusePrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "glowmap_skinned",
                update: defaultSkinnedUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(skinned, effectTypeData);
            effect = Effect.create("lightmap");
            effectsManager.add(effect);
            effectTypeData = {
                prepare: defaultPrepare,
                shaderName: "shaders/defaultrendering.cgfx",
                techniqueName: "lightmap",
                update: defaultUpdate,
                loadTechniques: loadTechniques
            };
            effectTypeData.loadTechniques(shaderManager);
            effect.add(rigid, effectTypeData);
            return dr
        };
        DefaultRendering.version = 1;
        DefaultRendering.numPasses = 3;
        DefaultRendering.passIndex = {
            opaque: 0,
            decal: 1,
            transparent: 2
        };
        DefaultRendering.nextRenderinfoID = 0;
        DefaultRendering.nextSkinID = 0;
        DefaultRendering.v4One = new Float32Array([1, 1, 1, 1]);
        DefaultRendering.identityUVTransform = new Float32Array([1, 0, 0, 1, 0, 0]);
        return DefaultRendering
    }();
    var RequestHandler = function() {
        function RequestHandler() {
            this.reasonConnectionLost = 0;
            this.reasonServiceBusy = 1
        }
        RequestHandler.prototype.retryExponential = function(callContext, requestFn, status) {
            if (!this.notifiedConnectionLost && TurbulenzEngine.time - this.connectionLostTime > this.notifyTime * .001) {
                this.notifiedConnectionLost = true;
                var reason;
                if (status === 0) {
                    reason = this.reasonConnectionLost
                } else {
                    reason = this.reasonServiceBusy
                }
                callContext.reason = reason;
                this.onRequestTimeout(reason, callContext)
            }
            if (this.connected) {
                this.connectionLostTime = TurbulenzEngine.time;
                this.notifiedConnectionLost = false;
                this.connected = false;
                this.reconnectTest = callContext;
                callContext.status = status
            } else if (this.reconnectTest !== callContext) {
                var reconnectedObserver = this.reconnectedObserver;
                var onReconnected = function onReconnectedFn() {
                    reconnectedObserver.unsubscribe(onReconnected);
                    requestFn()
                };
                reconnectedObserver.subscribe(onReconnected);
                return
            }
            if (callContext.expTime) {
                callContext.expTime = 2 * callContext.expTime;
                if (callContext.expTime > this.maxRetryTime) {
                    callContext.expTime = this.maxRetryTime
                }
            } else {
                callContext.expTime = this.initialRetryTime
            }
            if (callContext.retries) {
                callContext.retries += 1
            } else {
                callContext.retries = 1
            }
            TurbulenzEngine.setTimeout(requestFn, callContext.expTime)
        };
        RequestHandler.prototype.retryAfter = function(callContext, retryAfter, requestFn, status) {
            if (callContext.retries) {
                callContext.retries += 1
            } else {
                callContext.firstRetry = TurbulenzEngine.time;
                callContext.retries = 1
            }
            if (!callContext.notifiedMaxRetries && TurbulenzEngine.time - callContext.firstRetry + retryAfter > this.notifyTime) {
                callContext.notifiedMaxRetries = true;
                var reason = this.reasonServiceBusy;
                callContext.reason = reason;
                this.onRequestTimeout(reason, callContext)
            }
            TurbulenzEngine.setTimeout(requestFn, retryAfter * 1e3)
        };
        RequestHandler.prototype.request = function(callContext) {
            var makeRequest;
            var that = this;
            var responseCallback = function responseCallbackFn(responseAsset, status) {
                if (that.destroyed) {
                    return
                }
                var sendEventToHandlers = that.sendEventToHandlers;
                var handlers = that.handlers;
                if (status === 0 || status === 408 || status === 429 || status === 480 || status === 504) {
                    that.retryExponential(callContext, makeRequest, status);
                    return
                }
                if (!that.connected) {
                    that.connected = true;
                    if (that.reconnectTest === callContext && that.notifiedConnectionLost) {
                        that.onReconnected(that.reconnectTest.reason, that.reconnectTest)
                    }
                    that.reconnectTest = null;
                    that.reconnectedObserver.notify()
                }
                if (callContext.responseFilter && !callContext.responseFilter.call(this, callContext, makeRequest, responseAsset, status)) {
                    return
                }
                if (that.responseFilter && !that.responseFilter(callContext, makeRequest, responseAsset, status)) {
                    return
                }
                if (callContext.onload) {
                    var nameStr;
                    if (responseAsset && responseAsset.name) {
                        nameStr = responseAsset.name
                    } else {
                        nameStr = callContext.src
                    }
                    sendEventToHandlers(handlers.eventOnload, {
                        eventType: "eventOnload",
                        name: nameStr
                    });
                    callContext.onload(responseAsset, status, callContext);
                    callContext.onload = null
                }
                callContext = null
            };
            makeRequest = function makeRequestFn() {
                if (that.destroyed) {
                    return
                }
                if (callContext.requestFn) {
                    if (callContext.requestOwner) {
                        callContext.requestFn.call(callContext.requestOwner, callContext.src, responseCallback, callContext)
                    } else {
                        callContext.requestFn(callContext.src, responseCallback, callContext)
                    }
                } else if (callContext.requestOwner) {
                    callContext.requestOwner.request(callContext.src, responseCallback, callContext)
                } else {
                    TurbulenzEngine.request(callContext.src, responseCallback)
                }
            };
            makeRequest()
        };
        RequestHandler.prototype.addEventListener = function(eventType, eventListener) {
            var i;
            var length;
            var eventHandlers;
            if (this.handlers.hasOwnProperty(eventType)) {
                eventHandlers = this.handlers[eventType];
                if (eventListener) {
                    length = eventHandlers.length;
                    for (i = 0; i < length; i += 1) {
                        if (eventHandlers[i] === eventListener) {
                            return
                        }
                    }
                    eventHandlers.push(eventListener)
                }
            }
        };
        RequestHandler.prototype.removeEventListener = function(eventType, eventListener) {
            var i;
            var length;
            var eventHandlers;
            if (this.handlers.hasOwnProperty(eventType)) {
                eventHandlers = this.handlers[eventType];
                if (eventListener) {
                    length = eventHandlers.length;
                    for (i = 0; i < length; i += 1) {
                        if (eventHandlers[i] === eventListener) {
                            eventHandlers.splice(i, 1);
                            break
                        }
                    }
                }
            }
        };
        RequestHandler.prototype.sendEventToHandlers = function(eventHandlers, arg0) {
            var i;
            var length = eventHandlers.length;
            if (length) {
                for (i = 0; i < length; i += 1) {
                    eventHandlers[i](arg0)
                }
            }
        };
        RequestHandler.prototype.destroy = function() {
            this.destroyed = true;
            this.handlers = null;
            this.onReconnected = null;
            this.onRequestTimeout = null
        };
        RequestHandler.create = function(params) {
            var rh = new RequestHandler;
            rh.initialRetryTime = params.initialRetryTime || .5 * 1e3;
            rh.notifyTime = params.notifyTime || 4 * 1e3;
            rh.maxRetryTime = params.maxRetryTime || 8 * 1e3;
            rh.notifiedConnectionLost = false;
            rh.connected = true;
            rh.reconnectedObserver = Observer.create();
            rh.reconnectTest = null;
            rh.onReconnected = params.onReconnected || function onReconnectedFn() {};
            rh.onRequestTimeout = params.onRequestTimeout || function onRequestTimeoutFn() {};
            var handlers = {
                eventOnload: []
            };
            rh.handlers = handlers;
            return rh
        };
        return RequestHandler
    }();
    var ResourceLoader = function() {
        function ResourceLoader() {}
        ResourceLoader.prototype.clear = function() {
            this.nodesMap = {};
            this.referencesPending = {};
            this.numReferencesPending = 0;
            this.animationsPending = {}
        };
        ResourceLoader.prototype.endLoading = function(onload) {
            this.referencesPending = {};
            this.animationsPending = {};
            if (onload) {
                onload(this.data)
            }
        };
        ResourceLoader.prototype.resolveShapes = function(loadParams) {
            var copyObject = function copyObjectFn(o) {
                var newObj = {};
                for (var p in o) {
                    if (o.hasOwnProperty(p)) {
                        newObj[p] = o[p]
                    }
                }
                return newObj
            };
            var shapesNamePrefix = loadParams.shapesNamePrefix;
            var skeletonNamePrefix = loadParams.shapesNamePrefix;
            var sceneData = loadParams.data;
            var fileShapes = sceneData.geometries;
            var targetShapes = this.data.geometries;
            if (!targetShapes) {
                targetShapes = {};
                this.data.geometries = targetShapes
            }
            for (var fileShapeName in fileShapes) {
                if (fileShapes.hasOwnProperty(fileShapeName)) {
                    var fileShape = fileShapes[fileShapeName];
                    var targetShapeName = shapesNamePrefix ? shapesNamePrefix + "-" + fileShapeName : fileShapeName;
                    var fileSkeletonName = fileShape.skeleton;
                    if (fileSkeletonName) {
                        targetShapes[targetShapeName] = copyObject(fileShape);
                        targetShapes[targetShapeName].skeleton = skeletonNamePrefix ? skeletonNamePrefix + "-" + fileSkeletonName : fileSkeletonName
                    } else {
                        targetShapes[targetShapeName] = fileShape
                    }
                }
            }
        };
        ResourceLoader.prototype.resolveSkeletons = function(loadParams) {
            var skeletonNamePrefix = loadParams.shapesNamePrefix;
            var sceneData = loadParams.data;
            var fileSkeletons = sceneData.skeletons;
            var targetSkeletons = this.data.skeletons;
            if (!targetSkeletons) {
                targetSkeletons = {};
                this.data.skeletons = targetSkeletons
            }
            for (var fileSkeletonName in fileSkeletons) {
                if (fileSkeletons.hasOwnProperty(fileSkeletonName)) {
                    var fileSkeleton = fileSkeletons[fileSkeletonName];
                    var targetSkeletonName = skeletonNamePrefix ? skeletonNamePrefix + "-" + fileSkeletonName : fileSkeletonName;
                    targetSkeletons[targetSkeletonName] = fileSkeleton
                }
            }
        };
        ResourceLoader.prototype.resolveAnimations = function(loadParams) {
            var sceneData = loadParams.data;
            var fileAnims = sceneData.animations;
            if (!fileAnims) {
                return
            }
            var currentLoader = this;
            var anims = currentLoader.data.animations;
            if (!anims) {
                anims = {};
                currentLoader.data.animations = anims
            }
            var postLoadReference = function postLoadReferenceFn(sceneText) {
                if (sceneText) {
                    var sceneData = JSON.parse(sceneText);
                    var animations = sceneData.animations;
                    for (var anim in animations) {
                        if (animations.hasOwnProperty(anim)) {
                            anims[anim] = animations[anim]
                        }
                    }
                }
                currentLoader.numReferencesPending -= 1;
                if (currentLoader.numReferencesPending <= 0) {
                    currentLoader.endLoading(loadParams.onload)
                }
            };
            var requestOwner = loadParams.request ? loadParams : TurbulenzEngine;
            for (var a in fileAnims) {
                if (fileAnims.hasOwnProperty(a)) {
                    var reference = fileAnims[a].reference;
                    if (reference) {
                        if (!this.animationsPending[a]) {
                            this.animationsPending[a] = true;
                            this.numReferencesPending += 1;
                            delete fileAnims[a].reference;
                            loadParams.requestHandler.request({
                                src: reference,
                                requestOwner: requestOwner,
                                onload: postLoadReference
                            })
                        }
                    } else {
                        anims[a] = fileAnims[a]
                    }
                }
            }
        };
        ResourceLoader.prototype.resolveNodes = function(loadParams) {
            var sceneData = loadParams.data;
            var references = this.referencesPending;
            var numReferences = 0;
            var nodesMap = this.nodesMap;
            var currentLoader = this;
            var nodesNamePrefix = loadParams.nodesNamePrefix;
            var shapesNamePrefix = loadParams.shapesNamePrefix;
            var requestOwner = loadParams.request ? loadParams : TurbulenzEngine;
            var copyObject = function copyObjectFn(o) {
                var newObj = {};
                for (var p in o) {
                    if (o.hasOwnProperty(p)) {
                        newObj[p] = o[p]
                    }
                }
                return newObj
            };
            var resolveNode = function resolveNodeFn(fileNode, nodeName, parentNodePath) {
                var node = copyObject(fileNode);
                var nodePath = parentNodePath ? parentNodePath + "/" + nodeName : nodeName;
                var reference = node.reference;
                if (reference) {
                    var internalReferenceIndex = reference.indexOf("#");
                    if (internalReferenceIndex === -1) {
                        var referenceParameters = references[reference];
                        if (!referenceParameters || referenceParameters.length === 0 || !node.inplace) {
                            numReferences += 1;
                            var sceneParameters = copyObject(loadParams);
                            sceneParameters.append = true;
                            if (node.inplace) {
                                sceneParameters.nodesNamePrefix = parentNodePath;
                                sceneParameters.shapesNamePrefix = null;
                                sceneParameters.parentNode = null
                            } else {
                                sceneParameters.nodesNamePrefix = nodePath;
                                sceneParameters.shapesNamePrefix = reference;
                                sceneParameters.parentNode = node
                            }
                            if (node.skin) {
                                sceneParameters.skin = node.skin
                            }
                            if (!referenceParameters || referenceParameters.length === 0) {
                                referenceParameters = [sceneParameters];
                                references[reference] = referenceParameters;
                                var loadReference = function(sceneText) {
                                    var numInstances = referenceParameters.length;
                                    var sceneData;
                                    if (sceneText) {
                                        sceneData = JSON.parse(sceneText)
                                    } else {
                                        sceneData = {}
                                    }
                                    var params;
                                    for (var n = 0; n < numInstances; n += 1) {
                                        params = referenceParameters[n];
                                        params.data = sceneData;
                                        params.isReference = true;
                                        currentLoader.resolve(params)
                                    }
                                    referenceParameters.length = 0
                                };
                                loadParams.requestHandler.request({
                                    src: reference,
                                    requestOwner: requestOwner,
                                    onload: loadReference
                                })
                            } else {
                                referenceParameters.push(sceneParameters)
                            }
                        }
                    }
                    delete node.reference;
                    delete node.inplace
                }
                var geometryinstances = node.geometryinstances;
                if (shapesNamePrefix && geometryinstances) {
                    node.geometryinstances = {};
                    for (var gi in geometryinstances) {
                        if (geometryinstances.hasOwnProperty(gi)) {
                            node.geometryinstances[gi] = copyObject(geometryinstances[gi]);
                            var geometryInstance = node.geometryinstances[gi];
                            geometryInstance.geometry = shapesNamePrefix + "-" + geometryInstance.geometry
                        }
                    }
                }
                var fileChildren = fileNode.nodes;
                if (fileChildren) {
                    node.nodes = {};
                    for (var c in fileChildren) {
                        if (fileChildren.hasOwnProperty(c)) {
                            var childPath = nodePath + "/" + c;
                            if (!nodesMap[childPath]) {
                                node.nodes[c] = resolveNode(fileChildren[c], c, nodePath);
                                nodesMap[childPath] = node.nodes[c]
                            }
                        }
                    }
                }
                return node
            };
            var fileNodes = sceneData.nodes;
            var parentNode = loadParams.parentNode;
            for (var fn in fileNodes) {
                if (fileNodes.hasOwnProperty(fn) && fileNodes[fn]) {
                    var nodeName = fn;
                    var fileNode = resolveNode(fileNodes[fn], nodeName, nodesNamePrefix);
                    var nodePath = nodesNamePrefix ? nodesNamePrefix + "/" + fn : fn;
                    var overloadedNode = nodesMap[nodePath];
                    if (overloadedNode) {
                        var overloadedMatrix = overloadedNode.matrix;
                        if (overloadedMatrix && fileNode.matrix) {
                            overloadedNode.matrix = VMath.m43Mul(fileNode.matrix, overloadedMatrix);
                            overloadedMatrix = null
                        }
                        var overloadedChildren = overloadedNode.nodes;
                        if (overloadedChildren && fileNode.nodes) {
                            for (var c in fileNode.nodes) {
                                if (fileNode.nodes.hasOwnProperty(c)) {
                                    overloadedChildren[c] = fileNode.nodes[c]
                                }
                            }
                        } else if (fileNode.nodes) {
                            overloadedNode.nodes = fileNode.nodes
                        }
                        for (var on in fileNode) {
                            if (fileNode.hasOwnProperty(on)) {
                                overloadedNode[on] = fileNode[on]
                            }
                        }
                        fileNode = overloadedNode
                    } else {
                        if (loadParams.isReference && parentNode) {
                            if (!parentNode.nodes) {
                                parentNode.nodes = {}
                            }
                            parentNode.nodes[fn] = fileNode
                        } else {
                            this.data.nodes[fn] = fileNode
                        }
                        nodesMap[nodePath] = fileNode
                    }
                }
            }
            this.numReferencesPending += numReferences
        };
        ResourceLoader.prototype.resolvePhysicsNodes = function(loadParams) {
            var sceneData = loadParams.data;
            var nodesNamePrefix = loadParams.nodesNamePrefix;
            var shapesNamePrefix = loadParams.shapesNamePrefix;

            function begetFn(o) {
                var F = function() {};
                F.prototype = o;
                return new F
            }
            var fileModels = sceneData.physicsmodels;
            var targetFileModels = this.data.physicsmodels;
            if (!targetFileModels) {
                targetFileModels = {};
                this.data.physicsmodels = targetFileModels
            }
            for (var fm in fileModels) {
                if (fileModels.hasOwnProperty(fm)) {
                    var fileModel = fileModels[fm];
                    if (shapesNamePrefix) {
                        var newModelName = shapesNamePrefix ? shapesNamePrefix + "-" + fm : fm;
                        var model = begetFn(fileModel);
                        targetFileModels[newModelName] = model;
                        var geometry = model.geometry;
                        if (geometry) {
                            model.geometry = shapesNamePrefix ? shapesNamePrefix + "-" + geometry : geometry
                        }
                    } else {
                        targetFileModels[fm] = fileModel
                    }
                }
            }
            var fileNodes = sceneData.physicsnodes;
            var targetFileNodes = this.data.physicsnodes;
            if (!targetFileNodes) {
                targetFileNodes = {};
                this.data.physicsnodes = targetFileNodes
            }
            for (var fn in fileNodes) {
                if (fileNodes.hasOwnProperty(fn)) {
                    var fileNode = fileNodes[fn];
                    if (nodesNamePrefix || shapesNamePrefix) {
                        var targetName = fileNode.target;
                        targetName = nodesNamePrefix ? nodesNamePrefix + "/" + targetName : targetName;
                        var node = begetFn(fileNode);
                        node.target = targetName;
                        node.body = shapesNamePrefix ? shapesNamePrefix + "-" + fileNode.body : fileNode.body;
                        var newNodeName = nodesNamePrefix ? nodesNamePrefix + "/" + fn : fn;
                        targetFileNodes[newNodeName] = node
                    } else {
                        targetFileNodes[fn] = fileNode
                    }
                }
            }
        };
        ResourceLoader.prototype.resolveAreas = function(loadParams) {
            var sceneData = loadParams.data;
            var fileAreas = sceneData.areas;
            if (!fileAreas) {
                return
            }
            var numFileAreas = fileAreas.length;
            if (numFileAreas <= 0) {
                return
            }
            var targetAreas = this.data.areas;
            if (!targetAreas) {
                targetAreas = [];
                this.data.areas = targetAreas
            }
            var nodesNamePrefix = loadParams.nodesNamePrefix;
            for (var fa = 0; fa < numFileAreas; fa += 1) {
                var fileArea = fileAreas[fa];
                if (nodesNamePrefix) {
                    var targetName = fileArea.target;
                    fileArea.target = nodesNamePrefix + "/" + targetName
                }
                targetAreas.push(fileArea)
            }
        };
        ResourceLoader.prototype.resolve = function(loadParams) {
            if (!loadParams.append) {
                this.data = {
                    nodes: {}
                }
            }
            var appendData = loadParams.data;
            for (var d in appendData) {
                if (d !== "nodes" && d !== "skeletons" && d !== "geometries" && d !== "animations" && d !== "areas" && d !== "physicsnodes" && d !== "physicsmodels") {
                    if (appendData.hasOwnProperty(d)) {
                        var dict = appendData[d];
                        var targetDict = this.data[d];
                        if (!targetDict) {
                            this.data[d] = dict
                        } else {
                            for (var e in dict) {
                                if (dict.hasOwnProperty(e) && !targetDict[e]) {
                                    targetDict[e] = dict[e]
                                }
                            }
                        }
                    }
                }
            }
            this.resolveShapes(loadParams);
            this.resolveSkeletons(loadParams);
            this.resolveAnimations(loadParams);
            this.resolveNodes(loadParams);
            this.resolvePhysicsNodes(loadParams);
            this.resolveAreas(loadParams);
            if (loadParams.isReference) {
                this.numReferencesPending -= 1
            }
            if (this.numReferencesPending <= 0) {
                this.endLoading(loadParams.onload)
            }
        };
        ResourceLoader.prototype.load = function(assetPath, loadParams) {
            var loader = this;
            var dataReceived = function dataReceivedFn(text) {
                var sceneData = {};
                if (text) {
                    sceneData = JSON.parse(text)
                }
                loadParams.data = sceneData;
                loadParams.append = false;
                loader.resolve(loadParams)
            };
            loadParams.requestHandler.request({
                src: assetPath,
                requestOwner: loadParams.request ? loadParams : TurbulenzEngine,
                onload: dataReceived
            })
        };
        ResourceLoader.create = function() {
            var rl = new ResourceLoader;
            rl.clear();
            rl.skeletonNames = {};
            return rl
        };
        ResourceLoader.version = 1;
        return ResourceLoader
    }();
    var VertexBufferManager = function() {
        function VertexBufferManager() {
            this.maxVerticesPerVertexBuffer = 65535;
            this.numBuckets = 10
        }
        VertexBufferManager.prototype.bucket = function(numVertices) {
            if (numVertices <= 64) {
                if (numVertices <= 16) {
                    if (numVertices <= 8) {
                        return 0
                    }
                    return 1
                }
                if (numVertices <= 32) {
                    return 2
                }
                return 3
            }
            if (numVertices <= 512) {
                if (numVertices <= 256) {
                    if (numVertices <= 128) {
                        return 4
                    }
                    return 5
                }
                return 6
            }
            if (numVertices <= 2048) {
                if (numVertices <= 1024) {
                    return 7
                }
                return 8
            }
            return 9
        };
        VertexBufferManager.prototype.makeBuckets = function() {
            var result = [];
            for (var index = 0; index < this.numBuckets; index += 1) {
                result.push({
                    headChunk: null
                })
            }
            return result
        };
        VertexBufferManager.prototype.allocate = function(numVertices, attributes) {
            var vertexbuffer = null;
            var baseIndex = 0;
            var vertexbufferParameters = {
                numVertices: undefined,
                attributes: attributes,
                dynamic: this.dynamicVertexBuffers
            };
            var poolIndex;
            var maxVerticesPerVertexBuffer = this.maxVerticesPerVertexBuffer;
            var attributesHash = "";
            var attributeIndex;
            var attribute;
            for (attributeIndex = 0; attributeIndex < attributes.length; attributeIndex += 1) {
                attribute = attributes[attributeIndex];
                if (attribute.name) {
                    attributesHash += attribute.name
                } else if (typeof attribute === "number") {
                    attributesHash += attribute
                } else {
                    attributesHash += attribute.toString()
                }
                attributesHash += ","
            }
            var numVertexBuffersPools = this.vertexBuffersPools.length;
            var vertexBuffersPool;
            for (poolIndex = 0; poolIndex < numVertexBuffersPools; poolIndex += 1) {
                if (this.vertexBuffersPools[poolIndex].attributesHash === attributesHash) {
                    vertexBuffersPool = this.vertexBuffersPools[poolIndex];
                    break
                }
            }
            if (!vertexBuffersPool) {
                vertexBuffersPool = {
                    attributesHash: attributesHash,
                    vertexBufferData: []
                };
                this.vertexBuffersPools.push(vertexBuffersPool)
            }
            var vertexBufferData;
            if (numVertices < maxVerticesPerVertexBuffer) {
                for (var bucketIndex = this.bucket(numVertices); !vertexbuffer && bucketIndex < this.numBuckets; bucketIndex += 1) {
                    var previousChunk;
                    for (var vertexBufferIndex = 0; !vertexbuffer && vertexBufferIndex < vertexBuffersPool.vertexBufferData.length; vertexBufferIndex += 1) {
                        vertexBufferData = vertexBuffersPool.vertexBufferData[vertexBufferIndex];
                        previousChunk = null;
                        for (var chunk = vertexBufferData.bucket[bucketIndex].headChunk; chunk; chunk = chunk.nextChunk) {
                            if (numVertices <= chunk.length) {
                                vertexbuffer = vertexBufferData.vertexBuffer;
                                baseIndex = chunk.baseIndex;
                                if (numVertices < chunk.length) {
                                    chunk.baseIndex = baseIndex + numVertices;
                                    chunk.length -= numVertices;
                                    var newBucketIndex = this.bucket(chunk.length);
                                    if (newBucketIndex !== bucketIndex) {
                                        if (previousChunk) {
                                            previousChunk.nextChunk = chunk.nextChunk
                                        } else {
                                            vertexBufferData.bucket[bucketIndex].headChunk = chunk.nextChunk
                                        }
                                        chunk.nextChunk = vertexBufferData.bucket[newBucketIndex].headChunk;
                                        vertexBufferData.bucket[newBucketIndex].headChunk = chunk
                                    }
                                } else {
                                    if (previousChunk) {
                                        previousChunk.nextChunk = chunk.nextChunk
                                    } else {
                                        vertexBufferData.bucket[bucketIndex].headChunk = chunk.nextChunk
                                    }
                                    chunk.vertexBuffer = null
                                }
                                break
                            }
                            previousChunk = chunk
                        }
                    }
                }
                if (!vertexbuffer) {
                    vertexbufferParameters.numVertices = maxVerticesPerVertexBuffer;
                    vertexbuffer = this.graphicsDevice.createVertexBuffer(vertexbufferParameters);
                    this.debugCreatedVertexBuffers += 1;
                    if (vertexbuffer) {
                        vertexBufferData = {
                            vertexBuffer: vertexbuffer,
                            bucket: this.makeBuckets()
                        };
                        vertexBufferData.bucket[this.bucket(maxVerticesPerVertexBuffer - numVertices)].headChunk = {
                            baseIndex: numVertices,
                            length: maxVerticesPerVertexBuffer - numVertices,
                            nextChunk: null
                        };
                        vertexBuffersPool.vertexBufferData.push(vertexBufferData)
                    }
                }
            }
            if (!vertexbuffer) {
                vertexbufferParameters.numVertices = numVertices;
                vertexbuffer = this.graphicsDevice.createVertexBuffer(vertexbufferParameters);
                this.debugCreatedVertexBuffers += 1;
                if (vertexbuffer) {
                    vertexBuffersPool.vertexBufferData.push({
                        vertexBuffer: vertexbuffer,
                        bucket: this.makeBuckets()
                    })
                }
            }
            return {
                vertexBuffer: vertexbuffer,
                baseIndex: baseIndex,
                length: numVertices,
                poolIndex: poolIndex
            }
        };
        VertexBufferManager.prototype.free = function(allocation) {
            var vertexBuffersPool = this.vertexBuffersPools[allocation.poolIndex];
            var vertexBufferData;
            for (var vertexBufferIndex = 0; vertexBufferIndex < vertexBuffersPool.vertexBufferData.length; vertexBufferIndex += 1) {
                if (allocation.vertexBuffer === vertexBuffersPool.vertexBufferData[vertexBufferIndex].vertexBuffer) {
                    vertexBufferData = vertexBuffersPool.vertexBufferData[vertexBufferIndex];
                    break
                }
            }
            var leftChunk;
            var leftChunkPrevious;
            var rightChunk;
            var rightChunkPrevious;
            var previous;
            for (var bucketIndex = 0; !(leftChunk && rightChunk) && bucketIndex < this.numBuckets; bucketIndex += 1) {
                previous = null;
                for (var chunk = vertexBufferData.bucket[bucketIndex].headChunk; chunk && !(leftChunk && rightChunk); chunk = chunk.nextChunk) {
                    if (!leftChunk) {
                        if (chunk.baseIndex + chunk.length === allocation.baseIndex) {
                            leftChunk = chunk;
                            leftChunkPrevious = previous
                        }
                    }
                    if (!rightChunk) {
                        if (chunk.baseIndex === allocation.baseIndex + allocation.length) {
                            rightChunk = chunk;
                            rightChunkPrevious = previous
                        }
                    }
                    previous = chunk
                }
            }
            var oldBucketIndex;
            var newBucketIndex;
            if (leftChunk && rightChunk) {
                oldBucketIndex = this.bucket(leftChunk.length);
                leftChunk.length += allocation.length + rightChunk.length;
                if (rightChunkPrevious) {
                    rightChunkPrevious.nextChunk = rightChunk.nextChunk;
                    if (rightChunk === leftChunkPrevious) {
                        leftChunkPrevious = rightChunkPrevious
                    }
                } else {
                    vertexBufferData.bucket[this.bucket(rightChunk.length)].headChunk = rightChunk.nextChunk;
                    if (rightChunk === leftChunkPrevious) {
                        leftChunkPrevious = null
                    }
                }
                newBucketIndex = this.bucket(leftChunk.length);
                if (newBucketIndex !== oldBucketIndex) {
                    if (leftChunkPrevious) {
                        leftChunkPrevious.nextChunk = leftChunk.nextChunk
                    } else {
                        vertexBufferData.bucket[oldBucketIndex].headChunk = leftChunk.nextChunk
                    }
                    leftChunk.nextChunk = vertexBufferData.bucket[newBucketIndex].headChunk;
                    vertexBufferData.bucket[newBucketIndex].headChunk = leftChunk
                }
            } else if (leftChunk) {
                oldBucketIndex = this.bucket(leftChunk.length);
                leftChunk.length += allocation.length;
                newBucketIndex = this.bucket(leftChunk.length);
                if (newBucketIndex !== oldBucketIndex) {
                    if (leftChunkPrevious) {
                        leftChunkPrevious.nextChunk = leftChunk.nextChunk
                    } else {
                        vertexBufferData.bucket[oldBucketIndex].headChunk = leftChunk.nextChunk
                    }
                    leftChunk.nextChunk = vertexBufferData.bucket[newBucketIndex].headChunk;
                    vertexBufferData.bucket[newBucketIndex].headChunk = leftChunk
                }
            } else if (rightChunk) {
                oldBucketIndex = this.bucket(rightChunk.length);
                rightChunk.baseIndex = allocation.baseIndex;
                rightChunk.length += allocation.length;
                newBucketIndex = this.bucket(rightChunk.length);
                if (newBucketIndex !== oldBucketIndex) {
                    if (rightChunkPrevious) {
                        rightChunkPrevious.nextChunk = rightChunk.nextChunk
                    } else {
                        vertexBufferData.bucket[oldBucketIndex].headChunk = rightChunk.nextChunk
                    }
                    rightChunk.nextChunk = vertexBufferData.bucket[newBucketIndex].headChunk;
                    vertexBufferData.bucket[newBucketIndex].headChunk = rightChunk
                }
            } else {
                var bucket = vertexBufferData.bucket[this.bucket(allocation.length)];
                bucket.headChunk = {
                    baseIndex: allocation.baseIndex,
                    length: allocation.length,
                    nextChunk: bucket.headChunk
                }
            }
            var lastChunk = vertexBufferData.bucket[this.numBuckets - 1].headChunk;
            if (lastChunk && lastChunk.length >= this.maxVerticesPerVertexBuffer) {
                vertexBuffersPool.vertexBufferData.splice(vertexBufferIndex, 1);
                vertexBufferData.vertexBuffer.destroy();
                vertexBufferData.vertexBuffer = null;
                vertexBufferData.bucket.length = 0;
                vertexBufferData.bucket = null
            }
        };
        VertexBufferManager.prototype.destroy = function() {
            var vertexBuffersPools = this.vertexBuffersPools;
            if (vertexBuffersPools) {
                var numVertexBuffersPools = vertexBuffersPools.length;
                var i, j;
                for (i = 0; i < numVertexBuffersPools; i += 1) {
                    var vertexBuffersPool = vertexBuffersPools[i];
                    var vertexBufferDataArray = vertexBuffersPool.vertexBufferData;
                    var numVertexBufferData = vertexBufferDataArray.length;
                    for (j = 0; j < numVertexBufferData; j += 1) {
                        var vertexBufferData = vertexBufferDataArray[j];
                        var bucketArray = vertexBufferData.bucket;
                        if (bucketArray) {
                            bucketArray.length = 0;
                            vertexBufferData.bucket = null
                        }
                        var vertexbuffer = vertexBufferData.vertexBuffer;
                        if (vertexbuffer) {
                            vertexbuffer.destroy();
                            vertexBufferData.vertexBuffer = null
                        }
                    }
                    vertexBufferDataArray.length = 0
                }
                vertexBuffersPools.length = 0;
                this.vertexBuffersPools = null
            }
            this.graphicsDevice = null
        };
        VertexBufferManager.create = function(graphicsDevice, dynamicVertexBuffers) {
            var manager = new VertexBufferManager;
            manager.vertexBuffersPools = [];
            manager.debugCreatedVertexBuffers = 0;
            manager.graphicsDevice = graphicsDevice;
            manager.dynamicVertexBuffers = dynamicVertexBuffers ? true : false;
            return manager
        };
        VertexBufferManager.version = 1;
        return VertexBufferManager
    }();
    var CustomMetricEvent = function() {
        function CustomMetricEvent() {}
        CustomMetricEvent.create = function() {
            return new CustomMetricEvent
        };
        return CustomMetricEvent
    }();
    var CustomMetricEventBatch = function() {
        function CustomMetricEventBatch() {}
        CustomMetricEventBatch.prototype.push = function(key, value) {
            var event = CustomMetricEvent.create();
            event.key = key;
            event.value = value;
            event.timeOffset = TurbulenzEngine.time;
            this.events.push(event)
        };
        CustomMetricEventBatch.prototype.length = function() {
            return this.events.length
        };
        CustomMetricEventBatch.prototype.clear = function() {
            this.events.length = 0
        };
        CustomMetricEventBatch.create = function() {
            var batch = new CustomMetricEventBatch;
            batch.events = [];
            return batch
        };
        return CustomMetricEventBatch
    }();
    var ServiceRequester = function() {
        function ServiceRequester() {}
        ServiceRequester.prototype.request = function(params, serviceAction) {
            var servicesDomain = TurbulenzServices.servicesDomain;
            if (servicesDomain) {
                if (params.url.indexOf("http") !== 0) {
                    if (params.url[0] === "/") {
                        params.url = servicesDomain + params.url
                    } else {
                        params.url = servicesDomain + "/" + params.url
                    }
                }
                if (window.location) {
                    if (servicesDomain !== ServiceRequester.locationOrigin) {
                        params.enableCORSCredentials = true
                    }
                }
            }
            if (TurbulenzServices.bridgeServices) {
                var processed = TurbulenzServices.callOnBridge(serviceAction ? serviceAction : params.url, params, function unpackResponse(response) {
                    if (params.callback) {
                        params.callback(response, response.status)
                    }
                });
                if (processed) {
                    return true
                }
            }
            var discardRequestFn = function discardRequestFn() {
                if (params.callback) {
                    params.callback({
                        ok: false,
                        msg: "Service Unavailable. Discarding request"
                    }, 503)
                }
            };
            var that = this;
            var serviceStatusObserver = this.serviceStatusObserver;
            var onServiceStatusChange;
            onServiceStatusChange = function onServiceStatusChangeFn(running, discardRequest) {
                if (discardRequest) {
                    if (!params.neverDiscard) {
                        serviceStatusObserver.unsubscribe(onServiceStatusChange);
                        discardRequestFn()
                    }
                } else if (running) {
                    serviceStatusObserver.unsubscribe(onServiceStatusChange);
                    that.request(params)
                }
            };
            if (!this.running) {
                if (this.discardRequests && !params.neverDiscard) {
                    TurbulenzEngine.setTimeout(discardRequestFn, 0);
                    return false
                }
                if (!params.waiting) {
                    params.waiting = true;
                    serviceStatusObserver.subscribe(onServiceStatusChange)
                }
                return true
            }
            var oldResponseFilter = params.responseFilter;
            params.responseFilter = function checkServiceUnavailableFn(callContext, makeRequest, responseJSON, status) {
                if (status === 503) {
                    var responseObj = JSON.parse(responseJSON);
                    var statusObj = responseObj.data;
                    var discardRequests = statusObj ? statusObj.discardRequests : true;
                    that.discardRequests = discardRequests;
                    if (discardRequests && !params.neverDiscard) {
                        discardRequestFn()
                    } else {
                        serviceStatusObserver.subscribe(onServiceStatusChange)
                    }
                    TurbulenzServices.serviceUnavailable(that, callContext);
                    return false
                } else {
                    if (oldResponseFilter) {
                        return oldResponseFilter.call(params.requestHandler, callContext, makeRequest, responseJSON, status)
                    }
                    return true
                }
            };
            Utilities.ajax(params);
            return true
        };
        ServiceRequester.create = function(serviceName, params) {
            if (typeof ServiceRequester.locationOrigin === undefined && typeof window.location !== undefined) {
                ServiceRequester.locationOrigin = window.location.protocol + "//" + window.location.host
            }
            var serviceRequester = new ServiceRequester;
            if (!params) {
                params = {}
            }
            serviceRequester.running = true;
            serviceRequester.discardRequests = false;
            serviceRequester.serviceStatusObserver = Observer.create();
            serviceRequester.serviceName = serviceName;
            serviceRequester.onServiceUnavailable = params.onServiceUnavailable;
            serviceRequester.onServiceAvailable = params.onServiceAvailable;
            return serviceRequester
        };
        return ServiceRequester
    }();
    var TurbulenzServices = function() {
        function TurbulenzServices() {}
        TurbulenzServices.available = function() {
            return window.gameSlug !== undefined
        };
        TurbulenzServices.addBridgeEvents = function() {
            var turbulenz = window.Turbulenz;
            if (!turbulenz) {
                try {
                    turbulenz = window.top.Turbulenz
                } catch (e) {}
            }
            var turbulenzData = turbulenz && turbulenz.Data || {};
            var sessionToJoin = turbulenzData.joinMultiplayerSessionId;
            var that = this;
            var onJoinMultiplayerSession = function onJoinMultiplayerSessionFn(joinMultiplayerSessionId) {
                that.multiplayerJoinRequestQueue.push(joinMultiplayerSessionId)
            };
            var onReceiveConfig = function onReceiveConfigFn(configString) {
                var config = JSON.parse(configString);
                if (config.mode) {
                    that.mode = config.mode
                }
                if (config.joinMultiplayerSessionId) {
                    that.multiplayerJoinRequestQueue.push(config.joinMultiplayerSessionId)
                }
                that.bridgeServices = !!config.bridgeServices;
                if (config.servicesDomain) {
                    that.servicesDomain = config.servicesDomain
                }
                if (config.syncing) {
                    that.syncing = true
                }
                if (config.offline) {
                    that.offline = true
                }
            };
            if (sessionToJoin) {
                this.multiplayerJoinRequestQueue.push(sessionToJoin)
            }
            TurbulenzBridge.setOnMultiplayerSessionToJoin(onJoinMultiplayerSession);
            TurbulenzBridge.setOnReceiveConfig(onReceiveConfig);
            TurbulenzBridge.triggerRequestConfig();
            this.responseHandlers = [null];
            this.responseIndex = 0;
            TurbulenzBridge.on("bridgeservices.response", function(jsondata) {
                that.routeResponse(jsondata)
            });
            TurbulenzBridge.on("bridgeservices.sync.start", function() {
                that.syncing = true
            });
            TurbulenzBridge.on("bridgeservices.sync.end", function() {
                that.syncing = false
            });
            TurbulenzBridge.on("bridgeservices.offline.start", function() {
                that.offline = true
            });
            TurbulenzBridge.on("bridgeservices.offline.end", function() {
                that.offline = false
            })
        };
        TurbulenzServices.callOnBridge = function(event, data, callback) {
            var request = {
                data: data,
                key: undefined
            };
            if (callback) {
                this.responseIndex += 1;
                this.responseHandlers[this.responseIndex] = callback;
                request.key = this.responseIndex
            }
            var resultJSON = TurbulenzBridge.emit("bridgeservices." + event, JSON.stringify(request));
            var result = JSON.parse(resultJSON);
            return result.fullyProcessed
        };
        TurbulenzServices.addSignature = function(data, url) {
            var str;
            data.requestUrl = url;
            str = TurbulenzEngine.encrypt(JSON.stringify(data));
            data.str = str;
            data.signature = TurbulenzEngine.generateSignature(str);
            return data
        };
        TurbulenzServices.routeResponse = function(jsondata) {
            var response = JSON.parse(jsondata);
            var index = response.key || 0;
            var callback = this.responseHandlers[index];
            if (callback) {
                this.responseHandlers[index] = null;
                callback(response.data)
            }
        };
        TurbulenzServices.onServiceUnavailable = function(serviceName, callContext) {};
        TurbulenzServices.onServiceAvailable = function(serviceName, callContext) {};
        TurbulenzServices.createGameSession = function(requestHandler, sessionCreatedFn, errorCallbackFn) {
            return GameSession.create(requestHandler, sessionCreatedFn, errorCallbackFn)
        };
        TurbulenzServices.createMappingTable = function(requestHandler, gameSession, tableReceivedFn, defaultMappingSettings, errorCallbackFn) {
            var mappingTable;
            var mappingTableSettings = gameSession && gameSession.mappingTable;
            var mappingTableURL;
            var mappingTablePrefix;
            var assetPrefix;
            if (mappingTableSettings) {
                mappingTableURL = mappingTableSettings.mappingTableURL;
                mappingTablePrefix = mappingTableSettings.mappingTablePrefix;
                assetPrefix = mappingTableSettings.assetPrefix
            } else if (defaultMappingSettings) {
                mappingTableURL = defaultMappingSettings.mappingTableURL || (defaultMappingSettings.mappingTableURL === "" ? "" : "mapping_table.json");
                mappingTablePrefix = defaultMappingSettings.mappingTablePrefix || (defaultMappingSettings.mappingTablePrefix === "" ? "" : "staticmax/");
                assetPrefix = defaultMappingSettings.assetPrefix || (defaultMappingSettings.assetPrefix === "" ? "" : "missing/")
            } else {
                mappingTableURL = "mapping_table.json";
                mappingTablePrefix = "staticmax/";
                assetPrefix = "missing/"
            }
            var mappingTableErr = function mappingTableErrFn(msg) {
                var mapping = defaultMappingSettings && (defaultMappingSettings.urnMapping || {});
                var errorCallback = errorCallbackFn || TurbulenzServices.defaultErrorCallback;
                mappingTable.setMapping(mapping);
                errorCallback(msg)
            };
            var mappingTableParams = {
                mappingTableURL: mappingTableURL,
                mappingTablePrefix: mappingTablePrefix,
                assetPrefix: assetPrefix,
                requestHandler: requestHandler,
                onload: tableReceivedFn,
                errorCallback: mappingTableErr
            };
            mappingTable = MappingTable.create(mappingTableParams);
            return mappingTable
        };
        TurbulenzServices.createLeaderboardManager = function(requestHandler, gameSession, leaderboardMetaReceived, errorCallbackFn) {
            return LeaderboardManager.create(requestHandler, gameSession, leaderboardMetaReceived, errorCallbackFn)
        };
        TurbulenzServices.createBadgeManager = function(requestHandler, gameSession) {
            return BadgeManager.create(requestHandler, gameSession)
        };
        TurbulenzServices.createStoreManager = function(requestHandler, gameSession, storeMetaReceived, errorCallbackFn) {
            return StoreManager.create(requestHandler, gameSession, storeMetaReceived, errorCallbackFn)
        };
        TurbulenzServices.createNotificationsManager = function(requestHandler, gameSession, successCallbackFn, errorCallbackFn) {
            return NotificationsManager.create(requestHandler, gameSession, successCallbackFn, errorCallbackFn)
        };
        TurbulenzServices.createMultiplayerSessionManager = function(requestHandler, gameSession) {
            return MultiPlayerSessionManager.create(requestHandler, gameSession)
        };
        TurbulenzServices.createUserProfile = function(requestHandler, profileReceivedFn, errorCallbackFn) {
            var userProfile = {};
            if (!errorCallbackFn) {
                errorCallbackFn = TurbulenzServices.defaultErrorCallback
            }
            var loadUserProfileCallback = function loadUserProfileCallbackFn(userProfileData) {
                if (userProfileData && userProfileData.ok) {
                    userProfileData = userProfileData.data;
                    var p;
                    for (p in userProfileData) {
                        if (userProfileData.hasOwnProperty(p)) {
                            userProfile[p] = userProfileData[p]
                        }
                    }
                }
            };
            var url = "user.json";
            if (TurbulenzServices.available()) {
                this.getService("profiles").request({
                    url: url,
                    method: "GET",
                    callback: function createUserProfileAjaxErrorCheck(jsonResponse, status) {
                        if (status === 200) {
                            loadUserProfileCallback(jsonResponse)
                        } else if (errorCallbackFn) {
                            errorCallbackFn("TurbulenzServices.createUserProfile error with HTTP status " + status + ": " + jsonResponse.msg, status)
                        }
                        if (profileReceivedFn) {
                            profileReceivedFn(userProfile)
                        }
                    },
                    requestHandler: requestHandler
                }, "profile.user")
            }
            return userProfile
        };
        TurbulenzServices.upgradeAnonymousUser = function(upgradeCB) {
            if (upgradeCB) {
                var onUpgrade = function onUpgradeFn(_signal) {
                    upgradeCB()
                };
                TurbulenzBridge.on("user.upgrade.occurred", onUpgrade)
            }
            TurbulenzBridge.emit("user.upgrade.show")
        };
        TurbulenzServices.sendCustomMetricEvent = function(eventKey, eventValue, requestHandler, gameSession, errorCallbackFn) {
            if (!errorCallbackFn) {
                errorCallbackFn = TurbulenzServices.defaultErrorCallback
            }
            if (!TurbulenzServices.available()) {
                errorCallbackFn("TurbulenzServices.sendCustomMetricEvent " + "failed: Service not available", 0);
                return
            }
            if ("string" !== typeof eventKey || 0 === eventKey.length) {
                errorCallbackFn("TurbulenzServices.sendCustomMetricEvent " + "failed: Event key must be a non-empty string", 0);
                return
            }
            if ("number" !== typeof eventValue || isNaN(eventValue) || !isFinite(eventValue)) {
                if ("[object Array]" !== Object.prototype.toString.call(eventValue)) {
                    errorCallbackFn("TurbulenzServices.sendCustomMetricEvent " + "failed: Event value must be a number or " + "an array of numbers", 0);
                    return
                }
                var i, valuesLength = eventValue.length;
                for (i = 0; i < valuesLength; i += 1) {
                    if ("number" !== typeof eventValue[i] || isNaN(eventValue[i]) || !isFinite(eventValue[i])) {
                        errorCallbackFn("TurbulenzServices.sendCustomMetricEvent " + "failed: Event value array elements must " + "be numbers", 0);
                        return
                    }
                }
            }
            this.getService("customMetrics").request({
                url: "/api/v1/custommetrics/add-event/" + gameSession.gameSlug,
                method: "POST",
                data: {
                    key: eventKey,
                    value: eventValue,
                    gameSessionId: gameSession.gameSessionId
                },
                callback: function sendCustomMetricEventAjaxErrorCheck(jsonResponse, status) {
                    if (status !== 200) {
                        errorCallbackFn("TurbulenzServices.sendCustomMetricEvent " + "error with HTTP status " + status + ": " + jsonResponse.msg, status)
                    }
                },
                requestHandler: requestHandler,
                encrypt: true
            }, "custommetrics.addevent")
        };
        TurbulenzServices.sendCustomMetricEventBatch = function(eventBatch, requestHandler, gameSession, errorCallbackFn) {
            if (!errorCallbackFn) {
                errorCallbackFn = TurbulenzServices.defaultErrorCallback
            }
            if (!TurbulenzServices.available()) {
                if (errorCallbackFn) {
                    errorCallbackFn("TurbulenzServices.sendCustomMetricEventBatch failed: Service not available", 0)
                }
                return
            }
            var currentTime = TurbulenzEngine.time;
            var events = eventBatch.events;
            var eventIndex;
            var numEvents = events.length;
            for (eventIndex = 0; eventIndex < numEvents; eventIndex += 1) {
                var eventKey = events[eventIndex].key;
                var eventValue = events[eventIndex].value;
                var eventTime = events[eventIndex].timeOffset;
                if ("string" !== typeof eventKey || 0 === eventKey.length) {
                    if (errorCallbackFn) {
                        errorCallbackFn("TurbulenzServices.sendCustomMetricEventBatch failed: Event key must be a" + " non-empty string", 0)
                    }
                    return
                }
                if ("number" !== typeof eventValue || isNaN(eventValue) || !isFinite(eventValue)) {
                    if ("[object Array]" !== Object.prototype.toString.call(eventValue)) {
                        if (errorCallbackFn) {
                            errorCallbackFn("TurbulenzServices.sendCustomMetricEventBatch failed: Event value must be a" + " number or an array of numbers", 0)
                        }
                        return
                    }
                    var i, valuesLength = eventValue.length;
                    for (i = 0; i < valuesLength; i += 1) {
                        if ("number" !== typeof eventValue[i] || isNaN(eventValue[i]) || !isFinite(eventValue[i])) {
                            if (errorCallbackFn) {
                                errorCallbackFn("TurbulenzServices.sendCustomMetricEventBatch failed: Event value array" + " elements must be numbers", 0)
                            }
                            return
                        }
                    }
                }
                if ("number" !== typeof eventTime || isNaN(eventTime) || !isFinite(eventTime)) {
                    if (errorCallbackFn) {
                        errorCallbackFn("TurbulenzServices.sendCustomMetricEventBatch failed: Event time offset is" + " corrupted", 0)
                    }
                    return
                }
                events[eventIndex].timeOffset = eventTime - currentTime
            }
            this.getService("customMetrics").request({
                url: "/api/v1/custommetrics/add-event-batch/" + gameSession.gameSlug,
                method: "POST",
                data: {
                    batch: events,
                    gameSessionId: gameSession.gameSessionId
                },
                callback: function sendCustomMetricEventBatchAjaxErrorCheck(jsonResponse, status) {
                    if (status !== 200 && errorCallbackFn) {
                        errorCallbackFn("TurbulenzServices.sendCustomMetricEventBatch error with HTTP status " + status + ": " + jsonResponse.msg, status)
                    }
                },
                requestHandler: requestHandler,
                encrypt: true
            }, "custommetrics.addeventbatch")
        };
        TurbulenzServices.getService = function(serviceName) {
            var services = this.services;
            if (services.hasOwnProperty(serviceName)) {
                return services[serviceName]
            } else {
                var service = ServiceRequester.create(serviceName);
                services[serviceName] = service;
                return service
            }
        };
        TurbulenzServices.serviceUnavailable = function(service, callContext) {
            var waitingServices = this.waitingServices;
            var serviceName = service.serviceName;
            if (waitingServices.hasOwnProperty(serviceName)) {
                return
            }
            waitingServices[serviceName] = service;
            service.running = false;
            var onServiceUnavailableCallbacks = function onServiceUnavailableCallbacksFn(service) {
                var onServiceUnavailable = callContext.onServiceUnavailable;
                if (onServiceUnavailable) {
                    onServiceUnavailable.call(service, callContext)
                }
                if (service.onServiceUnavailable) {
                    service.onServiceUnavailable()
                }
                if (TurbulenzServices.onServiceUnavailable) {
                    TurbulenzServices.onServiceUnavailable(service)
                }
            };
            if (service.discardRequests) {
                onServiceUnavailableCallbacks(service)
            }
            if (this.pollingServiceStatus) {
                return
            }
            var that = this;
            var pollServiceStatus;
            var serviceUrl = "/api/v1/service-status/game/read/" + window.gameSlug;
            var servicesStatusCB = function servicesStatusCBFn(responseObj, status) {
                if (status === 200) {
                    var statusObj = responseObj.data;
                    var servicesObj = statusObj.services;
                    var retry = false;
                    var serviceName;
                    for (serviceName in waitingServices) {
                        if (waitingServices.hasOwnProperty(serviceName)) {
                            var service = waitingServices[serviceName];
                            var serviceData = servicesObj[serviceName];
                            var serviceRunning = serviceData.running;
                            service.running = serviceRunning;
                            service.description = serviceData.description;
                            if (serviceRunning) {
                                if (service.discardRequests) {
                                    var onServiceAvailable = callContext.onServiceAvailable;
                                    if (onServiceAvailable) {
                                        onServiceAvailable.call(service, callContext)
                                    }
                                    if (service.onServiceAvailable) {
                                        service.onServiceAvailable()
                                    }
                                    if (TurbulenzServices.onServiceAvailable) {
                                        TurbulenzServices.onServiceAvailable(service)
                                    }
                                }
                                delete waitingServices[serviceName];
                                service.discardRequests = false;
                                service.serviceStatusObserver.notify(serviceRunning, service.discardRequests)
                            } else {
                                if (serviceData.discardRequests && !service.discardRequests) {
                                    service.discardRequests = true;
                                    onServiceUnavailableCallbacks(service);
                                    service.serviceStatusObserver.notify(serviceRunning, service.discardRequests)
                                }
                                retry = true
                            }
                        }
                    }
                    if (!retry) {
                        this.pollingServiceStatus = false;
                        return
                    }
                    TurbulenzEngine.setTimeout(pollServiceStatus, statusObj.pollInterval * 1e3)
                } else {
                    TurbulenzEngine.setTimeout(pollServiceStatus, that.defaultPollInterval)
                }
            };
            var params = {
                url: serviceUrl,
                method: "GET",
                callback: servicesStatusCB
            };
            var servicesDomain = TurbulenzServices.servicesDomain;
            if (servicesDomain) {
                if (serviceUrl.indexOf("http") !== 0) {
                    if (serviceUrl[0] === "/") {
                        params.url = servicesDomain + serviceUrl
                    } else {
                        params.url = servicesDomain + "/" + serviceUrl
                    }
                }
                if (window.location) {
                    if (servicesDomain !== ServiceRequester.locationOrigin) {
                        params.enableCORSCredentials = true
                    }
                }
            }
            pollServiceStatus = function pollServiceStatusFn() {
                Utilities.ajax(params)
            };
            pollServiceStatus()
        };
        TurbulenzServices.multiplayerJoinRequestQueue = {
            argsQueue: [],
            handler: function nopFn() {},
            context: undefined,
            paused: true,
            onEvent: function onEventFn(handler, context) {
                this.handler = handler;
                this.context = context
            },
            push: function pushFn(sessionId) {
                var args = [sessionId];
                if (this.paused) {
                    this.argsQueue.push(args)
                } else {
                    this.handler.apply(this.context, args)
                }
            },
            shift: function shiftFn() {
                var args = this.argsQueue.shift();
                return args ? args[0] : undefined
            },
            clear: function clearFn() {
                this.argsQueue = []
            },
            pause: function pauseFn() {
                this.paused = true
            },
            resume: function resumeFn() {
                this.paused = false;
                while (this.argsQueue.length) {
                    this.handler.apply(this.context, this.argsQueue.shift());
                    if (this.paused) {
                        break
                    }
                }
            }
        };
        TurbulenzServices.defaultErrorCallback = function(errorMsg, httpStatus) {};
        TurbulenzServices.services = {};
        TurbulenzServices.waitingServices = {};
        TurbulenzServices.pollingServiceStatus = false;
        TurbulenzServices.defaultPollInterval = 4e3;
        return TurbulenzServices
    }();
    if (typeof TurbulenzBridge !== "undefined") {
        TurbulenzServices.addBridgeEvents()
    } else {}
    var TurbulenzBridge = function() {
        function TurbulenzBridge() {}
        TurbulenzBridge._initInstance = function() {
            var Turbulenz = window.Turbulenz;
            if (!Turbulenz) {
                try {
                    Turbulenz = window.top.Turbulenz
                } catch (e) {}
            }
            if (Turbulenz && Turbulenz.Services) {
                var bridge = Turbulenz.Services.bridge;
                if (!bridge) {
                    return
                }
                this._bridge = bridge;
                this.emit = bridge.emit;
                this.on = bridge.gameListenerOn || bridge.addListener || bridge.setListener;
                this.addListener = bridge.gameListenerOn || bridge.addListener || bridge.setListener;
                this.setListener = bridge.gameListenerOn || bridge.setListener
            } else {}
            if (typeof TurbulenzServices !== "undefined") {
                TurbulenzServices.addBridgeEvents()
            }
        };
        TurbulenzBridge.isInitialised = function() {
            return this._bridge !== undefined
        };
        TurbulenzBridge.emit = function(serviceName, request, arg) {
            return ""
        };
        TurbulenzBridge.on = function(serviceName, cb) {};
        TurbulenzBridge.addListener = function() {};
        TurbulenzBridge.setListener = function(eventName, listener) {};
        TurbulenzBridge.setOnReceiveConfig = function(callback) {
            this.on("config.set", callback)
        };
        TurbulenzBridge.triggerRequestConfig = function() {
            this.emit("config.request")
        };
        TurbulenzBridge.startLoading = function() {
            this.emit("status.loading.start")
        };
        TurbulenzBridge.startSaving = function() {
            this.emit("status.saving.start")
        };
        TurbulenzBridge.stopLoading = function() {
            this.emit("status.loading.stop")
        };
        TurbulenzBridge.stopSaving = function() {
            this.emit("status.saving.stop")
        };
        TurbulenzBridge.createdGameSession = function(gameSessionId) {
            this.emit("game.session.created", gameSessionId)
        };
        TurbulenzBridge.destroyedGameSession = function(gameSessionId) {
            this.emit("game.session.destroyed", gameSessionId)
        };
        TurbulenzBridge.setGameSessionStatus = function(gameSessionId, status) {
            this.emit("game.session.status", gameSessionId, status)
        };
        TurbulenzBridge.setGameSessionInfo = function(info) {
            this.emit("game.session.info", info)
        };
        TurbulenzBridge.updateUserBadge = function(badge) {
            this.emit("userbadge.update", badge)
        };
        TurbulenzBridge.updateLeaderBoard = function(scoreData) {
            this.emit("leaderboards.update", scoreData)
        };
        TurbulenzBridge.setOnMultiplayerSessionToJoin = function(callback) {
            this.on("multiplayer.session.join", callback)
        };
        TurbulenzBridge.triggerJoinedMultiplayerSession = function(session) {
            this.emit("multiplayer.session.joined", session)
        };
        TurbulenzBridge.triggerLeaveMultiplayerSession = function(sessionId) {
            this.emit("multiplayer.session.leave", sessionId)
        };
        TurbulenzBridge.triggerMultiplayerSessionMakePublic = function(sessionId) {
            this.emit("multiplayer.session.makepublic", sessionId)
        };
        TurbulenzBridge.setOnBasketUpdate = function(callback) {
            this.on("basket.site.update", callback)
        };
        TurbulenzBridge.triggerBasketUpdate = function(basket) {
            this.emit("basket.game.update.v2", basket)
        };
        TurbulenzBridge.triggerUserStoreUpdate = function(items) {
            this.emit("store.user.update", items)
        };
        TurbulenzBridge.setOnPurchaseConfirmed = function(callback) {
            this.on("purchase.confirmed", callback)
        };
        TurbulenzBridge.setOnPurchaseRejected = function(callback) {
            this.on("purchase.rejected", callback)
        };
        TurbulenzBridge.triggerShowConfirmPurchase = function() {
            this.emit("purchase.show.confirm")
        };
        TurbulenzBridge.triggerFetchStoreMeta = function() {
            this.emit("fetch.store.meta")
        };
        TurbulenzBridge.setOnStoreMeta = function(callback) {
            this.on("store.meta.v2", callback)
        };
        TurbulenzBridge.triggerSendInstantNotification = function(notification) {
            this.emit("notifications.ingame.sendInstant", notification)
        };
        TurbulenzBridge.triggerSendDelayedNotification = function(notification) {
            this.emit("notifications.ingame.sendDelayed", notification)
        };
        TurbulenzBridge.setOnNotificationSent = function(callback) {
            this.on("notifications.ingame.sent", callback)
        };
        TurbulenzBridge.triggerCancelNotificationByID = function(params) {
            this.emit("notifications.ingame.cancelByID", params)
        };
        TurbulenzBridge.triggerCancelNotificationsByKey = function(params) {
            this.emit("notifications.ingame.cancelByKey", params)
        };
        TurbulenzBridge.triggerCancelAllNotifications = function(params) {
            this.emit("notifications.ingame.cancelAll", params)
        };
        TurbulenzBridge.triggerInitNotificationManager = function(params) {
            this.emit("notifications.ingame.initNotificationManager", params)
        };
        TurbulenzBridge.setOnReceiveNotification = function(callback) {
            this.on("notifications.ingame.receive", callback)
        };
        TurbulenzBridge.changeAspectRatio = function(ratio) {
            this.emit("change.viewport.ratio", ratio)
        };
        TurbulenzBridge.setOnViewportHide = function(callback) {
            this.on("change.viewport.hide", callback)
        };
        TurbulenzBridge.setOnViewportShow = function(callback) {
            this.on("change.viewport.show", callback)
        };
        TurbulenzBridge.setOnFullscreenOn = function(callback) {
            this.on("change.viewport.fullscreen.on", callback)
        };
        TurbulenzBridge.setOnFullscreenOff = function(callback) {
            this.on("change.viewport.fullscreen.off", callback)
        };
        TurbulenzBridge.setOnMenuStateChange = function(callback) {
            this.on("change.menu.state", callback)
        };
        TurbulenzBridge.setOnUserStateChange = function(callback) {
            this.on("change.user.state", callback)
        };
        TurbulenzBridge.triggerOnFullscreen = function() {
            this.emit("trigger.viewport.fullscreen")
        };
        TurbulenzBridge.triggerOnViewportVisibility = function() {
            this.emit("trigger.viewport.visibility")
        };
        TurbulenzBridge.triggerOnMenuStateChange = function() {
            this.emit("trigger.menu.state")
        };
        TurbulenzBridge.triggerOnUserStateChange = function() {
            this.emit("trigger.user.state")
        };
        TurbulenzBridge.queryFullscreen = function(callback) {
            this.emit("query.viewport.fullscreen", callback)
        };
        TurbulenzBridge.queryViewportVisibility = function(callback) {
            this.emit("query.viewport.visibility", callback)
        };
        TurbulenzBridge.queryMenuState = function(callback) {
            this.emit("query.menu.state", callback)
        };
        TurbulenzBridge.queryUserState = function(callback) {
            this.emit("query.user.state", callback)
        };
        TurbulenzBridge._bridge = undefined;
        return TurbulenzBridge
    }();
    if (!TurbulenzBridge.isInitialised()) {
        TurbulenzBridge._initInstance()
    }
    var GameSession = function() {
        function GameSession() {
            this.post_delay = 1e3
        }
        GameSession.prototype.setStatus = function(status) {
            if (this.destroyed || this.status === status) {
                return
            }
            this.status = status;
            TurbulenzBridge.setGameSessionStatus(this.gameSessionId, status)
        };
        GameSession.prototype.destroy = function(callbackFn) {
            var dataSpec;
            if (this.pendingUpdate) {
                TurbulenzEngine.clearTimeout(this.pendingUpdate);
                this.pendingUpdate = null
            }
            if (!this.destroyed && this.gameSessionId) {
                TurbulenzBridge.destroyedGameSession(this.gameSessionId);
                this.destroyed = true;
                dataSpec = {
                    gameSessionId: this.gameSessionId
                };
                this.service.request({
                    url: "/api/v1/games/destroy-session",
                    method: "POST",
                    data: dataSpec,
                    callback: callbackFn,
                    requestHandler: this.requestHandler
                }, "gamesession.destroy")
            } else {
                if (callbackFn) {
                    TurbulenzEngine.setTimeout(callbackFn, 0)
                }
            }
        };
        GameSession.prototype.setTeamInfo = function(teamList) {
            var sessionData = this.info.sessionData;
            var oldTeamList = sessionData.teamList || [];
            if (teamList.join("#") !== oldTeamList.join("#")) {
                sessionData.teamList = teamList;
                this.update()
            }
        };
        GameSession.prototype.setPlayerInfo = function(playerId, data) {
            var playerData = this.info.playerSessionData[playerId];
            var key;
            var dirty = false;
            if (!playerData) {
                playerData = {};
                this.info.playerSessionData[playerId] = playerData;
                dirty = true
            }
            for (key in data) {
                if (data.hasOwnProperty(key)) {
                    if (!this.templatePlayerData.hasOwnProperty(key)) {
                        throw "unknown session data property " + key
                    }
                    if (playerData[key] !== data[key]) {
                        playerData[key] = data[key];
                        dirty = true
                    }
                }
            }
            if (dirty) {
                this.update()
            }
        };
        GameSession.prototype.removePlayerInfo = function(playerId) {
            delete this.info.playerSessionData[playerId];
            this.update()
        };
        GameSession.prototype.clearAllPlayerInfo = function() {
            this.info.playerSessionData = {};
            this.update()
        };
        GameSession.prototype.update = function() {
            if (!this.pendingUpdate) {
                this.pendingUpdate = TurbulenzEngine.setTimeout(this.postData, this.post_delay)
            }
        };
        GameSession.create = function(requestHandler, sessionCreatedFn, errorCallbackFn) {
            var gameSession = new GameSession;
            var gameSlug = window.gameSlug;
            var turbulenz = window.Turbulenz;
            if (!turbulenz) {
                try {
                    turbulenz = window.top.Turbulenz
                } catch (e) {}
            }
            var turbulenzData = turbulenz && turbulenz.Data || {};
            var mode = turbulenzData.mode || TurbulenzServices.mode;
            var createSessionURL = "create-session.json";
            gameSession.info = {
                sessionData: {},
                playerSessionData: {}
            };
            gameSession.templatePlayerData = {
                team: null,
                color: null,
                status: null,
                rank: null,
                score: null,
                sortkey: null
            };
            gameSession.postData = function postDataFn() {
                TurbulenzBridge.setGameSessionInfo(JSON.stringify(gameSession.info));
                gameSession.pendingUpdate = null
            };
            gameSession.pendingUpdate = null;
            gameSession.gameSlug = gameSlug;
            gameSession.requestHandler = requestHandler;
            gameSession.errorCallbackFn = errorCallbackFn || TurbulenzServices.defaultErrorCallback;
            gameSession.gameSessionId = null;
            gameSession.service = TurbulenzServices.getService("gameSessions");
            gameSession.status = null;
            if (!TurbulenzServices.available()) {
                if (sessionCreatedFn) {
                    TurbulenzEngine.setTimeout(function sessionCreatedCall() {
                        sessionCreatedFn(gameSession)
                    }, 0)
                }
                return gameSession
            }
            var gameSessionRequestCallback = function gameSessionRequestCallbackFn(jsonResponse, status) {
                if (status === 200) {
                    gameSession.mappingTable = jsonResponse.mappingTable;
                    gameSession.gameSessionId = jsonResponse.gameSessionId;
                    if (sessionCreatedFn) {
                        sessionCreatedFn(gameSession)
                    }
                    TurbulenzBridge.createdGameSession(gameSession.gameSessionId)
                } else if (404 === status) {
                    window.gameSlug = undefined;
                    gameSession.gameSlug = undefined;
                    if (sessionCreatedFn) {
                        sessionCreatedFn(gameSession)
                    }
                } else {
                    gameSession.errorCallbackFn("TurbulenzServices.createGameSession error with HTTP status " + status + ": " + jsonResponse.msg, status)
                }
            };
            if (mode) {
                createSessionURL += "/" + mode
            }
            gameSession.service.request({
                url: createSessionURL,
                method: "GET",
                callback: gameSessionRequestCallback,
                requestHandler: requestHandler,
                neverDiscard: true
            }, "gamesession.create");
			//console.log(gameSession);
            return gameSession
        };
        GameSession.version = 1;
        return GameSession
    }();
    var MappingTable = function() {
        function MappingTable() {}
        MappingTable.prototype.getURL = function(assetPath, missingCallbackFn) {
            var overrides = this.overrides;
            var profile = this.currentProfile;
            var override = overrides[profile];
            var url;
            while (override) {
                url = override.urnmapping[assetPath];
                if (url) {
                    return url
                }
                override = overrides[override.parent]
            }
            url = this.urlMapping[assetPath];
            if (url) {
                return url
            } else {
                if (missingCallbackFn) {
                    missingCallbackFn(assetPath)
                }
                return this.assetPrefix + assetPath
            }
        };
        MappingTable.prototype.setMapping = function(mapping) {
            this.urlMapping = mapping
        };
        MappingTable.prototype.map = function(logicalPath, physicalPath) {
            this.urlMapping[logicalPath] = physicalPath
        };
        MappingTable.prototype.alias = function(alias, logicalPath) {
            var urlMapping = this.urlMapping;
            urlMapping[alias] = urlMapping[logicalPath]
        };
        MappingTable.prototype.getCurrentProfile = function() {
            return this.currentProfile
        };
        MappingTable.prototype.setProfile = function(profile) {
            if (this.overrides.hasOwnProperty(profile)) {
                this.currentProfile = profile
            } else {
                this.currentProfile = undefined
            }
        };
        MappingTable.create = function(params) {
            var mappingTable = new MappingTable;
            mappingTable.mappingTableURL = params.mappingTableURL;
            mappingTable.tablePrefix = params.mappingTablePrefix;
            mappingTable.assetPrefix = params.assetPrefix;
            mappingTable.overrides = {};
            mappingTable.errorCallbackFn = params.errorCallback || TurbulenzServices.defaultErrorCallback;
            mappingTable.currentProfile = TurbulenzEngine.getSystemInfo().platformProfile;
            var onMappingTableLoad = function onMappingTableLoadFn(tableData) {
                var urlMapping = tableData.urnmapping || tableData.urnremapping || {};
                var overrides = tableData.overrides || {};
                mappingTable.urlMapping = urlMapping;
                mappingTable.overrides = overrides;
                var tablePrefix = mappingTable.tablePrefix;
                if (tablePrefix) {
                    var appendPrefix = function appendPrefix(map) {
                        var source;
                        for (source in map) {
                            if (map.hasOwnProperty(source)) {
                                map[source] = tablePrefix + map[source]
                            }
                        }
                    };
                    appendPrefix(urlMapping);
                    var o;
                    for (o in overrides) {
                        if (overrides.hasOwnProperty(o)) {
                            appendPrefix(overrides[o].urnmapping)
                        }
                    }
                }
                params.onload(mappingTable)
            };
            if (!mappingTable.mappingTableURL) {
                if (params.mappingTableData) {
                    TurbulenzEngine.setTimeout(function() {
                        onMappingTableLoad(JSON.parse(params.mappingTableData))
                    }, 0)
                } else {
                    TurbulenzEngine.setTimeout(function() {
                        mappingTable.errorCallbackFn("!! mappingtable params contain no url or data")
                    }, 0)
                }
            } else {
                params.requestHandler.request({
                    src: mappingTable.mappingTableURL,
                    onload: function jsonifyResponse(jsonResponse, status) {
                        if (status === 200) {
                            var obj = JSON.parse(jsonResponse);
                            onMappingTableLoad(obj)
                        } else {
                            mappingTable.urlMapping = {};
                            jsonResponse = jsonResponse || {
                                msg: "(no response)"
                            };
                            mappingTable.errorCallbackFn("MappingTable.create: HTTP status " + status + ": " + jsonResponse.msg, status)
                        }
                    }
                })
            }
            return mappingTable
        };
        MappingTable.version = 1;
        return MappingTable
    }();
    var OSD = function() {
        function OSD() {}
        OSD.prototype.startLoading = function() {
            try {
                var doc = this.topLevelDocument;
                if (doc && doc.osdStartLoading) {
                    doc.osdStartLoading()
                }
            } catch (exception) {}
        };
        OSD.prototype.startSaving = function() {
            try {
                var doc = this.topLevelDocument;
                if (doc && doc.osdStartSaving) {
                    doc.osdStartSaving()
                }
            } catch (exception) {}
        };
        OSD.prototype.stopLoading = function() {
            try {
                var doc = this.topLevelDocument;
                if (doc && doc.osdStopLoading) {
                    doc.osdStopLoading()
                }
            } catch (exception) {}
        };
        OSD.prototype.stopSaving = function() {
            try {
                var doc = this.topLevelDocument;
                if (doc && doc.osdStopSaving) {
                    doc.osdStopSaving()
                }
            } catch (exception) {}
        };
        OSD.create = function() {
            var osdObject = new OSD;
            var topLevelWindow = window;
            var counter = 15;
            while (topLevelWindow.parent !== topLevelWindow && counter > 0) {
                topLevelWindow = topLevelWindow.parent;
                counter -= 1
            }
            osdObject.topLevelDocument = topLevelWindow.document;
            return osdObject
        };
        OSD.version = 1;
        return OSD
    }();
    var UserDataManager = function() {
        function UserDataManager() {
            this.keyValidate = new RegExp("^[A-Za-z0-9]+([\\-\\.][A-Za-z0-9]+)*$")
        }
        UserDataManager.prototype.validateKey = function(key) {
            if (!key || typeof key !== "string") {
                this.errorCallbackFn("Invalid key string (Key string is empty or not a string)");
                return false
            }
            if (!this.keyValidate.test(key)) {
                this.errorCallbackFn("Invalid key string (Only alphanumeric characters and .- are permitted)");
                return false
            }
            return key
        };
        UserDataManager.prototype.getKeys = function(callbackFn, errorCallbackFn) {
            var that = this;
            var getKeysCallback = function getKeysCallbackFn(jsonResponse, status) {
                if (status === 200) {
                    callbackFn(jsonResponse.keys || jsonResponse.array)
                } else {
                    var errorCallback = errorCallbackFn || that.errorCallbackFn;
                    errorCallback("UserDataManager.getKeys failed with status " + status + ": " + jsonResponse.msg, status, that.getKeys, [callbackFn])
                }
            };
            var dataSpec = {
                gameSessionId: that.gameSessionId
            };
            this.service.request({
                url: "/api/v1/user-data/get-keys",
                method: "GET",
                data: dataSpec,
                callback: getKeysCallback,
                requestHandler: this.requestHandler,
                encrypt: true
            }, "userdata.getkeys")
        };
        UserDataManager.prototype.exists = function(key, callbackFn, errorCallbackFn) {
            if (!this.validateKey(key)) {
                return
            }
            var that = this;
            var existsCallback = function existsCallbackFn(jsonResponse, status) {
                if (status === 200) {
                    callbackFn(key, jsonResponse.exists)
                } else {
                    var errorCallback = errorCallbackFn || that.errorCallbackFn;
                    errorCallback("UserDataManager.exists failed with status " + status + ": " + jsonResponse.msg, status, that.exists, [key, callbackFn])
                }
            };
            var dataSpec = {
                gameSessionId: that.gameSessionId
            };
            this.service.request({
                url: "/api/v1/user-data/exists/" + key,
                method: "GET",
                data: dataSpec,
                callback: existsCallback,
                requestHandler: this.requestHandler,
                encrypt: true
            }, "userdata.exists")
        };
        UserDataManager.prototype.get = function(key, callbackFn, errorCallbackFn) {
            var obj = JSON.parse(localStorage.getItem(key));
                    callbackFn(key, obj)
               
        };
        UserDataManager.prototype.set = function(key, value, callbackFn, errorCallbackFn) {
           
			var obj = value;
				localStorage.setItem(key, JSON.stringify(obj));
        };
        UserDataManager.prototype.remove = function(key, callbackFn, errorCallbackFn) {
            if (!this.validateKey(key)) {
                return
            }
            var that = this;
            var removeCallback = function removeCallbackFn(jsonResponse, status) {
                if (status === 200) {
                    callbackFn(key)
                } else if (status === 404) {
                    callbackFn(key)
                } else {
                    var errorCallback = errorCallbackFn || that.errorCallbackFn;
                    errorCallback("UserDataManager.remove failed with status " + status + ": " + jsonResponse.msg, status, that.remove, [key, callbackFn])
                }
            };
            var dataSpec = {
                gameSessionId: that.gameSessionId
            };
            this.service.request({
                url: "/api/v1/user-data/remove/" + key,
                method: "POST",
                data: dataSpec,
                callback: removeCallback,
                requestHandler: this.requestHandler,
                encrypt: true
            }, "userdata.remove")
        };
        UserDataManager.prototype.removeAll = function(callbackFn, errorCallbackFn) {
            var that = this;
            var removeAllCallback = function removeAllCallbackFn(jsonResponse, status) {
                if (status === 200) {
                    callbackFn()
                } else {
                    var errorCallback = errorCallbackFn || that.errorCallbackFn;
                    errorCallback("UserDataManager.removeAll failed with status " + status + ": " + jsonResponse.msg, status, that.removeAll, [callbackFn])
                }
            };
            var dataSpec = {
                gameSessionId: that.gameSessionId
            };
            this.service.request({
                url: "/api/v1/user-data/remove-all",
                method: "POST",
                data: dataSpec,
                callback: removeAllCallback,
                requestHandler: this.requestHandler,
                encrypt: true
            }, "userdata.removeall")
        };
        UserDataManager.create = function(requestHandler, gameSession, errorCallbackFn) {
            var userdataManager;
            if (!TurbulenzServices.available()) {
                return null
            }
            userdataManager = new UserDataManager;
            userdataManager.requestHandler = requestHandler;
            userdataManager.errorCallbackFn = errorCallbackFn || TurbulenzServices.defaultErrorCallback;
            userdataManager.gameSessionId = gameSession.gameSessionId;
            userdataManager.service = TurbulenzServices.getService("userdata");
            return userdataManager
        };
        UserDataManager.version = 1;
        return UserDataManager
    }();
    var GameProfileManager = function() {
        function GameProfileManager() {
            this.maxValueSize = 1024;
            this.maxGetListUsernames = 64
        }
        GameProfileManager.prototype.set = function(value, callbackFn, errorCallbackFn) {
            if (!value) {
                return this.remove(callbackFn, errorCallbackFn)
            }
            if (value.length > this.maxValueSize) {
                return false
            }
            var that = this;
            var setCallback = function setCallbackFn(jsonResponse, status) {
                if (status === 200) {
                    if (callbackFn) {
                        callbackFn()
                    }
                } else {
                    var errorCallback = errorCallbackFn || that.errorCallbackFn;
                    errorCallback("GameProfileManager.set failed with status " + status + ": " + jsonResponse.msg, status, that.set, [value, callbackFn])
                }
            };
            var dataSpec = {
                value: value,
                gameSessionId: that.gameSessionId
            };
            var url = "/api/v1/game-profile/set";
            this.service.request({
                url: url,
                method: "POST",
                data: dataSpec,
                callback: setCallback,
                requestHandler: this.requestHandler,
                encrypt: true
            }, "gameprofile.set");
            return true
        };
        GameProfileManager.prototype.remove = function(callbackFn, errorCallbackFn) {
            var that = this;

            function removeCallbackFn(jsonResponse, status) {
                if (status === 200 || status === 404) {
                    if (callbackFn) {
                        callbackFn()
                    }
                } else {
                    var errorCallback = errorCallbackFn || that.errorCallbackFn;
                    errorCallback("GameProfileManager.remove failed with status " + status + ": " + jsonResponse.msg, status, that.remove, [callbackFn])
                }
            }
            var dataSpec = {
                gameSessionId: that.gameSessionId
            };
            var url = "/api/v1/game-profile/remove";
            this.service.request({
                url: url,
                method: "POST",
                data: dataSpec,
                callback: removeCallbackFn,
                requestHandler: this.requestHandler,
                encrypt: true
            }, "gameprofile.remove");
            return true
        };
        GameProfileManager.prototype.get = function(username, callbackFn, errorCallbackFn) {
            var callbackWrapper = function callbackWrapperFn(gameProfiles) {
                if (gameProfiles.hasOwnProperty(username)) {
                    callbackFn(username, gameProfiles[username])
                } else {
                    callbackFn(username, null)
                }
            };
            return this.getList([username], callbackWrapper, errorCallbackFn)
        };
        GameProfileManager.prototype.getList = function(usernames, callbackFn, errorCallbackFn) {
            if (usernames.length > this.maxGetListUsernames) {
                return false
            }
            var that = this;
            var getCallback = function getCallbackFn(jsonResponse, status) {
                if (status === 200) {
                    callbackFn(jsonResponse.data.profiles)
                } else if (status === 404) {
                    callbackFn(null)
                } else {
                    var errorCallback = errorCallbackFn || that.errorCallbackFn;
                    errorCallback("GameProfileManager.getList failed with status " + status + ": " + jsonResponse.msg, status, that.getList, [callbackFn])
                }
            };
            var dataSpec = {
                gameSessionId: that.gameSessionId,
                usernames: JSON.stringify(usernames)
            };
            this.service.request({
                url: "/api/v1/game-profile/read",
                method: "GET",
                data: dataSpec,
                callback: getCallback,
                requestHandler: this.requestHandler
            });
            return true
        };
        GameProfileManager.create = function(requestHandler, gameSession, errorCallbackFn) {
            if (!TurbulenzServices.available()) {
                return null
            }
            var gameProfileManager = new GameProfileManager;
            gameProfileManager.requestHandler = requestHandler;
            gameProfileManager.errorCallbackFn = errorCallbackFn || TurbulenzServices.defaultErrorCallback;
            gameProfileManager.gameSessionId = gameSession.gameSessionId;
            gameProfileManager.service = TurbulenzServices.getService("gameProfile");
            return gameProfileManager
        };
        GameProfileManager.version = 1;
        return GameProfileManager
    }();
    var LeaderboardManager = function() {
        function LeaderboardManager() {
            this.getTypes = {
                top: "top",
                near: "near",
                above: "above",
                below: "below"
            };
            this.maxGetSize = 32
        }
        LeaderboardManager.prototype.getOverview = function(spec, callbackFn, errorCallbackFn) {
            var errorCallback = errorCallbackFn || this.errorCallbackFn;
            if (!this.meta) {
                errorCallback("The leaderboard manager failed to initialize properly.");
                return
            }
            var that = this;
            var getOverviewCallback = function getOverviewCallbackFn(jsonResponse, status) {
                if (status === 200) {
                    var overview = jsonResponse.data;
                    var overviewLength = overview.length;
                    for (var i = 0; i < overviewLength; i += 1) {
                        var leaderboard = overview[i];
                        if (leaderboard.hasOwnProperty("score")) {
                            that.meta[leaderboard.key].bestScore = leaderboard.score
                        }
                    }
                    callbackFn(overview)
                } else {
                    errorCallback("LeaderboardManager.getKeys failed with status " + status + ": " + jsonResponse.msg, status, that.getOverview, [spec, callbackFn])
                }
            };
            var dataSpec = {};
            if (spec.friendsOnly) {
                dataSpec.friendsonly = spec.friendsOnly && 1
            }
            this.service.request({
                url: "/api/v1/leaderboards/scores/read/" + that.gameSession.gameSlug,
                method: "GET",
                data: dataSpec,
                callback: getOverviewCallback,
                requestHandler: this.requestHandler
            }, "leaderboard.read")
        };
        LeaderboardManager.prototype.getAggregates = function(spec, callbackFn, errorCallbackFn) {
            var errorCallback = errorCallbackFn || this.errorCallbackFn;
            if (!this.meta) {
                errorCallback("The leaderboard manager failed to initialize properly.");
                return
            }
            var that = this;
            var getAggregatesCallback = function getAggregatesCallbackFn(jsonResponse, status) {
                if (status === 200) {
                    var aggregates = jsonResponse.data;
                    callbackFn(aggregates)
                } else {
                    errorCallback("LeaderboardManager.getKeys failed with status " + status + ": " + jsonResponse.msg, status, that.getAggregates, [spec, callbackFn, errorCallbackFn])
                }
            };
            var dataSpec = {};
            this.service.request({
                url: "/api/v1/leaderboards/aggregates/read/" + that.gameSession.gameSlug,
                method: "GET",
                data: dataSpec,
                callback: getAggregatesCallback,
                requestHandler: this.requestHandler
            }, "leaderboard.aggregates")
        };
        LeaderboardManager.prototype.getRaw = function(key, spec, callbackFn, errorCallbackFn) {
            var that = this;
            var errorCallback = errorCallbackFn || this.errorCallbackFn;
            var getCallback = function getCallbackFn(jsonResponse, status) {
                if (status === 200) {
                    var data = jsonResponse.data;
                    callbackFn(data)
                } else {
                    errorCallback("LeaderboardManager.get failed with status " + status + ": " + jsonResponse.msg, status, that.get, [key, spec, callbackFn])
                }
            };
            this.service.request({
                url: "/api/v1/leaderboards/scores/read/" + that.gameSession.gameSlug + "/" + key,
                method: "GET",
                data: spec,
                callback: getCallback,
                requestHandler: this.requestHandler
            }, "leaderboard.read");
            return true
        };
        LeaderboardManager.prototype.get = function(key, spec, callbackFn, errorCallbackFn) {
            var errorCallback = errorCallbackFn || this.errorCallbackFn;
            if (!this.meta) {
                errorCallback("The leaderboard manager failed to initialize properly.");
                return false
            }
            var meta = this.meta[key];
            if (!meta) {
                errorCallback("No leaderboard with the name '" + key + "' exists.");
                return false
            }
            var dataSpec = {};
            if (spec.numNear) {
                dataSpec.type = this.getTypes.near;
                dataSpec.size = spec.numNear * 2 + 1
            }
            if (spec.numTop) {
                dataSpec.type = this.getTypes.top;
                dataSpec.size = spec.numTop
            }
            if (spec.size) {
                dataSpec.size = spec.size
            }
            if (!dataSpec.size) {
                dataSpec.size = 9
            }
            if (dataSpec.size > this.maxGetSize) {
                throw new Error("Leaderboard get request size must be smaller than " + this.maxGetSize)
            }
            if (spec.friendsOnly) {
                dataSpec.friendsonly = spec.friendsOnly && 1
            }
            if (spec.type) {
                dataSpec.type = spec.type
            }
            if (spec.hasOwnProperty("score")) {
                dataSpec.score = spec.score
            }
            if (spec.hasOwnProperty("time")) {
                dataSpec.time = spec.time
            }
            var that = this;
            var callbackWrapper = function callbackWrapperFn(data) {
                var lbr = LeaderboardResult.create(that, key, dataSpec, data);
                callbackFn(key, lbr)
            };
            return this.getRaw(key, dataSpec, callbackWrapper, errorCallbackFn)
        };
        LeaderboardManager.prototype.set = function(key, score, callbackFn, errorCallbackFn) {
            var errorCallback = errorCallbackFn || this.errorCallbackFn;
            if (!this.meta) {
                errorCallback("The leaderboard manager failed to initialize properly.");
                return
            }
            var meta = this.meta[key];
            if (!meta) {
                errorCallback("No leaderboard with the name '" + key + "' exists.");
                return
            }
            if (typeof score !== "number" || isNaN(score)) {
                throw new Error("Score must be a number.")
            }
            if (score < 0) {
                throw new Error("Score cannot be negative.")
            }
            var sortBy = meta.sortBy;
            var bestScore = meta.bestScore;
            if (bestScore && (sortBy === 1 && score <= bestScore || sortBy === -1 && score >= bestScore)) {
                TurbulenzEngine.setTimeout(function() {
                    callbackFn(key, score, false, bestScore)
                }, 0);
                return
            }
            var that = this;
            var setCallback = function setCallbackFn(jsonResponse, status) {
                if (status === 200) {
                    var data = jsonResponse.data;
                    var bestScore = data.bestScore || data.lastScore || null;
                    var newBest = data.newBest || false;
                    if (newBest) {
                        bestScore = score;
                        var scoreData = {
                            key: key,
                            title: meta.title,
                            sortBy: meta.sortBy,
                            score: score,
                            prevBest: data.prevBest,
                            gameSlug: that.gameSession.gameSlug
                        };
                        TurbulenzBridge.updateLeaderBoard(scoreData)
                    }
                    meta.bestScore = bestScore;
                    callbackFn(key, score, newBest, bestScore)
                } else {
                    errorCallback("LeaderboardManager.set failed with status " + status + ": " + jsonResponse.msg, status, that.set, [key, score, callbackFn])
                }
            };
            var dataSpec = {
                score: score,
                gameSessionId: that.gameSessionId,
                key: undefined
            };
            var url = "/api/v1/leaderboards/scores/set/" + key;
            this.service.request({
                url: url,
                method: "POST",
                data: dataSpec,
                callback: setCallback,
                requestHandler: this.requestHandler,
                encrypt: true
            }, "leaderboard.set")
        };
        LeaderboardManager.prototype.reset = function(callbackFn, errorCallbackFn) {
            var errorCallback = errorCallbackFn || this.errorCallbackFn;
            if (!this.meta) {
                errorCallback("The leaderboard manager failed to initialize properly.");
                return
            }
            var that = this;
            var resetCallback = function resetCallbackFn(jsonResponse, status) {
                if (status === 200) {
                    var meta = that.meta;
                    var m;
                    for (m in meta) {
                        if (meta.hasOwnProperty(m)) {
                            delete meta[m].bestScore
                        }
                    }
                    if (callbackFn) {
                        callbackFn()
                    }
                } else {
                    errorCallback("LeaderboardManager.reset failed with status " + status + ": " + jsonResponse.msg, status, that.reset, [callbackFn])
                }
            };
            this.service.request({
                url: "/api/v1/leaderboards/scores/remove-all/" + this.gameSession.gameSlug,
                method: "POST",
                callback: resetCallback,
                requestHandler: this.requestHandler
            }, "leaderboard.removeall")
        };
        LeaderboardManager.create = function(requestHandler, gameSession, leaderboardMetaReceived, errorCallbackFn) {
            if (!TurbulenzServices.available()) {
                TurbulenzEngine.setTimeout(function() {
                    if (errorCallbackFn) {
                        errorCallbackFn("TurbulenzServices.createLeaderboardManager could not load leaderboards meta data")
                    }
                }, 0);
                return null
            }
            var leaderboardManager = new LeaderboardManager;
            leaderboardManager.gameSession = gameSession;
            leaderboardManager.gameSessionId = gameSession.gameSessionId;
            leaderboardManager.errorCallbackFn = errorCallbackFn || TurbulenzServices.defaultErrorCallback;
            leaderboardManager.service = TurbulenzServices.getService("leaderboards");
            leaderboardManager.requestHandler = requestHandler;
            leaderboardManager.ready = false;
            leaderboardManager.service.request({
                url: "lb.json",
                method: "GET",
                callback: function createLeaderboardManagerAjaxErrorCheck(jsonResponse, status) {
                    if (status === 200) {
                        var metaArray = jsonResponse.data;
                        if (metaArray) {
                            leaderboardManager.meta = {};
                            var metaLength = metaArray.length;
                            var i;
                            for (i = 0; i < metaLength; i += 1) {
                                var board = metaArray[i];
                                leaderboardManager.meta[board.key] = board
                            }
                        }
                        leaderboardManager.ready = true;
                        if (leaderboardMetaReceived) {
                            leaderboardMetaReceived(leaderboardManager)
                        }
                    } else {
                        leaderboardManager.errorCallbackFn("TurbulenzServices.createLeaderboardManager " + "error with HTTP status " + status + ": " + jsonResponse.msg, status)
                    }
                },
                requestHandler: requestHandler,
                neverDiscard: true
            }, "leaderboard.meta");
            return leaderboardManager
        };
        LeaderboardManager.version = 1;
        return LeaderboardManager
    }();
    var LeaderboardResult = function() {
        function LeaderboardResult() {}
        LeaderboardResult.prototype.computeOverlap = function() {
            var results = this.results;
            var overlap = 0;
            if (results.top || results.bottom) {
                var ranking = results.ranking;
                var rankingLength = ranking.length;
                var sortBy = this.leaderboardManager.meta[this.key].sortBy;
                var aboveType = this.leaderboardManager.getTypes.above;
                var specScore = results.spec.score;
                var specTime = results.spec.time;
                var i;
                for (i = 0; i < rankingLength; i += 1) {
                    var rank = ranking[i];
                    if (rank.score * sortBy < specScore * sortBy || rank.score === specScore && rank.time >= specTime) {
                        if (results.spec.type === aboveType) {
                            overlap = rankingLength - i
                        } else {
                            overlap = i + 1
                        }
                        break
                    }
                }
            }
            results.overlap = overlap
        };
        LeaderboardResult.prototype.getPageOffset = function(type, offsetIndex, callbackFn, errorCallbackFn) {
            var offsetScore = this.results.ranking[offsetIndex];
            if (!offsetScore) {
                TurbulenzEngine.setTimeout(callbackFn, 0);
                return false
            }
            var newSpec = {
                type: type,
                score: offsetScore.score,
                time: offsetScore.time,
                size: this.requestSize,
                friendsonly: this.originalSpec.friendsOnly && 1 || 0
            };
            this.spec = newSpec;
            var that = this;

            function parseResults(data) {
                that.parseResults(that.key, newSpec, data);
                that.computeOverlap();
                callbackFn()
            }
            this.leaderboardManager.getRaw(this.key, newSpec, parseResults, errorCallbackFn);
            return true
        };
        LeaderboardResult.prototype.viewOperationBegin = function() {
            if (this.viewLock) {
                return false
            }
            this.viewLock = true;
            return true
        };
        LeaderboardResult.prototype.viewOperationEnd = function(callbackFn) {
            this.viewLock = false;
            var that = this;

            function callbackWrapperFn() {
                callbackFn(that.key, that)
            }
            if (callbackFn) {
                TurbulenzEngine.setTimeout(callbackWrapperFn, 0)
            }
        };
        LeaderboardResult.prototype.wrapViewOperationError = function(errorCallbackFn) {
            var that = this;
            return function errorWrapper(errorMsg, httpStatus, calledByFn, calledByParams) {
                that.viewLock = false;
                errorCallbackFn(errorMsg, httpStatus, calledByFn, calledByParams)
            }
        };
        LeaderboardResult.prototype.refresh = function(callbackFn, errorCallbackFn) {
            if (!this.viewOperationBegin()) {
                return false
            }
            var that = this;

            function parseResults(data) {
                that.parseResults(that.key, that.spec, data);
                that.computeOverlap();
                that.invalidView = true;
                if (that.onSlidingWindowUpdate) {
                    that.onSlidingWindowUpdate()
                }
                that.viewOperationEnd(callbackFn)
            }
            this.leaderboardManager.getRaw(this.key, this.spec, parseResults, this.wrapViewOperationError(errorCallbackFn));
            return true
        };
        LeaderboardResult.prototype.moveUp = function(offset, callbackFn, errorCallbackFn) {
            if (!this.viewOperationBegin()) {
                return false
            }
            var that = this;

            function newResult() {
                var results = that.results;
                that.viewTop = Math.max(0, results.ranking.length - that.viewSize - results.overlap);
                that.invalidView = true;
                if (that.onSlidingWindowUpdate) {
                    that.onSlidingWindowUpdate()
                }
                that.viewOperationEnd(callbackFn)
            }
            if (this.viewTop - offset < 0) {
                if (this.results.top) {
                    this.viewTop = 0;
                    this.viewOperationEnd(callbackFn)
                } else {
                    this.getPageOffset(this.leaderboardManager.getTypes.above, this.viewTop + this.viewSize - offset, newResult, this.wrapViewOperationError(errorCallbackFn))
                }
                return true
            }
            this.viewTop -= offset;
            this.invalidView = true;
            this.viewOperationEnd(callbackFn);
            return true
        };
        LeaderboardResult.prototype.moveDown = function(offset, callbackFn, errorCallbackFn) {
            if (!this.viewOperationBegin()) {
                return false
            }
            var that = this;

            function newResult() {
                var results = that.results;
                that.viewTop = Math.min(results.overlap, Math.max(results.ranking.length - that.viewSize, 0));
                that.invalidView = true;
                if (that.onSlidingWindowUpdate) {
                    that.onSlidingWindowUpdate()
                }
                that.viewOperationEnd(callbackFn)
            }
            var results = this.results;
            if (this.viewTop + this.viewSize + offset > results.ranking.length) {
                if (results.bottom) {
                    var orginalViewTop = this.viewTop;
                    this.viewTop = Math.max(results.ranking.length - this.viewSize, 0);
                    this.invalidView = this.invalidView || this.viewTop !== orginalViewTop;
                    this.viewOperationEnd(callbackFn)
                } else {
                    this.getPageOffset(this.leaderboardManager.getTypes.below, this.viewTop + offset - 1, newResult, this.wrapViewOperationError(errorCallbackFn))
                }
                return true
            }
            this.viewTop += offset;
            this.invalidView = true;
            this.viewOperationEnd(callbackFn);
            return true
        };
        LeaderboardResult.prototype.pageUp = function(callbackFn, errorCallbackFn) {
            return this.moveUp(this.viewSize, callbackFn, errorCallbackFn)
        };
        LeaderboardResult.prototype.pageDown = function(callbackFn, errorCallbackFn) {
            return this.moveDown(this.viewSize, callbackFn, errorCallbackFn)
        };
        LeaderboardResult.prototype.scrollUp = function(callbackFn, errorCallbackFn) {
            return this.moveUp(1, callbackFn, errorCallbackFn)
        };
        LeaderboardResult.prototype.scrollDown = function(callbackFn, errorCallbackFn) {
            return this.moveDown(1, callbackFn, errorCallbackFn)
        };
        LeaderboardResult.prototype.getView = function() {
            if (this.invalidView) {
                var viewTop = this.viewTop;
                var viewSize = this.viewSize;
                var results = this.results;
                var ranking = results.ranking;
                var rankingLength = ranking.length;
                var playerIndex = null;
                if (results.playerIndex !== undefined) {
                    playerIndex = results.playerIndex - viewTop;
                    if (playerIndex < 0 || playerIndex >= viewSize) {
                        playerIndex = null
                    }
                }
                this.view = {
                    ranking: ranking.slice(viewTop, Math.min(viewTop + viewSize, rankingLength)),
                    top: results.top && viewTop === 0,
                    bottom: results.bottom && viewTop >= rankingLength - viewSize,
                    player: results.player,
                    playerIndex: playerIndex
                }
            }
            return this.view
        };
        LeaderboardResult.prototype.getSlidingWindow = function() {
            return this.results
        };
        LeaderboardResult.prototype.parseResults = function(key, spec, data) {
            var results = {
                spec: spec,
                overlap: null
            };
            var player = results.player = data.player;
            var ranking = results.ranking = data.ranking;
            var entities = data.entities;
            var playerUsername;
            if (player) {
                this.leaderboardManager.meta[key].bestScore = player.score;
                if (entities) {
                    player.user = entities[player.user]
                }
                playerUsername = player.user.username
            }
            var rankingLength = ranking.length;
            var i;
            for (i = 0; i < rankingLength; i += 1) {
                var rank = ranking[i];
                if (entities) {
                    rank.user = entities[rank.user]
                }
                if (rank.user.username === playerUsername) {
                    results.playerIndex = i
                }
            }
            results.top = data.top;
            results.bottom = data.bottom;
            this.results = results;
            return results
        };
        LeaderboardResult.create = function(leaderboardManager, key, spec, data) {
            var leaderboardResult = new LeaderboardResult;
            leaderboardResult.leaderboardManager = leaderboardManager;
            leaderboardResult.key = key;
            spec.friendsOnly = 0 !== spec.friendsonly;
            delete spec.friendsonly;
            leaderboardResult.originalSpec = spec;
            leaderboardResult.spec = spec;
            var results = leaderboardResult.results = leaderboardResult.parseResults(key, spec, data);
            leaderboardResult.viewTop = 0;
            leaderboardResult.viewSize = spec.size;
            leaderboardResult.viewLock = false;
            leaderboardResult.view = {
                player: results.player,
                ranking: results.ranking,
                playerIndex: results.playerIndex,
                top: results.top,
                bottom: results.bottom
            };
            leaderboardResult.invalidView = false;
            leaderboardResult.onSlidingWindowUpdate = null;
            return leaderboardResult
        };
        return LeaderboardResult
    }();
    LeaderboardResult.prototype.version = 1;
    LeaderboardResult.prototype.requestSize = 64;
    var BadgeManager = function() {
        function BadgeManager() {}
        BadgeManager.prototype.listUserBadges = function(callbackFn, errorCallbackFn) {
            var that = this;
            var cb = function cbFn(jsonResponse, status) {
                if (status === 200) {
                    callbackFn(jsonResponse.data)
                } else if (status === 404) {
                    callbackFn(null)
                } else {
                    var errorCallback = errorCallbackFn || that.errorCallbackFn;
                    errorCallback("Badges.listUserBadges failed with status " + status + ": " + jsonResponse.msg, status, [callbackFn])
                }
            };
            this.service.request({
                url: "badge.json",
                method: "GET",
                callback: cb,
                requestHandler: this.requestHandler
            }, "badge.read")
        };
        BadgeManager.prototype.awardUserBadge = function(badge_key, callbackFn, errorCallbackFn) {
            this.addUserBadge(badge_key, null, callbackFn, errorCallbackFn)
        };
        BadgeManager.prototype.updateUserBadgeProgress = function(badge_key, current, callbackFn, errorCallbackFn) {
            var that = this;
            if (current && typeof current === "number") {
                this.addUserBadge(badge_key, current, callbackFn, errorCallbackFn)
            } else {
                var errorCallback = errorCallbackFn || that.errorCallbackFn;
                errorCallback("Badges.updateUserBadgeProgress expects a numeric value for current", 400, [badge_key, current, callbackFn])
            }
        };
        BadgeManager.prototype.addUserBadge = function(badge_key, current, callbackFn, errorCallbackFn) {
            var that = this;
            var cb = function cbFn(jsonResponse, status) {
                if (status === 200) {
                    var userbadge = jsonResponse.data;
                    userbadge.gameSlug = that.gameSession.gameSlug;
                    TurbulenzBridge.updateUserBadge(userbadge);
                    callbackFn(userbadge)
                } else {
                    var errorCallback = errorCallbackFn || that.errorCallbackFn;
                    errorCallback("Badges.addUserBadge failed with status " + status + ": " + jsonResponse.msg, status, [badge_key, current, callbackFn])
                }
            };
            var dataSpec = {};
            dataSpec.gameSessionId = this.gameSessionId;
            dataSpec.badge_key = badge_key;
            var url = "/api/v1/badges/progress/add/" + this.gameSession.gameSlug;
            if (current) {
                dataSpec.current = current
            }
            this.service.request({
                url: url,
                method: "POST",
                data: dataSpec,
                callback: cb,
                requestHandler: this.requestHandler,
                encrypt: true
            }, "badge.add")
        };
        BadgeManager.prototype.listBadges = function(callbackFn, errorCallbackFn) {
            var that = this;
            var cb = function cbFn(jsonResponse, status) {
                if (status === 200) {
                    callbackFn(jsonResponse.data)
                } else if (status === 404) {
                    callbackFn(null)
                } else {
                    var errorCallback = errorCallbackFn || that.errorCallbackFn;
                    errorCallback("Badges.listBadges failed with status " + status + ": " + jsonResponse.msg, status, [callbackFn])
                }
            };
            this.service.request({
                url: "/api/v1/badges/read/" + that.gameSession.gameSlug,
                method: "GET",
                callback: cb,
                requestHandler: this.requestHandler
            }, "badge.meta")
        };
        BadgeManager.prototype.errorCallbackFn = function() {
            var x = Array.prototype.slice.call(arguments);
            Utilities.log("BadgeManager error: ", x)
        };
        BadgeManager.create = function(requestHandler, gameSession) {
            if (!TurbulenzServices.available()) {
                return null
            }
            var badgeManager = new BadgeManager;
            badgeManager.gameSession = gameSession;
            badgeManager.gameSessionId = gameSession.gameSessionId;
            badgeManager.service = TurbulenzServices.getService("badges");
            badgeManager.requestHandler = requestHandler;
            return badgeManager
        };
        BadgeManager.version = 1;
        return BadgeManager
    }();
    var StoreManager = function() {
        function StoreManager() {}
        StoreManager.prototype.requestUserItems = function(callbackFn, errorCallbackFn) {
            var that = this;
            var requestUserItemsCallback = function requestUserItemsCallbackFn(jsonResponse, status) {
                if (status === 200) {
                    that.userItems = jsonResponse.data.userItems;
                    if (callbackFn) {
                        callbackFn(jsonResponse.userItems)
                    }
                } else {
                    var errorCallback = errorCallbackFn || that.errorCallbackFn;
                    if (errorCallback) {
                        errorCallback("StoreManager.requestUserItems failed with " + "status " + status + ": " + jsonResponse.msg, status, that.requestUserItems, [callbackFn, errorCallbackFn])
                    }
                }
            };
            var dataSpec = {
                token: this.userItemsRequestToken.next(),
                gameSessionId: this.gameSessionId
            };
            this.service.request({
                url: "items.json",
                method: "GET",
                data: dataSpec,
                callback: requestUserItemsCallback,
                requestHandler: this.requestHandler,
                encrypt: true
            }, "store.useritems")
        };
        StoreManager.prototype.getUserItems = function() {
            return this.userItems
        };
        StoreManager.prototype.getItemsSortedDict = function(items) {
            var itemsArray = [];
            var sortedItemsDict = {};
            var itemKey;
            var item;
            for (itemKey in items) {
                if (items.hasOwnProperty(itemKey)) {
                    item = items[itemKey];
                    item.key = itemKey;
                    itemsArray[item.index] = item
                }
            }
            var i;
            var itemsLength = itemsArray.length;
            for (i = 0; i < itemsLength; i += 1) {
                item = itemsArray[i];
                sortedItemsDict[item.key] = item
            }
            return sortedItemsDict
        };
        StoreManager.prototype.getOfferings = function() {
            return this.getItemsSortedDict(this.offerings)
        };
        StoreManager.prototype.getResources = function() {
            return this.getItemsSortedDict(this.resources)
        };
        StoreManager.prototype.getItems = function() {
            return this.getOfferings()
        };
        StoreManager.prototype.updateBasket = function(callback) {
            var token = null;
            if (callback) {
                token = this.basketUpdateRequestToken.next();
                this.updateBasketCallbacks[token] = callback
            }
            var that = this;
            TurbulenzEngine.setTimeout(function yieldOnUpdate() {
                TurbulenzBridge.triggerBasketUpdate(JSON.stringify({
                    basketItems: that.basket.items,
                    token: token
                }))
            }, 0)
        };
        StoreManager.prototype.addToBasket = function(key, amount) {
            var offering = this.offerings[key];
            if (!offering || !offering.available || Math.floor(amount) !== amount || amount <= 0) {
                return false
            }
            var resources = this.resources;

            function isOwnOffering(offering) {
                var outputKey;
                var output = offering.output;
                for (outputKey in output) {
                    if (output.hasOwnProperty(outputKey)) {
                        if (resources[outputKey].type !== "own") {
                            return false
                        }
                    }
                }
                return true
            }
            var userItems = this.userItems;

            function allOutputOwned(offering) {
                var outputKey;
                var output = offering.output;
                for (outputKey in output) {
                    if (output.hasOwnProperty(outputKey)) {
                        if (!userItems.hasOwnProperty(outputKey) || userItems[outputKey].amount === 0) {
                            return false
                        }
                    }
                }
                return true
            }
            var basketItems = this.basket.items;
            var oldBasketAmount = 0;
            if (basketItems[key]) {
                oldBasketAmount = basketItems[key].amount
            } else {
                oldBasketAmount = 0
            }
            var newBasketAmount = oldBasketAmount + amount;
            var ownOffering = isOwnOffering(offering);
            if (ownOffering && newBasketAmount > 1) {
                newBasketAmount = 1;
                if (oldBasketAmount === 1) {
                    return false
                }
            }
            if (newBasketAmount <= 0 || ownOffering && allOutputOwned(offering)) {
                return false
            }
            basketItems[key] = {
                amount: newBasketAmount
            };
            return true
        };
        StoreManager.prototype.removeFromBasket = function(key, amount) {
            if (!this.offerings[key] || Math.floor(amount) !== amount || amount <= 0) {
                return false
            }
            var basketItem = this.basket.items[key];
            if (!basketItem || basketItem.amount <= 0) {
                return false
            }
            var newAmount = basketItem.amount - amount;
            if (newAmount <= 0) {
                delete this.basket.items[key]
            } else {
                this.basket.items[key] = {
                    amount: newAmount
                }
            }
            return true
        };
        StoreManager.prototype.emptyBasket = function() {
            this.basket.items = {}
        };
        StoreManager.prototype.isBasketEmpty = function() {
            var key;
            var basketItems = this.basket.items;
            for (key in basketItems) {
                if (basketItems.hasOwnProperty(key) && basketItems[key].amount > 0) {
                    return false
                }
            }
            return true
        };
        StoreManager.prototype.showConfirmPurchase = function() {
            if (this.isBasketEmpty()) {
                return false
            }
            this.updateBasket(function showConfirmPurchaseBasketUpdate() {
                TurbulenzBridge.triggerShowConfirmPurchase()
            });
            return true
        };
        StoreManager.prototype.consume = function(key, consumeAmount, callbackFn, errorCallbackFn) {
            var that = this;
            var consumeItemsCallback = function consumeItemsCallbackFn(jsonResponse, status) {
                if (status === 200) {
                    that.userItems = jsonResponse.data.userItems;
                    if (callbackFn) {
                        callbackFn(jsonResponse.data.consumed)
                    }
                    TurbulenzBridge.triggerUserStoreUpdate(JSON.stringify(that.userItems))
                } else {
                    var errorCallback = errorCallbackFn || that.errorCallbackFn;
                    if (errorCallback) {
                        errorCallback("StoreManager.consume failed with status " + status + ": " + jsonResponse.msg, status, that.consume, [callbackFn, errorCallbackFn])
                    }
                }
            };
            var dataSpec = {
                token: this.consumeRequestToken.next(),
                gameSessionId: this.gameSessionId,
                key: key,
                consume: consumeAmount
            };
            this.service.request({
                url: "/api/v1/store/user/items/consume",
                method: "POST",
                data: dataSpec,
                callback: consumeItemsCallback,
                requestHandler: this.requestHandler,
                encrypt: true
            }, "store.useritems-consume")
        };
        StoreManager.create = function(requestHandler, gameSession, storeMetaReceived, errorCallbackFn) {
            if (!TurbulenzServices.available()) {
                TurbulenzEngine.setTimeout(function() {
                    if (errorCallbackFn) {
                        errorCallbackFn("TurbulenzServices.createStoreManager " + "requires Turbulenz services")
                    }
                }, 0);
                return null
            }
            var storeManager = new StoreManager;
            storeManager.gameSession = gameSession;
            storeManager.gameSessionId = gameSession.gameSessionId;
            storeManager.errorCallbackFn = errorCallbackFn || TurbulenzServices.defaultErrorCallback;
            storeManager.service = TurbulenzServices.getService("store");
            storeManager.requestHandler = requestHandler;
            storeManager.userItemsRequestToken = SessionToken.create();
            storeManager.basketUpdateRequestToken = SessionToken.create();
            storeManager.consumeRequestToken = SessionToken.create();
            storeManager.ready = false;
            storeManager.offerings = null;
            storeManager.resources = null;
            storeManager.basket = null;
            storeManager.userItems = null;
            var calledMetaReceived = false;

            function checkMetaReceived() {
                if (!calledMetaReceived && storeManager.offerings !== null && storeManager.resources !== null && storeManager.basket !== null && storeManager.userItems !== null) {
                    if (storeMetaReceived) {
                        storeMetaReceived(storeManager)
                    }
                    storeManager.ready = true;
                    calledMetaReceived = true
                }
            }
            storeManager.requestUserItems(checkMetaReceived);
            storeManager.onBasketUpdate = null;
            storeManager.updateBasketCallbacks = {};
            var onBasketUpdate = function onBasketUpdateFn(jsonParams) {
                var basket = JSON.parse(jsonParams);
                var token;
                if (basket.token) {
                    token = basket.token;
                    delete basket.token
                }
                storeManager.basket = basket;
                if (token && storeManager.updateBasketCallbacks.hasOwnProperty(token)) {
                    storeManager.updateBasketCallbacks[token]();
                    delete storeManager.updateBasketCallbacks[token]
                }
                if (storeManager.onBasketUpdate) {
                    storeManager.onBasketUpdate(basket)
                }
                checkMetaReceived()
            };
            TurbulenzBridge.setOnBasketUpdate(onBasketUpdate);
            TurbulenzBridge.triggerBasketUpdate();
            var onStoreMeta = function onStoreMetaFn(jsonMeta) {
                var meta = JSON.parse(jsonMeta);
                storeManager.currency = meta.currency;
                storeManager.offerings = meta.items || meta.offerings;
                storeManager.resources = meta.resources;
                checkMetaReceived()
            };
            TurbulenzBridge.setOnStoreMeta(onStoreMeta);
            TurbulenzBridge.triggerFetchStoreMeta();
            storeManager.onSitePurchaseConfirmed = null;

            function onSitePurchaseConfirmed() {
                function gotNewItems() {
                    if (storeManager.onSitePurchaseConfirmed) {
                        storeManager.onSitePurchaseConfirmed()
                    }
                }
                storeManager.requestUserItems(gotNewItems)
            }
            TurbulenzBridge.setOnPurchaseConfirmed(onSitePurchaseConfirmed);
            storeManager.onSitePurchaseRejected = null;
            var onSitePurchaseRejected = function onSitePurchaseRejectedFn() {
                if (storeManager.onSitePurchaseRejected) {
                    storeManager.onSitePurchaseRejected()
                }
            };
            TurbulenzBridge.setOnPurchaseRejected(onSitePurchaseRejected);
            return storeManager
        };
        StoreManager.version = 1;
        return StoreManager
    }();
    var SessionToken = function() {
        function SessionToken() {
            this.randomMax = Math.pow(2, 32)
        }
        SessionToken.prototype.next = function() {
            this.counter += 1;
            var count = this.counter;
            var random = Math.random() * this.randomMax;
            var bytes = this.bytes;
            bytes[0] = random & 255;
            bytes[1] = (random & 65280) >>> 8;
            bytes[2] = (random & 16711680) >>> 16;
            bytes[3] = (random & 4278190080) >>> 24;
            bytes[4] = count & 255;
            bytes[5] = (count & 65280) >>> 8;
            return TurbulenzEngine.base64Encode(bytes)
        };
        SessionToken.create = function() {
            var sessionToken = new SessionToken;
            sessionToken.counter = 0;
            sessionToken.randomGenerator = null;
            sessionToken.bytes = [];
            return sessionToken
        };
        SessionToken.version = 1;
        return SessionToken
    }();
    var MultiPlayerSession = function() {
        function MultiPlayerSession() {}
        MultiPlayerSession.prototype.sendTo = function(destinationID, messageType, messageData) {
            var packet = destinationID + ":" + messageType + ":";
            if (messageData) {
                packet += messageData
            }
            var socket = this.socket;
            if (socket) {
                socket.send(packet)
            } else {
                this.queue.push(packet)
            }
        };
        MultiPlayerSession.prototype.sendToGroup = function(destinationIDs, messageType, messageData) {
            var packet = destinationIDs.join(",") + ":" + messageType + ":";
            if (messageData) {
                packet += messageData
            }
            var socket = this.socket;
            if (socket) {
                socket.send(packet)
            } else {
                this.queue.push(packet)
            }
        };
        MultiPlayerSession.prototype.sendToAll = function(messageType, messageData) {
            var packet = ":" + messageType + ":";
            if (messageData) {
                packet += messageData
            }
            var socket = this.socket;
            if (socket) {
                socket.send(packet)
            } else {
                this.queue.push(packet)
            }
        };
        MultiPlayerSession.prototype.makePublic = function(callbackFn) {
            var sessionId = this.sessionId;
            this.service.request({
                url: "/api/v1/multiplayer/session/make-public",
                method: "POST",
                data: {
                    session: sessionId
                },
                callback: function() {
                    TurbulenzBridge.triggerMultiplayerSessionMakePublic(sessionId);
                    if (callbackFn) {
                        callbackFn.call(arguments)
                    }
                },
                requestHandler: this.requestHandler
            })
        };
        MultiPlayerSession.prototype.destroy = function(callbackFn) {
            var sessionId = this.sessionId;
            if (sessionId) {
                this.sessionId = null;
                var playerId = this.playerId;
                this.playerId = null;
                var gameSessionId = this.gameSessionId;
                this.gameSessionId = null;
                var socket = this.socket;
                if (socket) {
                    this.socket = null;
                    socket.onopen = null;
                    socket.onmessage = null;
                    socket.onclose = null;
                    socket.onerror = null;
                    socket.close();
                    socket = null
                }
                this.queue = null;
                this.onmessage = null;
                this.onclose = null;
                TurbulenzBridge.triggerLeaveMultiplayerSession(sessionId);
                Utilities.ajax({
                    url: "/api/v1/multiplayer/session/leave",
                    method: "POST",
                    data: {
                        session: sessionId,
                        player: playerId,
                        gameSessionId: gameSessionId
                    },
                    callback: callbackFn,
                    requestHandler: this.requestHandler
                })
            } else {
                if (callbackFn) {
                    TurbulenzEngine.setTimeout(callbackFn, 0)
                }
            }
        };
        MultiPlayerSession.prototype.connected = function() {
            return !!this.socket
        };
        MultiPlayerSession.prototype.flushQueue = function() {
            var socket = this.socket;
            var queue = this.queue;
            var numPackets = queue.length;
            for (var n = 0; n < numPackets; n += 1) {
                socket.send(queue[n])
            }
        };
        MultiPlayerSession.create = function(sessionData, createdCB, errorCB) {
            var ms = new MultiPlayerSession;
            ms.sessionId = sessionData.sessionid;
            ms.playerId = sessionData.playerid;
            ms.gameSessionId = sessionData.gameSessionId;
            ms.socket = null;
            ms.queue = [];
            ms.onmessage = null;
            ms.onclose = null;
            ms.requestHandler = sessionData.requestHandler;
            ms.service = TurbulenzServices.getService("multiplayer");
            var numplayers = sessionData.numplayers;
            var serverURL = sessionData.server;
            var socket;
            sessionData = null;
            var multiPlayerOnMessage = function multiPlayerOnMessageFn(packet) {
                var onmessage = ms.onmessage;
                if (onmessage) {
                    var message = packet.data;
                    var firstSplitIndex = message.indexOf(":");
                    var secondSplitIndex = message.indexOf(":", firstSplitIndex + 1);
                    var senderID = message.slice(0, firstSplitIndex);
                    var messageType = message.slice(firstSplitIndex + 1, secondSplitIndex) | 0;
                    var messageData = message.slice(secondSplitIndex + 1);
                    onmessage(senderID, messageType, messageData)
                }
            };
            var multiPlayerConnect = function multiPlayerConnectFn() {
                var multiPlayerConnectionError = function multiPlayerConnectionErrorFn() {
                    if (!socket) {
                        socket = ms.socket
                    }
                    ms.socket = null;
                    if (socket) {
                        socket.onopen = null;
                        socket.onmessage = null;
                        socket.onclose = null;
                        socket.onerror = null;
                        socket = null
                    }
                    var requestCallback = function requestCallbackFn(jsonResponse, status) {
                        if (status === 200) {
                            var reconnectData = jsonResponse.data;
                            numplayers = reconnectData.numplayers;
                            serverURL = reconnectData.server;
                            ms.sessionId = reconnectData.sessionid;
                            ms.playerId = reconnectData.playerid;
                            TurbulenzEngine.setTimeout(multiPlayerConnect, 0)
                        } else {
                            if (errorCB) {
                                errorCB("MultiPlayerSession failed: Server not available", 0);
                                errorCB = null;
                                createdCB = null
                            } else {
                                var onclose = ms.onclose;
                                if (onclose) {
                                    ms.onclose = null;
                                    onclose()
                                }
                            }
                        }
                    };
                    ms.service.request({
                        url: "/api/v1/multiplayer/session/join",
                        method: "POST",
                        data: {
                            session: ms.sessionId,
                            gameSessionId: ms.gameSessionId
                        },
                        callback: requestCallback,
                        requestHandler: ms.requestHandler
                    })
                };
                try {
                    var nd = TurbulenzEngine.getNetworkDevice();
                    if (!nd) {
                        nd = TurbulenzEngine.createNetworkDevice({})
                    }
                    socket = nd.createWebSocket(serverURL);
                    socket.onopen = function multiPlayerOnOpen() {
                        ms.socket = socket;
                        socket.onopen = null;
                        socket.onmessage = multiPlayerOnMessage;
                        socket = null;
                        ms.flushQueue();
                        TurbulenzBridge.triggerJoinedMultiplayerSession({
                            sessionId: ms.sessionId,
                            playerId: ms.playerId,
                            serverURL: serverURL,
                            numplayers: numplayers
                        });
                        if (createdCB) {
                            createdCB(ms, numplayers);
                            createdCB = null;
                            errorCB = null
                        }
                    };
                    socket.onclose = socket.onerror = multiPlayerConnectionError
                } catch (exc) {
                    multiPlayerConnectionError()
                }
            };
            multiPlayerConnect();
            return ms
        };
        MultiPlayerSession.version = 1;
        return MultiPlayerSession
    }();
    var MultiPlayerSessionManager = function() {
        function MultiPlayerSessionManager() {}
        MultiPlayerSessionManager.prototype.createSession = function(numSlots, sessionCreatedFn, errorCallbackFn) {
            var gameSession = this.gameSession;
            var gameSessionId = gameSession.gameSessionId;
            var requestHandler = this.requestHandler;
            var that = this;
            var request = {
                url: "/api/v1/multiplayer/session/create/" + gameSession.gameSlug,
                method: "POST",
                data: {
                    slots: numSlots,
                    gameSessionId: gameSessionId
                },
                requestHandler: requestHandler
            };
            var successCallback = function successCallbackFn(jsonResponse) {
                var mpSession;
                var sessionData = jsonResponse.data;
                sessionData.requestHandler = requestHandler;
                sessionData.gameSessionId = gameSessionId;
                mpSession = MultiPlayerSession.create(sessionData, sessionCreatedFn, errorCallbackFn);
                that.sessionList.push(mpSession)
            };
            this.processRequest("createSession", request, successCallback, errorCallbackFn)
        };
        MultiPlayerSessionManager.prototype.getJoinRequestQueue = function() {
            return TurbulenzServices.multiplayerJoinRequestQueue
        };
        MultiPlayerSessionManager.prototype.joinSession = function(sessionID, sessionJoinedFn, errorCallbackFn) {
            var gameSessionId = this.gameSession.gameSessionId;
            var requestHandler = this.requestHandler;
            var that = this;
            var request = {
                url: "/api/v1/multiplayer/session/join",
                method: "POST",
                data: {
                    session: sessionID,
                    gameSessionId: gameSessionId
                },
                requestHandler: requestHandler
            };
            var successCallback = function successCallbackFn(jsonResponse) {
                var mpSession;
                var sessionData = jsonResponse.data;
                sessionData.requestHandler = requestHandler;
                sessionData.gameSessionId = gameSessionId;
                mpSession = MultiPlayerSession.create(sessionData, sessionJoinedFn, errorCallbackFn);
                that.sessionList.push(mpSession)
            };
            this.processRequest("joinSession", request, successCallback, errorCallbackFn)
        };
        MultiPlayerSessionManager.prototype.joinAnySession = function(sessionJoinedFn, failCallbackFn, errorCallbackFn) {
            var gameSession = this.gameSession;
            var gameSessionId = gameSession.gameSessionId;
            var requestHandler = this.requestHandler;
            var that = this;
            var request = {
                url: "/api/v1/multiplayer/session/join-any/" + gameSession.gameSlug,
                method: "POST",
                data: {
                    gameSessionId: gameSessionId
                },
                requestHandler: requestHandler
            };
            var successCallback = function successCallbackFn(jsonResponse) {
                var sessionData = jsonResponse.data;
                var mpSession;
                if (sessionData.sessionid) {
                    sessionData.requestHandler = requestHandler;
                    sessionData.gameSessionId = gameSessionId;
                    mpSession = MultiPlayerSession.create(sessionData, sessionJoinedFn, errorCallbackFn);
                    that.sessionList.push(mpSession)
                } else {
                    failCallbackFn()
                }
            };
            this.processRequest("joinAnySession", request, successCallback, errorCallbackFn)
        };
        MultiPlayerSessionManager.prototype.joinOrCreateSession = function(numSlots, sessionJoinCreatedFn, errorCallbackFn) {
            var that = this;
            var joinFailedCallback = function joinFailedCallbackFn() {
                that.createSession(numSlots, sessionJoinCreatedFn, errorCallbackFn)
            };
            this.joinAnySession(sessionJoinCreatedFn, joinFailedCallback, errorCallbackFn)
        };
        MultiPlayerSessionManager.prototype.getFriendsSessions = function(querySuccessFn, errorCallbackFn) {
            var requestHandler = this.requestHandler;
            var request = {
                url: "/api/v1/multiplayer/session/list/" + this.gameSession.gameSlug,
                method: "GET",
                requestHandler: requestHandler
            };
            var successCallback = function successCallbackFn(jsonResponse) {
                querySuccessFn(jsonResponse.data)
            };
            this.processRequest("getFriendsSessions", request, successCallback, errorCallbackFn)
        };
        MultiPlayerSessionManager.prototype.destroy = function() {
            var sessionList = this.sessionList;
            var sessionListLength = sessionList.length;
            var i;
            for (i = 0; i < sessionListLength; i += 1) {
                sessionList[i].destroy()
            }
            delete this.sessionList
        };
        MultiPlayerSessionManager.prototype.processRequest = function(source, request, successFn, errorFn) {
            if (!errorFn) {
                errorFn = TurbulenzServices.defaultErrorCallback
            }
            if (TurbulenzServices.available()) {
                request.callback = function requestCallbackFn(jsonResponse, status) {
                    if (status === 200) {
                        successFn(jsonResponse)
                    } else if (errorFn) {
                        errorFn("MultiPlayerSessionManager." + source + " error with HTTP status " + status + ": " + jsonResponse.msg, status)
                    }
                };
                TurbulenzServices.getService("multiplayer").request(request)
            } else {
                if (errorFn) {
                    errorFn(source + " failed: Service not available", 0)
                }
            }
        };
        MultiPlayerSessionManager.create = function(requestHandler, gameSession) {
            var manager = new MultiPlayerSessionManager;
            manager.requestHandler = requestHandler;
            manager.gameSession = gameSession;
            manager.sessionList = [];
            return manager
        };
        return MultiPlayerSessionManager
    }();
    var __extends = this.__extends || function(d, b) {
        for (var p in b)
            if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() {
            this.constructor = d
        }
        __.prototype = b.prototype;
        d.prototype = new __
    };
    var Physics2DConfig = {
        CONTACT_SLOP: .01,
        EFF_MASS_EPSILON: 1e-10,
        ILL_THRESHOLD: 1e5,
        CLIP_EPSILON: 1.65e-10,
        BIAS_COEF: .15,
        STATIC_BIAS_COEF: .75,
        CONT_BIAS_COEF: .5,
        CONT_STATIC_BIAS_COEF: .6,
        BOUNCE_VELOCITY_THRESHOLD: .25,
        STATIC_FRIC_SQ_EPSILON: 1e-4,
        POINT_BIAS_COEF: .5,
        POINT_MAX_ERROR: .2,
        POINT_MAX_ERROR_SQ: .2 * .2,
        POINT_SLOP_SQ: 1e-6,
        POINT_LARGE_ERROR_SQ: .01,
        POINT_LARGE_ERROR_BIAS: .75,
        POINT_LARGE_ERROR_MAX: .4,
        WELD_BIAS_COEF: .5,
        WELD_MAX_LINEAR_ERROR: .2,
        WELD_MAX_ANGULAR_ERROR: .5,
        WELD_MAX_LINEAR_ERROR_SQ: .2 * .2,
        WELD_LINEAR_SLOP_SQ: 1e-6,
        WELD_ANGULAR_SLOP_SQ: 1e-6,
        WELD_LARGE_ERROR_SQ: .01,
        WELD_LARGE_ERROR_BIAS: .75,
        WELD_LARGE_ERROR_MAX: .4,
        ANGLE_BIAS_COEF: .5,
        ANGLE_SLOP_SQ: 1e-6,
        DIST_BIAS_COEF: .5,
        DIST_SLOP_SQ: 1e-6,
        DIST_LARGE_ERROR_SQ: .01,
        DIST_LARGE_ERROR_BIAS: .75,
        LINE_BIAS_COEF: .8,
        LINE_SLOP_SQ: 1e-6,
        LINE_LARGE_ERROR_SQ: .01,
        LINE_LARGE_ERROR_BIAS: .9,
        PULLEY_BIAS_COEF: .5,
        PULLEY_SLOP_SQ: 1e-6,
        PULLEY_LARGE_ERROR_SQ: .01,
        PULLEY_LARGE_ERROR_BIAS: .75,
        MIN_LINEAR_STATIC_SWEEP: .05,
        MIN_ANGULAR_STATIC_SWEEP: .005,
        MIN_LINEAR_BULLET_SWEEP: .5,
        MIN_ANGULAR_BULLET_SWEEP: .05,
        SWEEP_LIMIT: 5e-4,
        SWEEP_SLOP: .05,
        MINIMUM_SWEEP_ADVANCE: 1e-6,
        MAX_SWEEP_ITER: 50,
        EQUAL_SQ_VEL: .2,
        ZERO_ANG_BIAS: .02,
        TOI_SLIP_SCALE: .75,
        DELAYED_DEATH: 30,
        DELTA_ROTATION_EPSILON: 1e-4,
        SLEEP_DELAY: 60,
        SLEEP_LINEAR_SQ: 6e-4,
        SLEEP_ANGULAR_SQ: .001,
        CONTAINS_EPSILON: 1e-6,
        CONTAINS_SQ_EPSILON: 1e-12,
        COLLINEAR_EPSILON: 1e-5,
        COLLINEAR_SQ_EPSILON: 1e-5 * 1e-5,
        NORMALIZE_EPSILON: 1e-6,
        NORMALIZE_SQ_EPSILON: 1e-6 * 1e-6
    };
    var Physics2DMaterial = function() {
        function Physics2DMaterial() {}
        Physics2DMaterial.prototype.getElasticity = function() {
            return this._data[0]
        };
        Physics2DMaterial.prototype.getStaticFriction = function() {
            return this._data[1]
        };
        Physics2DMaterial.prototype.getDynamicFriction = function() {
            return this._data[2]
        };
        Physics2DMaterial.prototype.getRollingFriction = function() {
            return this._data[3]
        };
        Physics2DMaterial.prototype.getDensity = function() {
            return this._data[4]
        };
        Physics2DMaterial.create = function(params) {
            var m = new Physics2DMaterial;
            var elasticity = params && params.elasticity !== undefined ? params.elasticity : 0;
            var staticFriction = params && params.staticFriction !== undefined ? params.staticFriction : 2;
            var dynamicFriction = params && params.dynamicFriction !== undefined ? params.dynamicFriction : 1;
            var rollingFriction = params && params.rollingFriction !== undefined ? params.rollingFriction : .005;
            var density = params && params.density !== undefined ? params.density : 1;
            var data = m._data = new Physics2DDevice.prototype.floatArray(5);
            data[0] = elasticity;
            data[1] = staticFriction;
            data[2] = dynamicFriction;
            data[3] = rollingFriction;
            data[4] = density;
            m.userData = params && params.userData ? params.userData : null;
            return m
        };
        Physics2DMaterial.version = 1;
        return Physics2DMaterial
    }();
    var Physics2DConstraint = function() {
        function Physics2DConstraint() {}
        Physics2DConstraint.prototype._inWorld = function() {};
        Physics2DConstraint.prototype._outWorld = function() {};
        Physics2DConstraint.prototype._pairExists = function(b1, b2) {
            return false
        };
        Physics2DConstraint.prototype._wakeConnected = function() {};
        Physics2DConstraint.prototype._sleepComputation = function(union) {};
        Physics2DConstraint.prototype._preStep = function(deltaTime) {
            return false
        };
        Physics2DConstraint.prototype._warmStart = function() {};
        Physics2DConstraint.prototype._iterateVel = function() {
            return false
        };
        Physics2DConstraint.prototype._iteratePos = function() {
            return false
        };
        Physics2DConstraint.prototype.init = function(con, params) {
            var data = con._data;
            data[0] = params.frequency !== undefined ? params.frequency : 10;
            data[1] = params.damping !== undefined ? params.damping : 1;
            data[2] = params.maxForce !== undefined ? params.maxForce : Number.POSITIVE_INFINITY;
            data[3] = params.maxError !== undefined ? params.maxError : Number.POSITIVE_INFINITY;
            data[4] = -1;
            con._removeOnBreak = params.removeOnBreak !== undefined ? params.removeOnBreak : true;
            con._breakUnderError = params.breakUnderError !== undefined ? params.breakUnderError : false;
            con._breakUnderForce = params.breakUnderForce !== undefined ? params.breakUnderForce : false;
            con._stiff = params.stiff !== undefined ? params.stiff : true;
            con._ignoreInteractions = params.ignoreInteractions !== undefined ? params.ignoreInteractions : false;
            con.sleeping = params.sleeping !== undefined ? params.sleeping : false;
            con._active = params.disabled !== undefined ? !params.disabled : true;
            con.world = null;
            con._islandRoot = null;
            con._islandRank = 0;
            con._island = null;
            con._isBody = false;
            con._wakeTime = 0;
            con._onBreak = [];
            con._onWake = [];
            con._onSleep = [];
            con.userData = params.userData || null
        };
        Physics2DConstraint.prototype.configure = function(params) {
            var data = this._data;
            if (params.frequency !== undefined) {
                data[0] = params.frequency
            }
            if (params.damping !== undefined) {
                data[1] = params.damping
            }
            if (params.maxForce !== undefined) {
                data[2] = params.maxForce
            }
            if (params.maxError !== undefined) {
                data[3] = params.maxError
            }
            if (params.removeOnBreak !== undefined) {
                this._removeOnBreak = params.removeOnBreak
            }
            if (params.breakUnderError !== undefined) {
                this._breakUnderError = params.breakUnderError
            }
            if (params.breakUnderForce !== undefined) {
                this._breakUnderForce = params.breakUnderForce
            }
            if (params.ignoreInteractions !== undefined) {
                this._ignoreInteractions = params.ignoreInteractions
            }
            if (params.stiff !== undefined) {
                this._stiff = params.stiff
            }
            this.wake(true)
        };
        Physics2DConstraint.prototype.addEventListener = function(eventType, callback) {
            var events = eventType === "wake" ? this._onWake : eventType === "sleep" ? this._onSleep : eventType === "break" ? this._onBreak : null;
            if (events === null) {
                return false
            }
            var index = events.indexOf(callback);
            if (index !== -1) {
                return false
            }
            events.push(callback);
            this.wake();
            return true
        };
        Physics2DConstraint.prototype.removeEventListener = function(eventType, callback) {
            var events = eventType === "wake" ? this._onWake : eventType === "sleep" ? this._onSleep : eventType === "break" ? this._onBreak : null;
            if (events === null) {
                return false
            }
            var index = events.indexOf(callback);
            if (index === -1) {
                return false
            }
            events.splice(index, 1);
            this.wake();
            return true
        };
        Physics2DConstraint.prototype.wake = function(automated) {
            if (!this.world) {
                this.sleeping = false;
                return
            }
            this.world._wakeConstraint(this, !automated)
        };
        Physics2DConstraint.prototype.sleep = function() {
            if (!this.world) {
                this.sleeping = true;
                return
            }
            this.world._forceSleepConstraint(this)
        };
        Physics2DConstraint.prototype.isEnabled = function() {
            return this._active
        };
        Physics2DConstraint.prototype.isDisabled = function() {
            return !this._active
        };
        Physics2DConstraint.prototype.enable = function() {
            if (!this._active) {
                this._active = true;
                if (this.world) {
                    this.world._enabledConstraint(this);
                    this.wake(true)
                }
            }
        };
        Physics2DConstraint.prototype.disable = function() {
            if (this._active) {
                if (this.world) {
                    this.wake(false);
                    this.world._disabledConstraint(this)
                }
                this._active = false
            }
        };
        Physics2DConstraint.prototype.getAnchorA = function(dst) {
            if (dst === undefined) {
                dst = new Physics2DDevice.prototype.floatArray(2)
            }
            var data = this._data;
            var INDEX = this._ANCHOR_A;
            dst[0] = data[INDEX];
            dst[1] = data[INDEX + 1];
            return dst
        };
        Physics2DConstraint.prototype.getAnchorB = function(dst) {
            if (dst === undefined) {
                dst = new Physics2DDevice.prototype.floatArray(2)
            }
            var data = this._data;
            var INDEX = this._ANCHOR_B;
            dst[0] = data[INDEX];
            dst[1] = data[INDEX + 1];
            return dst
        };
        Physics2DConstraint.prototype.setAnchorA = function(anchor) {
            var data = this._data;
            var INDEX = this._ANCHOR_A;
            var newX = anchor[0];
            var newY = anchor[1];
            if (newX !== data[INDEX] || newY !== data[INDEX + 1]) {
                data[INDEX] = newX;
                data[INDEX + 1] = newY;
                this.wake(true)
            }
        };
        Physics2DConstraint.prototype.setAnchorB = function(anchor) {
            var data = this._data;
            var INDEX = this._ANCHOR_B;
            var newX = anchor[0];
            var newY = anchor[1];
            if (newX !== data[INDEX] || newY !== data[INDEX + 1]) {
                data[INDEX] = newX;
                data[INDEX + 1] = newY;
                this.wake(true)
            }
        };
        Physics2DConstraint.prototype.rotateAnchor = function(data, body, LOCAL, RELATIVE) {
            var x = data[LOCAL];
            var y = data[LOCAL + 1];
            var cos = body[5];
            var sin = body[5 + 1];
            data[RELATIVE] = cos * x - sin * y;
            data[RELATIVE + 1] = sin * x + cos * y
        };
        Physics2DConstraint.prototype.dtRatio = function(data, deltaTime) {
            var preDt = data[4];
            var dtRatio = preDt === -1 ? 1 : deltaTime / preDt;
            data[4] = deltaTime;
            return dtRatio
        };
        Physics2DConstraint.prototype.twoBodyInWorld = function() {
            this.bodyA.constraints.push(this);
            this.bodyB.constraints.push(this)
        };
        Physics2DConstraint.prototype.twoBodyOutWorld = function() {
            var constraints = this.bodyA.constraints;
            var index = constraints.indexOf(this);
            constraints[index] = constraints[constraints.length - 1];
            constraints.pop();
            constraints = this.bodyB.constraints;
            index = constraints.indexOf(this);
            constraints[index] = constraints[constraints.length - 1];
            constraints.pop()
        };
        Physics2DConstraint.prototype.twoBodyPairExists = function(b1, b2) {
            return b1 === this.bodyA && b2 === this.bodyB || b2 === this.bodyA && b1 === this.bodyB
        };
        Physics2DConstraint.prototype.twoBodyWakeConnected = function() {
            var body = this.bodyA;
            if (body._type === 0) {
                body.wake(true)
            }
            body = this.bodyB;
            if (body._type === 0) {
                body.wake(true)
            }
        };
        Physics2DConstraint.prototype.twoBodySleepComputation = function(union) {
            var body = this.bodyA;
            if (body._type === 0) {
                union(body, this)
            }
            body = this.bodyB;
            if (body._type === 0) {
                union(body, this)
            }
        };
        Physics2DConstraint.prototype._clearCache = function() {};
        Physics2DConstraint.prototype.clearCache = function() {
            var data = this._data;
            data[this._JACC] = 0;
            data[4] = -1
        };
        Physics2DConstraint.prototype.clearCache2 = function() {
            var data = this._data;
            var INDEX = this._JACC;
            data[INDEX] = data[INDEX + 1] = 0;
            data[4] = -1
        };
        Physics2DConstraint.prototype.clearCache3 = function() {
            var data = this._data;
            var INDEX = this._JACC;
            data[INDEX] = data[INDEX + 1] = data[INDEX + 2] = 0;
            data[4] = -1
        };
        Physics2DConstraint.prototype.soft_params = function(data, KMASS, GAMMA, BIAS, deltaTime, breakUnderError) {
            var bias = data[BIAS];
            var bsq = bias * bias;
            var maxError = data[3];
            if (breakUnderError && bsq > maxError * maxError) {
                return true
            }
            var omega = 2 * Math.PI * data[0];
            var gamma = 1 / (deltaTime * omega * (2 * data[1] + omega * deltaTime));
            var iG = 1 / (1 + gamma);
            var biasCoef = deltaTime * omega * omega * gamma;
            data[GAMMA] = gamma * iG;
            data[KMASS] *= iG;
            bias *= biasCoef;
            bsq *= biasCoef * biasCoef;
            if (bsq > maxError * maxError) {
                bsq = maxError / Math.sqrt(bsq);
                bias *= bsq
            }
            data[BIAS] = bias;
            return false
        };
        Physics2DConstraint.prototype.soft_params2 = function(data, KMASS, GAMMA, BIAS, deltaTime, breakUnderError) {
            var biasX = data[BIAS];
            var biasY = data[BIAS + 1];
            var bsq = biasX * biasX + biasY * biasY;
            var maxError = data[3];
            if (breakUnderError && bsq > maxError * maxError) {
                return true
            }
            var omega = 2 * Math.PI * data[0];
            var gamma = 1 / (deltaTime * omega * (2 * data[1] + omega * deltaTime));
            var iG = 1 / (1 + gamma);
            var biasCoef = deltaTime * omega * omega * gamma;
            data[GAMMA] = gamma * iG;
            data[KMASS] *= iG;
            data[KMASS + 1] *= iG;
            data[KMASS + 2] *= iG;
            biasX *= biasCoef;
            biasY *= biasCoef;
            bsq *= biasCoef * biasCoef;
            if (bsq > maxError * maxError) {
                bsq = maxError / Math.sqrt(bsq);
                biasX *= bsq;
                biasY *= bsq
            }
            data[BIAS] = biasX;
            data[BIAS + 1] = biasY;
            return false
        };
        Physics2DConstraint.prototype.soft_params3 = function(data, KMASS, GAMMA, BIAS, deltaTime, breakUnderError) {
            var biasX = data[BIAS];
            var biasY = data[BIAS + 1];
            var biasZ = data[BIAS + 2];
            var bsq = biasX * biasX + biasY * biasY + biasZ * biasZ;
            var maxError = data[3];
            if (breakUnderError && bsq > maxError * maxError) {
                return true
            }
            var omega = 2 * Math.PI * data[0];
            var gamma = 1 / (deltaTime * omega * (2 * data[1] + omega * deltaTime));
            var iG = 1 / (1 + gamma);
            var biasCoef = deltaTime * omega * omega * gamma;
            data[GAMMA] = gamma * iG;
            data[KMASS] *= iG;
            data[KMASS + 1] *= iG;
            data[KMASS + 2] *= iG;
            data[KMASS + 3] *= iG;
            data[KMASS + 4] *= iG;
            data[KMASS + 5] *= iG;
            biasX *= biasCoef;
            biasY *= biasCoef;
            biasZ *= biasCoef;
            bsq *= biasCoef * biasCoef;
            if (bsq > maxError * maxError) {
                bsq = maxError / Math.sqrt(bsq);
                biasX *= bsq;
                biasY *= bsq;
                biasZ *= bsq
            }
            data[BIAS] = biasX;
            data[BIAS + 1] = biasY;
            data[BIAS + 2] = biasZ;
            return false
        };
        Physics2DConstraint.prototype.safe_solve = function(data, KMASS, ERR, IMP) {
            var err = data[ERR];
            var K = data[KMASS];
            data[IMP] = K !== 0 ? err / K : 0
        };
        Physics2DConstraint.prototype.safe_solve2 = function(data, KMASS, ERR, IMP) {
            var errX = data[ERR];
            var errY = data[ERR + 1];
            var Ka = data[KMASS];
            var Kb = data[KMASS + 1];
            var Kc = data[KMASS + 2];
            var det = Ka * Kc - Kb * Kb;
            if (det === 0) {
                data[IMP] = Ka !== 0 ? errX / Ka : 0;
                data[IMP + 1] = Kc !== 0 ? errY / Kc : 0
            } else {
                det = 1 / det;
                data[IMP] = det * (Kc * errX - Kb * errY);
                data[IMP + 1] = det * (Ka * errY - Kb * errX)
            }
        };
        Physics2DConstraint.prototype.safe_solve3 = function(data, KMASS, ERR, IMP) {
            var errX = data[ERR];
            var errY = data[ERR + 1];
            var errZ = data[ERR + 2];
            var Ka = data[KMASS];
            var Kb = data[KMASS + 1];
            var Kc = data[KMASS + 2];
            var Kd = data[KMASS + 3];
            var Ke = data[KMASS + 4];
            var Kf = data[KMASS + 5];
            var A = Kd * Kf - Ke * Ke;
            var B = Kc * Ke - Kb * Kf;
            var C = Kb * Ke - Kc * Kd;
            var det = Ka * A + Kb * B + Kc * C;
            if (det === 0) {
                det = Ka * Kd - Kb * Kb;
                if (det !== 0) {
                    det = 1 / det;
                    data[IMP] = det * (Kd * errX - Kb * errY);
                    data[IMP + 1] = det * (Ka * errY - Kb * errX);
                    data[IMP + 2] = Kf !== 0 ? errZ / Kf : 0;
                    return
                }
                det = Ka * Kf - Kc * Kc;
                if (det !== 0) {
                    det = 1 / det;
                    data[IMP] = det * (Kf * errX - Kc * errZ);
                    data[IMP + 1] = Kd !== 0 ? errY / Kd : 0;
                    data[IMP + 2] = det * (Ka * errZ - Kc * errX);
                    return
                }
                det = Kd * Kf - Ke * Ke;
                if (det !== 0) {
                    det = 1 / det;
                    data[IMP] = Ka !== 0 ? errX / Ka : 0;
                    data[IMP + 1] = det * (Kf * errY - Ke * errZ);
                    data[IMP + 2] = det * (Kd * errZ - Ke * errY);
                    return
                }
                data[IMP] = Ka !== 0 ? errX / Ka : 0;
                data[IMP + 1] = Kd !== 0 ? errY / Kd : 0;
                data[IMP + 2] = Kf !== 0 ? errZ / Kf : 0
            } else {
                det = 1 / det;
                var D = Ka * Kf - Kc * Kc;
                var E = Kb * Kc - Ka * Ke;
                var F = Ka * Kd - Kb * Kb;
                data[IMP] = det * (A * errX + B * errY + C * errZ);
                data[IMP + 1] = det * (B * errX + D * errY + E * errZ);
                data[IMP + 2] = det * (C * errX + E * errY + F * errZ)
            }
        };
        Physics2DConstraint.prototype.safe_invert = function(data, KMASS, JACC) {
            var K = data[KMASS];
            if (K === 0) {
                data[JACC] = 0
            } else {
                data[KMASS] = 1 / K
            }
        };
        Physics2DConstraint.prototype.safe_invert2 = function(data, KMASS, JACC) {
            var Ka = data[KMASS];
            var Kb = data[KMASS + 1];
            var Kc = data[KMASS + 2];
            var det = Ka * Kc - Kb * Kb;
            if (det === 0) {
                if (Ka !== 0) {
                    data[KMASS] = 1 / Ka
                } else {
                    data[JACC] = 0
                }
                if (Kc !== 0) {
                    data[KMASS + 2] = 1 / Kc
                } else {
                    data[JACC + 1] = 0
                }
                data[KMASS + 1] = 0
            } else {
                det = 1 / det;
                data[KMASS] = det * Kc;
                data[KMASS + 1] = det * -Kb;
                data[KMASS + 2] = det * Ka
            }
        };
        Physics2DConstraint.prototype.safe_invert3 = function(data, KMASS, JACC) {
            var Ka = data[KMASS];
            var Kb = data[KMASS + 1];
            var Kc = data[KMASS + 2];
            var Kd = data[KMASS + 3];
            var Ke = data[KMASS + 4];
            var Kf = data[KMASS + 5];
            var A = Kd * Kf - Ke * Ke;
            var B = Kc * Ke - Kb * Kf;
            var C = Kb * Ke - Kc * Kd;
            var det = Ka * A + Kb * B + Kc * C;
            if (det === 0) {
                det = Ka * Kd - Kb * Kb;
                if (det !== 0) {
                    det = 1 / det;
                    data[KMASS] = det * Kd;
                    data[KMASS + 1] = det * -Kb;
                    data[KMASS + 3] = det * Ka;
                    if (Kf !== 0) {
                        data[KMASS + 5] = 1 / Kf
                    } else {
                        data[JACC + 2] = 0
                    }
                    data[KMASS + 2] = data[KMASS + 4] = 0;
                    return
                }
                det = Ka * Kf - Kc * Kc;
                if (det !== 0) {
                    det = 1 / det;
                    data[KMASS] = det * Kf;
                    data[KMASS + 2] = det * -Kc;
                    data[KMASS + 5] = det * Ka;
                    if (Kd !== 0) {
                        data[KMASS + 3] = 1 / Kd
                    } else {
                        data[JACC + 1] = 0
                    }
                    data[KMASS + 1] = data[KMASS + 4] = 0;
                    return
                }
                det = Kd * Kf - Ke * Ke;
                if (det !== 0) {
                    det = 1 / det;
                    data[KMASS + 3] = det * Kf;
                    data[KMASS + 4] = det * -Ke;
                    data[KMASS + 5] = det * Kd;
                    if (Ka !== 0) {
                        data[KMASS] = 1 / Ka
                    } else {
                        data[JACC] = 0
                    }
                    data[KMASS + 1] = data[KMASS + 2] = 0;
                    return
                }
                if (Ka !== 0) {
                    data[KMASS] = 1 / Ka
                } else {
                    data[JACC] = 0
                }
                if (Kd !== 0) {
                    data[KMASS + 3] = 1 / Kd
                } else {
                    data[JACC + 1] = 0
                }
                if (Kf !== 0) {
                    data[KMASS + 5] = 1 / Kf
                } else {
                    data[JACC + 2] = 0
                }
                data[KMASS + 1] = data[KMASS + 2] = data[KMASS + 4] = 0
            } else {
                det = 1 / det;
                data[KMASS] = det * A;
                data[KMASS + 1] = det * B;
                data[KMASS + 2] = det * C;
                data[KMASS + 3] = det * (Ka * Kf - Kc * Kc);
                data[KMASS + 4] = det * (Kb * Kc - Ka * Ke);
                data[KMASS + 5] = det * (Ka * Kd - Kb * Kb)
            }
        };
        return Physics2DConstraint
    }();
    var Physics2DCustomConstraint = function(_super) {
        __extends(Physics2DCustomConstraint, _super);

        function Physics2DCustomConstraint() {
            _super.apply(this, arguments);
            this.type = "CUSTOM"
        }
        Physics2DCustomConstraint.prototype._inWorld = function() {
            var bodies = this.bodies;
            var limit = bodies.length;
            var i;
            for (i = 0; i < limit; i += 1) {
                bodies[i].constraints.push(this)
            }
        };
        Physics2DCustomConstraint.prototype._outWorld = function() {
            var bodies = this.bodies;
            var limit = bodies.length;
            var i;
            for (i = 0; i < limit; i += 1) {
                var constraints = bodies[i].constraints;
                var index = constraints.indexOf(this);
                constraints[index] = constraints[constraints.length - 1];
                constraints.pop()
            }
        };
        Physics2DCustomConstraint.prototype._pairExists = function(b1, b2) {
            var bodies = this.bodies;
            var limit = bodies.length;
            var i;
            for (i = 0; i < limit; i += 1) {
                var bodyA = bodies[i];
                if (bodyA === b1 || bodyA === b2) {
                    var j;
                    for (j = i + 1; j < limit; j += 1) {
                        var bodyB = bodies[j];
                        if (bodyA === b1 && bodyB === b2 || bodyA === b2 && bodyB === b1) {
                            return true
                        }
                    }
                }
            }
            return false
        };
        Physics2DCustomConstraint.prototype._wakeConnected = function() {
            var bodies = this.bodies;
            var limit = bodies.length;
            var i;
            for (i = 0; i < limit; i += 1) {
                var body = bodies[i];
                if (body._type === 0) {
                    body.wake(true)
                }
            }
        };
        Physics2DCustomConstraint.prototype._sleepComputation = function(union) {
            var bodies = this.bodies;
            var limit = bodies.length;
            var i;
            for (i = 0; i < limit; i += 1) {
                var body = bodies[i];
                if (body._type === 0) {
                    union(body, this)
                }
            }
        };
        Physics2DCustomConstraint.prototype._clearCache = function() {
            var data = this._data;
            var J_ACC = this._J_ACC;
            var limit = J_ACC + this.dimension;
            var i;
            for (i = J_ACC; i < limit; i += 1) {
                data[i] = 0
            }
            data[4] = -1
        };
        Physics2DCustomConstraint.prototype._cholesky = function() {
            var data = this._data;
            var A = this._K_MASS;
            var L = this._K_CHOLESKY;
            var dim = this.dimension;
            var j;
            for (j = 0; j < dim; j += 1) {
                var sum = 0;
                var k;
                for (k = 0; k <= j - 1; k += 1) {
                    var Lval = data[L + j * dim + k];
                    sum += Lval * Lval
                }
                var rec = data[A] - sum;
                var zeroRank = rec <= 0;
                if (zeroRank) {
                    rec = data[A]
                }
                rec = rec <= 0 ? 0 : Math.sqrt(rec);
                A += 1;
                data[L + j * dim + j] = rec;
                var i;
                if (rec !== 0 && !zeroRank) {
                    rec = 1 / rec;
                    for (i = j + 1; i < dim; i += 1) {
                        sum = 0;
                        for (k = 0; k <= j - 1; k += 1) {
                            sum += data[L + i * dim + k] * data[L + j * dim + k]
                        }
                        data[L + i * dim + j] = rec * (data[A] - sum);
                        A += 1
                    }
                }
                if (zeroRank) {
                    for (i = j + 1; i < dim; i += 1) {
                        data[L + i * dim + j] = 0
                    }
                    for (i = 0; i < j; i += 1) {
                        data[L + j * dim + i] = 0
                    }
                    A += dim - j - 1
                }
            }
        };
        Physics2DCustomConstraint.prototype._transform = function(X) {
            var data = this._data;
            var Y = this._VECTOR_TMP;
            var L = this._K_CHOLESKY;
            var dim = this.dimension;
            var i, lii, sum, k;
            for (i = 0; i < dim; i += 1) {
                sum = data[X + i];
                lii = data[L + i * dim + i];
                if (lii !== 0) {
                    for (k = 0; k < i; k += 1) {
                        sum -= data[L + i * dim + k] * data[Y + k]
                    }
                    data[Y + i] = sum / lii
                } else {
                    data[Y + i] = 0
                }
            }
            var ix;
            for (ix = 0; ix < dim; ix += 1) {
                i = dim - 1 - ix;
                lii = data[L + i * dim + i];
                if (lii !== 0) {
                    sum = data[Y + i];
                    for (k = i + 1; k < dim; k += 1) {
                        sum -= data[L + k * dim + i] * data[X + k]
                    }
                    data[X + i] = sum / lii
                } else {
                    data[X + i] = 0
                }
            }
        };
        Physics2DCustomConstraint.prototype._effMass = function() {
            var data = this._data;
            var dimension = this.dimension;
            var bodies = this.bodies;
            var limit = bodies.length;
            var length = limit * 3;
            var JAC = this._JACOBIAN;
            var KMASS = this._K_MASS;
            var i, j, k;
            for (i = 0; i < dimension; i += 1) {
                var JACI = JAC + i * length;
                for (j = i; j < dimension; j += 1) {
                    var JACJ = JAC + j * length;
                    var sum = 0;
                    for (k = 0; k < limit; k += 1) {
                        var body = bodies[k]._data;
                        var k3 = k * 3;
                        sum += body[0] * (data[JACI + k3] * data[JACJ + k3] + data[JACI + k3 + 1] * data[JACJ + k3 + 1]);
                        sum += body[1] * (data[JACI + k3 + 2] * data[JACJ + k3 + 2])
                    }
                    data[KMASS] = sum;
                    KMASS += 1
                }
            }
        };
        Physics2DCustomConstraint.prototype._preStep = function(deltaTime) {
            var dimension = this.dimension;
            var data = this._data;
            var i, limit;
            if (this._posConsts) {
                this._posConsts.call(this)
            }
            var JAC = this._JACOBIAN;
            var K_CHOLESKY = this._K_CHOLESKY;
            var BIAS = this._BIAS;
            if (!this._stiff && !this._velocityOnly) {
                this._posError.call(this, data, BIAS);
                this._jacobian.call(this, data, JAC);
                this._effMass();
                this._cholesky();
                var bsq = 0;
                limit = BIAS + dimension;
                for (i = BIAS; i < limit; i += 1) {
                    var bias = data[i];
                    bsq += bias * bias
                }
                var maxError = data[3];
                if (this._breakUnderError && bsq > maxError * maxError) {
                    return true
                }
                var omega = 2 * Math.PI * data[0];
                var gamma = 1 / (deltaTime * omega * (2 * data[1] + omega * deltaTime));
                var iG = 1 / (1 + gamma);
                var biasCoef = -(deltaTime * omega * omega * gamma);
                data[6] = gamma * iG;
                limit = K_CHOLESKY + dimension * dimension;
                iG = 1 / Math.sqrt(iG);
                for (i = K_CHOLESKY; i < limit; i += 1) {
                    data[i] *= iG
                }
                bsq *= biasCoef * biasCoef;
                if (bsq > maxError * maxError) {
                    biasCoef *= maxError / Math.sqrt(bsq)
                }
                limit = BIAS + dimension;
                for (i = BIAS; i < limit; i += 1) {
                    data[i] *= biasCoef
                }
            } else {
                this._jacobian.call(this, data, JAC);
                this._effMass();
                this._cholesky();
                limit = BIAS + dimension;
                for (i = BIAS; i < limit; i += 1) {
                    data[i] = 0
                }
                data[6] = 0
            }
            var dtRatio = Physics2DConstraint.prototype.dtRatio(data, deltaTime);
            var J_ACC = this._J_ACC;
            limit = J_ACC + this.dimension;
            for (i = J_ACC; i < limit; i += 1) {
                data[i] *= dtRatio
            }
            data[5] = data[2] * deltaTime;
            return false
        };
        Physics2DCustomConstraint.prototype._warmStart = function() {
            this._applyImpulse(this._J_ACC)
        };
        Physics2DCustomConstraint.prototype.getImpulseForBody = function(body, dst) {
            if (dst === undefined) {
                dst = new Physics2DDevice.prototype.floatArray(3)
            }
            var data = this._data;
            var JAC = this._JACOBIAN;
            var J = this._J_ACC;
            var bodies = this.bodies;
            var limit = bodies.length;
            var length = limit * 3;
            var dim = this.dimension;
            var i;
            for (i = 0; i < limit; i += 1) {
                var b = bodies[i];
                if (b === body) {
                    var sumX = 0;
                    var sumY = 0;
                    var sumW = 0;
                    var j;
                    for (j = 0; j < dim; j += 1) {
                        sumX += data[J + j] * data[JAC + length * j];
                        sumY += data[J + j] * data[JAC + length * j + 1];
                        sumW += data[J + j] * data[JAC + length * j + 2]
                    }
                    dst[0] = sumX;
                    dst[1] = sumY;
                    dst[2] = sumW;
                    return dst
                }
                JAC += 3
            }
            dst[0] = dst[1] = dst[2] = 0;
            return dst
        };
        Physics2DCustomConstraint.prototype._applyImpulse = function(J, position) {
            var data = this._data;
            var JAC = this._JACOBIAN;
            var bodies = this.bodies;
            var limit = bodies.length;
            var length = limit * 3;
            var dim = this.dimension;
            var i;
            for (i = 0; i < limit; i += 1) {
                var b = bodies[i];
                var body = b._data;
                var sumX = 0;
                var sumY = 0;
                var sumW = 0;
                var j;
                for (j = 0; j < dim; j += 1) {
                    sumX += data[J + j] * data[JAC + length * j];
                    sumY += data[J + j] * data[JAC + length * j + 1];
                    sumW += data[J + j] * data[JAC + length * j + 2]
                }
                var im = body[0];
                var dr = sumW * body[1];
                if (position) {
                    body[2] += sumX * im;
                    body[2 + 1] += sumY * im;
                    if (dr !== 0) {
                        b._deltaRotation(dr)
                    }
                } else {
                    body[7] += sumX * im;
                    body[7 + 1] += sumY * im;
                    body[7 + 2] += dr
                }
                JAC += 3
            }
        };
        Physics2DCustomConstraint.prototype._iterateVel = function() {
            var dimension = this.dimension;
            var data = this._data;
            var i, limit;
            var VECTOR = this._VECTOR;
            var BIAS = this._BIAS;
            var j;
            var bodies = this.bodies;
            var limit2 = bodies.length;
            var JAC = this._JACOBIAN;
            for (i = 0; i < dimension; i += 1) {
                var term = data[BIAS + i];
                for (j = 0; j < limit2; j += 1) {
                    var body = bodies[j]._data;
                    term -= body[7] * data[JAC] + body[7 + 1] * data[JAC + 1] + body[7 + 2] * data[JAC + 2];
                    JAC += 3
                }
                data[VECTOR + i] = term
            }
            this._transform(VECTOR);
            var JACC = this._J_ACC;
            var JOLD = this._VECTOR_TMP;
            var jAcc;
            var gamma = data[6];
            for (i = 0; i < dimension; i += 1) {
                jAcc = data[JOLD + i] = data[JACC + i];
                data[JACC + i] += data[VECTOR + i] - jAcc * gamma
            }
            if (this._velClamp) {
                this._velClamp.call(this, data, JACC)
            }
            var jlsq = 0;
            limit = JACC + dimension;
            for (i = JACC; i < limit; i += 1) {
                jAcc = data[i];
                jlsq += jAcc * jAcc
            }
            var jMax = data[5];
            if (this._breakUnderForce && jlsq > jMax * jMax) {
                return true
            } else if (!this._stiff && jlsq > jMax * jMax) {
                jlsq = jMax / Math.sqrt(jlsq);
                for (i = JACC; i < limit; i += 1) {
                    data[i] *= jlsq
                }
            }
            for (i = 0; i < dimension; i += 1) {
                data[VECTOR + i] = data[JACC + i] - data[JOLD + i]
            }
            this._applyImpulse(VECTOR);
            return false
        };
        Physics2DCustomConstraint.prototype._iteratePos = function() {
            if (this._velocityOnly) {
                return false
            }
            if (this._posConsts) {
                this._posConsts.call(this)
            }
            var dimension = this.dimension;
            var data = this._data;
            var i, limit;
            var BIAS = this._BIAS;
            this._posError.call(this, data, BIAS);
            limit = BIAS + dimension;
            var err;
            var elsq = 0;
            for (i = BIAS; i < limit; i += 1) {
                err = data[i];
                elsq += err * err;
                data[i] = -err
            }
            var maxError = data[3];
            if (this._breakUnderError && elsq > maxError * maxError) {
                return true
            }
            var JAC = this._JACOBIAN;
            this._jacobian.call(this, data, JAC);
            this._effMass();
            this._cholesky();
            this._transform(BIAS);
            if (this._posClamp) {
                this._posClamp.call(this, data, BIAS)
            }
            this._applyImpulse(BIAS, true);
            return false
        };
        Physics2DCustomConstraint.create = function(params) {
            var p = new Physics2DCustomConstraint;
            var dim = p.dimension = params.dimension;
            p.bodies = params.bodies.concat();
            var dataSize = 7 + (dim * (4 + dim) + dim * (dim + 1) / 2);
            dataSize += dim * p.bodies.length * 3;
            p._data = new Physics2DDevice.prototype.floatArray(dataSize);
            Physics2DConstraint.prototype.init(p, params);
            p._K_MASS = 7;
            p._K_CHOLESKY = p._K_MASS + dim * (dim + 1) / 2;
            p._BIAS = p._K_CHOLESKY + dim * dim;
            p._J_ACC = p._BIAS + dim;
            p._VECTOR = p._J_ACC + dim;
            p._JACOBIAN = p._VECTOR + dim;
            p._VECTOR_TMP = p._JACOBIAN + dim * p.bodies.length * 3;
            p._draw = params.debugDraw;
            p._posConsts = params.positionConstants;
            p._posError = params.position;
            p._posClamp = params.positionClamp;
            p._velClamp = params.velocityClamp;
            p._jacobian = params.jacobian;
            p._velocityOnly = p._posError === undefined;
            return p
        };
        return Physics2DCustomConstraint
    }(Physics2DConstraint);
    var Physics2DPulleyConstraint = function(_super) {
        __extends(Physics2DPulleyConstraint, _super);

        function Physics2DPulleyConstraint() {
            _super.apply(this, arguments);
            this.type = "PULLEY";
            this.dimension = 1;
            this._ANCHOR_A = 11;
            this._ANCHOR_B = 13;
            this._ANCHOR_C = 15;
            this._ANCHOR_D = 17;
            this._JACC = 9
        }
        Physics2DPulleyConstraint.prototype.getRatio = function() {
            return this._data[7]
        };
        Physics2DPulleyConstraint.prototype.setRatio = function(ratio) {
            var data = this._data;
            if (data[7] !== ratio) {
                data[7] = ratio;
                this.wake(true)
            }
        };
        Physics2DPulleyConstraint.prototype.getLowerBound = function() {
            return this._data[5]
        };
        Physics2DPulleyConstraint.prototype.getUpperBound = function() {
            return this._data[6]
        };
        Physics2DPulleyConstraint.prototype.setLowerBound = function(lowerBound) {
            var data = this._data;
            if (data[5] !== lowerBound) {
                data[5] = lowerBound;
                this._equal = lowerBound === data[6];
                this.wake(true)
            }
        };
        Physics2DPulleyConstraint.prototype.setUpperBound = function(upperBound) {
            var data = this._data;
            if (data[6] !== upperBound) {
                data[6] = upperBound;
                this._equal = upperBound === data[5];
                this.wake(true)
            }
        };
        Physics2DPulleyConstraint.prototype.getAnchorC = function(dst) {
            if (dst === undefined) {
                dst = new Physics2DDevice.prototype.floatArray(2)
            }
            var data = this._data;
            var INDEX = this._ANCHOR_C;
            dst[0] = data[INDEX];
            dst[1] = data[INDEX + 1];
            return dst
        };
        Physics2DPulleyConstraint.prototype.setAnchorC = function(anchor) {
            var data = this._data;
            var INDEX = this._ANCHOR_C;
            var newX = anchor[0];
            var newY = anchor[1];
            if (newX !== data[INDEX] || newY !== data[INDEX + 1]) {
                data[INDEX] = newX;
                data[INDEX + 1] = newY;
                this.wake(true)
            }
        };
        Physics2DPulleyConstraint.prototype.getAnchorD = function(dst) {
            if (dst === undefined) {
                dst = new Physics2DDevice.prototype.floatArray(2)
            }
            var data = this._data;
            var INDEX = this._ANCHOR_D;
            dst[0] = data[INDEX];
            dst[1] = data[INDEX + 1];
            return dst
        };
        Physics2DPulleyConstraint.prototype.setAnchorD = function(anchor) {
            var data = this._data;
            var INDEX = this._ANCHOR_D;
            var newX = anchor[0];
            var newY = anchor[1];
            if (newX !== data[INDEX] || newY !== data[INDEX + 1]) {
                data[INDEX] = newX;
                data[INDEX + 1] = newY;
                this.wake(true)
            }
        };
        Physics2DPulleyConstraint.prototype._inWorld = function() {
            this.bodyA.constraints.push(this);
            this.bodyB.constraints.push(this);
            if (this.bodyB !== this.bodyC) {
                this.bodyC.constraints.push(this)
            }
            this.bodyD.constraints.push(this)
        };
        Physics2DPulleyConstraint.prototype._outWorld = function() {
            var constraints = this.bodyA.constraints;
            var index = constraints.indexOf(this);
            constraints[index] = constraints[constraints.length - 1];
            constraints.pop();
            constraints = this.bodyB.constraints;
            index = constraints.indexOf(this);
            constraints[index] = constraints[constraints.length - 1];
            constraints.pop();
            if (this.bodyB !== this.bodyC) {
                constraints = this.bodyB.constraints;
                index = constraints.indexOf(this);
                constraints[index] = constraints[constraints.length - 1];
                constraints.pop()
            }
            constraints = this.bodyD.constraints;
            index = constraints.indexOf(this);
            constraints[index] = constraints[constraints.length - 1];
            constraints.pop()
        };
        Physics2DPulleyConstraint.prototype._pairExists = function(b1, b2) {
            var bodyA = this.bodyA;
            var bodyB = this.bodyB;
            var bodyC = this.bodyC;
            var bodyD = this.bodyD;
            return b1 === bodyA && (b2 === bodyB || b2 === bodyC || b2 === bodyD) || b1 === bodyB && (b2 === bodyA || b2 === bodyC || b2 === bodyD) || b1 === bodyC && (b2 === bodyA || b2 === bodyB || b2 === bodyD) || b1 === bodyD && (b2 === bodyA || b2 === bodyB || b2 === bodyC)
        };
        Physics2DPulleyConstraint.prototype._wakeConnected = function() {
            var body = this.bodyA;
            if (body._type === 0) {
                body.wake(true)
            }
            body = this.bodyB;
            if (body._type === 0) {
                body.wake(true)
            }
            body = this.bodyC;
            if (body !== this.bodyB && body._type === 0) {
                body.wake(true)
            }
            body = this.bodyD;
            if (body._type === 0) {
                body.wake(true)
            }
        };
        Physics2DPulleyConstraint.prototype._sleepComputation = function(union) {
            var body = this.bodyA;
            if (body._type === 0) {
                union(body, this)
            }
            body = this.bodyB;
            if (body._type === 0) {
                union(body, this)
            }
            body = this.bodyC;
            if (body !== this.bodyB && body._type === 0) {
                union(body, this)
            }
            body = this.bodyD;
            if (body._type === 0) {
                union(body, this)
            }
        };
        Physics2DPulleyConstraint.prototype._posError = function() {
            var data = this._data;
            var b1 = this.bodyA._data;
            var b2 = this.bodyB._data;
            var b3 = this.bodyC._data;
            var b4 = this.bodyD._data;
            Physics2DConstraint.prototype.rotateAnchor(data, b1, 11, 19);
            Physics2DConstraint.prototype.rotateAnchor(data, b2, 13, 21);
            Physics2DConstraint.prototype.rotateAnchor(data, b3, 15, 23);
            Physics2DConstraint.prototype.rotateAnchor(data, b4, 17, 25);
            var jointMin = data[5];
            var jointMax = data[6];
            var n12x = b2[2] + data[21] - (b1[2] + data[19]);
            var n12y = b2[2 + 1] + data[21 + 1] - (b1[2 + 1] + data[19 + 1]);
            var n34x = b4[2] + data[25] - (b3[2] + data[23]);
            var n34y = b4[2 + 1] + data[25 + 1] - (b3[2 + 1] + data[23 + 1]);
            var err12 = n12x * n12x + n12y * n12y;
            var err34 = n34x * n34x + n34y * n34y;
            var rec;
            if (err12 < Physics2DConfig.NORMALIZE_SQ_EPSILON) {
                err12 = 0;
                n12x = data[29];
                n12y = data[29 + 1]
            } else {
                err12 = Math.sqrt(err12);
                rec = 1 / err12;
                n12x *= rec;
                n12y *= rec
            }
            var ratio = data[7];
            if (err34 < Physics2DConfig.NORMALIZE_SQ_EPSILON) {
                err34 = 0;
                n34x = data[31];
                n34y = data[31 + 1]
            } else {
                err34 = Math.sqrt(err34);
                rec = ratio / err34;
                n34x *= rec;
                n34y *= rec
            }
            var err = err12 + err34 * ratio;
            if (this._equal) {
                err -= jointMin;
                this._slack = false
            } else if (err < jointMin) {
                err = jointMin - err;
                n12x = -n12x;
                n12y = -n12y;
                n34x = -n34x;
                n34y = -n34y;
                this._slack = false
            } else if (err > jointMax) {
                err -= jointMax;
                this._slack = false
            } else {
                n12x = -n12x;
                n12y = -n12y;
                n34x = -n34x;
                n34y = -n34y;
                err = 0;
                this._slack = true
            }
            data[29] = n12x;
            data[29 + 1] = n12y;
            data[31] = n34x;
            data[31 + 1] = n34y;
            data[28] = -err
        };
        Physics2DPulleyConstraint.prototype._preStep = function(deltaTime) {
            this._posError();
            if (this._slack) {
                return false
            }
            var data = this._data;
            var b1 = this.bodyA._data;
            var b2 = this.bodyB._data;
            var b3 = this.bodyC._data;
            var b4 = this.bodyD._data;
            var ratioSq = data[7];
            ratioSq *= ratioSq;
            var n12x = data[29];
            var n12y = data[29 + 1];
            var n34x = data[31];
            var n34y = data[31 + 1];
            var cx1 = data[33] = data[19] * n12y - data[19 + 1] * n12x;
            var cx2 = data[34] = data[21] * n12y - data[21 + 1] * n12x;
            var cx3 = data[35] = data[23] * n34y - data[23 + 1] * n34x;
            var cx4 = data[36] = data[25] * n34y - data[25 + 1] * n34x;
            var im3 = b3[0];
            var ii3 = b3[1];
            var K = b1[0] + b2[0] + ratioSq * (im3 + b4[0]) + cx1 * b1[1] * cx1 + cx2 * b2[1] * cx2 + cx3 * ii3 * cx3 + cx4 * b4[1] * cx4;
            if (b2 === b3) {
                K -= 2 * ((n12x * n34x + n12y * n34y) * im3 + cx2 * cx3 * ii3)
            }
            data[8] = K;
            Physics2DConstraint.prototype.safe_invert(data, 8, 9);
            if (!this._stiff) {
                if (Physics2DConstraint.prototype.soft_params(data, 8, 27, 28, deltaTime, this._breakUnderError)) {
                    return true
                }
            } else {
                data[27] = 0;
                data[28] = 0
            }
            var dtRatio = Physics2DConstraint.prototype.dtRatio(data, deltaTime);
            data[9] *= dtRatio;
            data[10] = data[2] * deltaTime;
            return false
        };
        Physics2DPulleyConstraint.prototype._warmStart = function() {
            if (this._slack) {
                return false
            }
            var data = this._data;
            var b1 = this.bodyA._data;
            var b2 = this.bodyB._data;
            var b3 = this.bodyC._data;
            var b4 = this.bodyD._data;
            var jAcc = data[9];
            var jx = data[29] * jAcc;
            var jy = data[29 + 1] * jAcc;
            var im = b1[0];
            b1[7] -= jx * im;
            b1[7 + 1] -= jy * im;
            b1[7 + 2] -= data[33] * jAcc * b1[1];
            im = b2[0];
            b2[7] += jx * im;
            b2[7 + 1] += jy * im;
            b2[7 + 2] += data[34] * jAcc * b2[1];
            jx = data[31] * jAcc;
            jy = data[31 + 1] * jAcc;
            im = b3[0];
            b3[7] -= jx * im;
            b3[7 + 1] -= jy * im;
            b3[7 + 2] -= data[35] * jAcc * b3[1];
            im = b4[0];
            b4[7] += jx * im;
            b4[7 + 1] += jy * im;
            b4[7 + 2] += data[36] * jAcc * b4[1]
        };
        Physics2DPulleyConstraint.prototype.getImpulseForBody = function(body, dst) {
            if (dst === undefined) {
                dst = new Physics2DDevice.prototype.floatArray(3)
            }
            var jAcc = data[9];
            var data = this._data;
            if (body === this.bodyA) {
                dst[0] = -(data[29] * jAcc);
                dst[1] = -(data[29 + 1] * jAcc);
                dst[2] = -data[33] * jAcc
            } else if (body === this.bodyD) {
                dst[0] = data[31] * jAcc;
                dst[1] = data[31 + 1] * jAcc;
                dst[2] = data[36] * jAcc
            } else {
                var sumX = 0;
                var sumY = 0;
                var sumW = 0;
                if (body === this.bodyB) {
                    sumX += data[29] * jAcc;
                    sumY += data[29 + 1] * jAcc;
                    sumW += data[34] * jAcc
                }
                if (body === this.bodyC) {
                    sumX -= data[31] * jAcc;
                    sumY -= data[31 + 1] * jAcc;
                    sumW -= data[35] * jAcc
                }
                dst[0] = sumX;
                dst[1] = sumY;
                dst[2] = sumW
            }
            return dst
        };
        Physics2DPulleyConstraint.prototype._iterateVel = function() {
            if (this._slack) {
                return false
            }
            var data = this._data;
            var b1 = this.bodyA._data;
            var b2 = this.bodyB._data;
            var b3 = this.bodyC._data;
            var b4 = this.bodyD._data;
            var n12x = data[29];
            var n12y = data[29 + 1];
            var n34x = data[31];
            var n34y = data[31 + 1];
            var cx1 = data[33];
            var cx2 = data[34];
            var cx3 = data[35];
            var cx4 = data[36];
            var x = data[28] - (n12x * (b2[7] - b1[7]) + n12y * (b2[7 + 1] - b1[7 + 1]) + n34x * (b4[7] - b3[7]) + n34y * (b4[7 + 1] - b3[7 + 1]) + cx2 * b2[7 + 2] - cx1 * b1[7 + 2] + cx4 * b4[7 + 2] - cx3 * b3[7 + 2]);
            var jOld = data[9];
            var j = data[8] * x - jOld * data[27];
            var jAcc = jOld + j;
            var jMax = data[10];
            if (!this._equal && jAcc > 0) {
                jAcc = 0
            }
            if (this._breakUnderForce) {
                if (jAcc > jMax || jAcc < -jMax) {
                    return true
                }
            } else if (!this._stiff) {
                if (jAcc > jMax) {
                    jAcc = jMax
                } else if (jAcc < -jMax) {
                    jAcc = -jMax
                }
            }
            j = jAcc - jOld;
            data[9] = jAcc;
            var jx = data[29] * j;
            var jy = data[29 + 1] * j;
            var im = b1[0];
            b1[7] -= jx * im;
            b1[7 + 1] -= jy * im;
            b1[7 + 2] -= cx1 * j * b1[1];
            im = b2[0];
            b2[7] += jx * im;
            b2[7 + 1] += jy * im;
            b2[7 + 2] += cx2 * j * b2[1];
            jx = data[31] * j;
            jy = data[31 + 1] * j;
            im = b3[0];
            b3[7] -= jx * im;
            b3[7 + 1] -= jy * im;
            b3[7 + 2] -= cx3 * j * b3[1];
            im = b4[0];
            b4[7] += jx * im;
            b4[7 + 1] += jy * im;
            b4[7 + 2] += cx4 * j * b4[1];
            return false
        };
        Physics2DPulleyConstraint.prototype._iteratePos = function() {
            this._posError();
            if (this._slack) {
                return false
            }
            var data = this._data;
            var b1 = this.bodyA._data;
            var b2 = this.bodyB._data;
            var b3 = this.bodyC._data;
            var b4 = this.bodyD._data;
            var im1 = b1[0];
            var im2 = b2[0];
            var im3 = b3[0];
            var im4 = b4[0];
            var ii1 = b1[1];
            var ii2 = b2[1];
            var ii3 = b3[1];
            var ii4 = b4[1];
            var err = data[28];
            var maxError = data[3];
            if (this._breakUnderError && (err > maxError || err < -maxError)) {
                return true
            }
            var slop = Physics2DConfig.PULLEY_SLOP_SQ;
            if (err * err < slop) {
                return false
            }
            err *= Physics2DConfig.PULLEY_BIAS_COEF;
            var ratioSq = data[7];
            ratioSq *= ratioSq;
            var K = im1 + im2 + ratioSq * (im3 + im4);
            var n12x = data[29];
            var n12y = data[29 + 1];
            var n34x = data[31];
            var n34y = data[31 + 1];
            if (b2 === b3) {
                K -= 2 * (n12x * n34x + n12y * n34y) * im2
            }
            var j, jx, jy;
            if (err * err > Physics2DConfig.PULLEY_LARGE_ERROR_SQ) {
                if (K > Physics2DConfig.EFF_MASS_EPSILON) {
                    j = err * Physics2DConfig.PULLEY_LARGE_ERROR_BIAS / K;
                    if (this._equal || j < 0) {
                        jx = n12x * j;
                        jy = n12y * j;
                        b1[2] -= jx * im1;
                        b1[2 + 1] -= jy * im1;
                        b2[2] += jx * im2;
                        b2[2 + 1] += jy * im2;
                        jx = n34x * j;
                        jy = n34y * j;
                        b3[2] -= jx * im3;
                        b3[2 + 1] -= jy * im3;
                        b4[2] += jx * im4;
                        b4[2 + 1] += jy * im4;
                        this._posError();
                        n12x = data[29];
                        n12y = data[29 + 1];
                        n34x = data[31];
                        n34y = data[31 + 1];
                        err = data[28] * Physics2DConfig.PULLEY_BIAS_COEF
                    }
                }
            }
            var cx1 = data[19] * n12y - data[19 + 1] * n12x;
            var cx2 = data[21] * n12y - data[21 + 1] * n12x;
            var cx3 = data[23] * n34y - data[23 + 1] * n34x;
            var cx4 = data[25] * n34y - data[25 + 1] * n34x;
            K += cx1 * ii1 * cx1 + cx2 * ii2 * cx2 + cx3 * ii3 * cx3 + cx4 * ii4 * cx4;
            if (b2 === b2) {
                K -= 2 * cx2 * ii2 * cx3
            }
            data[8] = K;
            data[28] = err;
            Physics2DConstraint.prototype.safe_solve(data, 8, 28, 28);
            j = data[28];
            if (this._equal || j < 0) {
                var dr;
                jx = n12x * j;
                jy = n12y * j;
                b1[2] -= jx * im1;
                b1[2 + 1] -= jy * im1;
                dr = -cx1 * j * ii1;
                if (dr !== 0) {
                    this.bodyA._deltaRotation(dr)
                }
                b2[2] += jx * im2;
                b2[2 + 1] += jy * im2;
                dr = cx2 * j * ii2;
                if (dr !== 0) {
                    this.bodyB._deltaRotation(dr)
                }
                jx = n34x * j;
                jy = n34y * j;
                b3[2] -= jx * im3;
                b3[2 + 1] -= jy * im3;
                dr = -cx3 * j * ii3;
                if (dr !== 0) {
                    this.bodyC._deltaRotation(dr)
                }
                b4[2] += jx * im4;
                b4[2 + 1] += jy * im4;
                dr = cx4 * j * ii4;
                if (dr !== 0) {
                    this.bodyD._deltaRotation(dr)
                }
            }
            return false
        };
        Physics2DPulleyConstraint.create = function(params) {
            var p = new Physics2DPulleyConstraint;
            var data = p._data = new Physics2DDevice.prototype.floatArray(37);
            Physics2DConstraint.prototype.init(p, params);
            var anchor = params.anchorA;
            data[11] = anchor ? anchor[0] : 0;
            data[11 + 1] = anchor ? anchor[1] : 0;
            anchor = params.anchorB;
            data[13] = anchor ? anchor[0] : 0;
            data[13 + 1] = anchor ? anchor[1] : 0;
            anchor = params.anchorC;
            data[15] = anchor ? anchor[0] : 0;
            data[15 + 1] = anchor ? anchor[1] : 0;
            anchor = params.anchorD;
            data[17] = anchor ? anchor[0] : 0;
            data[17 + 1] = anchor ? anchor[1] : 0;
            var min = data[5] = params.lowerBound !== undefined ? params.lowerBound : 0;
            var max = data[6] = params.upperBound !== undefined ? params.upperBound : 0;
            p._equal = min === max;
            data[7] = params.ratio !== undefined ? params.ratio : 1;
            p._slack = false;
            p.bodyA = params.bodyA;
            p.bodyB = params.bodyB;
            p.bodyC = params.bodyC;
            p.bodyD = params.bodyD;
            data[29] = 1;
            data[29 + 1] = 0;
            data[31] = 1;
            data[31 + 1] = 0;
            return p
        };
        return Physics2DPulleyConstraint
    }(Physics2DConstraint);
    var Physics2DMotorConstraint = function(_super) {
        __extends(Physics2DMotorConstraint, _super);

        function Physics2DMotorConstraint() {
            _super.apply(this, arguments);
            this.type = "MOTOR";
            this.dimension = 1;
            this._JACC = 8
        }
        Physics2DMotorConstraint.prototype.getRate = function() {
            return this._data[5]
        };
        Physics2DMotorConstraint.prototype.getRatio = function() {
            return this._data[6]
        };
        Physics2DMotorConstraint.prototype.setRate = function(rate) {
            var data = this._data;
            if (data[5] !== rate) {
                data[5] = rate;
                this.wake(true)
            }
        };
        Physics2DMotorConstraint.prototype.setRatio = function(ratio) {
            var data = this._data;
            if (data[6] !== ratio) {
                data[6] = ratio;
                this.wake(true)
            }
        };
        Physics2DMotorConstraint.prototype._preStep = function(deltaTime) {
            var data = this._data;
            var b1 = this.bodyA._data;
            var b2 = this.bodyB._data;
            var ratio = data[6];
            data[7] = b1[1] + ratio * ratio * b2[1];
            Physics2DConstraint.prototype.safe_invert(data, 7, 8);
            var dtRatio = Physics2DConstraint.prototype.dtRatio(data, deltaTime);
            data[8] *= dtRatio;
            data[9] = data[2] * deltaTime;
            return false
        };
        Physics2DMotorConstraint.prototype._warmStart = function() {
            var data = this._data;
            var b1 = this.bodyA._data;
            var b2 = this.bodyB._data;
            var j = data[8];
            b1[7 + 2] -= j * b1[1];
            b2[7 + 2] += data[6] * j * b2[1]
        };
        Physics2DMotorConstraint.prototype.getImpulseForBody = function(body, dst) {
            if (dst === undefined) {
                dst = new Physics2DDevice.prototype.floatArray(3)
            }
            var data = this._data;
            dst[0] = dst[1] = 0;
            dst[2] = (body === this.bodyA ? -1 : body === this.bodyB ? data[6] : 0) * data[8];
            return dst
        };
        Physics2DMotorConstraint.prototype._iterateVel = function() {
            var data = this._data;
            var b1 = this.bodyA._data;
            var b2 = this.bodyB._data;
            var ratio = data[6];
            var j = data[7] * (data[5] + b1[7 + 2] - ratio * b2[7 + 2]);
            var jOld = data[8];
            var jAcc = jOld + j;
            var jMax = data[9];
            if (this._breakUnderForce && (jAcc > jMax || jAcc < -jMax)) {
                return true
            } else {
                if (jAcc > jMax) {
                    jAcc = jMax
                } else if (jAcc < -jMax) {
                    jAcc = -jMax
                }
            }
            j = jAcc - jOld;
            data[8] = jAcc;
            b1[7 + 2] -= j * b1[1];
            b2[7 + 2] += ratio * j * b2[1];
            return false
        };
        Physics2DMotorConstraint.prototype._iteratePos = function() {
            return false
        };
        Physics2DMotorConstraint.create = function(params) {
            var p = new Physics2DMotorConstraint;
            var data = p._data = new Physics2DDevice.prototype.floatArray(10);
            Physics2DConstraint.prototype.init(p, params);
            data[5] = params.rate !== undefined ? params.rate : 0;
            data[6] = params.ratio !== undefined ? params.ratio : 1;
            p.bodyA = params.bodyA;
            p.bodyB = params.bodyB;
            return p
        };
        return Physics2DMotorConstraint
    }(Physics2DConstraint);
    Physics2DMotorConstraint.prototype._inWorld = Physics2DConstraint.prototype.twoBodyInWorld;
    Physics2DMotorConstraint.prototype._outWorld = Physics2DConstraint.prototype.twoBodyOutWorld;
    Physics2DMotorConstraint.prototype._pairExists = Physics2DConstraint.prototype.twoBodyPairExists;
    Physics2DMotorConstraint.prototype._wakeConnected = Physics2DConstraint.prototype.twoBodyWakeConnected;
    Physics2DMotorConstraint.prototype._sleepComputation = Physics2DConstraint.prototype.twoBodySleepComputation;
    var Physics2DLineConstraint = function(_super) {
        __extends(Physics2DLineConstraint, _super);

        function Physics2DLineConstraint() {
            _super.apply(this, arguments);
            this.type = "LINE";
            this.dimension = 2;
            this._ANCHOR_A = 7;
            this._ANCHOR_B = 9;
            this._JACC = 22
        }
        Physics2DLineConstraint.prototype.getLowerBound = function() {
            return this._data[5]
        };
        Physics2DLineConstraint.prototype.getUpperBound = function() {
            return this._data[6]
        };
        Physics2DLineConstraint.prototype.setLowerBound = function(lowerBound) {
            var data = this._data;
            if (data[5] !== lowerBound) {
                data[5] = lowerBound;
                this._equal = lowerBound === data[6];
                this.wake(true)
            }
        };
        Physics2DLineConstraint.prototype.setUpperBound = function(upperBound) {
            var data = this._data;
            if (data[6] !== upperBound) {
                data[6] = upperBound;
                this._equal = upperBound === data[5];
                this.wake(true)
            }
        };
        Physics2DLineConstraint.prototype.getAxis = function(dst) {
            if (dst === undefined) {
                dst = new Physics2DDevice.prototype.floatArray(2)
            }
            var data = this._data;
            dst[0] = data[11];
            dst[1] = data[11 + 1];
            return dst
        };
        Physics2DLineConstraint.prototype.setAxis = function(axis) {
            var data = this._data;
            var newX = axis[0];
            var newY = axis[1];
            if (newX !== data[11] || newY !== data[11 + 1]) {
                var nlsq = newX * newX + newY * newY;
                if (nlsq === 0) {
                    return
                } else {
                    nlsq = 1 / Math.sqrt(nlsq);
                    newX *= nlsq;
                    newY *= nlsq
                }
                data[11] = newX;
                data[11 + 1] = newY;
                this.wake(true)
            }
        };
        Physics2DLineConstraint.prototype._posError = function() {
            var data = this._data;
            var b1 = this.bodyA._data;
            var b2 = this.bodyB._data;
            Physics2DConstraint.prototype.rotateAnchor(data, b1, 7, 13);
            Physics2DConstraint.prototype.rotateAnchor(data, b2, 9, 15);
            Physics2DConstraint.prototype.rotateAnchor(data, b1, 11, 17);
            var jointMin = data[5];
            var jointMax = data[6];
            var rx1 = data[13];
            var ry1 = data[13 + 1];
            var rx2 = data[15];
            var ry2 = data[15 + 1];
            var nx = data[17];
            var ny = data[17 + 1];
            var dx = data[28] = b2[2] + rx2 - (b1[2] + rx1);
            var dy = data[29] = b2[2 + 1] + ry2 - (b1[2 + 1] + ry1);
            var errX = nx * dy - ny * dx;
            var errY = nx * dx + ny * dy;
            if (this._equal) {
                errY -= jointMin;
                data[32] = 1
            } else {
                if (errY > jointMax) {
                    errY -= jointMax;
                    data[32] = 1
                } else if (errY < jointMin) {
                    errY = jointMin - errY;
                    data[32] = -1
                } else {
                    errY = 0;
                    data[32] = 0
                }
            }
            data[26] = -errX;
            data[26 + 1] = -errY
        };
        Physics2DLineConstraint.prototype._preStep = function(deltaTime) {
            var data = this._data;
            var b1 = this.bodyA._data;
            var b2 = this.bodyB._data;
            this._posError();
            var rx1 = data[13];
            var ry1 = data[13 + 1];
            var rx2 = data[15];
            var ry2 = data[15 + 1];
            var nx = data[17];
            var ny = data[17 + 1];
            var scale = data[32];
            var delX = data[28] + rx1;
            var delY = data[29] + ry1;
            var cx1 = data[28] = nx * delY - ny * delX;
            var cx2 = data[29] = nx * ry2 - ny * rx2;
            var dot1 = data[30] = nx * delX + ny * delY;
            var dot2 = data[31] = nx * rx2 + ny * ry2;
            var massSum = b1[0] + b2[0];
            var ii1 = b1[1];
            var ii2 = b2[1];
            data[19] = massSum + dot1 * ii1 * dot1 + dot2 * ii2 * dot2;
            data[19 + 1] = -scale * (dot1 * ii1 * cx1 + dot2 * ii2 * cx2);
            data[19 + 2] = scale * scale * (massSum + cx1 * ii1 * cx1 + cx2 * ii2 * cx2);
            Physics2DConstraint.prototype.safe_invert2(data, 19, 22);
            if (!this._stiff) {
                if (Physics2DConstraint.prototype.soft_params2(data, 19, 25, 26, deltaTime, this._breakUnderError)) {
                    return true
                }
            } else {
                data[25] = 0;
                data[26] = 0;
                data[26 + 1] = 0
            }
            var dtRatio = Physics2DConstraint.prototype.dtRatio(data, deltaTime);
            data[22] *= dtRatio;
            data[22 + 1] *= dtRatio;
            data[24] = data[2] * deltaTime;
            return false
        };
        Physics2DLineConstraint.prototype._warmStart = function() {
            var data = this._data;
            var b1 = this.bodyA._data;
            var b2 = this.bodyB._data;
            var jx = data[22];
            var jy = data[22 + 1];
            var scale = data[32];
            var nx = data[17];
            var ny = data[17 + 1];
            var lx = scale * nx * jy - ny * jx;
            var ly = nx * jx + scale * ny * jy;
            var im = b1[0];
            b1[7] -= lx * im;
            b1[7 + 1] -= ly * im;
            b1[7 + 2] += (scale * data[28] * jy - data[30] * jx) * b1[1];
            im = b2[0];
            b2[7] += lx * im;
            b2[7 + 1] += ly * im;
            b2[7 + 2] += (data[31] * jx - scale * data[29] * jy) * b2[1]
        };
        Physics2DLineConstraint.prototype.getImpulseForBody = function(body, dst) {
            if (dst === undefined) {
                dst = new Physics2DDevice.prototype.floatArray(3)
            }
            var data = this._data;
            var jx = data[22];
            var jy = data[22 + 1];
            var scale = data[32];
            var nx = data[17];
            var ny = data[17 + 1];
            var lx = scale * nx * jy - ny * jx;
            var ly = nx * jx + scale * ny * jy;
            if (body === this.bodyA) {
                dst[0] = -lx;
                dst[1] = -ly;
                dst[2] = scale * data[28] * jy - data[30] * jx
            } else if (body === this.bodyB) {
                dst[0] = lx;
                dst[1] = ly;
                dst[2] = data[31] * jx - scale * data[29] * jy
            } else {
                dst[0] = dst[1] = dst[2] = 0
            }
            return dst
        };
        Physics2DLineConstraint.prototype._iterateVel = function() {
            var data = this._data;
            var b1 = this.bodyA._data;
            var b2 = this.bodyB._data;
            var scale = data[32];
            var nx = data[17];
            var ny = data[17 + 1];
            var cx1 = data[28];
            var cx2 = data[29];
            var dot1 = data[30];
            var dot2 = data[31];
            var vx = b2[7] - b1[7];
            var vy = b2[7 + 1] - b1[7 + 1];
            var vw1 = b1[7 + 2];
            var vw2 = b2[7 + 2];
            var x = data[26] - (nx * vy - ny * vx + vw2 * dot2 - vw1 * dot1);
            var y = data[26 + 1] - scale * (nx * vx + ny * vy - vw2 * cx2 + vw1 * cx1);
            var jOldX = data[22];
            var jOldY = data[22 + 1];
            var gamma = data[25];
            var Kb = data[19 + 1];
            var jx = data[19] * x + Kb * y - jOldX * gamma;
            var jy = Kb * x + data[19 + 2] * y - jOldY * gamma;
            var jAccX = jOldX + jx;
            var jAccY = jOldY + jy;
            if (!this._equal && jAccY > 0) {
                jAccY = 0
            }
            var jlsq = jAccX * jAccX + jAccY * jAccY;
            var jMax = data[24];
            if (this._breakUnderForce) {
                if (jlsq > jMax * jMax) {
                    return true
                }
            } else if (!this._stiff) {
                if (jlsq > jMax * jMax) {
                    jlsq = jMax / Math.sqrt(jlsq);
                    jAccX *= jlsq;
                    jAccY *= jlsq
                }
            }
            jx = jAccX - jOldX;
            jy = jAccY - jOldY;
            data[22] = jAccX;
            data[22 + 1] = jAccY;
            var lx = scale * nx * jy - ny * jx;
            var ly = nx * jx + scale * ny * jy;
            var im = b1[0];
            b1[7] -= lx * im;
            b1[7 + 1] -= ly * im;
            b1[7 + 2] += (scale * cx1 * jy - dot1 * jx) * b1[1];
            im = b2[0];
            b2[7] += lx * im;
            b2[7 + 1] += ly * im;
            b2[7 + 2] += (dot2 * jx - scale * cx2 * jy) * b2[1];
            return false
        };
        Physics2DLineConstraint.prototype._iteratePos = function() {
            var data = this._data;
            var b1 = this.bodyA._data;
            var b2 = this.bodyB._data;
            this._posError();
            var errX = data[26];
            var errY = data[26 + 1];
            var elsq = errX * errX + errY * errY;
            var maxError = data[3];
            if (this._breakUnderError && elsq > maxError * maxError) {
                return true
            }
            var slop = Physics2DConfig.LINE_SLOP_SQ;
            if (elsq < slop) {
                return false
            }
            var bias = Physics2DConfig.LINE_BIAS_COEF;
            errX *= bias;
            errY *= bias;
            elsq *= bias * bias;
            var im1 = b1[0];
            var im2 = b2[0];
            var ii1 = b1[1];
            var ii2 = b2[1];
            var massSum = im1 + im2;
            var nx = data[17];
            var ny = data[17 + 1];
            var scale = data[32];
            var lx, ly;
            if (elsq > Physics2DConfig.LINE_LARGE_ERROR_SQ) {
                if (massSum > Physics2DConfig.EFF_MASS_EPSILON) {
                    var K = Physics2DConfig.LINE_LARGE_ERROR_BIAS / massSum;
                    lx = K * (ny * errX - scale * nx * errY);
                    ly = K * (nx * errX * scale - ny * errX);
                    b1[2] -= lx * im1;
                    b1[2 + 1] -= ly * im1;
                    b2[2] += lx * im2;
                    b2[2 + 1] += ly * im2;
                    this._posError();
                    nx = data[17];
                    ny = data[17 + 1];
                    scale = data[32];
                    errX = data[26] * bias;
                    errY = data[26 + 1] * bias
                }
            }
            var rx1 = data[13];
            var ry1 = data[13 + 1];
            var rx2 = data[15];
            var ry2 = data[15 + 1];
            var delX = data[28] + rx1;
            var delY = data[29] + ry1;
            var cx1 = nx * delY - ny * delX;
            var cx2 = nx * ry2 - ny * rx2;
            var dot1 = nx * delX + ny * delY;
            var dot2 = nx * rx2 + ny * ry2;
            data[19] = massSum + dot1 * ii1 * dot1 + dot2 * ii2 * dot2;
            data[19 + 1] = -scale * (dot1 * ii1 * cx1 + dot2 * ii2 * cx2);
            data[19 + 2] = scale * scale * (massSum + cx1 * ii1 * cx1 + cx2 * ii2 * cx2);
            data[26] = errX;
            data[26 + 1] = errY;
            Physics2DConstraint.prototype.safe_solve2(data, 19, 26, 26);
            var jx = data[26];
            var jy = data[26 + 1];
            if (!this._equal && jy > 0) {
                jy = 0
            }
            lx = scale * nx * jy - ny * jx;
            ly = nx * jx + scale * ny * jy;
            b1[2] -= lx * im1;
            b1[2 + 1] -= ly * im1;
            var dr = (scale * cx1 * jy - dot1 * jx) * ii1;
            if (dr !== 0) {
                this.bodyA._deltaRotation(dr)
            }
            b2[2] += lx * im2;
            b2[2 + 1] += ly * im2;
            dr = (dot2 * jx - scale * cx2 * jy) * ii2;
            if (dr !== 0) {
                this.bodyB._deltaRotation(dr)
            }
            return false
        };
        Physics2DLineConstraint.create = function(params) {
            var p = new Physics2DLineConstraint;
            var data = p._data = new Physics2DDevice.prototype.floatArray(33);
            Physics2DConstraint.prototype.init(p, params);
            var anchor = params.anchorA;
            data[7] = anchor ? anchor[0] : 0;
            data[7 + 1] = anchor ? anchor[1] : 0;
            anchor = params.anchorB;
            data[9] = anchor ? anchor[0] : 0;
            data[9 + 1] = anchor ? anchor[1] : 0;
            anchor = params.axis;
            data[11] = anchor[0];
            data[11 + 1] = anchor[1];
            var min = data[5] = params.lowerBound !== undefined ? params.lowerBound : Number.NEGATIVE_INFINITY;
            var max = data[6] = params.upperBound !== undefined ? params.upperBound : Number.POSITIVE_INFINITY;
            p._equal = min === max;
            p.bodyA = params.bodyA;
            p.bodyB = params.bodyB;
            return p
        };
        return Physics2DLineConstraint
    }(Physics2DConstraint);
    Physics2DLineConstraint.prototype._inWorld = Physics2DConstraint.prototype.twoBodyInWorld;
    Physics2DLineConstraint.prototype._outWorld = Physics2DConstraint.prototype.twoBodyOutWorld;
    Physics2DLineConstraint.prototype._pairExists = Physics2DConstraint.prototype.twoBodyPairExists;
    Physics2DLineConstraint.prototype._wakeConnected = Physics2DConstraint.prototype.twoBodyWakeConnected;
    Physics2DLineConstraint.prototype._sleepComputation = Physics2DConstraint.prototype.twoBodySleepComputation;
    var Physics2DDistanceConstraint = function(_super) {
        __extends(Physics2DDistanceConstraint, _super);

        function Physics2DDistanceConstraint() {
            _super.apply(this, arguments);
            this.type = "DISTANCE";
            this.dimension = 1;
            this._ANCHOR_A = 7;
            this._ANCHOR_B = 9;
            this._JACC = 16
        }
        Physics2DDistanceConstraint.prototype.getLowerBound = function() {
            return this._data[5]
        };
        Physics2DDistanceConstraint.prototype.getUpperBound = function() {
            return this._data[6]
        };
        Physics2DDistanceConstraint.prototype.setLowerBound = function(lowerBound) {
            var data = this._data;
            if (data[5] !== lowerBound) {
                data[5] = lowerBound;
                this._equal = lowerBound === data[6];
                this.wake(true)
            }
        };
        Physics2DDistanceConstraint.prototype.setUpperBound = function(upperBound) {
            var data = this._data;
            if (data[6] !== upperBound) {
                data[6] = upperBound;
                this._equal = upperBound === data[5];
                this.wake(true)
            }
        };
        Physics2DDistanceConstraint.prototype._posError = function() {
            var data = this._data;
            var b1 = this.bodyA._data;
            var b2 = this.bodyB._data;
            var jointMin = data[5];
            var jointMax = data[6];
            Physics2DConstraint.prototype.rotateAnchor(data, b1, 7, 11);
            Physics2DConstraint.prototype.rotateAnchor(data, b2, 9, 13);
            var nx = b2[2] + data[13] - (b1[2] + data[11]);
            var ny = b2[2 + 1] + data[13 + 1] - (b1[2 + 1] + data[11 + 1]);
            var err = nx * nx + ny * ny;
            if (err < Physics2DConfig.NORMALIZE_SQ_EPSILON) {
                nx = data[20];
                ny = data[20 + 1];
                err = 0
            } else {
                err = Math.sqrt(err);
                var rec = 1 / err;
                nx *= rec;
                ny *= rec
            }
            if (this._equal) {
                err -= jointMin;
                this._slack = false
            } else if (err < jointMin) {
                err = jointMin - err;
                nx = -nx;
                ny = -ny;
                this._slack = false
            } else if (err > jointMax) {
                err -= jointMax;
                this._slack = false
            } else {
                nx = -nx;
                ny = -ny;
                err = 0;
                this._slack = true
            }
            data[20] = nx;
            data[20 + 1] = ny;
            data[19] = -err
        };
        Physics2DDistanceConstraint.prototype._preStep = function(deltaTime) {
            this._posError();
            if (this._slack) {
                return false
            }
            var data = this._data;
            var b1 = this.bodyA._data;
            var b2 = this.bodyB._data;
            var nx = data[20];
            var ny = data[20 + 1];
            var cx1 = data[22] = data[11] * ny - data[11 + 1] * nx;
            var cx2 = data[23] = data[13] * ny - data[13 + 1] * nx;
            data[15] = b1[0] + cx1 * b1[1] * cx1 + b2[0] + cx2 * b2[1] * cx2;
            Physics2DConstraint.prototype.safe_invert(data, 15, 16);
            if (!this._stiff) {
                if (Physics2DConstraint.prototype.soft_params(data, 15, 18, 19, deltaTime, this._breakUnderError)) {
                    return true
                }
            } else {
                data[18] = 0;
                data[19] = 0
            }
            var dtRatio = Physics2DConstraint.prototype.dtRatio(data, deltaTime);
            data[16] *= dtRatio;
            data[17] = data[2] * deltaTime;
            return false
        };
        Physics2DDistanceConstraint.prototype._warmStart = function() {
            if (this._slack) {
                return
            }
            var data = this._data;
            var b1 = this.bodyA._data;
            var b2 = this.bodyB._data;
            var jAcc = data[16];
            var jx = data[20] * jAcc;
            var jy = data[20 + 1] * jAcc;
            var im = b1[0];
            b1[7] -= jx * im;
            b1[7 + 1] -= jy * im;
            b1[7 + 2] -= data[22] * jAcc * b1[1];
            im = b2[0];
            b2[7] += jx * im;
            b2[7 + 1] += jy * im;
            b2[7 + 2] += data[23] * jAcc * b2[1]
        };
        Physics2DDistanceConstraint.prototype.getImpulseForBody = function(body, dst) {
            if (dst === undefined) {
                dst = new Physics2DDevice.prototype.floatArray(3)
            }
            var data = this._data;
            var jAcc = data[16];
            var jx = data[20] * jAcc;
            var jy = data[20 + 1] * jAcc;
            if (body === this.bodyA) {
                dst[0] = -jx;
                dst[1] = -jy;
                dst[2] = -(data[22] * jAcc)
            } else if (body === this.bodyB) {
                dst[0] = jx;
                dst[1] = jy;
                dst[2] = data[23] * jAcc
            } else {
                dst[0] = dst[1] = dst[2] = 0
            }
            return dst
        };
        Physics2DDistanceConstraint.prototype._iterateVel = function() {
            if (this._slack) {
                return false
            }
            var data = this._data;
            var b1 = this.bodyA._data;
            var b2 = this.bodyB._data;
            var nx = data[20];
            var ny = data[20 + 1];
            var cx1 = data[22];
            var cx2 = data[23];
            var x = data[19] - (nx * (b2[7] - b1[7]) + ny * (b2[7 + 1] - b1[7 + 1]) + cx2 * b2[7 + 2] - cx1 * b1[7 + 2]);
            var jOld = data[16];
            var j = data[15] * x - jOld * data[18];
            var jAcc = jOld + j;
            var jMax = data[17];
            if (!this._equal && jAcc > 0) {
                jAcc = 0
            }
            if (this._breakUnderForce) {
                if (jAcc > jMax || jAcc < -jMax) {
                    return true
                }
            } else if (!this._stiff) {
                if (jAcc > jMax) {
                    jAcc = jMax
                } else if (jAcc < -jMax) {
                    jAcc = -jMax
                }
            }
            j = jAcc - jOld;
            data[16] = jAcc;
            var jx = nx * j;
            var jy = ny * j;
            var im = b1[0];
            b1[7] -= jx * im;
            b1[7 + 1] -= jy * im;
            b1[7 + 2] -= data[22] * j * b1[1];
            im = b2[0];
            b2[7] += jx * im;
            b2[7 + 1] += jy * im;
            b2[7 + 2] += data[23] * j * b2[1];
            return false
        };
        Physics2DDistanceConstraint.prototype._iteratePos = function() {
            this._posError();
            if (this._slack) {
                return false
            }
            var data = this._data;
            var b1 = this.bodyA._data;
            var b2 = this.bodyB._data;
            var im1 = b1[0];
            var im2 = b2[0];
            var ii1 = b1[1];
            var ii2 = b2[1];
            var err = data[19];
            var maxError = data[3];
            if (this._breakUnderError && (err > maxError || err < -maxError)) {
                return true
            }
            var slop = Physics2DConfig.DIST_SLOP_SQ;
            if (err * err < slop) {
                return false
            }
            err *= Physics2DConfig.DIST_BIAS_COEF;
            var massSum = im1 + im2;
            var nx = data[20];
            var ny = data[20 + 1];
            var j, jx, jy;
            if (err * err > Physics2DConfig.DIST_LARGE_ERROR_SQ) {
                if (massSum > Physics2DConfig.EFF_MASS_EPSILON) {
                    j = err * Physics2DConfig.DIST_LARGE_ERROR_BIAS / massSum;
                    if (this._equal || j < 0) {
                        jx = nx * j;
                        jy = ny * j;
                        b1[2] -= jx * im1;
                        b1[2 + 1] -= jy * im1;
                        b2[2] += jx * im2;
                        b2[2 + 1] += jy * im2;
                        this._posError();
                        err = data[19] * Physics2DConfig.DIST_BIAS_COEF;
                        nx = data[20];
                        ny = data[20 + 1]
                    }
                }
            }
            var cx1 = data[11] * ny - data[11 + 1] * nx;
            var cx2 = data[13] * ny - data[13 + 1] * nx;
            data[15] = massSum + cx1 * ii1 * cx1 + cx2 * ii2 * cx2;
            data[19] = err;
            Physics2DConstraint.prototype.safe_solve(data, 15, 19, 19);
            j = data[19];
            if (this._equal || j < 0) {
                jx = nx * j;
                jy = ny * j;
                b1[2] -= jx * im1;
                b1[2 + 1] -= jy * im1;
                var dr = -cx1 * ii1 * j;
                if (dr !== 0) {
                    this.bodyA._deltaRotation(dr)
                }
                b2[2] += jx * im2;
                b2[2 + 1] += jy * im2;
                dr = cx2 * ii2 * j;
                if (dr !== 0) {
                    this.bodyB._deltaRotation(dr)
                }
            }
            return false
        };
        Physics2DDistanceConstraint.create = function(params) {
            var p = new Physics2DDistanceConstraint;
            var data = p._data = new Physics2DDevice.prototype.floatArray(24);
            Physics2DConstraint.prototype.init(p, params);
            var anchor = params.anchorA;
            data[7] = anchor ? anchor[0] : 0;
            data[7 + 1] = anchor ? anchor[1] : 0;
            anchor = params.anchorB;
            data[9] = anchor ? anchor[0] : 0;
            data[9 + 1] = anchor ? anchor[1] : 0;
            var min = data[5] = params.lowerBound !== undefined ? params.lowerBound : 0;
            var max = data[6] = params.upperBound !== undefined ? params.upperBound : 0;
            p._equal = min === max;
            p._slack = false;
            p.bodyA = params.bodyA;
            p.bodyB = params.bodyB;
            data[20] = 1;
            data[20 + 1] = 0;
            return p
        };
        return Physics2DDistanceConstraint
    }(Physics2DConstraint);
    Physics2DDistanceConstraint.prototype._inWorld = Physics2DConstraint.prototype.twoBodyInWorld;
    Physics2DDistanceConstraint.prototype._outWorld = Physics2DConstraint.prototype.twoBodyOutWorld;
    Physics2DDistanceConstraint.prototype._pairExists = Physics2DConstraint.prototype.twoBodyPairExists;
    Physics2DDistanceConstraint.prototype._wakeConnected = Physics2DConstraint.prototype.twoBodyWakeConnected;
    Physics2DDistanceConstraint.prototype._sleepComputation = Physics2DConstraint.prototype.twoBodySleepComputation;
    var Physics2DAngleConstraint = function(_super) {
        __extends(Physics2DAngleConstraint, _super);

        function Physics2DAngleConstraint() {
            _super.apply(this, arguments);
            this.type = "ANGLE";
            this.dimension = 1;
            this._JACC = 9
        }
        Physics2DAngleConstraint.prototype.getLowerBound = function() {
            return this._data[5]
        };
        Physics2DAngleConstraint.prototype.getUpperBound = function() {
            return this._data[6]
        };
        Physics2DAngleConstraint.prototype.getRatio = function() {
            return this._data[7]
        };
        Physics2DAngleConstraint.prototype.setLowerBound = function(lowerBound) {
            var data = this._data;
            if (data[5] !== lowerBound) {
                data[5] = lowerBound;
                this._equal = lowerBound === data[6];
                this.wake(true)
            }
        };
        Physics2DAngleConstraint.prototype.setUpperBound = function(upperBound) {
            var data = this._data;
            if (data[6] !== upperBound) {
                data[6] = upperBound;
                this._equal = upperBound === data[5];
                this.wake(true)
            }
        };
        Physics2DAngleConstraint.prototype.setRatio = function(ratio) {
            var data = this._data;
            if (data[7] !== ratio) {
                data[7] = ratio;
                this.wake(true)
            }
        };
        Physics2DAngleConstraint.prototype._posError = function() {
            var data = this._data;
            var b1 = this.bodyA._data;
            var b2 = this.bodyB._data;
            var ratio = data[7];
            var jointMin = data[5];
            var jointMax = data[6];
            var err = ratio * b2[2 + 2] - b1[2 + 2];
            if (this._equal) {
                err -= jointMax;
                this._slack = false;
                data[13] = 1
            } else {
                if (err < jointMin) {
                    err = jointMin - err;
                    this._slack = false;
                    data[13] = -1
                } else if (err > jointMax) {
                    err -= jointMax;
                    this._slack = false;
                    data[13] = 1
                } else {
                    err = 0;
                    this._slack = true;
                    data[13] = 0
                }
            }
            data[12] = -err
        };
        Physics2DAngleConstraint.prototype._preStep = function(deltaTime) {
            var data = this._data;
            var b1 = this.bodyA._data;
            var b2 = this.bodyB._data;
            var ratio = data[7];
            var ii1 = b1[1];
            var ii2 = b2[1];
            data[8] = ii1 + ratio * ratio * ii2;
            Physics2DConstraint.prototype.safe_invert(data, 8, 9);
            this._posError();
            if (this._slack) {
                return false
            }
            if (!this._stiff) {
                if (Physics2DConstraint.prototype.soft_params(data, 8, 11, 12, deltaTime, this._breakUnderError)) {
                    return true
                }
            } else {
                data[11] = 0;
                data[12] = 0
            }
            var dtRatio = Physics2DConstraint.prototype.dtRatio(data, deltaTime);
            data[9] *= dtRatio;
            data[10] = data[2] * deltaTime;
            return false
        };
        Physics2DAngleConstraint.prototype._warmStart = function() {
            if (this._slack) {
                return
            }
            var data = this._data;
            var b1 = this.bodyA._data;
            var b2 = this.bodyB._data;
            var j = data[9] * data[13];
            b1[7 + 2] -= j * b1[1];
            b2[7 + 2] += j * data[7] * b2[1]
        };
        Physics2DAngleConstraint.prototype.getImpulseForBody = function(body, dst) {
            if (dst === undefined) {
                dst = new Physics2DDevice.prototype.floatArray(3)
            }
            var data = this._data;
            var j = data[9] * data[13];
            dst[0] = dst[1] = 0;
            dst[2] = (body === this.bodyA ? -1 : body === this.bodyB ? data[7] : 0) * j;
            return dst
        };
        Physics2DAngleConstraint.prototype._iterateVel = function() {
            if (this._slack) {
                return false
            }
            var data = this._data;
            var b1 = this.bodyA._data;
            var b2 = this.bodyB._data;
            var scale = data[13];
            var ratio = data[7];
            var x = data[12] - scale * (ratio * b2[7 + 2] - b1[7 + 2]);
            var jOld = data[9];
            var j = data[8] * x - jOld * data[11];
            var jAcc = jOld + j;
            var jMax = data[10];
            if (this._breakUnderForce) {
                if (jAcc > jMax || jAcc < -jMax) {
                    return true
                } else if (!this._equal && jAcc > 0) {
                    jAcc = 0
                }
            } else if (!this._stiff) {
                if (!this._equal) {
                    if (jAcc > 0) {
                        jAcc = 0
                    } else if (jAcc < -jMax) {
                        jAcc = -jMax
                    }
                } else {
                    if (jAcc > jMax) {
                        jAcc = jMax
                    } else if (jAcc < -jMax) {
                        jAcc = -jMax
                    }
                }
            } else if (!this._equal && jAcc > 0) {
                jAcc = 0
            }
            j = jAcc - jOld;
            data[9] = jAcc;
            j *= scale;
            b1[7 + 2] -= j * b1[1];
            b2[7 + 2] += j * ratio * b2[1];
            return false
        };
        Physics2DAngleConstraint.prototype._iteratePos = function() {
            this._posError();
            if (this._slack) {
                return false
            }
            var data = this._data;
            var err = data[12];
            var maxError = data[3];
            if (this._breakUnderError && (err > maxError || err < -maxError)) {
                return true
            }
            var slop = Physics2DConfig.ANGLE_SLOP_SQ;
            if (err * err < slop) {
                return false
            }
            err *= Physics2DConfig.ANGLE_BIAS_COEF;
            var j = err * Physics2DConfig.ANGLE_BIAS_COEF * data[8];
            if (this._equal || j < 0) {
                var b = this.bodyA;
                j *= data[13];
                var dr = -j * b._data[1];
                if (dr !== 0) {
                    b._deltaRotation(dr)
                }
                b = this.bodyB;
                dr = j * b._data[1];
                if (dr !== 0) {
                    b._deltaRotation(dr)
                }
            }
            return false
        };
        Physics2DAngleConstraint.create = function(params) {
            var p = new Physics2DAngleConstraint;
            var data = p._data = new Physics2DDevice.prototype.floatArray(14);
            Physics2DConstraint.prototype.init(p, params);
            data[7] = params.ratio !== undefined ? params.ratio : 1;
            var min = data[5] = params.lowerBound !== undefined ? params.lowerBound : 0;
            var max = data[6] = params.upperBound !== undefined ? params.upperBound : 0;
            p._equal = min === max;
            p._slack = false;
            p.bodyA = params.bodyA;
            p.bodyB = params.bodyB;
            return p
        };
        return Physics2DAngleConstraint
    }(Physics2DConstraint);
    Physics2DAngleConstraint.prototype._inWorld = Physics2DConstraint.prototype.twoBodyInWorld;
    Physics2DAngleConstraint.prototype._outWorld = Physics2DConstraint.prototype.twoBodyOutWorld;
    Physics2DAngleConstraint.prototype._pairExists = Physics2DConstraint.prototype.twoBodyPairExists;
    Physics2DAngleConstraint.prototype._wakeConnected = Physics2DConstraint.prototype.twoBodyWakeConnected;
    Physics2DAngleConstraint.prototype._sleepComputation = Physics2DConstraint.prototype.twoBodySleepComputation;
    var Physics2DWeldConstraint = function(_super) {
        __extends(Physics2DWeldConstraint, _super);

        function Physics2DWeldConstraint() {
            _super.apply(this, arguments);
            this.type = "WELD";
            this.dimension = 3;
            this._ANCHOR_A = 5;
            this._ANCHOR_B = 7;
            this._JACC = 20
        }
        Physics2DWeldConstraint.prototype.getPhase = function() {
            return this._data[13]
        };
        Physics2DWeldConstraint.prototype.setPhase = function(phase) {
            var data = this._data;
            if (phase !== data[13]) {
                data[13] = phase;
                this.wake(true)
            }
        };
        Physics2DWeldConstraint.prototype._preStep = function(deltaTime) {
            var data = this._data;
            var b1 = this.bodyA._data;
            var b2 = this.bodyB._data;
            Physics2DConstraint.prototype.rotateAnchor(data, b1, 5, 9);
            var rx1 = data[9];
            var ry1 = data[9 + 1];
            Physics2DConstraint.prototype.rotateAnchor(data, b2, 7, 11);
            var rx2 = data[11];
            var ry2 = data[11 + 1];
            var massSum = b1[0] + b2[0];
            var ii1 = b1[1];
            var ii2 = b2[1];
            data[14] = massSum + ry1 * ii1 * ry1 + ry2 * ii2 * ry2;
            data[14 + 1] = -(rx1 * ii1 * ry1) - rx2 * ii2 * ry2;
            data[14 + 2] = -(ry1 * ii1) - ry2 * ii2;
            data[14 + 3] = massSum + rx1 * ii1 * rx1 + rx2 * ii2 * rx2;
            data[14 + 4] = rx1 * ii1 + rx2 * ii2;
            data[14 + 5] = ii1 + ii2;
            Physics2DConstraint.prototype.safe_invert3(data, 14, 20);
            if (!this._stiff) {
                data[25] = b1[2] + rx1 - (b2[2] + rx2);
                data[25 + 1] = b1[2 + 1] + ry1 - (b2[2 + 1] + ry2);
                data[25 + 2] = b1[2 + 2] + data[13] - b2[2 + 2];
                if (Physics2DConstraint.prototype.soft_params3(data, 14, 24, 25, deltaTime, this._breakUnderError)) {
                    return true
                }
            } else {
                data[24] = 0;
                data[25] = 0;
                data[25 + 1] = 0;
                data[25 + 2] = 0
            }
            var dtRatio = Physics2DConstraint.prototype.dtRatio(data, deltaTime);
            data[20] *= dtRatio;
            data[20 + 1] *= dtRatio;
            data[20 + 2] *= dtRatio;
            data[23] = data[2] * deltaTime;
            return false
        };
        Physics2DWeldConstraint.prototype._warmStart = function() {
            var data = this._data;
            var b1 = this.bodyA._data;
            var b2 = this.bodyB._data;
            var jx = data[20];
            var jy = data[20 + 1];
            var jz = data[20 + 2];
            var im = b1[0];
            b1[7] -= jx * im;
            b1[7 + 1] -= jy * im;
            b1[7 + 2] -= (data[9] * jy - data[9 + 1] * jx + jz) * b1[1];
            im = b2[0];
            b2[7] += jx * im;
            b2[7 + 1] += jy * im;
            b2[7 + 2] += (data[11] * jy - data[11 + 1] * jx + jz) * b2[1]
        };
        Physics2DWeldConstraint.prototype.getImpulseForBody = function(body, dst) {
            if (dst === undefined) {
                dst = new Physics2DDevice.prototype.floatArray(3)
            }
            var data = this._data;
            var jx = data[20];
            var jy = data[20 + 1];
            var jz = data[20 + 2];
            if (body === this.bodyA) {
                dst[0] = -jx;
                dst[1] = -jy;
                dst[2] = -(data[9] * jy - data[9 + 1] * jx + jz)
            } else if (body === this.bodyB) {
                dst[0] = jx;
                dst[1] = jy;
                dst[2] = data[11] * jy - data[11 + 1] * jx + jz
            } else {
                dst[0] = dst[1] = dst[2] = 0
            }
            return dst
        };
        Physics2DWeldConstraint.prototype._iterateVel = function() {
            var data = this._data;
            var b1 = this.bodyA._data;
            var b2 = this.bodyB._data;
            var rx1 = data[9];
            var ry1 = data[9 + 1];
            var rx2 = data[11];
            var ry2 = data[11 + 1];
            var vw1 = b1[7 + 2];
            var vw2 = b2[7 + 2];
            var x = data[25] - (b2[7] - ry2 * vw2) + (b1[7] - ry1 * vw1);
            var y = data[25 + 1] - (b2[7 + 1] + rx2 * vw2) + (b1[7 + 1] + rx1 * vw1);
            var z = data[25 + 2] - vw2 + vw1;
            var jOldX = data[20];
            var jOldY = data[20 + 1];
            var jOldZ = data[20 + 2];
            var gamma = data[24];
            var Kb = data[14 + 1];
            var Kc = data[14 + 2];
            var Ke = data[14 + 4];
            var jx = data[14] * x + Kb * y + Kc * z - jOldX * gamma;
            var jy = Kb * x + data[14 + 3] * y + Ke * z - jOldY * gamma;
            var jz = Kc * x + Ke * y + data[14 + 5] * z - jOldZ * gamma;
            var jAccX = jOldX + jx;
            var jAccY = jOldY + jy;
            var jAccZ = jOldZ + jz;
            var jsq = jAccX * jAccX + jAccY * jAccY + jAccZ * jAccZ;
            var jMax = data[23];
            if (this._breakUnderForce) {
                if (jsq > jMax * jMax) {
                    return true
                }
            } else if (!this._stiff) {
                if (jsq > jMax * jMax) {
                    jsq = jMax / Math.sqrt(jsq);
                    jAccX *= jsq;
                    jAccY *= jsq;
                    jAccZ *= jsq
                }
            }
            jx = jAccX - jOldX;
            jy = jAccY - jOldY;
            jz = jAccZ - jOldZ;
            data[20] = jAccX;
            data[20 + 1] = jAccY;
            data[20 + 2] = jAccZ;
            var im = b1[0];
            b1[7] -= jx * im;
            b1[7 + 1] -= jy * im;
            b1[7 + 2] -= (rx1 * jy - ry1 * jx + jz) * b1[1];
            im = b2[0];
            b2[7] += jx * im;
            b2[7 + 1] += jy * im;
            b2[7 + 2] += (rx2 * jy - ry2 * jx + jz) * b2[1];
            return false
        };
        Physics2DWeldConstraint.prototype._iteratePos = function() {
            var data = this._data;
            var b1 = this.bodyA._data;
            var b2 = this.bodyB._data;
            var im1 = b1[0];
            var im2 = b2[0];
            var ii1 = b1[1];
            var ii2 = b2[1];
            Physics2DConstraint.prototype.rotateAnchor(data, b1, 5, 9);
            var rx1 = data[9];
            var ry1 = data[9 + 1];
            Physics2DConstraint.prototype.rotateAnchor(data, b2, 7, 11);
            var rx2 = data[11];
            var ry2 = data[11 + 1];
            var errX = b1[2] + rx1 - (b2[2] + rx2);
            var errY = b1[2 + 1] + ry1 - (b2[2 + 1] + ry2);
            var errZ = b1[2 + 2] + data[13] - b2[2 + 2];
            var elsq = errX * errX + errY * errY;
            var wlsq = errZ * errZ;
            var maxError = data[3];
            if (this._breakUnderError && elsq + wlsq > maxError * maxError) {
                return true
            }
            if (elsq < Physics2DConfig.WELD_LINEAR_SLOP_SQ && wlsq < Physics2DConfig.WELD_ANGULAR_SLOP_SQ) {
                return false
            }
            var scale = Physics2DConfig.WELD_BIAS_COEF;
            errX *= scale;
            errY *= scale;
            errZ *= scale;
            elsq *= scale * scale;
            var massSum = im1 + im2;
            var jx, jy;
            if (elsq > Physics2DConfig.WELD_LARGE_ERROR_SQ) {
                if (massSum > Physics2DConfig.EFF_MASS_EPSILON) {
                    var K = Physics2DConfig.WELD_BIAS_COEF / massSum;
                    jx = errX * K;
                    jy = errY * K;
                    var jsq = jx * jx + jy * jy;
                    var maxJ = Physics2DConfig.WELD_LARGE_ERROR_MAX;
                    if (jsq > maxJ * maxJ) {
                        jsq = maxJ / Math.sqrt(jsq);
                        jx *= jsq;
                        jy *= jsq
                    }
                    b1[2] -= jx * im1;
                    b1[2 + 1] -= jy * im1;
                    b2[2] += jx * im1;
                    b2[2 + 1] += jy * im1;
                    errX = b1[2] + rx1 - (b2[2] + rx2);
                    errY = b1[2 + 1] + ry1 - (b2[2 + 1] + ry2);
                    errX *= scale;
                    errY *= scale;
                    elsq = errX * errX + errY * errY
                }
            }
            data[14] = massSum + ry1 * ii1 * ry1 + ry2 * ii2 * ry2;
            data[14 + 1] = -(rx1 * ii1 * ry1) - rx2 * ii2 * ry2;
            data[14 + 2] = -(ry1 * ii1) - ry2 * ii2;
            data[14 + 3] = massSum + rx1 * ii1 * rx1 + rx2 * ii2 * rx2;
            data[14 + 4] = rx1 * ii1 + rx2 * ii2;
            data[14 + 5] = ii1 + ii2;
            if (elsq > Physics2DConfig.WELD_MAX_LINEAR_ERROR_SQ) {
                elsq = Physics2DConfig.WELD_MAX_LINEAR_ERROR / Math.sqrt(elsq);
                errX *= elsq;
                errY *= elsq
            }
            var maxW = Physics2DConfig.WELD_MAX_ANGULAR_ERROR;
            if (errZ > maxW) {
                errZ = maxW
            } else if (errZ < -maxW) {
                errZ = -maxW
            }
            data[25] = errX;
            data[25 + 1] = errY;
            data[25 + 2] = errZ;
            Physics2DConstraint.prototype.safe_solve3(data, 14, 25, 25);
            jx = data[25];
            jy = data[25 + 1];
            var jz = data[25 + 2];
            b1[2] -= jx * im1;
            b1[2 + 1] -= jy * im1;
            var dW = -((rx1 * jy - ry1 * jx + jz) * ii1);
            if (dW !== 0) {
                this.bodyA._deltaRotation(dW)
            }
            b2[2] += jx * im2;
            b2[2 + 1] += jy * im2;
            dW = (rx2 * jy - ry2 * jx + jz) * ii2;
            if (dW !== 0) {
                this.bodyB._deltaRotation(dW)
            }
            return false
        };
        Physics2DWeldConstraint.create = function(params) {
            var p = new Physics2DWeldConstraint;
            var data = p._data = new Physics2DDevice.prototype.floatArray(28);
            Physics2DConstraint.prototype.init(p, params);
            var anchor = params.anchorA;
            data[5] = anchor ? anchor[0] : 0;
            data[5 + 1] = anchor ? anchor[1] : 0;
            anchor = params.anchorB;
            data[7] = anchor ? anchor[0] : 0;
            data[7 + 1] = anchor ? anchor[1] : 0;
            data[13] = params.phase !== undefined ? params.phase : 0;
            p.bodyA = params.bodyA;
            p.bodyB = params.bodyB;
            return p
        };
        return Physics2DWeldConstraint
    }(Physics2DConstraint);
    Physics2DWeldConstraint.prototype._inWorld = Physics2DConstraint.prototype.twoBodyInWorld;
    Physics2DWeldConstraint.prototype._outWorld = Physics2DConstraint.prototype.twoBodyOutWorld;
    Physics2DWeldConstraint.prototype._pairExists = Physics2DConstraint.prototype.twoBodyPairExists;
    Physics2DWeldConstraint.prototype._wakeConnected = Physics2DConstraint.prototype.twoBodyWakeConnected;
    Physics2DWeldConstraint.prototype._sleepComputation = Physics2DConstraint.prototype.twoBodySleepComputation;
    var Physics2DPointConstraint = function(_super) {
        __extends(Physics2DPointConstraint, _super);

        function Physics2DPointConstraint() {
            _super.apply(this, arguments);
            this.type = "POINT";
            this.dimension = 2;
            this._ANCHOR_A = 5;
            this._ANCHOR_B = 7;
            this._JACC = 16
        }
        Physics2DPointConstraint.prototype._preStep = function(deltaTime) {
            var data = this._data;
            var b1 = this.bodyA._data;
            var b2 = this.bodyB._data;
            Physics2DConstraint.prototype.rotateAnchor(data, b1, 5, 9);
            var rx1 = data[9];
            var ry1 = data[9 + 1];
            Physics2DConstraint.prototype.rotateAnchor(data, b2, 7, 11);
            var rx2 = data[11];
            var ry2 = data[11 + 1];
            var massSum = b1[0] + b2[0];
            var ii1 = b1[1];
            var ii2 = b2[1];
            data[13] = massSum + ry1 * ii1 * ry1 + ry2 * ii2 * ry2;
            data[13 + 1] = -(rx1 * ii1 * ry1) - rx2 * ii2 * ry2;
            data[13 + 2] = massSum + rx1 * ii1 * rx1 + rx2 * ii2 * rx2;
            Physics2DConstraint.prototype.safe_invert2(data, 13, 16);
            if (!this._stiff) {
                data[20] = b1[2] + rx1 - (b2[2] + rx2);
                data[20 + 1] = b1[2 + 1] + ry1 - (b2[2 + 1] + ry2);
                if (Physics2DConstraint.prototype.soft_params2(data, 13, 19, 20, deltaTime, this._breakUnderError)) {
                    return true
                }
            } else {
                data[19] = 0;
                data[20] = 0;
                data[20 + 1] = 0
            }
            var dtRatio = Physics2DConstraint.prototype.dtRatio(data, deltaTime);
            data[16] *= dtRatio;
            data[16 + 1] *= dtRatio;
            data[18] = data[2] * deltaTime;
            return false
        };
        Physics2DPointConstraint.prototype._warmStart = function() {
            var data = this._data;
            var b1 = this.bodyA._data;
            var b2 = this.bodyB._data;
            var jx = data[16];
            var jy = data[16 + 1];
            var im = b1[0];
            b1[7] -= jx * im;
            b1[7 + 1] -= jy * im;
            b1[7 + 2] -= (data[9] * jy - data[9 + 1] * jx) * b1[1];
            im = b2[0];
            b2[7] += jx * im;
            b2[7 + 1] += jy * im;
            b2[7 + 2] += (data[11] * jy - data[11 + 1] * jx) * b2[1]
        };
        Physics2DPointConstraint.prototype.getImpulseForBody = function(body, dst) {
            if (dst === undefined) {
                dst = new Physics2DDevice.prototype.floatArray(3)
            }
            var data = this._data;
            var jx = data[16];
            var jy = data[16 + 1];
            if (body === this.bodyA) {
                dst[0] = -jx;
                dst[1] = -jy;
                dst[2] = -(data[9] * jy - data[9 + 1] * jx)
            } else if (body === this.bodyB) {
                dst[0] = jx;
                dst[1] = jy;
                dst[2] = data[11] * jy - data[11 + 1] * jx
            } else {
                dst[0] = dst[1] = dst[2] = 0
            }
            return dst
        };
        Physics2DPointConstraint.prototype._iterateVel = function() {
            var data = this._data;
            var b1 = this.bodyA._data;
            var b2 = this.bodyB._data;
            var rx1 = data[9];
            var ry1 = data[9 + 1];
            var rx2 = data[11];
            var ry2 = data[11 + 1];
            var vw1 = b1[7 + 2];
            var vw2 = b2[7 + 2];
            var x = data[20] - (b2[7] - ry2 * vw2) + (b1[7] - ry1 * vw1);
            var y = data[20 + 1] - (b2[7 + 1] + rx2 * vw2) + (b1[7 + 1] + rx1 * vw1);
            var jOldX = data[16];
            var jOldY = data[16 + 1];
            var Kb = data[13 + 1];
            var gamma = data[19];
            var jx = data[13] * x + Kb * y - jOldX * gamma;
            var jy = Kb * x + data[13 + 2] * y - jOldY * gamma;
            var jAccX = jOldX + jx;
            var jAccY = jOldY + jy;
            var jsq = jAccX * jAccX + jAccY * jAccY;
            var jMax = data[18];
            if (this._breakUnderForce) {
                if (jsq > jMax * jMax) {
                    return true
                }
            } else if (!this._stiff) {
                if (jsq > jMax * jMax) {
                    jsq = jMax / Math.sqrt(jsq);
                    jAccX *= jsq;
                    jAccY *= jsq
                }
            }
            jx = jAccX - jOldX;
            jy = jAccY - jOldY;
            data[16] = jAccX;
            data[16 + 1] = jAccY;
            var im = b1[0];
            b1[7] -= jx * im;
            b1[7 + 1] -= jy * im;
            b1[7 + 2] -= (rx1 * jy - ry1 * jx) * b1[1];
            im = b2[0];
            b2[7] += jx * im;
            b2[7 + 1] += jy * im;
            b2[7 + 2] += (rx2 * jy - ry2 * jx) * b2[1];
            return false
        };
        Physics2DPointConstraint.prototype._iteratePos = function() {
            var data = this._data;
            var b1 = this.bodyA._data;
            var b2 = this.bodyB._data;
            var im1 = b1[0];
            var im2 = b2[0];
            var ii1 = b1[1];
            var ii2 = b2[1];
            Physics2DConstraint.prototype.rotateAnchor(data, b1, 5, 9);
            var rx1 = data[9];
            var ry1 = data[9 + 1];
            Physics2DConstraint.prototype.rotateAnchor(data, b2, 7, 11);
            var rx2 = data[11];
            var ry2 = data[11 + 1];
            var errX = b1[2] + rx1 - (b2[2] + rx2);
            var errY = b1[2 + 1] + ry1 - (b2[2 + 1] + ry2);
            var elsq = errX * errX + errY * errY;
            var maxError = data[3];
            if (this._breakUnderError && elsq > maxError * maxError) {
                return true
            }
            if (elsq < Physics2DConfig.POINT_SLOP_SQ) {
                return false
            }
            var scale = Physics2DConfig.POINT_BIAS_COEF;
            errX *= scale;
            errY *= scale;
            elsq *= scale * scale;
            var massSum = im1 + im2;
            var jx, jy;
            if (elsq > Physics2DConfig.POINT_LARGE_ERROR_SQ) {
                if (massSum > Physics2DConfig.EFF_MASS_EPSILON) {
                    var K = Physics2DConfig.POINT_LARGE_ERROR_BIAS / massSum;
                    jx = errX * K;
                    jy = errY * K;
                    var jsq = jx * jx + jy * jy;
                    var maxJ = Physics2DConfig.POINT_LARGE_ERROR_MAX;
                    if (jsq > maxJ * maxJ) {
                        jsq = maxJ / Math.sqrt(jsq);
                        jx *= jsq;
                        jy *= jsq
                    }
                    b1[2] -= jx * im1;
                    b1[2 + 1] -= jy * im1;
                    b2[2] += jx * im1;
                    b2[2 + 1] += jy * im1;
                    errX = b1[2] + rx1 - (b2[2] + rx2);
                    errY = b1[2 + 1] + ry1 - (b2[2 + 1] + ry2);
                    errX *= scale;
                    errY *= scale;
                    elsq = errX * errX + errY * errY
                }
            }
            data[13] = massSum + ry1 * ii1 * ry1 + ry2 * ii2 * ry2;
            data[13 + 1] = -(rx1 * ii1 * ry1) - rx2 * ii2 * ry2;
            data[13 + 2] = massSum + rx1 * ii1 * rx1 + rx2 * ii2 * rx2;
            if (elsq > Physics2DConfig.POINT_MAX_ERROR_SQ) {
                elsq = Physics2DConfig.POINT_MAX_ERROR / Math.sqrt(elsq);
                errX *= elsq;
                errY *= elsq
            }
            data[20] = errX;
            data[20 + 1] = errY;
            Physics2DConstraint.prototype.safe_solve2(data, 13, 20, 20);
            jx = data[20];
            jy = data[20 + 1];
            b1[2] -= jx * im1;
            b1[2 + 1] -= jy * im1;
            var dW = -((rx1 * jy - ry1 * jx) * ii1);
            if (dW !== 0) {
                this.bodyA._deltaRotation(dW)
            }
            b2[2] += jx * im2;
            b2[2 + 1] += jy * im2;
            dW = (rx2 * jy - ry2 * jx) * ii2;
            if (dW !== 0) {
                this.bodyB._deltaRotation(dW)
            }
            return false
        };
        Physics2DPointConstraint.create = function(params) {
            var p = new Physics2DPointConstraint;
            var data = p._data = new Physics2DDevice.prototype.floatArray(22);
            Physics2DConstraint.prototype.init(p, params);
            var anchor = params.anchorA;
            data[5] = anchor ? anchor[0] : 0;
            data[5 + 1] = anchor ? anchor[1] : 0;
            anchor = params.anchorB;
            data[7] = anchor ? anchor[0] : 0;
            data[7 + 1] = anchor ? anchor[1] : 0;
            p.bodyA = params.bodyA;
            p.bodyB = params.bodyB;
            return p
        };
        return Physics2DPointConstraint
    }(Physics2DConstraint);
    Physics2DPointConstraint.prototype._inWorld = Physics2DConstraint.prototype.twoBodyInWorld;
    Physics2DPointConstraint.prototype._outWorld = Physics2DConstraint.prototype.twoBodyOutWorld;
    Physics2DPointConstraint.prototype._pairExists = Physics2DConstraint.prototype.twoBodyPairExists;
    Physics2DPointConstraint.prototype._wakeConnected = Physics2DConstraint.prototype.twoBodyWakeConnected;
    Physics2DPointConstraint.prototype._sleepComputation = Physics2DConstraint.prototype.twoBodySleepComputation;
    var Physics2DShape = function() {
        function Physics2DShape() {}
        Physics2DShape.prototype.computeArea = function() {
            return 0
        };
        Physics2DShape.prototype.computeMasslessInertia = function() {
            return 0
        };
        Physics2DShape.prototype.computeCenterOfMass = function(dst) {
            return null
        };
        Physics2DShape.prototype.translate = function(translation, skip) {};
        Physics2DShape.prototype._update = function(posX, posY, cos, sin, skipAABB) {};
        Physics2DShape.prototype.clone = function() {
            return undefined
        };
        Physics2DShape.prototype.getGroup = function() {
            return this._group
        };
        Physics2DShape.prototype.setGroup = function(group) {
            this._group = group;
            if (this.body) {
                this.body.wake(true)
            }
        };
        Physics2DShape.prototype.getMask = function() {
            return this._mask
        };
        Physics2DShape.prototype.setMask = function(mask) {
            this._mask = mask;
            if (this.body) {
                this.body.wake(true)
            }
        };
        Physics2DShape.prototype.getMaterial = function() {
            return this._material
        };
        Physics2DShape.prototype.setMaterial = function(material) {
            if (this._material !== material) {
                this._material = material;
                if (this.body) {
                    this.body._invalidate()
                }
                var arbiters = this.arbiters;
                var limit2 = arbiters.length;
                var j;
                for (j = 0; j < limit2; j += 1) {
                    arbiters[j]._invalidate()
                }
            }
        };
        Physics2DShape.prototype.copyCommon = function(from, to) {
            to._type = from._type;
            to._material = from._material;
            to._group = from._group;
            to._mask = from._mask;
            to.sensor = from.sensor;
            to.id = Physics2DShape.uniqueId;
            Physics2DShape.uniqueId += 1;
            to.arbiters = [];
            to._bphaseHandle = null;
            to.userData = from.userData;
            var fromData = from._data;
            var limit = from._data.length;
            var toData = to._data = new Physics2DDevice.prototype.floatArray(limit);
            var i;
            for (i = 0; i < limit; i += 1) {
                toData[i] = fromData[i]
            }
            to._onPreSolve = [];
            to._events = []
        };
        Physics2DShape.prototype.init = function(shape, params) {
            shape._material = params.material || Physics2DMaterial.create();
            shape._group = params.group !== undefined ? params.group : 1;
            shape._mask = params.mask !== undefined ? params.mask : 4294967295;
            shape.sensor = params.sensor !== undefined ? params.sensor : false;
            shape.arbiters = [];
            shape._bphaseHandle = null;
            shape.userData = params.userData !== undefined ? params.userData : null;
            shape.id = Physics2DShape.uniqueId;
            Physics2DShape.uniqueId += 1;
            shape._onPreSolve = [];
            shape._events = []
        };
        Physics2DShape.eventIndex = function(events, type, callback, callbackMask) {
            var limit = events.length;
            var i;
            for (i = 0; i < limit; i += 1) {
                var eventObject = events[i];
                if (eventObject.callback === callback && eventObject.mask === callbackMask && eventObject.type === type) {
                    return i
                }
            }
            return -1
        };
        Physics2DShape.prototype.addEventListener = function(eventType, callback, callbackMask, deterministic) {
            var events, type;
            if (eventType === "preSolve") {
                events = this._onPreSolve;
                type = 6
            } else {
                events = this._events;
                type = eventType === "begin" ? 1 : eventType === "progress" ? 2 : eventType === "end" ? 3 : null
            }
            if (type === null) {
                return false
            }
            if (eventType !== "preSolve") {
                deterministic = undefined
            } else if (deterministic === undefined) {
                deterministic = false
            }
            var index = Physics2DShape.eventIndex(events, type, callback, callbackMask);
            if (index !== -1) {
                return false
            }
            events.push({
                callback: callback,
                mask: callbackMask,
                type: type,
                deterministic: deterministic
            });
            if (this.body) {
                this.body.wake(true)
            }
            return true
        };
        Physics2DShape.prototype.removeEventListener = function(eventType, callback, callbackMask) {
            var events, type;
            if (eventType === "preSolve") {
                events = this._onPreSolve;
                type = 6
            } else {
                events = this._events;
                type = eventType === "begin" ? 1 : eventType === "progress" ? 2 : eventType === "end" ? 3 : null
            }
            if (type === null) {
                return false
            }
            var index = Physics2DShape.eventIndex(events, type, callback, callbackMask);
            if (index === -1) {
                return false
            }
            events.splice(index, 1);
            if (this.body) {
                this.body.wake(true)
            }
            return true
        };
        Physics2DShape.uniqueId = 0;
        return Physics2DShape
    }();
    var Physics2DCircle = function(_super) {
        __extends(Physics2DCircle, _super);

        function Physics2DCircle() {
            _super.call(this);
            this.type = "CIRCLE"
        }
        Physics2DCircle.prototype.computeArea = function() {
            var r = this._data[6];
            return Math.PI * r * r
        };
        Physics2DCircle.prototype.computeMasslessInertia = function() {
            var data = this._data;
            var r = this._data[6];
            var x = data[7];
            var y = data[7 + 1];
            return .5 * r * r + (x * x + y * y)
        };
        Physics2DCircle.prototype.getRadius = function() {
            return this._data[6]
        };
        Physics2DCircle.prototype.setRadius = function(radius) {
            var body = this.body;
            if (body && body.world && (body._type === 2 || body.world._midStep)) {
                return
            }
            var data = this._data;
            if (radius !== data[6]) {
                data[6] = radius;
                this._validate();
                if (body) {
                    body._invalidate()
                }
            }
        };
        Physics2DCircle.prototype.getOrigin = function(dst) {
            if (dst === undefined) {
                dst = new Physics2DDevice.prototype.floatArray(2)
            }
            var data = this._data;
            dst[0] = data[7];
            dst[1] = data[7 + 1];
            return dst
        };
        Physics2DCircle.prototype.setOrigin = function(origin) {
            var body = this.body;
            if (body && body.world && (body._type === 2 || body.world._midStep)) {
                return
            }
            var data = this._data;
            var originX = origin[0];
            var originY = origin[1];
            if (data[7] !== originX || data[7 + 1] !== originY) {
                data[7] = originX;
                data[7 + 1] = originY;
                this._validate();
                if (body) {
                    body._invalidate()
                }
            }
        };
        Physics2DCircle.prototype.clone = function() {
            var c = new Physics2DCircle;
            Physics2DShape.prototype.copyCommon(this, c);
            return c
        };
        Physics2DCircle.prototype.scale = function(scale) {
            if (scale <= 0) {
                return
            }
            var body = this.body;
            if (body && body.world && (body._type === 2 || body.world._midStep)) {
                return
            }
            var data = this._data;
            data[7] *= scale;
            data[7 + 1] *= scale;
            data[6] *= scale;
            this._validate();
            if (body) {
                body._invalidate()
            }
        };
        Physics2DCircle.prototype.translate = function(translation, skip) {
            var body = this.body;
            if (!skip && body && body.world && (body._type === 2 || body.world._midStep)) {
                return
            }
            var data = this._data;
            data[7] += translation[0];
            data[7 + 1] += translation[1];
            this._validate();
            if (!skip && body) {
                body._invalidate()
            }
        };
        Physics2DCircle.prototype.rotate = function(rotation) {
            var body = this.body;
            if (body && body.world && (body._type === 2 || body.world._midStep)) {
                return
            }
            var cos = Math.cos(rotation);
            var sin = Math.sin(rotation);
            var data = this._data;
            var x = data[7];
            var y = data[7 + 1];
            data[7] = cos * x - sin * y;
            data[7 + 1] = sin * x + cos * y;
            this._validate();
            if (body) {
                body._invalidate()
            }
        };
        Physics2DCircle.prototype.transform = function(matrix) {
            var body = this.body;
            if (body && body.world && (body._type === 2 || body.world._midStep)) {
                return
            }
            var a = matrix[0];
            var b = matrix[2];
            var c = matrix[1];
            var d = matrix[3];
            var data = this._data;
            var det = a * d - b * c;
            if (det <= 0) {
                return
            }
            data[6] *= Math.sqrt(det);
            var x = data[7];
            var y = data[7 + 1];
            data[7] = a * x + b * y + matrix[4];
            data[7 + 1] = c * x + d * y + matrix[5];
            this._validate();
            if (body) {
                body._invalidate()
            }
        };
        Physics2DCircle.prototype._update = function(posX, posY, cos, sin, skipAABB) {
            var data = this._data;
            var originX = data[7];
            var originY = data[7 + 1];
            var ox = data[9] = posX + cos * originX - sin * originY;
            var oy = data[9 + 1] = posY + sin * originX + cos * originY;
            if (!skipAABB) {
                var radius = data[6];
                data[0] = ox - radius;
                data[0 + 1] = oy - radius;
                data[0 + 2] = ox + radius;
                data[0 + 3] = oy + radius
            }
        };
        Physics2DCircle.prototype._validate = function() {
            var data = this._data;
            var originX = data[7];
            var originY = data[7 + 1];
            var radius = data[6];
            var olength = Math.sqrt(originX * originX + originY * originY);
            data[4] = radius + olength;
            data[5] = data[4] - Math.max(radius - olength, 0)
        };
        Physics2DCircle.prototype.computeCenterOfMass = function(dst) {
            return this.getOrigin(dst)
        };
        Physics2DCircle.create = function(params) {
            var c = new Physics2DCircle;
            c._type = 0;
            Physics2DShape.prototype.init(c, params);
            var radius = params.radius;
            var originX = params.origin ? params.origin[0] : 0;
            var originY = params.origin ? params.origin[1] : 0;
            var data = c._data = new Physics2DDevice.prototype.floatArray(11);
            data[6] = radius;
            data[7] = originX;
            data[7 + 1] = originY;
            c._validate();
            return c
        };
        Physics2DCircle.version = 1;
        return Physics2DCircle
    }(Physics2DShape);
    var Physics2DPolygon = function(_super) {
        __extends(Physics2DPolygon, _super);

        function Physics2DPolygon() {
            _super.call(this);
            this.type = "POLYGON"
        }
        Physics2DPolygon.prototype.computeArea = function() {
            var data = this._data;
            var index = 6;
            var limit = data.length;
            var doubleArea = 0;
            for (; index < limit; index += 13) {
                var next = index + 13;
                if (next === limit) {
                    next = 6
                }
                doubleArea += data[index + 0] * data[next + 0 + 1] - data[index + 0 + 1] * data[next + 0]
            }
            return doubleArea * .5
        };
        Physics2DPolygon.prototype.computeMasslessInertia = function() {
            var data = this._data;
            var index = 6;
            var limit = data.length;
            var s1 = 0;
            var s2 = 0;
            for (; index < limit; index += 13) {
                var next = index + 13;
                if (next === limit) {
                    next = 6
                }
                var x1 = data[index + 0];
                var y1 = data[index + 0 + 1];
                var x2 = data[next + 0];
                var y2 = data[next + 0 + 1];
                var a = x1 * y2 - x2 * y1;
                var b = x1 * x1 + y1 * y1 + (x2 * x2 + y2 * y2) + (x1 * x2 + y1 * y2);
                s1 += a * b;
                s2 += a
            }
            return s1 / (6 * s2)
        };
        Physics2DPolygon.prototype.computeCenterOfMass = function(dst) {
            if (dst === undefined) {
                dst = new Physics2DDevice.prototype.floatArray(2)
            }
            var data = this._data;
            var index = 6;
            var limit = data.length;
            var doubleArea = 0;
            var cx = 0;
            var cy = 0;
            for (; index < limit; index += 13) {
                var next = index + 13;
                if (next === limit) {
                    next = 6
                }
                var x1 = data[index + 0];
                var y1 = data[index + 0 + 1];
                var x2 = data[next + 0];
                var y2 = data[next + 0 + 1];
                var cross = x1 * y2 - y1 * x2;
                doubleArea += cross;
                cx += (x1 + x2) * cross;
                cy += (y1 + y2) * cross
            }
            var rec = 1 / (3 * doubleArea);
            dst[0] = cx * rec;
            dst[1] = cy * rec;
            return dst
        };
        Physics2DPolygon.prototype.setVertices = function(vertices) {
            var body = this.body;
            if (body && body.world && (body._type === 2 || body.world._midStep)) {
                return
            }
            this._validate(vertices);
            if (body) {
                body._invalidate()
            }
        };
        Physics2DPolygon.prototype.clone = function() {
            var c = new Physics2DPolygon;
            Physics2DShape.prototype.copyCommon(this, c);
            return c
        };
        Physics2DPolygon.prototype.scale = function(scaleX, scaleY) {
            var body = this.body;
            if (body && body.world && (body._type === 2 || body.world._midStep)) {
                return
            }
            if (scaleY === undefined) {
                scaleY = scaleX
            }
            if (scaleX <= 0 || scaleY <= 0) {
                return
            }
            var iscaleX = 1 / scaleX;
            var iscaleY = 1 / scaleY;
            var data = this._data;
            var limit = data.length;
            var index = 6;
            var radius = 0;
            var minProj = Number.POSITIVE_INFINITY;
            for (; index < limit; index += 13) {
                var x = data[index + 0] *= scaleX;
                var y = data[index + 0 + 1] *= scaleY;
                var nx = data[index + 4] * iscaleX;
                var ny = data[index + 4 + 1] * iscaleY;
                var rec = 1 / Math.sqrt(nx * nx + ny * ny);
                data[index + 4] = nx *= rec;
                data[index + 4 + 1] = ny *= rec;
                var lproj = data[index + 8] = nx * x + ny * y;
                if (lproj < minProj) {
                    minProj = lproj
                }
                var vlsq = x * x + y * y;
                if (vlsq > radius) {
                    radius = vlsq
                }
                var next = index + 13;
                if (next === limit) {
                    next = 6
                }
                var dx = data[next + 0] * scaleX - x;
                var dy = data[next + 0 + 1] * scaleY - y;
                var dL = Math.sqrt(dx * dx + dy * dy);
                data[index + 12] = dL
            }
            data[4] = Math.sqrt(radius);
            data[5] = data[4] - Math.max(minProj, 0);
            if (body) {
                body._invalidate()
            }
        };
        Physics2DPolygon.prototype.translate = function(translation, skip) {
            var body = this.body;
            if (!skip && body && body.world && (body._type === 2 || body.world._midStep)) {
                return
            }
            var data = this._data;
            var limit = data.length;
            var index = 6;
            var tx = translation[0];
            var ty = translation[1];
            var radius = 0;
            var minProj = Number.POSITIVE_INFINITY;
            for (; index < limit; index += 13) {
                var x = data[index + 0] += tx;
                var y = data[index + 0 + 1] += ty;
                var nx = data[index + 4];
                var ny = data[index + 4 + 1];
                var lproj = data[index + 8] += nx * tx + ny * ty;
                if (lproj < minProj) {
                    minProj = lproj
                }
                var vlsq = x * x + y * y;
                if (vlsq > radius) {
                    radius = vlsq
                }
            }
            data[4] = Math.sqrt(radius);
            data[5] = data[4] - Math.max(minProj, 0);
            if (!skip && body) {
                body._invalidate()
            }
        };
        Physics2DPolygon.prototype.rotate = function(rotation) {
            var body = this.body;
            if (body && body.world && (body._type === 2 || body.world._midStep)) {
                return
            }
            var data = this._data;
            var limit = data.length;
            var index = 6;
            var cos = Math.cos(rotation);
            var sin = Math.sin(rotation);
            for (; index < limit; index += 13) {
                var x = data[index + 0];
                var y = data[index + 0 + 1];
                data[index + 0] = x * cos - y * sin;
                data[index + 0 + 1] = x * sin + y * cos;
                x = data[index + 4];
                y = data[index + 4 + 1];
                data[index + 4] = x * cos - y * sin;
                data[index + 4 + 1] = x * sin + y * cos
            }
            if (body) {
                body._invalidate()
            }
        };
        Physics2DPolygon.prototype.transform = function(matrix) {
            var body = this.body;
            if (body && body.world && (body._type === 2 || body.world._midStep)) {
                return
            }
            var a = matrix[0];
            var b = matrix[2];
            var c = matrix[1];
            var d = matrix[3];
            var tx = matrix[4];
            var ty = matrix[5];
            if (a * d - b * c <= 0) {
                return
            }
            var data = this._data;
            var limit = data.length;
            var index = 6;
            var x, y;
            for (; index < limit; index += 13) {
                x = data[index + 0];
                y = data[index + 0 + 1];
                data[index + 0] = a * x + b * y + tx;
                data[index + 0 + 1] = c * x + d * y + ty
            }
            var radius = 0;
            var minProj = Number.POSITIVE_INFINITY;
            index = 6;
            for (; index < limit; index += 13) {
                x = data[index + 0];
                y = data[index + 0 + 1];
                var next = index + 13;
                if (next === limit) {
                    next = 6
                }
                var dx = -(data[next + 0] - x);
                var dy = -(data[next + 0 + 1] - y);
                var dL = Math.sqrt(dx * dx + dy * dy);
                var rec = 1 / dL;
                var nx = -dy * rec;
                var ny = dx * rec;
                data[index + 4] = nx;
                data[index + 4 + 1] = ny;
                data[index + 12] = dL;
                var lproj = data[index + 8] = nx * x + ny * y;
                var vlsq = x * x + y * y;
                if (vlsq > radius) {
                    radius = vlsq
                }
                if (lproj < minProj) {
                    minProj = lproj
                }
            }
            data[4] = Math.sqrt(radius);
            data[5] = data[4] - Math.max(minProj, 0);
            if (body) {
                body._invalidate()
            }
        };
        Physics2DPolygon.prototype._update = function(posX, posY, cos, sin, skipAABB) {
            var data = this._data;
            var limit = data.length;
            var index = 6;
            var j;
            var minX, minY, maxX, maxY;
            for (; index < limit; index += 13) {
                var x = data[index + 0];
                var y = data[index + 0 + 1];
                var vX = data[index + 2] = posX + cos * x - sin * y;
                var vY = data[index + 2 + 1] = posY + sin * x + cos * y;
                x = data[index + 4];
                y = data[index + 4 + 1];
                var nx = data[index + 6] = cos * x - sin * y;
                var ny = data[index + 6 + 1] = sin * x + cos * y;
                data[index + 9] = nx * vX + ny * vY;
                data[index + 10] = nx * vY - ny * vX;
                if (index !== 6) {
                    j = index - 13;
                    data[j + 11] = data[j + 6] * vY - data[j + 6 + 1] * vX;
                    if (!skipAABB) {
                        if (vX < minX) {
                            minX = vX
                        } else if (vX > maxX) {
                            maxX = vX
                        }
                        if (vY < minY) {
                            minY = vY
                        } else if (vY > maxY) {
                            maxY = vY
                        }
                    }
                } else if (!skipAABB) {
                    minX = maxX = vX;
                    minY = maxY = vY
                }
            }
            index = 6;
            j = data.length - 13;
            data[j + 11] = data[j + 6] * data[index + 2 + 1] - data[j + 6 + 1] * data[index + 2];
            if (!skipAABB) {
                data[0] = minX;
                data[0 + 1] = minY;
                data[0 + 2] = maxX;
                data[0 + 3] = maxY
            }
        };
        Physics2DPolygon.prototype._validate = function(vertices) {
            var vCount = vertices.length;
            var data = this._data;
            var newLimit = 6 + vCount * 13;
            if (!data || newLimit !== data.length) {
                data = this._data = new Physics2DDevice.prototype.floatArray(newLimit)
            }
            var radius = 0;
            var minProj = Number.POSITIVE_INFINITY;
            var index = 6;
            var i;
            for (i = 0; i < vCount; i += 1, index += 13) {
                var v1 = vertices[i];
                var v2 = vertices[i === vCount - 1 ? 0 : i + 1];
                var x = v1[0];
                var y = v1[1];
                var dx = x - v2[0];
                var dy = y - v2[1];
                var dL = Math.sqrt(dx * dx + dy * dy);
                var rec = 1 / dL;
                var nx = -dy * rec;
                var ny = dx * rec;
                data[index + 0] = x;
                data[index + 0 + 1] = y;
                data[index + 4] = nx;
                data[index + 4 + 1] = ny;
                data[index + 12] = dL;
                var lproj = data[index + 8] = nx * x + ny * y;
                var vlsq = x * x + y * y;
                if (vlsq > radius) {
                    radius = vlsq
                }
                if (lproj < minProj) {
                    minProj = lproj
                }
            }
            data[4] = Math.sqrt(radius);
            data[5] = data[4] - Math.max(minProj, 0)
        };
        Physics2DPolygon.create = function(params, inVertices) {
            var p = new Physics2DPolygon;
            p._type = 1;
            Physics2DShape.prototype.init(p, params);
            p._validate(inVertices || params.vertices);
            return p
        };
        Physics2DPolygon.version = 1;
        return Physics2DPolygon
    }(Physics2DShape);
    var Physics2DRigidBody = function() {
        function Physics2DRigidBody() {}
        Physics2DRigidBody.prototype.isDynamic = function() {
            return this._type === 0
        };
        Physics2DRigidBody.prototype.setAsDynamic = function() {
            if (this.world && this.world._midStep) {
                return
            }
            this._setTypeValue(0);
            var data = this._data;
            var mass = data[23];
            var inertia = data[24];
            data[0] = mass === Number.POSITIVE_INFINITY ? 0 : 1 / mass;
            data[1] = inertia === Number.POSITIVE_INFINITY ? 0 : 1 / inertia
        };
        Physics2DRigidBody.prototype.isStatic = function() {
            return this._type === 2
        };
        Physics2DRigidBody.prototype.setAsStatic = function() {
            if (this.world && this.world._midStep) {
                return
            }
            this._setTypeValue(2);
            var data = this._data;
            data[0] = data[1] = 0;
            data[7] = data[7 + 1] = data[7 + 2] = 0
        };
        Physics2DRigidBody.prototype.isKinematic = function() {
            return this._type === 1
        };
        Physics2DRigidBody.prototype.setAsKinematic = function() {
            if (this.world && this.world._midStep) {
                return
            }
            this._setTypeValue(1);
            var data = this._data;
            data[0] = data[1] = 0
        };
        Physics2DRigidBody.prototype._setTypeValue = function(newType) {
            if (newType === this._type) {
                return
            }
            if (!this.world) {
                this._type = newType;
                return
            }
            this.world._transmitBodyType(this, newType)
        };
        Physics2DRigidBody.prototype.applyImpulse = function(impulse, position) {
            if (this._type !== 0) {
                return
            }
            var data = this._data;
            var x, y;
            if (position) {
                x = position[0] - data[2];
                y = position[1] - data[2 + 1]
            } else {
                x = 0;
                y = 0
            }
            var ix = impulse[0];
            var iy = impulse[1];
            var im = data[0];
            data[7] += ix * im;
            data[7 + 1] += iy * im;
            data[7 + 2] += (x * iy - y * ix) * data[1];
            this.wake(true)
        };
        Physics2DRigidBody.prototype.setVelocityFromPosition = function(newPosition, newRotation, deltaTime) {
            if (this._type === 2) {
                return
            }
            var data = this._data;
            var idt = 1 / deltaTime;
            data[7] = (newPosition[0] - data[2]) * idt;
            data[7 + 1] = (newPosition[1] - data[2 + 1]) * idt;
            data[7 + 2] = (newRotation - data[2 + 2]) * idt;
            this.wake(true)
        };
        Physics2DRigidBody.prototype.transformWorldPointToLocal = function(src, dst) {
            if (dst === undefined) {
                dst = new Physics2DDevice.prototype.floatArray(2)
            }
            var data = this._data;
            var cos = data[5];
            var sin = data[5 + 1];
            var x = src[0] - data[2];
            var y = src[1] - data[2 + 1];
            dst[0] = cos * x + sin * y;
            dst[1] = cos * y - sin * x;
            return dst
        };
        Physics2DRigidBody.prototype.transformWorldVectorToLocal = function(src, dst) {
            if (dst === undefined) {
                dst = new Physics2DDevice.prototype.floatArray(2)
            }
            var data = this._data;
            var cos = data[5];
            var sin = data[5 + 1];
            var x = src[0];
            var y = src[1];
            dst[0] = cos * x + sin * y;
            dst[1] = cos * y - sin * x;
            return dst
        };
        Physics2DRigidBody.prototype.transformLocalPointToWorld = function(src, dst) {
            if (dst === undefined) {
                dst = new Physics2DDevice.prototype.floatArray(2)
            }
            var data = this._data;
            var cos = data[5];
            var sin = data[5 + 1];
            var x = src[0];
            var y = src[1];
            dst[0] = cos * x - sin * y + data[2];
            dst[1] = sin * x + cos * y + data[2 + 1];
            return dst
        };
        Physics2DRigidBody.prototype.transformLocalVectorToWorld = function(src, dst) {
            if (dst === undefined) {
                dst = new Physics2DDevice.prototype.floatArray(2)
            }
            var data = this._data;
            var cos = data[5];
            var sin = data[5 + 1];
            var x = src[0];
            var y = src[1];
            dst[0] = cos * x - sin * y;
            dst[1] = sin * x + cos * y;
            return dst
        };
        Physics2DRigidBody.prototype.getPosition = function(dst) {
            if (dst === undefined) {
                dst = new Physics2DDevice.prototype.floatArray(2)
            }
            var data = this._data;
            dst[0] = data[2];
            dst[1] = data[2 + 1];
            return dst
        };
        Physics2DRigidBody.prototype.setPosition = function(position) {
            if (this.world && (this.world._midStep || this._type === 2)) {
                return
            }
            var data = this._data;
            var newX = position[0];
            var newY = position[1];
            if (data[2] !== newX || data[2 + 1] !== newY) {
                data[2] = newX;
                data[2 + 1] = newY;
                this._invalidated = true;
                this.wake(true)
            }
        };
        Physics2DRigidBody.prototype.getRotation = function() {
            return this._data[2 + 2]
        };
        Physics2DRigidBody.prototype.setRotation = function(rotation) {
            if (this.world && (this.world._midStep || this._type === 2)) {
                return
            }
            var data = this._data;
            if (data[2 + 2] !== rotation) {
                this._data[2 + 2] = rotation;
                this._data[5] = Math.cos(rotation);
                this._data[5 + 1] = Math.sin(rotation);
                this._invalidated = true;
                this.wake(true)
            }
        };
        Physics2DRigidBody.prototype.getVelocity = function(dst) {
            if (dst === undefined) {
                dst = new Physics2DDevice.prototype.floatArray(2)
            }
            var data = this._data;
            dst[0] = data[7];
            dst[1] = data[7 + 1];
            return dst
        };
        Physics2DRigidBody.prototype.setVelocity = function(velocity) {
            if (this._type === 2) {
                return
            }
            var data = this._data;
            var newX = velocity[0];
            var newY = velocity[1];
            if (data[7] !== newX || data[7 + 1] !== newY) {
                data[7] = newX;
                data[7 + 1] = newY;
                this.wake(true)
            }
        };
        Physics2DRigidBody.prototype.getAngularVelocity = function() {
            return this._data[7 + 2]
        };
        Physics2DRigidBody.prototype.setAngularVelocity = function(angularVelocity) {
            if (this._type === 2) {
                return
            }
            var data = this._data;
            if (data[7 + 2] !== angularVelocity) {
                data[7 + 2] = angularVelocity;
                this.wake(true)
            }
        };
        Physics2DRigidBody.prototype.getForce = function(dst) {
            if (dst === undefined) {
                dst = new Physics2DDevice.prototype.floatArray(2)
            }
            var data = this._data;
            dst[0] = data[10];
            dst[1] = data[10 + 1];
            return dst
        };
        Physics2DRigidBody.prototype.setForce = function(force) {
            var data = this._data;
            var newX = force[0];
            var newY = force[1];
            if (data[10] !== newX || data[10 + 1] !== newY) {
                data[10] = newX;
                data[10 + 1] = newY;
                this.wake(true)
            }
        };
        Physics2DRigidBody.prototype.getTorque = function() {
            return this._data[10 + 2]
        };
        Physics2DRigidBody.prototype.setTorque = function(torque) {
            var data = this._data;
            if (data[10 + 2] !== torque) {
                data[10 + 2] = torque;
                this.wake(true)
            }
        };
        Physics2DRigidBody.prototype.getSurfaceVelocity = function(dst) {
            if (dst === undefined) {
                dst = new Physics2DDevice.prototype.floatArray(2)
            }
            var data = this._data;
            dst[0] = data[13];
            dst[1] = data[13 + 1];
            return dst
        };
        Physics2DRigidBody.prototype.setSurfaceVelocity = function(surfaceVelocity) {
            var data = this._data;
            data[13] = surfaceVelocity[0];
            data[13 + 1] = surfaceVelocity[1];
            this.wake(true)
        };
        Physics2DRigidBody.prototype.getMass = function() {
            return this._data[23]
        };
        Physics2DRigidBody.prototype.getInertia = function() {
            return this._data[24]
        };
        Physics2DRigidBody.prototype.setMass = function(mass) {
            var data = this._data;
            var oldMass = data[23];
            if (!this._customMass || oldMass !== mass) {
                data[23] = mass;
                this._customMass = true;
                this._invalidateMassInertia()
            }
        };
        Physics2DRigidBody.prototype.setMassFromShapes = function() {
            if (this._customMass) {
                this._customMass = false;
                this._data[23] = this.computeMassFromShapes();
                this._invalidateMassInertia()
            }
        };
        Physics2DRigidBody.prototype.setInertia = function(inertia) {
            var data = this._data;
            var oldInertia = data[24];
            if (!this._customInertia || oldInertia !== inertia) {
                data[24] = inertia;
                this._customInertia = true;
                this._invalidateMassInertia()
            }
        };
        Physics2DRigidBody.prototype.setInertiaFromShapes = function() {
            if (this._customInertia) {
                this._customInertia = false;
                this._data[24] = this.computeInertiaFromShapes();
                this._invalidateMassInertia()
            }
        };
        Physics2DRigidBody.prototype._invalidateMassInertia = function() {
            var data = this._data;
            var mass = data[23];
            var inertia = data[24];
            var staticType = this._type !== 0;
            var inf = Number.POSITIVE_INFINITY;
            data[0] = staticType || mass === inf ? 0 : 1 / mass;
            data[1] = staticType || inertia === inf ? 0 : 1 / inertia;
            this.wake(true)
        };
        Physics2DRigidBody.prototype.getLinearDrag = function() {
            return 1 - Math.exp(this._data[21])
        };
        Physics2DRigidBody.prototype.setLinearDrag = function(linearDrag) {
            this._data[21] = Math.log(1 - linearDrag);
            this.wake(true)
        };
        Physics2DRigidBody.prototype.getAngularDrag = function() {
            return 1 - Math.exp(this._data[22])
        };
        Physics2DRigidBody.prototype.setAngularDrag = function(angularDrag) {
            this._data[22] = Math.log(1 - angularDrag);
            this.wake(true)
        };
        Physics2DRigidBody.prototype.addShape = function(shape) {
            if (this.world && (this.world._midStep || this._type === 2)) {
                return false
            }
            if (shape.body) {
                return false
            }
            shape.body = this;
            this.shapes.push(shape);
            if (this.world) {
                this.wake(true);
                this.world._addShape(shape)
            }
            var rad = shape._data[4];
            var data = this._data;
            if (rad > data[19]) {
                data[19] = rad
            }
            this._invalidate();
            return true
        };
        Physics2DRigidBody.prototype.removeShape = function(shape) {
            if (this.world && (this.world._midStep || this._type === 2)) {
                return false
            }
            if (shape.body !== this) {
                return false
            }
            if (this.world) {
                this.wake(true);
                this.world._removeShape(shape)
            }
            shape.body = null;
            var shapes = this.shapes;
            var limit = shapes.length - 1;
            var index = shapes.indexOf(shape);
            shapes[index] = shapes[limit];
            shapes.pop();
            var i;
            var radius = 0;
            for (i = 0; i < limit; i += 1) {
                shape = shapes[i];
                var rad = shape._data[4];
                if (rad > radius) {
                    radius = rad
                }
            }
            this._data[19] = radius;
            this._invalidate();
            return true
        };
        Physics2DRigidBody.prototype.computeMassFromShapes = function() {
            var mass = 0;
            var i;
            var shapes = this.shapes;
            var limit = shapes.length;
            for (i = 0; i < limit; i += 1) {
                var shape = shapes[i];
                mass += shape._material._data[4] * shape.computeArea()
            }
            return mass
        };
        Physics2DRigidBody.prototype.computeInertiaFromShapes = function() {
            var inertia = 0;
            var i;
            var shapes = this.shapes;
            var limit = shapes.length;
            for (i = 0; i < limit; i += 1) {
                var shape = shapes[i];
                inertia += shape._material._data[4] * shape.computeMasslessInertia() * shape.computeArea()
            }
            return inertia
        };
        Physics2DRigidBody.prototype.wake = function(automated) {
            if (!this.world) {
                this.sleeping = false;
                return
            }
            this.world._wakeBody(this, !automated)
        };
        Physics2DRigidBody.prototype.sleep = function() {
            if (!this.world) {
                this.sleeping = true;
                return
            }
            this.world._forceSleepBody(this)
        };
        Physics2DRigidBody.prototype.computeLocalCenterOfMass = function(dst) {
            if (dst === undefined) {
                dst = new Physics2DDevice.prototype.floatArray(2)
            }
            var comX = 0;
            var comY = 0;
            var totalMass = 0;
            var shapes = this.shapes;
            var limit = shapes.length;
            var i;
            for (i = 0; i < limit; i += 1) {
                var shape = shapes[i];
                shape.computeCenterOfMass(dst);
                var mass = shape.computeArea() * shape._material._data[4];
                comX += dst[0] * mass;
                comY += dst[1] * mass;
                totalMass += mass
            }
            var imass = 1 / totalMass;
            dst[0] = comX * imass;
            dst[1] = comY * imass;
            return dst
        };
        Physics2DRigidBody.prototype.computeWorldBounds = function(dst) {
            if (dst === undefined) {
                dst = new Physics2DDevice.prototype.floatArray(4)
            }
            var inf = Number.POSITIVE_INFINITY;
            var minX = inf;
            var minY = inf;
            var maxX = -inf;
            var maxY = -inf;
            this._update();
            var shapes = this.shapes;
            var limit = shapes.length;
            var i;
            for (i = 0; i < limit; i += 1) {
                var shape = shapes[i]._data;
                var x0 = shape[0];
                var y0 = shape[0 + 1];
                var x1 = shape[0 + 2];
                var y1 = shape[0 + 3];
                if (x0 < minX) {
                    minX = x0
                }
                if (x1 > maxX) {
                    maxX = x1
                }
                if (y0 < minY) {
                    minY = y0
                }
                if (y1 > maxY) {
                    maxY = y1
                }
            }
            dst[0] = minX;
            dst[1] = minY;
            dst[2] = maxX;
            dst[3] = maxY;
            return dst
        };
        Physics2DRigidBody.prototype.alignWithOrigin = function() {
            if (this.world && (this.world._midStep || this._type === 2)) {
                return
            }
            var negCOM = this.computeLocalCenterOfMass();
            negCOM[0] *= -1;
            negCOM[1] *= -1;
            var shapes = this.shapes;
            var limit = shapes.length;
            var i;
            for (i = 0; i < limit; i += 1) {
                shapes[i].translate(negCOM, true)
            }
            this._invalidate()
        };
        Physics2DRigidBody.prototype._invalidate = function() {
            this._invalidated = true;
            var customMass = this._customMass;
            var customInertia = this._customInertia;
            if (!customMass || !customInertia) {
                if (!customMass) {
                    this._data[23] = this.computeMassFromShapes()
                }
                if (!customInertia) {
                    this._data[24] = this.computeInertiaFromShapes()
                }
                this._invalidateMassInertia()
            }
            this.wake(true)
        };
        Physics2DRigidBody.prototype._update = function() {
            if (this._invalidated) {
                this._invalidated = false;
                var data = this._data;
                var shapes = this.shapes;
                var limit = shapes.length;
                var i;
                for (i = 0; i < limit; i += 1) {
                    shapes[i]._update(data[2], data[2 + 1], data[5], data[5 + 1])
                }
            }
        };
        Physics2DRigidBody.prototype._atRest = function(deltaTime, timeStamp) {
            if (this._type !== 0) {
                return this.sleeping
            } else {
                var data = this._data;
                var canSleep;
                do {
                    var x = data[7];
                    var y = data[7 + 1];
                    var conf = Physics2DConfig.SLEEP_LINEAR_SQ;
                    if (x * x + y * y > conf) {
                        canSleep = false;
                        break
                    }
                    x = data[2] - data[15];
                    y = data[2 + 1] - data[15 + 1];
                    var threshold = deltaTime * deltaTime * conf;
                    if (x * x + y * y > threshold) {
                        canSleep = false;
                        break
                    }
                    y = data[19];
                    x = data[7 + 2] * y;
                    conf = Physics2DConfig.SLEEP_ANGULAR_SQ;
                    if (x * x > conf) {
                        canSleep = false;
                        break
                    }
                    x = (data[2 + 2] - data[15 + 2]) * y;
                    threshold = deltaTime * deltaTime * conf;
                    canSleep = x * x <= threshold
                } while (false);
                if (!canSleep) {
                    this._wakeTime = timeStamp;
                    return false
                } else {
                    return this._wakeTime + Physics2DConfig.SLEEP_DELAY < timeStamp
                }
            }
        };
        Physics2DRigidBody.prototype._deltaRotation = function(delta) {
            var data = this._data;
            var rotation = data[2 + 2] += delta;
            if (delta * delta > Physics2DConfig.DELTA_ROTATION_EPSILON) {
                data[5] = Math.cos(rotation);
                data[5 + 1] = Math.sin(rotation)
            } else {
                var d2 = delta * delta;
                var p = 1 - .5 * d2;
                var m = 1 - d2 * d2 * .125;
                var cos = data[5];
                var sin = data[5 + 1];
                var nSin = (p * sin + delta * cos) * m;
                var nCos = (p * cos - delta * sin) * m;
                data[5] = nCos;
                data[5 + 1] = nSin
            }
            return rotation
        };
        Physics2DRigidBody.prototype._sweepIntegrate = function(deltaTime) {
            var data = this._data;
            var delta = deltaTime - data[18];
            if (delta !== 0) {
                data[18] = deltaTime;
                data[2] += data[7] * delta;
                data[2 + 1] += data[7 + 1] * delta;
                var angVel = data[20];
                if (angVel !== 0) {
                    this._deltaRotation(data[20] * delta)
                }
            }
        };
        Physics2DRigidBody.prototype.integrate = function(deltaTime) {
            if (this.world && (this.world._midStep || this._type === 2)) {
                return
            }
            var data = this._data;
            data[18] = 0;
            data[20] = data[7 + 2];
            this._sweepIntegrate(deltaTime);
            data[18] = 0;
            this._invalidated = true;
            this.wake(true)
        };
        Physics2DRigidBody.prototype.addEventListener = function(eventType, callback) {
            var events = eventType === "wake" ? this._onWake : eventType === "sleep" ? this._onSleep : null;
            if (events === null) {
                return false
            }
            var index = events.indexOf(callback);
            if (index !== -1) {
                return false
            }
            events.push(callback);
            this.wake();
            return true
        };
        Physics2DRigidBody.prototype.removeEventListener = function(eventType, callback) {
            var events = eventType === "wake" ? this._onWake : eventType === "sleep" ? this._onSleep : null;
            if (events === null) {
                return false
            }
            var index = events.indexOf(callback);
            if (index === -1) {
                return false
            }
            events.splice(index, 1);
            this.wake();
            return true
        };
        Physics2DRigidBody.create = function(params) {
            var b = new Physics2DRigidBody;
            var data = b._data = new Physics2DDevice.prototype.floatArray(25);
            var inf = Number.POSITIVE_INFINITY;
            b._type = params.type === "dynamic" ? 0 : params.type === "static" ? 2 : params.type === "kinematic" ? 1 : 0;
            var shapes = params.shapes;
            b.shapes = [];
            b.constraints = [];
            b.world = null;
            var radius = 0;
            if (shapes) {
                var limit = shapes.length;
                var i;
                for (i = 0; i < limit; i += 1) {
                    var shape = shapes[i];
                    if (shape.body === b) {
                        continue
                    }
                    shape.body = b;
                    b.shapes.push(shape);
                    var rad = shape._data[4];
                    if (rad > radius) {
                        radius = rad
                    }
                }
            }
            data[19] = radius;
            b._customMass = params.mass !== undefined;
            b._customInertia = params.inertia !== undefined;
            var mass = b._customMass ? params.mass : b.computeMassFromShapes();
            var inertia = b._customInertia ? params.inertia : b.computeInertiaFromShapes();
            var isDynamic = b._type === 0;
            var isStatic = b._type === 2;
            data[0] = !isDynamic || mass === inf ? 0 : 1 / mass;
            data[1] = !isDynamic || inertia === inf ? 0 : 1 / inertia;
            data[23] = mass;
            data[24] = inertia;
            var vec = params.position;
            var x = data[2] = vec ? vec[0] : 0;
            var y = data[2 + 1] = vec ? vec[1] : 0;
            var rot = data[2 + 2] = params.rotation || 0;
            data[5] = Math.cos(rot);
            data[5 + 1] = Math.sin(rot);
            data[15] = x;
            data[15 + 1] = y;
            data[15 + 2] = rot;
            vec = params.velocity;
            data[7] = !isStatic && vec ? vec[0] : 0;
            data[7 + 1] = !isStatic && vec ? vec[1] : 0;
            data[7 + 2] = !isStatic && params.angularVelocity || 0;
            vec = params.force;
            data[10] = vec ? vec[0] : 0;
            data[10 + 1] = vec ? vec[1] : 0;
            data[10 + 2] = params.torque || 0;
            vec = params.surfaceVelocity;
            data[13] = vec ? vec[0] : 0;
            data[13 + 1] = vec ? vec[1] : 0;
            b.sleeping = params.sleeping || false;
            b.bullet = params.bullet || false;
            b._sweepFrozen = b._type !== 0;
            b._deferred = false;
            b._island = null;
            b._islandRank = 0;
            b._islandRoot = null;
            b._isBody = true;
            b._wakeTime = 0;
            b._woken = false;
            b._invalidated = true;
            data[21] = Math.log(1 - (params.linearDrag !== undefined ? params.linearDrag : .05));
            data[22] = Math.log(1 - (params.angularDrag !== undefined ? params.angularDrag : .05));
            b.userData = params.userData || null;
            b._onWake = [];
            b._onSleep = [];
            return b
        };
        Physics2DRigidBody.version = 1;
        return Physics2DRigidBody
    }();
    var Physics2DCallback = function() {
        function Physics2DCallback() {
            this.thisObject = null;
            this.callback = null;
            this.time = 0;
            this.index = 0;
            this.arbiter = null;
            this.next = null
        }
        Physics2DCallback.allocate = function() {
            if (Physics2DCallback.pool) {
                var ret = Physics2DCallback.pool;
                Physics2DCallback.pool = ret.next;
                ret.next = null;
                return ret
            } else {
                return new Physics2DCallback
            }
        };
        Physics2DCallback.deallocate = function(callback) {
            callback.next = Physics2DCallback.pool;
            Physics2DCallback.pool = callback;
            callback.thisObject = null;
            callback.callback = null;
            callback.arbiter = null
        };
        Physics2DCallback.pool = null;
        return Physics2DCallback
    }();
    var Physics2DIsland = function() {
        function Physics2DIsland() {
            this.components = [];
            this.sleeping = false;
            this.wakeTime = 0;
            this.next = null
        }
        Physics2DIsland.allocate = function() {
            if (Physics2DIsland.pool) {
                var ret = Physics2DIsland.pool;
                Physics2DIsland.pool = ret.next;
                ret.next = null;
                return ret
            } else {
                return new Physics2DIsland
            }
        };
        Physics2DIsland.deallocate = function(island) {
            island.next = Physics2DIsland.pool;
            Physics2DIsland.pool = island;
            island.wakeTime = 0
        };
        Physics2DIsland.pool = null;
        return Physics2DIsland
    }();
    var Physics2DTOIEvent = function() {
        function Physics2DTOIEvent() {
            this.next = null;
            this.shapeA = null;
            this.shapeB = null;
            this.frozenA = this.frozenB = false;
            this.arbiter = null;
            this.failed = false;
            this.slipped = false;
            this._data = new Physics2DDevice.prototype.floatArray(7)
        }
        Physics2DTOIEvent.allocate = function() {
            if (Physics2DTOIEvent.pool) {
                var ret = Physics2DTOIEvent.pool;
                Physics2DTOIEvent.pool = ret.next;
                ret.next = null;
                return ret
            } else {
                return new Physics2DTOIEvent
            }
        };
        Physics2DTOIEvent.deallocate = function(toi) {
            toi.next = Physics2DTOIEvent.pool;
            Physics2DTOIEvent.pool = toi;
            toi.shapeA = toi.shapeB = null;
            toi.failed = false;
            toi.slipped = false;
            toi.arbiter = null
        };
        Physics2DTOIEvent.pool = null;
        return Physics2DTOIEvent
    }();
    var Physics2DBoxTreeBroadphaseHandle = function() {
        function Physics2DBoxTreeBroadphaseHandle() {
            this.boxTreeIndex = -1;
            this.data = null;
            this.isStatic = false
        }
        Physics2DBoxTreeBroadphaseHandle.allocate = function() {
            if (0 < this.pool.length) {
                return this.pool.pop()
            } else {
                return new Physics2DBoxTreeBroadphaseHandle
            }
        };
        Physics2DBoxTreeBroadphaseHandle.deallocate = function(handle) {
            this.pool.push(handle);
            handle.data = null
        };
        Physics2DBoxTreeBroadphaseHandle.pool = [];
        return Physics2DBoxTreeBroadphaseHandle
    }();
    var Physics2DBoxTreeBroadphase = function() {
        function Physics2DBoxTreeBroadphase() {
            this.staticTree = BoxTree.create(true);
            this.dynamicTree = BoxTree.create(false);
            this.overlappingNodes = []
        }
        Physics2DBoxTreeBroadphase.prototype.sample = function(box, lambda, thisObject) {
            var overlappingNodes = this.overlappingNodes;
            var numOverlappingNodes = this.staticTree.getOverlappingNodes(box, overlappingNodes, 0);
            numOverlappingNodes += this.dynamicTree.getOverlappingNodes(box, overlappingNodes, numOverlappingNodes);
            var n;
            for (n = 0; n < numOverlappingNodes; n += 1) {
                lambda.call(thisObject, overlappingNodes[n], box)
            }
        };
        Physics2DBoxTreeBroadphase.prototype.insert = function(data, box, isStatic) {
            var handle = Physics2DBoxTreeBroadphaseHandle.allocate();
            handle.data = data;
            handle.isStatic = isStatic;
            if (isStatic) {
                this.staticTree.add(handle, box)
            } else {
                this.dynamicTree.add(handle, box)
            }
            return handle
        };
        Physics2DBoxTreeBroadphase.prototype.update = function(handle, box, isStatic) {
            if (isStatic !== undefined && handle.isStatic !== isStatic) {
                if (handle.isStatic) {
                    this.staticTree.remove(handle);
                    this.dynamicTree.add(handle, box)
                } else {
                    this.dynamicTree.remove(handle);
                    this.staticTree.add(handle, box)
                }
                handle.isStatic = isStatic
            } else {
                if (isStatic) {
                    this.staticTree.update(handle, box)
                } else {
                    this.dynamicTree.update(handle, box)
                }
            }
        };
        Physics2DBoxTreeBroadphase.prototype.remove = function(handle) {
            if (handle.isStatic) {
                this.staticTree.remove(handle)
            } else {
                this.dynamicTree.remove(handle)
            }
            Physics2DBoxTreeBroadphaseHandle.deallocate(handle)
        };
        Physics2DBoxTreeBroadphase.prototype.clear = function(callback, thisObject) {
            this._clearTree(this.staticTree, callback, thisObject);
            this._clearTree(this.dynamicTree, callback, thisObject)
        };
        Physics2DBoxTreeBroadphase.prototype._clearTree = function(tree, callback, thisObject) {
            var nodes = tree.getNodes();
            var numNodes = nodes.length;
            var n;
            for (n = 0; n < numNodes; n += 1) {
                var handle = nodes[n].externalNode;
                if (handle) {
                    if (callback) {
                        callback.call(thisObject, handle)
                    }
                    Physics2DBoxTreeBroadphaseHandle.deallocate(handle)
                }
            }
            tree.clear()
        };
        Physics2DBoxTreeBroadphase.prototype._validate = function() {
            this.staticTree.finalize();
            this.dynamicTree.finalize()
        };
        Physics2DBoxTreeBroadphase.prototype.perform = function(lambda, thisObject) {
            this._validate();
            var overlappingNodes = this.overlappingNodes;
            var staticTree = this.staticTree;
            var dynamicTree = this.dynamicTree;
            var dynamicNodes = dynamicTree.getNodes();
            var numDynamicNodes = dynamicNodes.length;
            var n;
            for (n = 0; n < numDynamicNodes; n += 1) {
                var dynamicNode = dynamicNodes[n];
                var handle = dynamicNode.externalNode;
                if (handle) {
                    var numOverlappingNodes = staticTree.getOverlappingNodes(dynamicNode.extents, overlappingNodes, 0);
                    var i;
                    for (i = 0; i < numOverlappingNodes; i += 1) {
                        lambda.call(thisObject, handle, overlappingNodes[i])
                    }
                }
            }
            var numPairs = dynamicTree.getOverlappingPairs(overlappingNodes, 0);
            for (n = 0; n < numPairs; n += 2) {
                lambda.call(thisObject, overlappingNodes[n], overlappingNodes[n + 1])
            }
        };
        Physics2DBoxTreeBroadphase.create = function() {
            return new Physics2DBoxTreeBroadphase
        };
        Physics2DBoxTreeBroadphase.version = 1;
        return Physics2DBoxTreeBroadphase
    }();
    var Physics2DSweepAndPruneHandle = function() {
        function Physics2DSweepAndPruneHandle() {
            this._next = null;
            this._prev = null;
            this._aabb = new Physics2DDevice.prototype.floatArray(4);
            this.data = null;
            this.isStatic = false
        }
        Physics2DSweepAndPruneHandle.allocate = function() {
            if (!this.pool) {
                return new Physics2DSweepAndPruneHandle
            } else {
                var ret = this.pool;
                this.pool = ret._next;
                ret._next = null;
                return ret
            }
        };
        Physics2DSweepAndPruneHandle.deallocate = function(handle) {
            handle._prev = null;
            handle._next = this.pool;
            this.pool = handle;
            handle.data = null
        };
        Physics2DSweepAndPruneHandle.pool = null;
        return Physics2DSweepAndPruneHandle
    }();
    var Physics2DSweepAndPrune = function() {
        function Physics2DSweepAndPrune() {}
        Physics2DSweepAndPrune.prototype.sample = function(rectangle, lambda, thisObject) {
            var minX = rectangle[0];
            var minY = rectangle[1];
            var maxX = rectangle[2];
            var maxY = rectangle[3];
            this._validate();
            var d1 = this._list;
            while (d1) {
                var aabb = d1._aabb;
                if (aabb[2] < minX) {
                    d1 = d1._next;
                    continue
                }
                if (aabb[0] > maxX) {
                    break
                }
                if (aabb[1] <= maxY && minY <= aabb[3]) {
                    lambda.call(thisObject, d1, rectangle)
                }
                d1 = d1._next
            }
        };
        Physics2DSweepAndPrune.prototype.insert = function(data, aabb, isStatic) {
            var handle = Physics2DSweepAndPruneHandle.allocate();
            var ab = handle._aabb;
            ab[0] = aabb[0];
            ab[1] = aabb[1];
            ab[2] = aabb[2];
            ab[3] = aabb[3];
            handle.data = data;
            handle.isStatic = isStatic;
            var list = this._list;
            handle._next = list;
            if (list) {
                list._prev = handle
            }
            this._list = handle;
            return handle
        };
        Physics2DSweepAndPrune.prototype.update = function(handle, aabb, isStatic) {
            var ab = handle._aabb;
            ab[0] = aabb[0];
            ab[1] = aabb[1];
            ab[2] = aabb[2];
            ab[3] = aabb[3];
            if (isStatic !== undefined) {
                handle.isStatic = isStatic
            }
        };
        Physics2DSweepAndPrune.prototype.remove = function(handle) {
            if (!handle._prev) {
                this._list = handle._next
            } else {
                handle._prev._next = handle._next
            }
            if (handle._next) {
                handle._next._prev = handle._prev
            }
            Physics2DSweepAndPruneHandle.deallocate(handle)
        };
        Physics2DSweepAndPrune.prototype.clear = function(callback, thisObject) {
            var handle = this._list;
            while (handle) {
                var next = handle._next;
                if (callback) {
                    callback.call(thisObject, handle)
                }
                Physics2DSweepAndPruneHandle.deallocate(handle);
                handle = next
            }
            this._list = null
        };
        Physics2DSweepAndPrune.prototype._validate = function() {
            if (!this._list) {
                return
            }
            var a = this._list._next;
            while (a) {
                var next = a._next;
                var b = a._prev;
                var aMinX = a._aabb[0];
                if (aMinX > b._aabb[0]) {
                    a = next;
                    continue
                }
                while (b._prev && b._prev._aabb[0] > aMinX) {
                    b = b._prev
                }
                var prev = a._prev;
                prev._next = next;
                if (next) {
                    next._prev = prev
                }
                if (!b._prev) {
                    a._prev = null;
                    this._list = a;
                    a._next = b;
                    b._prev = a
                } else {
                    a._prev = b._prev;
                    b._prev = a;
                    a._prev._next = a;
                    a._next = b
                }
                a = next
            }
        };
        Physics2DSweepAndPrune.prototype.perform = function(lambda, thisObject) {
            this._validate();
            var d1 = this._list;
            while (d1) {
                var d2 = d1._next;
                var aabb1 = d1._aabb;
                var d1Static = d1.isStatic;
                var maxX = aabb1[2];
                while (d2) {
                    var aabb2 = d2._aabb;
                    if (aabb2[0] > maxX) {
                        break
                    }
                    if (d1Static && d2.isStatic) {
                        d2 = d2._next;
                        continue
                    }
                    if (aabb1[1] > aabb2[3] || aabb2[1] > aabb1[3]) {
                        d2 = d2._next;
                        continue
                    }
                    lambda.call(thisObject, d1, d2);
                    d2 = d2._next
                }
                d1 = d1._next
            }
        };
        Physics2DSweepAndPrune.create = function() {
            var b = new Physics2DSweepAndPrune;
            b._list = null;
            return b
        };
        Physics2DSweepAndPrune.version = 1;
        return Physics2DSweepAndPrune
    }();
    var Physics2DContact = function() {
        function Physics2DContact() {
            this._data = new Physics2DDevice.prototype.floatArray(17);
            this.fresh = false;
            this._hash = 0;
            this._timeStamp = 0;
            this._next = null;
            this.active = false;
            this.virtual = false
        }
        Physics2DContact.allocate = function() {
            if (!this.pool) {
                return new Physics2DContact
            } else {
                var ret = this.pool;
                this.pool = ret._next;
                ret._next = null;
                return ret
            }
        };
        Physics2DContact.deallocate = function(contact) {
            contact._next = this.pool;
            this.pool = contact
        };
        Physics2DContact.prototype.getPosition = function(dst) {
            if (dst === undefined) {
                dst = new Physics2DDevice.prototype.floatArray(2)
            }
            var data = this._data;
            dst[0] = data[0];
            dst[1] = data[0 + 1];
            return dst
        };
        Physics2DContact.prototype.getPenetration = function() {
            return -this._data[2]
        };
        Physics2DContact.prototype.getNormalImpulse = function() {
            return this.virtual ? 0 : this._data[11]
        };
        Physics2DContact.prototype.getTangentImpulse = function() {
            return this.virtual ? 0 : this._data[12]
        };
        Physics2DContact.version = 1;
        Physics2DContact.pool = null;
        return Physics2DContact
    }();
    var Physics2DArbiter = function() {
        function Physics2DArbiter() {
            this.shapeA = null;
            this.shapeB = null;
            this.bodyA = null;
            this.bodyB = null;
            this._next = null;
            this._retired = false;
            this._lazyRetired = false;
            this._static = false;
            this._state = 0;
            this.sensor = false;
            this._createStamp = 0;
            this._updateStamp = 0;
            this._sleepStamp = 0;
            this._timeStamp = 0;
            this._createContinuous = false;
            this._endGenerated = 0;
            this._midStep = false;
            this.sleeping = false;
            this.active = false;
            this._invalidated = false;
            this._data = new Physics2DDevice.prototype.floatArray(24);
            this.contacts = [];
            this._userdef = 0;
            this._velocity2Contact = false;
            this._position2Contact = false;
            this._contact1 = this._contact2 = null;
            this._faceType = 0
        }
        Physics2DArbiter.prototype.getNormal = function(dst) {
            if (dst === undefined) {
                dst = new Physics2DDevice.prototype.floatArray(2)
            }
            if (this.sensor) {
                dst[0] = dst[1] = 0
            } else {
                var data = this._data;
                dst[0] = data[4];
                dst[1] = data[4 + 1]
            }
            return dst
        };
        Physics2DArbiter.prototype.getRollingImpulse = function() {
            if (this.sensor || this._velocity2Contact || this._contact1._hash !== 0) {
                return 0
            } else {
                return this._data[16]
            }
        };
        Physics2DArbiter.prototype.getElasticity = function() {
            if (this.sensor) {
                return undefined
            }
            this._validate();
            return this._data[2]
        };
        Physics2DArbiter.prototype.getDynamicFriction = function() {
            if (this.sensor) {
                return undefined
            }
            this._validate();
            return this._data[0]
        };
        Physics2DArbiter.prototype.getStaticFriction = function() {
            if (this.sensor) {
                return undefined
            }
            this._validate();
            return this._data[1]
        };
        Physics2DArbiter.prototype.getRollingFriction = function() {
            if (this.sensor) {
                return undefined
            }
            this._validate();
            return this._data[3]
        };
        Physics2DArbiter.prototype.setElasticity = function(elasticity) {
            if (this.sensor) {
                return
            }
            this._data[2] = elasticity;
            this._userdef |= 1 << 2;
            this._invalidate(true)
        };
        Physics2DArbiter.prototype.setDynamicFriction = function(dynamicFriction) {
            if (this.sensor) {
                return
            }
            this._data[0] = dynamicFriction;
            this._userdef |= 1 << 0;
            this._invalidate(true)
        };
        Physics2DArbiter.prototype.setStaticFriction = function(staticFriction) {
            if (this.sensor) {
                return
            }
            this._data[1] = staticFriction;
            this._userdef |= 1 << 1;
            this._invalidate(true)
        };
        Physics2DArbiter.prototype.setRollingFriction = function(rollingFriction) {
            if (this.sensor) {
                return
            }
            this._data[3] = rollingFriction;
            this._userdef |= 1 << 3;
            this._invalidate(true)
        };
        Physics2DArbiter.prototype.setElasticityFromShapes = function() {
            if (this.sensor) {
                return
            }
            this._userdef &= ~(1 << 2);
            this._invalidate(true)
        };
        Physics2DArbiter.prototype.setDynamicFrictionFromShapes = function() {
            if (this.sensor) {
                return
            }
            this._userdef &= ~(1 << 0);
            this._invalidate(true)
        };
        Physics2DArbiter.prototype.setStaticFrictionFromShapes = function() {
            if (this.sensor) {
                return
            }
            this._userdef &= ~(1 << 1);
            this._invalidate(true)
        };
        Physics2DArbiter.prototype.setRollingFrictionFromShapes = function() {
            if (this.sensor) {
                return
            }
            this._userdef &= ~(1 << 3);
            this._invalidate(true)
        };
        Physics2DArbiter.prototype.isStateAccepted = function() {
            if (this.sensor) {
                return false
            } else {
                return (this._state & 1) !== 0
            }
        };
        Physics2DArbiter.prototype.isStatePersistent = function() {
            if (this.sensor) {
                return false
            } else {
                return (this._state & 2) !== 0
            }
        };
        Physics2DArbiter.prototype.setAcceptedState = function(accepted) {
            if (this.sensor) {
                return
            }
            if (accepted) {
                this._state |= 1
            } else {
                this._state &= ~1
            }
            this._invalidate(true)
        };
        Physics2DArbiter.prototype.setPersistentState = function(persistent) {
            if (this.sensor) {
                return
            }
            if (persistent) {
                this._state |= 2
            } else {
                this._state &= ~2
            }
            this._invalidate(true)
        };
        Physics2DArbiter.prototype._lazyRetire = function(ignoreShape) {
            this._lazyRetired = true;
            this._retired = true;
            this.active = false;
            var arbiters;
            var index;
            if (this.shapeA !== ignoreShape) {
                arbiters = this.shapeA.arbiters;
                index = arbiters.indexOf(this);
                arbiters[index] = arbiters[arbiters.length - 1];
                arbiters.pop()
            }
            if (this.shapeB !== ignoreShape) {
                arbiters = this.shapeB.arbiters;
                index = arbiters.indexOf(this);
                arbiters[index] = arbiters[arbiters.length - 1];
                arbiters.pop()
            }
        };
        Physics2DArbiter.prototype._assign = function(s1, s2) {
            this.bodyA = s1.body;
            this.bodyB = s2.body;
            this.shapeA = s1;
            this.shapeB = s2;
            s1.arbiters.push(this);
            s2.arbiters.push(this);
            this._retired = false;
            this.sleeping = false;
            this._invalidate()
        };
        Physics2DArbiter.prototype._retire = function() {
            this.shapeA = this.shapeB = null;
            this.bodyA = this.bodyB = null;
            this._retired = true;
            this._lazyRetired = false;
            this.active = false;
            this._data[6] = 0;
            var contacts = this.contacts;
            while (contacts.length > 0) {
                var contact = contacts.pop();
                Physics2DContact.deallocate(contact)
            }
            this._contact1 = this._contact2 = null
        };
        Physics2DArbiter.prototype._invalidate = function(dontSkip) {
            this._invalidated = true;
            if (dontSkip && !this._midStep) {
                this.shapeA.body.wake();
                this.shapeB.body.wake()
            }
        };
        Physics2DArbiter.prototype._validate = function() {
            this._invalidated = false;
            var data = this._data;
            var mA = this.shapeA._material._data;
            var mB = this.shapeB._material._data;
            var userdef = this._userdef;
            if ((userdef & 1 << 2) === 0) {
                var elasticity;
                var elasticA = mA[0];
                var elasticB = mB[0];
                if (elasticA <= Number.NEGATIVE_INFINITY || elasticB <= Number.NEGATIVE_INFINITY) {
                    elasticity = 0
                } else if (elasticA >= Number.POSITIVE_INFINITY || elasticB >= Number.POSITIVE_INFINITY) {
                    elasticity = 1
                } else {
                    elasticity = (elasticA + elasticB) * .5;
                    if (elasticity < 0) {
                        elasticity = 0
                    } else if (elasticity > 1) {
                        elasticity = 1
                    }
                }
                data[2] = elasticity
            }
            var sqrt = Math.sqrt;
            if ((userdef & 1 << 0) === 0) {
                data[0] = sqrt(mA[2] * mB[2])
            }
            if ((userdef & 1 << 1) === 0) {
                data[1] = sqrt(mA[1] * mB[1])
            }
            if ((userdef & 1 << 3) === 0) {
                data[3] = sqrt(mA[3] * mB[3])
            }
        };
        Physics2DArbiter.prototype._injectContact = function(px, py, nx, ny, dist, hash, virtual) {
            var contact;
            var contacts = this.contacts;
            var limit = contacts.length;
            if (limit !== 0) {
                contact = contacts[0];
                if (contact._hash !== hash) {
                    if (limit !== 1) {
                        contact = contacts[1];
                        if (contact._hash !== hash) {
                            contact = null
                        }
                    } else {
                        contact = null
                    }
                }
            }
            if (virtual === undefined) {
                virtual = false
            }
            var data;
            if (!contact) {
                contact = Physics2DContact.allocate();
                data = contact._data;
                data[11] = data[12] = 0;
                contact._hash = hash;
                contact.fresh = !virtual;
                contacts.push(contact);
                if (hash === 0) {
                    this._data[16] = 0
                }
            } else {
                contact.fresh = !virtual && contact.virtual;
                data = contact._data
            }
            data[0] = px;
            data[0 + 1] = py;
            data[2] = dist;
            contact._timeStamp = this._timeStamp;
            contact.virtual = virtual;
            data = this._data;
            data[4] = nx;
            data[4 + 1] = ny;
            return contact
        };
        Physics2DArbiter.prototype._cleanContacts = function(timeStamp) {
            var fst = true;
            this._position2Contact = false;
            this._contact2 = null;
            var contacts = this.contacts;
            var limit = contacts.length;
            var i;
            for (i = 0; i < limit;) {
                var c = contacts[i];
                if (c._timeStamp + Physics2DConfig.DELAYED_DEATH < timeStamp) {
                    limit -= 1;
                    contacts[i] = contacts[limit];
                    contacts.pop();
                    Physics2DContact.deallocate(c);
                    continue
                }
                c.active = c._timeStamp === timeStamp;
                if (c.active) {
                    if (fst) {
                        this._contact1 = c;
                        fst = false
                    } else {
                        this._contact2 = c;
                        this._position2Contact = true
                    }
                }
                i += 1
            }
            if (this._position2Contact) {
                if (this._contact1.virtual) {
                    var tmp = this._contact1;
                    this._contact1 = this._contact2;
                    this._contact2 = tmp
                }
                this._velocity2Contact = !this._contact2.virtual
            } else {
                this._velocity2Contact = false
            }
            return !fst
        };
        Physics2DArbiter.prototype._preStep = function(deltaTime, timeStamp, continuous) {
            if (!this._cleanContacts(timeStamp)) {
                return false
            }
            if (this._invalidated) {
                this._validate()
            }
            var adata = this._data;
            var predt = adata[6];
            var dtRatio = predt === 0 ? 1 : deltaTime / predt;
            adata[6] = deltaTime;
            var data1 = this.bodyA._data;
            var data2 = this.bodyB._data;
            var px1 = data1[2];
            var py1 = data1[2 + 1];
            var px2 = data2[2];
            var py2 = data2[2 + 1];
            var vx1 = data1[7];
            var vy1 = data1[7 + 1];
            var vw1 = data1[7 + 2];
            var vx2 = data2[7];
            var vy2 = data2[7 + 1];
            var vw2 = data2[7 + 2];
            var nx = adata[4];
            var ny = adata[4 + 1];
            var massSum = data1[0] + data2[0];
            var ii1 = data1[1];
            var ii2 = data2[1];
            var EPS = Physics2DConfig.EFF_MASS_EPSILON;
            var BIAS = continuous ? this._static ? Physics2DConfig.CONT_STATIC_BIAS_COEF : Physics2DConfig.CONT_BIAS_COEF : this._static ? Physics2DConfig.STATIC_BIAS_COEF : Physics2DConfig.BIAS_COEF;
            adata[15] = BIAS;
            var c = this._contact1;
            var data;
            var rx1, ry1, rx2, ry2;
            while (true) {
                data = c._data;
                var px = data[0];
                var py = data[0 + 1];
                rx1 = data[7] = px - px1;
                ry1 = data[7 + 1] = py - py1;
                rx2 = data[9] = px - px2;
                ry2 = data[9 + 1] = py - py2;
                var v1 = rx1 * nx + ry1 * ny;
                var v2 = rx2 * nx + ry2 * ny;
                var kt = massSum + ii2 * v2 * v2 + ii1 * v1 * v1;
                data[6] = kt < EPS ? 0 : 1 / kt;
                v1 = rx1 * ny - ry1 * nx;
                v2 = rx2 * ny - ry2 * nx;
                var kn = massSum + ii2 * v2 * v2 + ii1 * v1 * v1;
                data[5] = kn < EPS ? 0 : 1 / kn;
                var vrx = vx2 - ry2 * vw2 - (vx1 - ry1 * vw1);
                var vry = vy2 + rx2 * vw2 - (vy1 + rx1 * vw1);
                var vdot = nx * vrx + ny * vry;
                var bounce = vdot * adata[2];
                if (bounce > -Physics2DConfig.BOUNCE_VELOCITY_THRESHOLD) {
                    bounce = 0
                }
                data[3] = bounce;
                vdot = nx * vry - ny * vrx;
                if (vdot * vdot > Physics2DConfig.STATIC_FRIC_SQ_EPSILON) {
                    data[4] = adata[0]
                } else {
                    data[4] = adata[1]
                }
                data[11] *= dtRatio;
                data[12] *= dtRatio;
                if (this._velocity2Contact) {
                    if (c === this._contact2) {
                        break
                    }
                    c = this._contact2
                } else {
                    break
                }
            }
            data = this._contact1._data;
            rx1 = data[7];
            ry1 = data[7 + 1];
            rx2 = data[9];
            ry2 = data[9 + 1];
            var rn1a = adata[7] = rx1 * ny - ry1 * nx;
            var rn1b = adata[8] = rx2 * ny - ry2 * nx;
            adata[9] = rx1 * nx + ry1 * ny;
            adata[10] = rx2 * nx + ry2 * ny;
            if (!this._velocity2Contact && this._contact1._hash === 0) {
                adata[16] *= dtRatio;
                var sum = ii1 + ii2;
                adata[17] = sum < EPS ? 0 : 1 / sum
            } else if (this._velocity2Contact) {
                data = this._contact2._data;
                var r2x1 = data[7];
                var r2y1 = data[7 + 1];
                var r2x2 = data[9];
                var r2y2 = data[9 + 1];
                var rn2a = adata[16] = r2x1 * ny - r2y1 * nx;
                var rn2b = adata[17] = r2x2 * ny - r2y2 * nx;
                adata[18] = r2x1 * nx + r2y1 * ny;
                adata[19] = r2x2 * nx + r2y2 * ny;
                var Ka = adata[20] = massSum + ii1 * rn1a * rn1a + ii2 * rn1b * rn1b;
                var Kb = adata[20 + 1] = massSum + ii1 * rn1a * rn2a + ii2 * rn1b * rn2b;
                var Kc = adata[20 + 2] = massSum + ii1 * rn2a * rn2a + ii2 * rn2b * rn2b;
                var det = Ka * Kc - Kb * Kb;
                if (Ka * Ka > Physics2DConfig.ILL_THRESHOLD * det) {
                    if (this._contact2._data[2] < this._contact1._data[2]) {
                        this._contact1 = this._contact2;
                        adata[7] = rn2a;
                        adata[8] = rn2b;
                        adata[9] = adata[18];
                        adata[10] = adata[19]
                    }
                    this._velocity2Contact = false;
                    this._position2Contact = false;
                    this._contact2 = null
                } else {
                    adata[23] = 1 / det
                }
            }
            return true
        };
        Physics2DArbiter.prototype._iterateVelocity = function() {
            var data1 = this.bodyA._data;
            var data2 = this.bodyB._data;
            var im1 = data1[0];
            var ii1 = data1[1];
            var im2 = data2[0];
            var ii2 = data2[1];
            var vx1 = data1[7];
            var vy1 = data1[7 + 1];
            var vw1 = data1[7 + 2];
            var vx2 = data2[7];
            var vy2 = data2[7 + 1];
            var vw2 = data2[7 + 2];
            var adata = this._data;
            var nx = adata[4];
            var ny = adata[4 + 1];
            var rn1a = adata[7];
            var rn1b = adata[8];
            var rt1a = adata[9];
            var rt1b = adata[10];
            var cdata1 = this._contact1._data;
            var rx1 = cdata1[7];
            var ry1 = cdata1[7 + 1];
            var rx2 = cdata1[9];
            var ry2 = cdata1[9 + 1];
            var surfaceX = data2[13] - data1[13];
            var surfaceY = data2[13 + 1] - data1[13 + 1];
            var vrx1 = vx2 - ry2 * vw2 - (vx1 - ry1 * vw1);
            var vry1 = vy2 + rx2 * vw2 - (vy1 + rx1 * vw1);
            var j, jOld, cjAcc, jx, jy, jMax;
            j = (nx * vry1 - ny * vrx1 + surfaceX) * cdata1[6];
            jMax = cdata1[4] * cdata1[11];
            jOld = cdata1[12];
            cjAcc = jOld - j;
            if (cjAcc > jMax) {
                cjAcc = jMax
            } else if (cjAcc < -jMax) {
                cjAcc = -jMax
            }
            j = cjAcc - jOld;
            cdata1[12] = cjAcc;
            jx = -ny * j;
            jy = nx * j;
            vx1 -= jx * im1;
            vy1 -= jy * im1;
            vw1 -= rt1a * j * ii1;
            vx2 += jx * im2;
            vy2 += jy * im2;
            vw2 += rt1b * j * ii2;
            if (this._velocity2Contact) {
                var cdata2 = this._contact2._data;
                var r2x1 = cdata2[7];
                var r2y1 = cdata2[7 + 1];
                var r2x2 = cdata2[9];
                var r2y2 = cdata2[9 + 1];
                var Ka = adata[20];
                var Kb = adata[20 + 1];
                var Kc = adata[20 + 2];
                var idet = adata[23];
                var rn2a = adata[16];
                var rn2b = adata[17];
                var rt2a = adata[18];
                var rt2b = adata[19];
                var vrx2 = vx2 - r2y2 * vw2 - (vx1 - r2y1 * vw1);
                var vry2 = vy2 + r2x2 * vw2 - (vy1 + r2x1 * vw1);
                j = (nx * vry2 - ny * vrx2 + surfaceX) * cdata2[6];
                jMax = cdata2[4] * cdata2[11];
                jOld = cdata2[12];
                cjAcc = jOld - j;
                if (cjAcc > jMax) {
                    cjAcc = jMax
                } else if (cjAcc < -jMax) {
                    cjAcc = -jMax
                }
                j = cjAcc - jOld;
                cdata2[12] = cjAcc;
                jx = -ny * j;
                jy = nx * j;
                vx1 -= jx * im1;
                vy1 -= jy * im1;
                vw1 -= rt2a * j * ii1;
                vx2 += jx * im2;
                vy2 += jy * im2;
                vw2 += rt2b * j * ii2;
                vrx1 = vx2 - ry2 * vw2 - (vx1 - ry1 * vw1);
                vry1 = vy2 + rx2 * vw2 - (vy1 + rx1 * vw1);
                vrx2 = vx2 - r2y2 * vw2 - (vx1 - r2y1 * vw1);
                vry2 = vy2 + r2x2 * vw2 - (vy1 + r2x1 * vw1);
                var ax = cdata1[11];
                var ay = cdata2[11];
                var jnx = vrx1 * nx + vry1 * ny + surfaceY + cdata1[3] - (Ka * ax + Kb * ay);
                var jny = vrx2 * nx + vry2 * ny + surfaceY + cdata2[3] - (Kb * ax + Kc * ay);
                var xx = idet * (Kb * jny - Kc * jnx);
                var xy = idet * (Kb * jnx - Ka * jny);
                if (xx >= 0 && xy >= 0) {
                    jnx = xx - ax;
                    jny = xy - ay;
                    cdata1[11] = xx;
                    cdata2[11] = xy
                } else {
                    xx = -(cdata1[5] * jnx);
                    if (xx >= 0 && Kb * xx + jny >= 0) {
                        jnx = xx - ax;
                        jny = -ay;
                        cdata1[11] = xx;
                        cdata2[11] = 0
                    } else {
                        xy = -(cdata2[5] * jny);
                        if (xy >= 0 && Kb * xy + jnx >= 0) {
                            jnx = -ax;
                            jny = xy - ay;
                            cdata1[11] = 0;
                            cdata2[11] = xy
                        } else if (jnx >= 0 && jny >= 0) {
                            jnx = -ax;
                            jny = -ay;
                            cdata1[11] = cdata2[11] = 0
                        } else {
                            jnx = 0;
                            jny = 0
                        }
                    }
                }
                j = jnx + jny;
                jx = nx * j;
                jy = ny * j;
                vx1 -= jx * im1;
                vy1 -= jy * im1;
                vw1 -= (rn1a * jnx + rn2a * jny) * ii1;
                vx2 += jx * im2;
                vy2 += jy * im2;
                vw2 += (rn1b * jnx + rn2b * jny) * ii2
            } else {
                if (this._contact1._hash === 0) {
                    var dw = vw2 - vw1;
                    j = dw * adata[17];
                    jMax = adata[3] * cdata1[11];
                    jOld = adata[16];
                    cjAcc = jOld - j;
                    if (cjAcc > jMax) {
                        cjAcc = jMax
                    } else if (cjAcc < -jMax) {
                        cjAcc = -jMax
                    }
                    j = cjAcc - jOld;
                    adata[16] = cjAcc;
                    vw1 -= j * ii1;
                    vw2 += j * ii2
                }
                vrx1 = vx2 - ry2 * vw2 - (vx1 - ry1 * vw1);
                vry1 = vy2 + rx2 * vw2 - (vy1 + rx1 * vw1);
                j = (cdata1[3] + surfaceY + (nx * vrx1 + ny * vry1)) * cdata1[5];
                jOld = cdata1[11];
                cjAcc = jOld - j;
                if (cjAcc < 0) {
                    cjAcc = 0
                }
                j = cjAcc - jOld;
                cdata1[11] = cjAcc;
                jx = nx * j;
                jy = ny * j;
                vx1 -= jx * im1;
                vy1 -= jy * im1;
                vw1 -= rn1a * j * ii1;
                vx2 += jx * im2;
                vy2 += jy * im2;
                vw2 += rn1b * j * ii2
            }
            data1[7] = vx1;
            data1[7 + 1] = vy1;
            data1[7 + 2] = vw1;
            data2[7] = vx2;
            data2[7 + 1] = vy2;
            data2[7 + 2] = vw2
        };
        Physics2DArbiter.prototype._refreshContactData = function() {
            var data1 = this.bodyA._data;
            var data2 = this.bodyB._data;
            var cos1 = data1[5];
            var sin1 = data1[5 + 1];
            var cos2 = data2[5];
            var sin2 = data2[5 + 1];
            var px1 = data1[2];
            var py1 = data1[2 + 1];
            var px2 = data2[2];
            var py2 = data2[2 + 1];
            var err, nx, ny;
            var adata = this._data;
            var rad = adata[14];
            var cdata1 = this._contact1._data;
            if (this._faceType === 0) {
                var x = cdata1[13];
                var y = cdata1[13 + 1];
                var rx1 = cos1 * x - sin1 * y + px1;
                var ry1 = sin1 * x + cos1 * y + py1;
                x = cdata1[15];
                y = cdata1[15 + 1];
                var rx2 = cos2 * x - sin2 * y + px2;
                var ry2 = sin2 * x + cos2 * y + py2;
                var dx = rx2 - rx1;
                var dy = ry2 - ry1;
                var dl = Math.sqrt(dx * dx + dy * dy);
                nx = adata[4];
                ny = adata[4 + 1];
                if (dl < Physics2DConfig.NORMALIZE_EPSILON) {
                    dx = nx;
                    dy = ny
                } else {
                    var rec = 1 / dl;
                    dx *= rec;
                    dy *= rec
                }
                err = dl - rad;
                if (dx * nx + dy * ny < 0) {
                    err -= rad;
                    dx = -dx;
                    dy = -dy
                }
                adata[4] = dx;
                adata[4 + 1] = dy;
                var px, py, r1;
                if (this.shapeA._type === 0) {
                    r1 = this.shapeA._data[6] + err * .5;
                    px = cdata1[0] = rx1 + dx * r1;
                    py = cdata1[0 + 1] = ry1 + dy * r1
                } else {
                    r1 = this.shapeB._data[6] + err * .5;
                    px = cdata1[0] = rx2 - dx * r1;
                    py = cdata1[0 + 1] = ry2 - dy * r1
                }
                cdata1[2] = err
            } else {
                var cdata2 = this._position2Contact ? this._contact2._data : null;
                var proj;
                var cx1, cx2, cy1, cy2;
                var lx = adata[11];
                var ly = adata[11 + 1];
                var rx = cdata1[13];
                var ry = cdata1[13 + 1];
                if (this._faceType === 1) {
                    nx = lx * cos1 - ly * sin1;
                    ny = lx * sin1 + ly * cos1;
                    proj = adata[13] + (nx * px1 + ny * py1);
                    cx1 = px2 + rx * cos2 - ry * sin2;
                    cy1 = py2 + rx * sin2 + ry * cos2;
                    if (cdata2) {
                        rx = cdata2[13];
                        ry = cdata2[13 + 1];
                        cx2 = px2 + rx * cos2 - ry * sin2;
                        cy2 = py2 + rx * sin2 + ry * cos2
                    }
                } else {
                    nx = lx * cos2 - ly * sin2;
                    ny = lx * sin2 + ly * cos2;
                    proj = adata[13] + (nx * px2 + ny * py2);
                    cx1 = px1 + rx * cos1 - ry * sin1;
                    cy1 = py1 + rx * sin1 + ry * cos1;
                    if (cdata2) {
                        rx = cdata2[13];
                        ry = cdata2[13 + 1];
                        cx2 = px1 + rx * cos1 - ry * sin1;
                        cy2 = py1 + rx * sin1 + ry * cos1
                    }
                }
                var flip = this._reverse ? -1 : 1;
                adata[4] = flip * nx;
                adata[4 + 1] = flip * ny;
                var bias = -proj - rad;
                err = cx1 * nx + cy1 * ny + bias;
                var df = err * .5 + rad;
                cdata1[0] = cx1 - nx * df;
                cdata1[0 + 1] = cy1 - ny * df;
                cdata1[2] = err;
                if (cdata2) {
                    err = cx2 * nx + cy2 * ny + bias;
                    df = err * .5 + rad;
                    cdata2[0] = cx2 - nx * df;
                    cdata2[0 + 1] = cy2 - ny * df;
                    cdata2[2] = err
                }
            }
        };
        Physics2DArbiter.prototype._iteratePosition = function() {
            this._refreshContactData();
            var b1 = this.bodyA;
            var b2 = this.bodyB;
            var data1 = b1._data;
            var data2 = b2._data;
            var im1 = data1[0];
            var ii1 = data1[1];
            var im2 = data2[0];
            var ii2 = data2[1];
            var px1 = data1[2];
            var py1 = data1[2 + 1];
            var px2 = data2[2];
            var py2 = data2[2 + 1];
            var px, py, nx, ny, Jx, Jy, jn, dr, Ka, bc;
            var c1r1x, c1r1y, c1r2x, c1r2y, rn1a, rn1b;
            var adata = this._data;
            var cdata1 = this._contact1._data;
            var err1 = cdata1[2] + Physics2DConfig.CONTACT_SLOP;
            if (this._position2Contact) {
                var cdata2 = this._contact2._data;
                var err2 = cdata2[2] + Physics2DConfig.CONTACT_SLOP;
                if (err1 < 0 || err2 < 0) {
                    px = cdata1[0];
                    py = cdata1[0 + 1];
                    c1r1x = px - px1;
                    c1r1y = py - py1;
                    c1r2x = px - px2;
                    c1r2y = py - py2;
                    px = cdata2[0];
                    py = cdata2[0 + 1];
                    var c2r1x = px - px1;
                    var c2r1y = py - py1;
                    var c2r2x = px - px2;
                    var c2r2y = py - py2;
                    nx = adata[4];
                    ny = adata[4 + 1];
                    rn1a = c1r1x * ny - c1r1y * nx;
                    rn1b = c1r2x * ny - c1r2y * nx;
                    var rn2a = c2r1x * ny - c2r1y * nx;
                    var rn2b = c2r2x * ny - c2r2y * nx;
                    var massSum = im1 + im2;
                    Ka = massSum + ii1 * rn1a * rn1a + ii2 * rn1b * rn1b;
                    var Kb = massSum + ii1 * rn1a * rn2a + ii2 * rn1b * rn2b;
                    var Kc = massSum + ii1 * rn2a * rn2a + ii2 * rn2b * rn2b;
                    bc = adata[15];
                    var bx = err1 * bc;
                    var by = err2 * bc;
                    var det = Ka * Kc - Kb * Kb;
                    var xx, xy;
                    if (det === 0) {
                        xx = Ka === 0 ? 0 : -bx / Ka;
                        xy = Kc === 0 ? 0 : -by / Kc
                    } else {
                        det = 1 / det;
                        xx = det * (Kb * by - Kc * bx);
                        xy = det * (Kb * bx - Ka * by)
                    }
                    if (xx < 0 || xy < 0) {
                        xx = -bx / Ka;
                        xy = 0;
                        if (xx < 0 || Kb * xx + by < 0) {
                            xx = 0;
                            xy = -by / Kc;
                            if (xy < 0 || Kb * xy + bx < 0) {
                                xx = xy = 0
                            }
                        }
                    }
                    jn = xx + xy;
                    Jx = nx * jn;
                    Jy = ny * jn;
                    px1 -= Jx * im1;
                    py1 -= Jy * im1;
                    dr = -(rn1a * xx + rn2a * xy) * ii1;
                    if (dr !== 0) {
                        b1._deltaRotation(dr)
                    }
                    px2 += Jx * im2;
                    py2 += Jy * im2;
                    dr = (rn1b * xx + rn2b * xy) * ii2;
                    if (dr !== 0) {
                        b2._deltaRotation(dr)
                    }
                }
            } else {
                if (err1 < 0) {
                    px = cdata1[0];
                    py = cdata1[0 + 1];
                    c1r1x = px - px1;
                    c1r1y = py - py1;
                    c1r2x = px - px2;
                    c1r2y = py - py2;
                    nx = adata[4];
                    ny = adata[4 + 1];
                    rn1a = c1r1x * ny - c1r1y * nx;
                    rn1b = c1r2x * ny - c1r2y * nx;
                    Ka = im2 + rn1b * rn1b * ii2 + im1 + rn1a * rn1a * ii1;
                    if (Ka !== 0) {
                        bc = adata[15];
                        jn = -(bc * err1 / Ka);
                        Jx = nx * jn;
                        Jy = ny * jn;
                        px1 -= Jx * im1;
                        py1 -= Jy * im1;
                        dr = -(rn1a * ii1 * jn);
                        if (dr !== 0) {
                            b1._deltaRotation(dr)
                        }
                        px2 += Jx * im2;
                        py2 += Jy * im2;
                        dr = rn1b * ii2 * jn;
                        if (dr !== 0) {
                            b2._deltaRotation(dr)
                        }
                    }
                }
            }
            data1[2] = px1;
            data1[2 + 1] = py1;
            data2[2] = px2;
            data2[2 + 1] = py2
        };
        Physics2DArbiter.prototype._warmStart = function() {
            var data1 = this.bodyA._data;
            var data2 = this.bodyB._data;
            var im1 = data1[0];
            var ii1 = data1[1];
            var im2 = data2[0];
            var ii2 = data2[1];
            var adata = this._data;
            var nx = adata[4];
            var ny = adata[4 + 1];
            var cdata = this._contact1._data;
            var jn = cdata[11];
            var jt = cdata[12];
            var jx = nx * jn - ny * jt;
            var jy = ny * jn + nx * jt;
            data1[7] -= jx * im1;
            data1[7 + 1] -= jy * im1;
            data1[7 + 2] -= (cdata[7] * jy - cdata[7 + 1] * jx) * ii1;
            data2[7] += jx * im2;
            data2[7 + 1] += jy * im2;
            data2[7 + 2] += (cdata[9] * jy - cdata[9 + 1] * jx) * ii2;
            if (this._velocity2Contact) {
                cdata = this._contact2._data;
                jn = cdata[11];
                jt = cdata[12];
                jx = nx * jn - ny * jt;
                jy = ny * jn + nx * jt;
                data1[7] -= jx * im1;
                data1[7 + 1] -= jy * im1;
                data1[7 + 2] -= (cdata[7] * jy - cdata[7 + 1] * jx) * ii1;
                data2[7] += jx * im2;
                data2[7 + 1] += jy * im2;
                data2[7 + 2] += (cdata[9] * jy - cdata[9 + 1] * jx) * ii2
            } else if (this._contact1._hash === 0) {
                jn = adata[16];
                data1[7 + 2] -= jn * ii1;
                data2[7 + 2] += jn * ii2
            }
        };
        Physics2DArbiter.prototype.getImpulseForBody = function(body, dst) {
            if (dst === undefined) {
                dst = new Physics2DDevice.prototype.floatArray(3)
            }
            var adata = this._data;
            var nx = adata[4];
            var ny = adata[4 + 1];
            var cdata = this._contact1._data;
            var jn = cdata[11];
            var jt = cdata[12];
            var jx = nx * jn - ny * jt;
            var jy = ny * jn + nx * jt;
            var sumX = 0;
            var sumY = 0;
            var sumW = 0;
            if (body === this.bodyA) {
                sumX -= jx;
                sumY -= jy;
                sumW -= cdata[7] * jy - cdata[7 + 1] * jx
            } else if (body === this.bodyB) {
                sumX += jx;
                sumY += jy;
                sumW += cdata[9] * jy - cdata[9 + 1] * jx
            }
            if (this._velocity2Contact) {
                cdata = this._contact2._data;
                jn = cdata[11];
                jt = cdata[12];
                jx = nx * jn - ny * jt;
                jy = ny * jn + nx * jt;
                if (body === this.bodyA) {
                    sumX -= jx;
                    sumY -= jy;
                    sumW -= cdata[7] * jy - cdata[7 + 1] * jx
                } else if (body === this.bodyB) {
                    sumX += jx;
                    sumY += jy;
                    sumW += cdata[9] * jy - cdata[9 + 1] * jx
                }
            } else if (this._contact1._hash === 0) {
                jn = adata[16];
                sumW += (body === this.bodyA ? -1 : body === this.bodyB ? 1 : 0) * jn
            }
            dst[0] = sumX;
            dst[1] = sumY;
            dst[2] = sumW;
            return dst
        };
        Physics2DArbiter.allocate = function() {
            if (!this.pool) {
                return new Physics2DArbiter
            } else {
                var arb = this.pool;
                this.pool = arb._next;
                arb._next = null;
                return arb
            }
        };
        Physics2DArbiter.deallocate = function(arb) {
            arb._next = this.pool;
            this.pool = arb;
            arb._userdef = 0
        };
        Physics2DArbiter.version = 1;
        Physics2DArbiter.pool = null;
        return Physics2DArbiter
    }();
    var Physics2DWorld = function() {
        function Physics2DWorld() {}
        Physics2DWorld.prototype.getGravity = function(dst) {
            if (dst === undefined) {
                dst = new Physics2DDevice.prototype.floatArray(2)
            }
            dst[0] = this._gravityX;
            dst[1] = this._gravityY;
            return dst
        };
        Physics2DWorld.prototype.setGravity = function(gravity) {
            var newX = gravity[0];
            var newY = gravity[1];
            if (newX !== this._gravityX || newY !== this._gravityY) {
                this._gravityX = newX;
                this._gravityY = newY;
                var bodies = this.rigidBodies;
                var limit = bodies.length;
                var i;
                for (i = 0; i < limit; i += 1) {
                    this._wakeBody(bodies[i])
                }
            }
        };
        Physics2DWorld.prototype._addShape = function(shape) {
            var body = shape.body;
            body._update();
            var isStaticHandle = body._type === 2 || body.sleeping;
            shape._bphaseHandle = this.broadphase.insert(shape, shape._data, isStaticHandle)
        };
        Physics2DWorld.prototype._removeShape = function(shape, noCallbacks) {
            var body = shape.body;
            this.broadphase.remove(shape._bphaseHandle);
            shape._bphaseHandle = null;
            var arbiters = shape.arbiters;
            while (arbiters.length !== 0) {
                var arb = arbiters.pop();
                if (arb._retired) {
                    continue
                }
                if (arb.bodyA !== body && arb.bodyA._type === 0) {
                    this._wakeBody(arb.bodyA)
                }
                if (arb.bodyB !== body && arb.bodyB._type === 0) {
                    this._wakeBody(arb.bodyB)
                }
                arb._lazyRetire(shape);
                if (!noCallbacks) {
                    this._pushInteractionEvents(3, arb)
                }
            }
        };
        Physics2DWorld.prototype._enabledConstraint = function(constraint) {
            constraint._islandRoot = constraint;
            constraint._islandRank = 0;
            if (!constraint.sleeping) {
                constraint.sleeping = true;
                this._wakeConstraint(constraint, true)
            }
        };
        Physics2DWorld.prototype._disabledConstraint = function(constraint) {
            this._wakeConstraint(constraint);
            var constraints = this.liveConstraints;
            var index = constraints.indexOf(constraint);
            constraints[index] = constraints[constraints.length - 1];
            constraints.pop()
        };
        Physics2DWorld.prototype.addConstraint = function(constraint) {
            if (constraint.world) {
                return false
            }
            constraint.world = this;
            this.constraints.push(constraint);
            constraint._inWorld();
            if (constraint._active) {
                this._enabledConstraint(constraint)
            }
            return true
        };
        Physics2DWorld.prototype.removeConstraint = function(constraint) {
            if (constraint.world !== this) {
                return false
            }
            var constraints = this.constraints;
            var index = constraints.indexOf(constraint);
            constraints[index] = constraints[constraints.length - 1];
            constraints.pop();
            if (constraint._active) {
                this._disabledConstraint(constraint)
            }
            constraint.world = null;
            constraint._outWorld();
            return true
        };
        Physics2DWorld.prototype.addRigidBody = function(body) {
            if (body.world) {
                return false
            }
            body.world = this;
            this.rigidBodies.push(body);
            body._update();
            var i;
            var shapes = body.shapes;
            var limit = shapes.length;
            for (i = 0; i < limit; i += 1) {
                this._addShape(shapes[i])
            }
            if (body._type === 2) {
                body.sleeping = true;
                return true
            }
            body._islandRoot = body;
            body._islandRank = 0;
            if (!body.sleeping) {
                body.sleeping = true;
                this._wakeBody(body, true)
            }
            return true
        };
        Physics2DWorld.prototype.removeRigidBody = function(body, noCallbacks) {
            if (body.world !== this) {
                return false
            }
            this._wakeBody(body);
            body.world = null;
            var rigidBodies = this.rigidBodies;
            var index = rigidBodies.indexOf(body);
            rigidBodies[index] = rigidBodies[rigidBodies.length - 1];
            rigidBodies.pop();
            if (!body.sleeping && body._type !== 2) {
                if (body._type === 0) {
                    rigidBodies = this.liveDynamics
                } else {
                    rigidBodies = this.liveKinematics
                }
                index = rigidBodies.indexOf(body);
                rigidBodies[index] = rigidBodies[rigidBodies.length - 1];
                rigidBodies.pop()
            }
            var i;
            var shapes = body.shapes;
            var limit = shapes.length;
            for (i = 0; i < limit; i += 1) {
                this._removeShape(shapes[i], noCallbacks)
            }
            var constraints = body.constraints;
            while (constraints.length > 0) {
                this.removeConstraint(constraints[0])
            }
            return true
        };
        Physics2DWorld.prototype.clear = function() {
            var bodies = this.rigidBodies;
            var limit = bodies.length;
            while (limit > 0) {
                limit -= 1;
                this.removeRigidBody(bodies[limit], true)
            }
            var constraints = this.constraints;
            limit = constraints.length;
            while (limit > 0) {
                limit -= 1;
                this.removeConstraint(constraints[limit])
            }
            this._clearArbiters(this.staticArbiters);
            this._clearArbiters(this.dynamicArbiters);
            var callbacks = this._callbacks;
            limit = callbacks.length;
            while (limit > 0) {
                limit -= 1;
                Physics2DCallback.deallocate(callbacks.pop())
            }
        };
        Physics2DWorld.prototype._clearArbiters = function(arbiters) {
            var limit = arbiters.length;
            while (limit > 0) {
                var arb = arbiters.pop();
                limit -= 1;
                arb._retire();
                Physics2DArbiter.deallocate(arb)
            }
        };
        Physics2DWorld.prototype.shapePointQuery = function(point, store) {
            return this._pointQuery(this._shapePointCallback, point, store)
        };
        Physics2DWorld.prototype.bodyPointQuery = function(point, store) {
            return this._pointQuery(this._bodyPointCallback, point, store)
        };
        Physics2DWorld.prototype._pointQuery = function(callback, point, store) {
            var rect = this._sampleRectangle;
            rect[0] = rect[2] = point[0];
            rect[1] = rect[3] = point[1];
            callback.store = store;
            callback.count = 0;
            this.broadphase.sample(rect, callback.sample, callback);
            return callback.count
        };
        Physics2DWorld.prototype.shapeCircleQuery = function(center, radius, store) {
            return this._circleQuery(this._shapeCircleCallback, center, radius, store)
        };
        Physics2DWorld.prototype.bodyCircleQuery = function(center, radius, store) {
            return this._circleQuery(this._bodyCircleCallback, center, radius, store)
        };
        Physics2DWorld.prototype._circleQuery = function(callback, center, radius, store) {
            var circle = this._circleQueryShape;
            circle.setRadius(radius);
            var posX = center[0];
            var posY = center[1];
            circle._update(posX, posY, 1, 0);
            var rect = this._sampleRectangle;
            rect[0] = posX - radius;
            rect[1] = posY - radius;
            rect[2] = posX + radius;
            rect[3] = posY + radius;
            callback.store = store;
            callback.count = 0;
            this.broadphase.sample(rect, callback.sample, callback);
            return callback.count
        };
        Physics2DWorld.prototype.shapeRectangleQuery = function(aabb, store) {
            return this._rectangleQuery(this._shapeRectangleCallback, aabb, store)
        };
        Physics2DWorld.prototype.bodyRectangleQuery = function(aabb, store) {
            return this._rectangleQuery(this._bodyRectangleCallback, aabb, store)
        };
        Physics2DWorld.prototype._rectangleQuery = function(callback, aabb, store) {
            var vertices = this._rectangleQueryVertices;
            var x1 = aabb[0];
            var y1 = aabb[1];
            var x2 = aabb[2];
            var y2 = aabb[3];
            vertices[0][0] = vertices[3][0] = x1 < x2 ? x1 : x2;
            vertices[0][1] = vertices[1][1] = y1 < y2 ? y1 : y2;
            vertices[1][0] = vertices[2][0] = x1 < x2 ? x2 : x1;
            vertices[2][1] = vertices[3][1] = y1 < y2 ? y2 : y1;
            var poly = this._rectangleQueryShape;
            poly.setVertices(vertices);
            poly._update(0, 0, 1, 0);
            callback.store = store;
            callback.count = 0;
            this.broadphase.sample(aabb, callback.sample, callback);
            return callback.count
        };
        Physics2DWorld.prototype.rayCast = function(ray, noInnerSurfaces, customCallback, thisObject) {
            var origin = ray.origin;
            var direction = ray.direction;
            var maxFactor = ray.maxFactor;
            var x1 = origin[0];
            var y1 = origin[1];
            var x2 = x1 + direction[0] * maxFactor;
            var y2 = y1 + direction[1] * maxFactor;
            var rect = this._sampleRectangle;
            rect[0] = x1 < x2 ? x1 : x2;
            rect[1] = y1 < y2 ? y1 : y2;
            rect[2] = x1 < x2 ? x2 : x1;
            rect[3] = y1 < y2 ? y2 : y1;
            var callback = this._rayCast;
            callback.ray = ray;
            callback.noInner = noInnerSurfaces || false;
            callback.minFactor = ray.maxFactor;
            callback.userCallback = customCallback;
            callback.userThis = thisObject;
            callback.minShape = null;
            this.broadphase.sample(rect, callback.sample, callback);
            if (callback.minShape) {
                var data = callback.minNormal;
                var hitNormal = new Physics2DDevice.prototype.floatArray(2);
                var hitPoint = new Physics2DDevice.prototype.floatArray(2);
                hitNormal[0] = data[0];
                hitNormal[1] = data[1];
                hitPoint[0] = x1 + direction[0] * callback.minFactor;
                hitPoint[1] = y1 + direction[1] * callback.minFactor;
                return {
                    shape: callback.minShape,
                    hitNormal: hitNormal,
                    hitPoint: hitPoint,
                    factor: callback.minFactor
                }
            } else {
                return null
            }
        };
        Physics2DWorld.prototype.convexCast = function(shape, deltaTime, customCallback, thisObject) {
            var body = shape.body;
            var bdata = body._data;
            var preX = bdata[2];
            var preY = bdata[2 + 1];
            body._sweepIntegrate(deltaTime);
            var curX = bdata[2];
            var curY = bdata[2 + 1];
            var rect = this._sampleRectangle;
            var radius = shape._data[4];
            rect[0] = (preX < curX ? preX : curX) - radius;
            rect[1] = (preY < curY ? preY : curY) - radius;
            rect[2] = (preX < curX ? curX : preX) + radius;
            rect[3] = (preY < curY ? curY : preY) + radius;
            body[20] = body[7 + 2];
            var callback = this._convexCast;
            callback.deltaTime = deltaTime;
            callback.minTOIAlpha = 1;
            callback.minShape = null;
            callback.toi.shapeA = shape;
            callback.userCallback = customCallback;
            callback.userThis = thisObject;
            this.broadphase.sample(rect, callback.sample, callback);
            body._sweepIntegrate(0);
            shape._update(preX, preY, bdata[5], bdata[5 + 1], true);
            if (callback.minShape) {
                var data = callback.minData;
                var hitNormal = new Physics2DDevice.prototype.floatArray(2);
                var hitPoint = new Physics2DDevice.prototype.floatArray(2);
                hitNormal[0] = -data[0];
                hitNormal[1] = -data[1];
                hitPoint[0] = data[2];
                hitPoint[1] = data[3];
                return {
                    shape: callback.minShape,
                    hitNormal: hitNormal,
                    hitPoint: hitPoint,
                    factor: callback.minTOIAlpha * deltaTime
                }
            } else {
                return null
            }
        };
        Physics2DWorld.prototype.step = function(deltaTime) {
            this._midStep = true;
            this._eventTime = 0;
            this.timeStamp += 1;
            this._deltaTime = deltaTime;
            this.simulatedTime += deltaTime;
            this._validate();
            this._discreteCollisions();
            this._sleepComputations(deltaTime);
            this._preStep(deltaTime);
            this._sortArbiters();
            this._integrateVelocity(deltaTime);
            this._warmStart();
            this._iterateVelocity(this.velocityIterations);
            this._integratePosition(deltaTime);
            this._eventTime = 1;
            this._continuousCollisions(deltaTime);
            this._sortArbiters();
            this._iteratePosition(this.positionIterations);
            this._finalize();
            this._midStep = false;
            this._eventTime = -1;
            this._doCallbacks()
        };
        Physics2DWorld.prototype._discreteCollisions = function() {
            this.broadphase.perform(this._discreteNarrowPhase, this);
            this._doDeferredWake(false)
        };
        Physics2DWorld.prototype._doDeferredWake = function(continuous) {
            var wakes = this._deferredWake;
            var limit = wakes.length;
            while (limit > 0) {
                var body = wakes.pop();
                body._deferred = false;
                this._wakeBody(body, false, continuous);
                limit -= 1
            }
        };
        Physics2DWorld.prototype._collisionType = function(s1, s2, b1, b2) {
            if (b1 === b2) {
                return undefined
            }
            var constraints = b1.constraints.length < b2.constraints.length ? b1.constraints : b2.constraints;
            var limit = constraints.length;
            var i;
            for (i = 0; i < limit; i += 1) {
                var con = constraints[i];
                if (con._active && con._ignoreInteractions && con._pairExists(b1, b2)) {
                    return undefined
                }
            }
            if ((s1._group & s2._mask) === 0 || (s2._group & s1._mask) === 0) {
                return undefined
            }
            var collisionType = !(s1.sensor || s2.sensor);
            if (b1._type !== 0 && b2._type !== 0 && collisionType) {
                return undefined
            }
            return collisionType
        };
        Physics2DWorld.prototype._discreteNarrowPhase = function(handleA, handleB, continuous) {
            var s1 = handleA.data;
            var s2 = handleB.data;
            var b1 = s1.body;
            var b2 = s2.body;
            var ctype = this._collisionType(s1, s2, b1, b2);
            if (ctype === undefined) {
                return null
            }
            var staticType = b1._type !== 0 || b2._type !== 0;
            var sa, sb;
            if (s1.id < s2.id) {
                sa = s1;
                sb = s2
            } else {
                sa = s2;
                sb = s1
            }
            var arbiters = (sa.arbiters.length < sb.arbiters.length ? sa : sb).arbiters;
            var limit = arbiters.length;
            var i;
            var arb;
            for (i = 0; i < limit; i += 1) {
                var sarb = arbiters[i];
                if (sarb.shapeA === sa && sarb.shapeB === sb) {
                    arb = sarb;
                    break
                }
            }
            var first = !arb;
            if (first) {
                arb = Physics2DArbiter.allocate()
            }
            if (first || arb._timeStamp !== this.timeStamp || continuous) {
                arb._timeStamp = this.timeStamp;
                if (ctype && this._collisions._collide(sa, sb, arb) || !ctype && this._collisions._test(sa, sb)) {
                    if (first) {
                        arb.sensor = !ctype;
                        arb._assign(sa, sb);
                        arb._static = staticType;
                        if (staticType) {
                            this.staticArbiters.push(arb)
                        } else {
                            this.dynamicArbiters.push(arb)
                        }
                    }
                    if (first || arb._endGenerated === this.timeStamp && continuous || arb._updateStamp < this.timeStamp - 1) {
                        arb._createContinuous = continuous;
                        arb._createStamp = this.timeStamp;
                        arb._state = ctype ? 0 : 1 | 2
                    }
                    arb._updateStamp = this.timeStamp;
                    var anyIndeterminate = false;
                    if (ctype && (arb._state & 2) === 0) {
                        arb._state = 1;
                        arb._midStep = true;
                        var events = sa._onPreSolve;
                        limit = events.length;
                        var eventObject;
                        for (i = 0; i < limit; i += 1) {
                            eventObject = events[i];
                            eventObject.callback.call(eventObject.thisObject, arb, sb);
                            if (!eventObject.deterministic) {
                                anyIndeterminate = true
                            }
                        }
                        events = sb._onPreSolve;
                        limit = events.length;
                        for (i = 0; i < limit; i += 1) {
                            eventObject = events[i];
                            eventObject.callback.call(eventObject.thisObject, arb, sa);
                            if (!eventObject.deterministic) {
                                anyIndeterminate = true
                            }
                        }
                        arb._midStep = false;
                        arb._indeterminate = anyIndeterminate;
                        if (anyIndeterminate && (arb._state & 2) === 0) {
                            if (b1._type === 0 && !b1._deferred) {
                                b1._deferred = true;
                                this._deferredWake.push(b1)
                            }
                            if (b2._type === 0 && !b1._deferred) {
                                b2._deferred = true;
                                this._deferredWake.push(b2)
                            }
                        }
                    }
                    if (ctype && (arb._state & 1) !== 0) {
                        if (b1._type === 0 && b1.sleeping && !b1._deferred) {
                            b1._deferred = true;
                            this._deferredWake.push(b1)
                        }
                        if (b2._type === 0 && b2.sleeping && !b2._deferred) {
                            b2._deferred = true;
                            this._deferredWake.push(b2)
                        }
                    }
                    if (arb.sleeping) {
                        this._wakeArbiter(arb)
                    }
                } else if (first) {
                    Physics2DArbiter.deallocate(arb);
                    arb = null
                }
            }
            return arb
        };
        Physics2DWorld.prototype._continuousCollisions = function(deltaTime) {
            this.broadphase.perform(this._continuousNarrowPhase, this);
            var curTimeAlpha = 0;
            var toiEvents = this._toiEvents;
            var limit = toiEvents.length;
            var toi, i;
            while (curTimeAlpha < 1 && limit !== 0) {
                var minTOIAlpha = Number.POSITIVE_INFINITY;
                var minKinematic = false;
                var min = -1;
                var b1, b2;
                for (i = 0; i < limit;) {
                    toi = toiEvents[i];
                    b1 = toi.shapeA.body;
                    b2 = toi.shapeB.body;
                    if (b1._sweepFrozen && b2._sweepFrozen) {
                        limit -= 1;
                        toiEvents[i] = toiEvents[limit];
                        toiEvents.pop();
                        Physics2DTOIEvent.deallocate(toi);
                        continue
                    }
                    if (toi.frozenA !== b1._sweepFrozen || toi.frozenB !== b2._sweepFrozen) {
                        toi.frozenA = b1._sweepFrozen;
                        toi.frozenB = b2._sweepFrozen;
                        if (toi.frozenA) {
                            var tmp = toi.shapeA;
                            toi.shapeA = toi.shapeB;
                            toi.shapeB = tmp;
                            toi.frozenA = false;
                            toi.frozenB = true
                        }
                        this._collisions._staticSweep(toi, deltaTime, Physics2DConfig.SWEEP_SLOP);
                        if (toi._data[6] < 0) {
                            limit -= 1;
                            toiEvents[i] = toiEvents[limit];
                            toiEvents.pop();
                            Physics2DTOIEvent.deallocate(toi);
                            continue
                        }
                    }
                    var curTOIAlpha = toi._data[6];
                    if (curTOIAlpha >= 0 && (curTOIAlpha < minTOIAlpha || !minKinematic && toi.kinematic)) {
                        minTOIAlpha = curTOIAlpha;
                        minKinematic = toi.kinematic;
                        min = i
                    }
                    i += 1
                }
                if (min === -1) {
                    break
                }
                toi = toiEvents[min];
                limit -= 1;
                toiEvents[min] = toiEvents[limit];
                toiEvents.pop();
                curTimeAlpha = minTOIAlpha;
                var s1 = toi.shapeA;
                var s2 = toi.shapeB;
                b1 = s1.body;
                b2 = s2.body;
                var data1 = b1._data;
                var data2 = b2._data;
                if (!b1._sweepFrozen || toi.kinematic) {
                    b1._sweepIntegrate(curTimeAlpha * deltaTime);
                    s1._update(data1[2], data1[2 + 1], data1[5], data1[5 + 1], true)
                }
                if (!b2._sweepFrozen || toi.kinematic) {
                    b2._sweepIntegrate(curTimeAlpha * deltaTime);
                    s2._update(data2[2], data2[2 + 1], data2[5], data2[5 + 1], true)
                }
                var arb = this._discreteNarrowPhase(s1._bphaseHandle, s2._bphaseHandle, true);
                if (arb) {
                    this._continuousArbiterPrepare(arb, deltaTime)
                }
                if (arb && !arb.sensor && (arb._state & 1) !== 0) {
                    if (!b1._sweepFrozen && b1._type === 0) {
                        b1._sweepFrozen = true;
                        if (toi.failed) {
                            data1[20] = 0
                        } else if (toi.slipped) {
                            data1[20] *= Physics2DConfig.TOI_SLIP_SCALE
                        }
                        data1[7 + 2] = data1[20]
                    }
                    if (!b2._sweepFrozen && b2._type === 0) {
                        b2._sweepFrozen = true;
                        if (toi.failed) {
                            data2[20] = 0
                        } else if (toi.slipped) {
                            data2[20] *= Physics2DConfig.TOI_SLIP_SCALE
                        }
                        data2[7 + 2] = data2[20]
                    }
                }
                Physics2DTOIEvent.deallocate(toi)
            }
            while (limit > 0) {
                toi = toiEvents.pop();
                Physics2DTOIEvent.deallocate(toi);
                limit -= 1
            }
            var bodies = this.liveDynamics;
            limit = bodies.length;
            for (i = 0; i < limit; i += 1) {
                var body = bodies[i];
                if (!body._sweepFrozen) {
                    body._sweepIntegrate(deltaTime)
                }
            }
            bodies = this.liveKinematics;
            limit = bodies.length;
            for (i = 0; i < limit; i += 1) {
                bodies[i]._sweepIntegrate(deltaTime)
            }
            this._doDeferredWake(true)
        };
        Physics2DWorld.prototype._continuousNarrowPhase = function(handleA, handleB) {
            var s1 = handleA.data;
            var s2 = handleB.data;
            var b1 = s1.body;
            var b2 = s2.body;
            if (b1._sweepFrozen && b2._sweepFrozen) {
                return
            }
            var staticType = b1._type !== 0 || b2._type !== 0;
            if (staticType || (b1._bullet || b2._bullet)) {
                var toi = Physics2DTOIEvent.allocate();
                var kin = b1._type === 1 || b2._type === 1;
                if (staticType && !kin) {
                    if (b1._type !== 0) {
                        toi.shapeB = s1;
                        toi.shapeA = s2
                    } else {
                        toi.shapeA = s1;
                        toi.shapeB = s2
                    }
                    this._collisions._staticSweep(toi, this._deltaTime, Physics2DConfig.SWEEP_SLOP)
                } else {
                    if (s1.body._sweepFrozen) {
                        toi.shapeB = s1;
                        toi.shapeA = s2;
                        this._collisions._staticSweep(toi, this._deltaTime, Physics2DConfig.SWEEP_SLOP)
                    } else if (s2.body._sweepFrozen) {
                        toi.shapeA = s1;
                        toi.shapeB = s2;
                        this._collisions._staticSweep(toi, this._deltaTime, Physics2DConfig.SWEEP_SLOP)
                    } else {
                        toi.shapeA = s1;
                        toi.shapeB = s2;
                        this._collisions._dynamicSweep(toi, this._deltaTime, Physics2DConfig.SWEEP_SLOP)
                    }
                }
                if (staticType && toi._data[6] < 0 || toi.failed) {
                    Physics2DTOIEvent.deallocate(toi)
                } else {
                    this._toiEvents.push(toi);
                    toi.frozenA = toi.shapeA.body._sweepFrozen;
                    toi.frozenB = toi.shapeB.body._sweepFrozen;
                    toi.staticType = staticType;
                    toi.kinematic = kin
                }
            }
        };
        Physics2DWorld.prototype.__union = function(x, y) {
            var stack, next;
            while (x !== x._islandRoot) {
                next = x._islandRoot;
                x._islandRoot = stack;
                stack = x;
                x = next
            }
            while (stack) {
                next = stack._islandRoot;
                stack._islandRoot = x;
                stack = next
            }
            while (y !== y._islandRoot) {
                next = y._islandRoot;
                y._islandRoot = stack;
                stack = y;
                y = next
            }
            while (stack) {
                next = stack._islandRoot;
                stack._islandRoot = y;
                stack = next
            }
            if (x !== y) {
                if (x._islandRank < y._islandRank) {
                    x._islandRoot = y
                } else if (y._islandRank < x._islandRank) {
                    y._islandRoot = x
                } else {
                    y._islandRoot = x;
                    x._islandRank += 1
                }
            }
        };
        Physics2DWorld.prototype.__find = function(x) {
            if (x === x._islandRoot) {
                return x
            }
            var stack = null;
            var next;
            while (x !== x._islandRoot) {
                next = x._islandRoot;
                x._islandRoot = stack;
                stack = x;
                x = next
            }
            while (stack) {
                next = stack._islandRoot;
                stack._islandRoot = x;
                stack = next
            }
            return x
        };
        Physics2DWorld.prototype._sleepComputations = function(deltaTime) {
            var arbiters = this.dynamicArbiters;
            var arb;
            var limit = arbiters.length;
            var i;
            for (i = 0; i < limit; i += 1) {
                arb = arbiters[i];
                if (!arb.sensor && !arb._retired && arb._updateStamp === this.timeStamp && (arb._state & 1) !== 0) {
                    var b1 = arb.bodyA;
                    var b2 = arb.bodyB;
                    if (b1._type === 0 && b2._type === 0) {
                        this.__union(b1, b2)
                    }
                }
            }
            var constraints = this.liveConstraints;
            limit = constraints.length;
            for (i = 0; i < limit; i += 1) {
                constraints[i]._sleepComputation(this.__union)
            }
            var islands = this._islands;
            var island, root;
            var bodies = this.liveDynamics;
            limit = bodies.length;
            while (limit > 0) {
                limit -= 1;
                var body = bodies.pop();
                root = this.__find(body);
                island = root._island;
                if (island === null) {
                    root._island = island = Physics2DIsland.allocate();
                    islands.push(island);
                    island.sleeping = true;
                    island.wakeTime = 0
                }
                body._island = island;
                island.components.push(body);
                var atRest = body._atRest(deltaTime, this.timeStamp);
                island.sleeping = island.sleeping && atRest;
                if (body._wakeTime > island.wakeTime) {
                    island.wakeTime = body._wakeTime
                }
            }
            limit = constraints.length;
            while (limit > 0) {
                limit -= 1;
                var con = constraints.pop();
                root = this.__find(con);
                island = root._island;
                if (island === null) {
                    root._island = island = Physics2DIsland.allocate();
                    islands.push(island);
                    island.sleeping = true;
                    island.wakeTime = 0
                }
                con._island = island;
                island.components.push(con);
                if (con._wakeTime > island.wakeTime) {
                    island.wakeTime = con._wakeTime
                }
            }
            limit = islands.length;
            var limit2;
            var bphase = this.broadphase;
            while (limit > 0) {
                limit -= 1;
                island = islands[limit];
                islands.pop();
                var comp, comps;
                if (island.sleeping) {
                    comps = island.components;
                    limit2 = comps.length;
                    var j;
                    for (j = 0; j < limit2; j += 1) {
                        comp = comps[j];
                        comp.sleeping = true;
                        if (comp._isBody) {
                            var shapes = comp.shapes;
                            var limit3 = shapes.length;
                            var k;
                            for (k = 0; k < limit3; k += 1) {
                                var shape = shapes[k];
                                bphase.update(shape._bphaseHandle, shape._data, true)
                            }
                            var data = comp._data;
                            data[7] = 0;
                            data[7 + 1] = 0;
                            data[7 + 2] = 0
                        }
                        if (comp._onSleep.length > 0) {
                            this._pushCallbacks(comp, comp._onSleep)
                        }
                    }
                } else {
                    comps = island.components;
                    limit2 = comps.length;
                    while (limit2 > 0) {
                        limit2 -= 1;
                        comp = comps.pop();
                        comp._wakeTime = island.wakeTime;
                        if (comp._isBody) {
                            bodies.push(comp)
                        } else {
                            constraints.push(comp)
                        }
                        comp._island = null;
                        comp._islandRoot = comp;
                        comp._islandRank = 0
                    }
                    Physics2DIsland.deallocate(island)
                }
            }
        };
        Physics2DWorld.prototype._sortArbiters = function() {
            this._subSortArbiters(this.dynamicArbiters);
            this._subSortArbiters(this.staticArbiters)
        };
        Physics2DWorld.prototype._subSortArbiters = function(arbiters) {
            var i;
            var limit = arbiters.length - 1;
            for (i = 1; i < limit; i += 1) {
                var item = arbiters[i];
                var idA = item.shapeA.id;
                var idB = item.shapeB.id;
                var hole = i;
                while (hole > 0) {
                    var cur = arbiters[hole - 1];
                    var curIDA = cur.shapeA.id;
                    if (curIDA < idA || curIDA === idA && cur.shapeB.id < idB) {
                        break
                    }
                    arbiters[hole] = cur;
                    hole -= 1
                }
                arbiters[hole] = item
            }
        };
        Physics2DWorld.prototype._onWakeCallbacks = function(component) {
            if (this._midStep) {
                if (component._onWake.length > 0) {
                    this._pushCallbacks(component, component._onWake)
                }
            } else {
                component._woken = true
            }
        };
        Physics2DWorld.prototype._pushCallbacks = function(thisObject, callbacks) {
            var cbs = this._callbacks;
            var limit = callbacks.length;
            var i;
            for (i = 0; i < limit; i += 1) {
                var cb = Physics2DCallback.allocate();
                cb.thisObject = thisObject;
                cb.callback = callbacks[i];
                cb.time = this._eventTime;
                cb.index = i;
                cbs.push(cb)
            }
        };
        Physics2DWorld.prototype._pushInteractionEvents = function(eventType, arb) {
            var cbs = this._callbacks;
            var shapeA = arb.shapeA;
            var shapeB = arb.shapeB;
            var groupA = shapeA._group;
            var groupB = shapeB._group;
            var events = shapeA._events;
            var limit = events.length;
            var i, eventObject, cb;
            for (i = 0; i < limit; i += 1) {
                eventObject = events[i];
                if (eventObject.type === eventType && (eventObject.mask === undefined || (eventObject.mask & groupB) !== 0)) {
                    cb = Physics2DCallback.allocate();
                    cb.thisObject = shapeA;
                    cb.callback = eventObject.callback;
                    cb.time = this._eventTime;
                    cb.index = i;
                    cb.arbiter = arb;
                    cbs.push(cb)
                }
            }
            events = shapeB._events;
            limit = events.length;
            for (i = 0; i < limit; i += 1) {
                eventObject = events[i];
                if (eventObject.type === eventType && (eventObject.mask === undefined || (eventObject.mask & groupA) !== 0)) {
                    cb = Physics2DCallback.allocate();
                    cb.thisObject = shapeA;
                    cb.callback = eventObject.callback;
                    cb.time = this._eventTime;
                    cb.index = i;
                    cb.arbiter = arb;
                    cbs.push(cb)
                }
            }
        };
        Physics2DWorld.prototype._brokenConstraint = function(con) {
            if (con._onBreak.length > 0) {
                this._pushCallbacks(con, con._onBreak)
            }
            if (con._removeOnBreak) {
                con.world = null;
                var constraints = this.constraints;
                var index = constraints.indexOf(con);
                constraints[index] = constraints[constraints.length - 1];
                constraints.pop();
                con._outWorld()
            } else {
                con._active = false
            }
            con._clearCache()
        };
        Physics2DWorld.prototype._preStep = function(deltaTime) {
            var constraints = this.liveConstraints;
            var limit = constraints.length;
            var i;
            for (i = 0; i < limit;) {
                var con = constraints[i];
                if (con._preStep(deltaTime)) {
                    limit -= 1;
                    constraints[i] = constraints[limit];
                    constraints.pop();
                    this._brokenConstraint(con);
                    continue
                }
                i += 1
            }
            this._preStepArbiters(this.dynamicArbiters, deltaTime);
            this._preStepArbiters(this.staticArbiters, deltaTime)
        };
        Physics2DWorld.prototype._preStepArbiter = function(arb, deltaTime, progressEvents) {
            var timeStamp = this.timeStamp;
            arb.active = arb._updateStamp === timeStamp;
            if (arb._createContinuous && arb._createStamp === timeStamp) {
                this._pushInteractionEvents(1, arb)
            } else if (progressEvents && arb.active) {
                this._pushInteractionEvents(2, arb)
            }
            if (arb.active) {
                if ((arb._state & 1) !== 0) {
                    if (!arb._preStep(deltaTime, timeStamp, true)) {
                        arb.active = false
                    }
                } else if (!arb.sensor && !arb._cleanContacts(timeStamp)) {
                    arb.active = false
                }
            }
        };
        Physics2DWorld.prototype._preStepArbiters = function(arbiters, deltaTime) {
            var timeStamp = this.timeStamp;
            var limit = arbiters.length;
            var i;
            for (i = 0; i < limit;) {
                var arb = arbiters[i];
                if (!arb._retired && (arb.bodyA.sleeping && arb.bodyB.sleeping)) {
                    arb._sleepStamp = timeStamp;
                    arb.sleeping = true;
                    arb.active = false;
                    this._pushInteractionEvents(2, arb);
                    limit -= 1;
                    arbiters[i] = arbiters[limit];
                    arbiters.pop();
                    continue
                }
                if (!arb._lazyRetired) {
                    if (arb._retired || arb._updateStamp + (arb.sensor ? 1 : Physics2DConfig.DELAYED_DEATH) < timeStamp) {
                        arb._retire();
                        limit -= 1;
                        arbiters[i] = arbiters[limit];
                        arbiters.pop();
                        Physics2DArbiter.deallocate(arb);
                        continue
                    }
                } else {
                    arb._lazyRetired = false;
                    i += 1;
                    continue
                }
                arb.active = arb._updateStamp === timeStamp;
                if (arb._createStamp === timeStamp) {
                    this._pushInteractionEvents(1, arb)
                } else if (arb.active) {
                    this._pushInteractionEvents(2, arb)
                } else if (arb._updateStamp === timeStamp - 1) {
                    this._pushInteractionEvents(3, arb);
                    arb._endGenerated = this.timeStamp
                }
                if (arb.active) {
                    if ((arb._state & 1) !== 0) {
                        if (!arb._preStep(deltaTime, timeStamp)) {
                            arb.active = false
                        }
                    } else if (!arb.sensor && !arb._cleanContacts(timeStamp)) {
                        arb.active = false
                    }
                }
                i += 1
            }
        };
        Physics2DWorld.prototype._iterateVelocity = function(count) {
            var constraints = this.liveConstraints;
            while (count > 0) {
                var limit = constraints.length;
                var i;
                for (i = 0; i < limit;) {
                    var con = constraints[i];
                    if (con._iterateVel()) {
                        limit -= 1;
                        constraints[i] = constraints[limit];
                        constraints.pop();
                        this._brokenConstraint(con);
                        continue
                    }
                    i += 1
                }
                this._iterateVelocityArbiters(this.dynamicArbiters);
                this._iterateVelocityArbiters(this.staticArbiters);
                count -= 1
            }
        };
        Physics2DWorld.prototype._iterateVelocityArbiters = function(arbiters) {
            var limit = arbiters.length;
            var i;
            for (i = 0; i < limit; i += 1) {
                var arb = arbiters[i];
                if (arb.active && !arb.sensor && (arb._state & 1) !== 0) {
                    arb._iterateVelocity()
                }
            }
        };
        Physics2DWorld.prototype._iteratePosition = function(count) {
            var constraints = this.liveConstraints;
            while (count > 0) {
                var limit = constraints.length;
                var i;
                for (i = 0; i < limit;) {
                    var con = constraints[i];
                    if (con._stiff && con._iteratePos()) {
                        limit -= 1;
                        constraints[i] = constraints[limit];
                        constraints.pop();
                        this._brokenConstraint(con);
                        continue
                    }
                    i += 1
                }
                this._iteratePositionArbiters(this.dynamicArbiters);
                this._iteratePositionArbiters(this.staticArbiters);
                count -= 1
            }
        };
        Physics2DWorld.prototype._iteratePositionArbiters = function(arbiters) {
            var limit = arbiters.length;
            var i;
            for (i = 0; i < limit; i += 1) {
                var arb = arbiters[i];
                if (arb.active && !arb.sensor && (arb._state & 1) !== 0) {
                    arb._iteratePosition()
                }
            }
        };
        Physics2DWorld.prototype._integrateVelocity = function(deltaTime) {
            var gravityX = this._gravityX;
            var gravityY = this._gravityY;
            var bodies = this.liveDynamics;
            var limit = bodies.length;
            var i;
            for (i = 0; i < limit; i += 1) {
                var body = bodies[i];
                var data = body._data;
                var imass = data[0];
                var drag;
                if (imass !== 0) {
                    data[7] += (data[10] * imass + gravityX) * deltaTime;
                    data[7 + 1] += (data[10 + 1] * imass + gravityY) * deltaTime;
                    drag = Math.exp(deltaTime * data[21]);
                    data[7] *= drag;
                    data[7 + 1] *= drag
                }
                var iinertia = data[1];
                if (iinertia !== 0) {
                    data[7 + 2] += data[10 + 2] * iinertia * deltaTime;
                    data[7 + 2] *= Math.exp(deltaTime * data[22])
                }
            }
        };
        Physics2DWorld.prototype._integratePosition = function(deltaTime) {
            this._integratePositionBodies(this.liveDynamics, deltaTime);
            this._integratePositionBodies(this.liveKinematics, deltaTime)
        };
        Physics2DWorld.prototype._integratePositionBodies = function(bodies, deltaTime) {
            var MAX_VEL = 2 * Math.PI / deltaTime;
            var idt2 = 1 / (deltaTime * deltaTime);
            var linThreshold = Physics2DConfig.MIN_LINEAR_STATIC_SWEEP;
            var angThreshold = Physics2DConfig.MIN_ANGULAR_STATIC_SWEEP;
            linThreshold *= linThreshold * idt2;
            angThreshold *= angThreshold * idt2;
            var bulletLinThreshold = Physics2DConfig.MIN_LINEAR_BULLET_SWEEP;
            var bulletAngThreshold = Physics2DConfig.MIN_ANGULAR_BULLET_SWEEP;
            bulletLinThreshold *= bulletLinThreshold * idt2;
            bulletAngThreshold *= bulletAngThreshold * idt2;
            var bphase = this.broadphase;
            var limit = bodies.length;
            var i;
            for (i = 0; i < limit; i += 1) {
                var body = bodies[i];
                var data = body._data;
                var preX = data[15] = data[2];
                var preY = data[15 + 1] = data[2 + 1];
                data[15 + 2] = data[2 + 2];
                var curX = data[2] += data[7] * deltaTime;
                var curY = data[2 + 1] += data[7 + 1] * deltaTime;
                var angVel = data[7 + 2];
                body._deltaRotation(angVel * deltaTime);
                data[18] = deltaTime;
                var vx = data[7];
                var vy = data[7 + 1];
                var vw = data[20] = angVel % MAX_VEL;
                var rad = data[19];
                var lin = linThreshold * rad * rad;
                var vmag = vx * vx + vy * vy;
                if (vmag > lin || vw * vw > angThreshold) {
                    var minX = preX < curX ? preX : curX;
                    var minY = preY < curY ? preY : curY;
                    var maxX = preX < curX ? curX : preX;
                    var maxY = preY < curY ? curY : preY;
                    var shapes = body.shapes;
                    var limit2 = shapes.length;
                    var j;
                    for (j = 0; j < limit2; j += 1) {
                        var shape = shapes[j];
                        var sdata = shape._data;
                        rad = sdata[4];
                        sdata[0] = minX - rad;
                        sdata[0 + 1] = minY - rad;
                        sdata[0 + 2] = maxX + rad;
                        sdata[0 + 3] = maxY + rad;
                        bphase.update(shape._bphaseHandle, sdata)
                    }
                    body._sweepFrozen = false;
                    if (body._type === 0) {
                        body._bullet = body.bullet && (vmag > bulletLinThreshold * rad * rad || vw * vw > bulletAngThreshold)
                    }
                } else {
                    body._sweepFrozen = true;
                    body._bullet = false
                }
            }
        };
        Physics2DWorld.prototype._finalize = function() {
            this._finalizeBodies(this.liveDynamics);
            this._finalizeBodies(this.liveKinematics);
            this._finalizeArbiters(this.dynamicArbiters);
            this._finalizeArbiters(this.staticArbiters)
        };
        Physics2DWorld.prototype._finalizeArbiters = function(arbiters) {
            var limit = arbiters.length;
            var i;
            for (i = 0; i < limit; i += 1) {
                var arb = arbiters[i];
                if (arb.active && !arb.sensor) {
                    arb._refreshContactData()
                }
            }
        };
        Physics2DWorld.prototype._finalizeBodies = function(bodies) {
            var bphase = this.broadphase;
            var limit = bodies.length;
            var i;
            for (i = 0; i < limit;) {
                var body = bodies[i];
                var data = body._data;
                var shapes = body.shapes;
                var limit2 = shapes.length;
                var j, shape;
                if (data[15] !== data[2] || data[15 + 1] !== data[2 + 1] || data[15 + 2] !== data[2 + 2]) {
                    body._invalidated = true
                } else if (body._type === 1) {
                    limit -= 1;
                    bodies[i] = bodies[limit];
                    bodies.pop();
                    body.sleeping = true;
                    for (j = 0; j < limit2; j += 1) {
                        shape = shapes[j];
                        bphase.update(shape._bphaseHandle, shape._data, true)
                    }
                    continue
                }
                i += 1
            }
        };
        Physics2DWorld.prototype._doCallbacks = function() {
            var callbacks = this._callbacks;
            var i;
            var stack = [callbacks.length - 1, 0];
            do {
                var left = stack.pop();
                var right = stack.pop();
                if (left > right) {
                    continue
                }
                var pivot = left + right >> 1;
                var pivotValue = callbacks[pivot];
                var index = left;
                var pIndex = pivotValue.index;
                var pTime = pivotValue.time;
                callbacks[pivot] = callbacks[right];
                callbacks[right] = pivotValue;
                for (i = left; i < right; i += 1) {
                    var cur = callbacks[i];
                    if (cur.time < pTime || cur.time === pTime && cur.index < pIndex) {
                        callbacks[i] = callbacks[index];
                        callbacks[index] = cur;
                        index += 1
                    }
                }
                callbacks[right] = callbacks[index];
                callbacks[index] = pivotValue;
                if (index + 1 < right) {
                    stack.push(right);
                    stack.push(index + 1)
                }
                if (left < index - 1) {
                    stack.push(index - 1);
                    stack.push(left)
                }
            } while (stack.length > 0);
            var limit = callbacks.length;
            for (i = 0; i < limit; i += 1) {
                var cb = callbacks[i];
                if (cb.arbiter) {
                    var arb = cb.arbiter;
                    var sa = arb.shapeA;
                    var sb = arb.shapeB;
                    var thisShape = cb.thisObject;
                    cb.callback.call(thisShape, arb, thisShape === sa ? sb : sa)
                } else {
                    cb.callback.call(cb.thisObject)
                }
                Physics2DCallback.deallocate(cb)
            }
            callbacks.length = 0
        };
        Physics2DWorld.prototype._warmStart = function() {
            var constraints = this.liveConstraints;
            var limit = constraints.length;
            var i;
            for (i = 0; i < limit; i += 1) {
                constraints[i]._warmStart()
            }
            this._warmStartArbiters(this.dynamicArbiters);
            this._warmStartArbiters(this.staticArbiters)
        };
        Physics2DWorld.prototype._warmStartArbiters = function(arbiters) {
            var limit = arbiters.length;
            var i;
            for (i = 0; i < limit; i += 1) {
                var arb = arbiters[i];
                if (arb.active && !arb.sensor && (arb._state & 1) !== 0) {
                    arb._warmStart()
                }
            }
        };
        Physics2DWorld.prototype._forceSleepBody = function(body) {
            if (body.sleeping || body._type !== 0) {
                return
            }
            body.sleeping = true;
            var bodies = this.liveDynamics;
            var index = bodies.indexOf(body);
            bodies[index] = bodies[bodies.length - 1];
            bodies.pop();
            var shapes = body.shapes;
            var limit = shapes.length;
            var i;
            var bphase = this.broadphase;
            for (i = 0; i < limit; i += 1) {
                var shape = shapes[i];
                bphase.update(shape._bphaseHandle, shape._data, true);
                var arbiters = shape.arbiters;
                var limit2 = arbiters.length;
                var j;
                for (j = 0; j < limit2; j += 1) {
                    var arb = arbiters[j];
                    if (arb._retired || arb.sleeping) {
                        continue
                    }
                    arb.sleeping = true;
                    arb._sleepStamp = this.timeStamp;
                    var arbs;
                    if (arb._static) {
                        arbs = this.staticArbiters
                    } else {
                        arbs = this.dynamicArbiters
                    }
                    index = arbs.indexOf(arb);
                    arbs[index] = arbs[arbs.length - 1];
                    arbs.pop()
                }
            }
        };
        Physics2DWorld.prototype._forceSleepConstraint = function(constraint) {
            if (constraint.sleeping) {
                return
            }
            constraint.sleeping = true;
            if (constraint._active) {
                var constraints = this.liveConstraints;
                var index = constraints.indexOf(constraint);
                constraints[index] = constraints[constraints.length - 1];
                constraints.pop()
            }
        };
        Physics2DWorld.prototype._wakeConstraint = function(constraint, noCallback) {
            if (constraint.world !== this) {
                return
            }
            if (constraint._active) {
                constraint._wakeTime = this.timeStamp + (this._midStep ? 0 : 1);
                if (constraint.sleeping) {
                    if (!constraint._island) {
                        constraint.sleeping = false;
                        this.liveConstraints.push(constraint);
                        constraint._wakeConnected();
                        if (!noCallback) {
                            this._onWakeCallbacks(constraint)
                        }
                    } else {
                        this._wakeIsland(constraint._island, noCallback ? constraint : null)
                    }
                }
            }
        };
        Physics2DWorld.prototype._wakeBody = function(body, noCallback, continuousCallbacks) {
            if (body.world !== this) {
                return
            }
            body._wakeTime = this.timeStamp + (this._midStep ? 0 : 1);
            if (body.sleeping) {
                if (!body._island) {
                    var bphase = this.broadphase;
                    if (body._type === 0) {
                        body.sleeping = false;
                        this.liveDynamics.push(body)
                    } else if (body._type === 1) {
                        body.sleeping = false;
                        this.liveKinematics.push(body)
                    }
                    var constraints = body.constraints;
                    var limit = constraints.length;
                    var i;
                    for (i = 0; i < limit; i += 1) {
                        this._wakeConstraint(constraints[i])
                    }
                    var isStatic = body._type === 2;
                    var shapes = body.shapes;
                    limit = shapes.length;
                    for (i = 0; i < limit; i += 1) {
                        var shape = shapes[i];
                        this._wakeArbiters(shape.arbiters, false, continuousCallbacks);
                        if (!isStatic) {
                            bphase.update(shape._bphaseHandle, shape._data, false)
                        }
                    }
                    if (!noCallback && body._type === 0) {
                        this._onWakeCallbacks(body)
                    }
                } else {
                    this._wakeIsland(body._island, noCallback ? body : null, continuousCallbacks)
                }
            }
        };
        Physics2DWorld.prototype._wakeArbiter = function(arb, continuousCallbacks) {
            arb.sleeping = false;
            var timeStamp = this.timeStamp + (this._midStep ? 0 : 1);
            var tDelta = timeStamp - arb._sleepStamp;
            arb._updateStamp += tDelta;
            var contacts = arb.contacts;
            var limit2 = contacts.length;
            var j;
            for (j = 0; j < limit2; j += 1) {
                contacts[j]._timeStamp += tDelta
            }
            if (arb._static) {
                this.staticArbiters.push(arb)
            } else {
                this.dynamicArbiters.push(arb)
            }
            if (continuousCallbacks) {
                this._continuousArbiterPrepare(arb, this._deltaTime, true)
            }
        };
        Physics2DWorld.prototype._continuousArbiterPrepare = function(arb, deltaTime, progressEvents) {
            this._preStepArbiter(arb, deltaTime, progressEvents);
            if (arb.active && !arb.sensor && (arb._state & 1) !== 0) {
                arb._iterateVelocity()
            }
        };
        Physics2DWorld.prototype._wakeArbiters = function(arbiters, skip, continuousCallbacks) {
            var limit = arbiters.length;
            var i;
            var timeStamp = this.timeStamp + (this._midStep ? 0 : 1);
            for (i = 0; i < limit; i += 1) {
                var arb = arbiters[i];
                if (arb._retired) {
                    continue
                }
                if (arb.sleeping) {
                    this._wakeArbiter(arb, continuousCallbacks)
                }
                if (!skip) {
                    if (arb._updateStamp === timeStamp && !arb.sensor && (arb._state & 1) !== 0) {
                        var b1 = arb.bodyA;
                        var b2 = arb.bodyB;
                        if (b1._type === 0 && b1.sleeping) {
                            this._wakeBody(b1, false, continuousCallbacks)
                        }
                        if (b2._type === 0 && b2.sleeping) {
                            this._wakeBody(b2, false, continuousCallbacks)
                        }
                    }
                }
            }
        };
        Physics2DWorld.prototype._wakeIsland = function(island, noCallbackObject, continuousCallbacks) {
            var bphase = this.broadphase;
            var bodies = this.liveDynamics;
            var constraints = this.liveConstraints;
            var timeStamp = this.timeStamp + (this._midStep ? 0 : 1);
            var components = island.components;
            var limit = components.length;
            while (limit > 0) {
                limit -= 1;
                var c = components.pop();
                c._wakeTime = timeStamp;
                c._island = null;
                c._islandRoot = c;
                c._islandRank = 0;
                c.sleeping = false;
                if (c._isBody) {
                    bodies.push(c);
                    var shapes = c.shapes;
                    var limit2 = shapes.length;
                    var i;
                    for (i = 0; i < limit2; i += 1) {
                        var shape = shapes[i];
                        this._wakeArbiters(shape.arbiters, true, continuousCallbacks);
                        bphase.update(shape._bphaseHandle, shape._data, false)
                    }
                } else {
                    constraints.push(c)
                }
                if (noCallbackObject !== c) {
                    this._onWakeCallbacks(c)
                }
            }
            Physics2DIsland.deallocate(island)
        };
        Physics2DWorld.prototype._transmitBodyType = function(body, newType) {
            this._wakeBody(body);
            var bodies;
            if (body._type === 0) {
                bodies = this.liveDynamics
            } else if (body._type === 1) {
                bodies = this.liveKinematics
            }
            var index;
            if (bodies) {
                index = bodies.indexOf(body);
                bodies[index] = bodies[bodies.length - 1];
                bodies.pop()
            }
            body._type = newType;
            var staticBody = newType === 2;
            if (staticBody) {
                body._update()
            }
            if (newType === 0) {
                body._islandRoot = body;
                body._islandRank = 0
            }
            var bphase = this.broadphase;
            var shapes = body.shapes;
            var limit = shapes.length;
            var i;
            for (i = 0; i < limit; i += 1) {
                var shape = shapes[i];
                if (staticBody) {
                    bphase.update(shape._bphaseHandle, shape._data, true)
                }
                var arbiters = shape.arbiters;
                var limit2 = arbiters.length;
                var j;
                for (j = 0; j < limit2;) {
                    var arb = arbiters[j];
                    if (arb._retired) {
                        j += 1;
                        continue
                    }
                    var bothStaticType = arb.bodyA._type !== 0 && arb.bodyB._type !== 0;
                    var atleastOneKinematic = arb.bodyA._type === 1 || arb.bodyB._type === 1;
                    if (bothStaticType && !(atleastOneKinematic && arb.sensor)) {
                        limit2 -= 1;
                        arbiters[j] = arbiters[limit2];
                        arbiters.pop();
                        arb._lazyRetire(shape);
                        this._pushInteractionEvents(3, arb);
                        continue
                    }
                    var staticType = arb.bodyA._type !== 0 || arb.bodyB._type !== 0;
                    if (staticType !== arb._static) {
                        var arbs = arb._static ? this.staticArbiters : this.dynamicArbiters;
                        index = arbs.indexOf(arb);
                        arbs[index] = arbs[arbs.length - 1];
                        arbs.pop();
                        arb._static = staticType;
                        arbs = staticType ? this.staticArbiters : this.dynamicArbiters;
                        arbs.push(arb)
                    }
                    j += 1
                }
            }
            body.sleeping = true;
            this._wakeBody(body)
        };
        Physics2DWorld.prototype._validate = function() {
            this._validateBodies(this.liveDynamics);
            this._validateBodies(this.liveKinematics);
            var constraints = this.liveConstraints;
            var i;
            var limit = constraints.length;
            for (i = 0; i < limit; i += 1) {
                var con = constraints[i];
                if (con._woken && con._onWake.length > 0) {
                    this._pushCallbacks(con, con._onWake)
                }
                con._woken = false
            }
        };
        Physics2DWorld.prototype._validateBodies = function(bodies) {
            var bphase = this.broadphase;
            var i;
            var limit = bodies.length;
            for (i = 0; i < limit; i += 1) {
                var body = bodies[i];
                var data = body._data;
                var rot = data[2 + 2];
                data[5] = Math.cos(rot);
                data[5 + 1] = Math.sin(rot);
                body._update();
                if (body._type === 0 && body._woken && body._onWake.length > 0) {
                    this._pushCallbacks(body, body._onWake)
                }
                body._woken = false;
                var shapes = body.shapes;
                var limit2 = shapes.length;
                var j;
                for (j = 0; j < limit2; j += 1) {
                    var shape = shapes[j];
                    bphase.update(shape._bphaseHandle, shape._data)
                }
            }
        };
        Physics2DWorld.create = function(params) {
            var w = new Physics2DWorld;
            w.simulatedTime = 0;
            w.rigidBodies = [];
            w.constraints = [];
            w.liveDynamics = [];
            w.liveKinematics = [];
            w.liveConstraints = [];
            w.dynamicArbiters = [];
            w.staticArbiters = [];
            w._islands = [];
            w._toiEvents = [];
            w._deferredWake = [];
            w._eventTime = -1;
            w._callbacks = [];
            w.broadphase = params.broadphase || Physics2DBoxTreeBroadphase.create();
            w.velocityIterations = params.velocityIterations || 8;
            w.positionIterations = params.positionIterations || 8;
            w._midStep = false;
            w.timeStamp = 0;
            var gravity = params.gravity;
            w._gravityX = gravity ? gravity[0] : 0;
            w._gravityY = gravity ? gravity[1] : 10;
            w._collisions = Physics2DCollisionUtils.create();
            w._sampleRectangle = new Physics2DDevice.prototype.floatArray(4);
            var shapeSampler = function shapeSamplerFn(lambda) {
                return {
                    store: null,
                    count: 0,
                    collisions: w._collisions,
                    sample: function(handle, bounds) {
                        var shape = handle.data;
                        if (lambda.call(this, shape, bounds)) {
                            this.store[this.count] = shape;
                            this.count += 1
                        }
                    }
                }
            };
            var bodySampler = function bodySamplerFn(lambda) {
                return {
                    store: null,
                    count: 0,
                    collisions: w._collisions,
                    sample: function(handle, bounds) {
                        var shape = handle.data;
                        if (lambda.call(this, shape, bounds)) {
                            var found = false;
                            var body = shape.body;
                            var i;
                            var limit = this.count;
                            var bodies = this.store;
                            for (i = 0; i < limit; i += 1) {
                                if (bodies[i] === body) {
                                    found = true;
                                    break
                                }
                            }
                            if (!found) {
                                bodies[limit] = body;
                                this.count += 1
                            }
                        }
                    }
                }
            };
            var pointSampler = function pointSamplerFn(shape, point) {
                return this.collisions._contains(shape, point[0], point[1])
            };
            w._shapePointCallback = shapeSampler(pointSampler);
            w._bodyPointCallback = bodySampler(pointSampler);
            var rectangleSampler = function rectangleSamplerFn(shape, unusedSampleBox) {
                return this.collisions._test(shape, this.rectangleShape)
            };
            w._shapeRectangleCallback = shapeSampler(rectangleSampler);
            w._bodyRectangleCallback = bodySampler(rectangleSampler);
            w._rectangleQueryVertices = [new Physics2DDevice.prototype.floatArray(2), new Physics2DDevice.prototype.floatArray(2), new Physics2DDevice.prototype.floatArray(2), new Physics2DDevice.prototype.floatArray(2)];
            w._rectangleQueryShape = Physics2DPolygon.create({
                vertices: w._rectangleQueryVertices
            });
            w._shapeRectangleCallback.rectangleShape = w._rectangleQueryShape;
            w._bodyRectangleCallback.rectangleShape = w._rectangleQueryShape;
            var circleSampler = function circleSamplerFn(shape, unusedSampleBox) {
                return this.collisions._test(shape, this.circleShape)
            };
            w._shapeCircleCallback = shapeSampler(circleSampler);
            w._bodyCircleCallback = bodySampler(circleSampler);
            w._circleQueryShape = Physics2DCircle.create({
                radius: 1
            });
            w._shapeCircleCallback.circleShape = w._circleQueryShape;
            w._bodyCircleCallback.circleShape = w._circleQueryShape;
            var tempCastResult = {
                shape: null,
                hitPoint: new Physics2DDevice.prototype.floatArray(2),
                hitNormal: new Physics2DDevice.prototype.floatArray(2),
                factor: 0
            };
            w._rayCast = {
                minNormal: new Physics2DDevice.prototype.floatArray(2),
                minShape: null,
                minFactor: 0,
                userCallback: null,
                userThis: null,
                ray: null,
                noInner: false,
                normal: new Physics2DDevice.prototype.floatArray(2),
                sample: function sampleFn(handle, _) {
                    var shape = handle.data;
                    var ray = this.ray;
                    var normal = this.normal;
                    var oldFactor = ray.maxFactor;
                    ray.maxFactor = this.minFactor;
                    var factor = w._collisions.rayTest(shape, ray, normal, this.noInner);
                    ray.maxFactor = oldFactor;
                    if (this.userCallback) {
                        var result = tempCastResult;
                        var vector = result.hitNormal;
                        vector[0] = normal[0];
                        vector[1] = normal[1];
                        vector = result.hitPoint;
                        var origin = ray.origin;
                        var direction = ray.direction;
                        vector[0] = origin[0] + direction[0] * factor;
                        vector[1] = origin[1] + direction[1] * factor;
                        result.factor = factor;
                        result.shape = shape;
                        if (!this.userCallback.call(this.userThis, ray, result)) {
                            return
                        }
                    }
                    if (factor !== undefined) {
                        this.minFactor = factor;
                        this.minShape = shape;
                        var minNormal = this.minNormal;
                        minNormal[0] = normal[0];
                        minNormal[1] = normal[1]
                    }
                }
            };
            w._convexCast = {
                toi: w._collisions._toi,
                minData: new Physics2DDevice.prototype.floatArray(4),
                minShape: null,
                minTOIAlpha: 0,
                userCallback: null,
                userThis: null,
                deltaTime: 0,
                sample: function sampleFn(handle, _) {
                    var toi = this.toi;
                    var shape = handle.data;
                    if (shape === toi.shapeA) {
                        return
                    }
                    toi.shapeB = shape;
                    shape.body._update();
                    var ret = w._collisions._staticSweep(toi, this.minTOIAlpha * this.deltaTime, 0) * this.minTOIAlpha;
                    if (ret <= 0) {
                        return
                    }
                    var tdata = toi._data;
                    if (this.userCallback) {
                        var result = tempCastResult;
                        var vector = result.hitNormal;
                        vector[0] = -tdata[0];
                        vector[1] = -tdata[0 + 1];
                        vector = result.hitPoint;
                        vector[0] = tdata[4];
                        vector[1] = tdata[4 + 1];
                        result.factor = ret * this.deltaTime;
                        result.shape = shape;
                        result.shape = shape;
                        if (!this.userCallback.call(this.userThis, toi.shapeA, result)) {
                            return
                        }
                    }
                    this.minTOIAlpha = ret;
                    var data = this.minData;
                    data[0] = tdata[0];
                    data[1] = tdata[0 + 1];
                    data[2] = tdata[4];
                    data[3] = tdata[4 + 1];
                    this.minShape = shape
                }
            };
            return w
        };
        Physics2DWorld.version = 1;
        return Physics2DWorld
    }();
    var Physics2DCollisionUtils = function() {
        function Physics2DCollisionUtils() {}
        Physics2DCollisionUtils.prototype.containsPoint = function(shape, point) {
            shape.body._update();
            return this._contains(shape, point[0], point[1])
        };
        Physics2DCollisionUtils.prototype.signedDistance = function(shapeA, shapeB, witnessA, witnessB, axis) {
            shapeA.body._update();
            if (shapeB.body !== shapeA.body) {
                shapeB.body._update()
            }
            var data = this._toi._data;
            var ret = this._distance(shapeA, shapeB, data);
            witnessA[0] = data[2];
            witnessA[1] = data[2 + 1];
            witnessB[0] = data[4];
            witnessB[1] = data[4 + 1];
            axis[0] = data[0];
            axis[1] = data[0 + 1];
            return ret
        };
        Physics2DCollisionUtils.prototype.intersects = function(shapeA, shapeB) {
            shapeA.body._update();
            if (shapeB.body !== shapeA.body) {
                shapeB.body._update()
            }
            return this._test(shapeA, shapeB)
        };
        Physics2DCollisionUtils.prototype.rayTest = function(shape, ray, normal, ignoreInnerSurfaces) {
            shape.body._update();
            return this._rayTest(shape, ray, normal, ignoreInnerSurfaces)
        };
        Physics2DCollisionUtils.prototype.sweepTest = function(shapeA, shapeB, deltaTime, point, normal) {
            var toi = this._toi;
            toi.shapeA = shapeA;
            toi.shapeB = shapeB;
            var bodyA = shapeA.body;
            var bodyB = shapeB.body;
            var dataA = bodyA._data;
            var dataB = bodyB._data;
            dataA[18] = 0;
            dataB[18] = 0;
            dataA[20] = dataA[7 + 2];
            dataB[20] = dataB[7 + 2];
            var ret = this._dynamicSweep(toi, deltaTime, 0, true);
            bodyA._sweepIntegrate(0);
            bodyB._sweepIntegrate(0);
            shapeA._update(dataA[2], dataA[2 + 1], dataA[5], dataA[5 + 1]);
            shapeB._update(dataB[2], dataB[2 + 1], dataB[5], dataB[5 + 1]);
            if (ret < 0) {
                return undefined
            }
            var data = toi._data;
            point[0] = .5 * (data[2] + data[4]);
            point[1] = .5 * (data[2 + 1] + data[4 + 1]);
            normal[0] = data[0];
            normal[1] = data[0 + 1];
            return ret * deltaTime
        };
        Physics2DCollisionUtils.prototype._rayTest = function(shape, ray, normal, noInner) {
            if (shape._type === 0) {
                return this._rayTestCircle(shape, ray, normal, noInner)
            } else {
                return this._rayTestPolygon(shape, ray, normal, noInner)
            }
        };
        Physics2DCollisionUtils.prototype._rayTestPolygon = function(poly, ray, normal, noInner) {
            var origin = ray.origin;
            var direction = ray.direction;
            var data = poly._data;
            var ox = origin[0];
            var oy = origin[1];
            var dx = direction[0];
            var dy = direction[1];
            var min = ray.maxFactor;
            var edge, inner;
            var index = 6;
            var limit = data.length;
            for (; index < limit; index += 13) {
                var nx = data[index + 6];
                var ny = data[index + 6 + 1];
                var den = nx * dx + ny * dy;
                if (den >= 0 && noInner || den * den < Physics2DConfig.COLLINEAR_SQ_EPSILON) {
                    continue
                }
                var t = (data[index + 9] - (ox * nx + oy * ny)) / den;
                if (t < 0 || t >= min) {
                    continue
                }
                var hitX = ox + dx * t;
                var hitY = oy + dy * t;
                var dproj = nx * hitY - ny * hitX;
                if (dproj < data[index + 10] || dproj > data[index + 11]) {
                    continue
                }
                min = t;
                edge = index;
                inner = den >= 0
            }
            if (edge === undefined) {
                return undefined
            } else {
                var scale = inner ? -1 : 1;
                normal[0] = data[edge + 6] * scale;
                normal[1] = data[edge + 6 + 1] * scale;
                return min
            }
        };
        Physics2DCollisionUtils.prototype._rayTestCircle = function(circle, ray, normal, noInner) {
            var origin = ray.origin;
            var direction = ray.direction;
            var data = circle._data;
            var ox = origin[0];
            var oy = origin[1];
            var dx = direction[0];
            var dy = direction[1];
            var cx = data[9];
            var cy = data[9 + 1];
            var radius = data[6];
            var ocX = ox - cx;
            var ocY = oy - cy;
            var a = dx * dx + dy * dy;
            var b = 2 * (ocX * dx + ocY * dy);
            var c = ocX * ocX + ocY * ocY - radius * radius;
            var determinant = b * b - 4 * a * c;
            if (determinant < 0) {
                return undefined
            }
            var normalScale = 1;
            var rec = 1 / (2 * a);
            var rootD = Math.sqrt(determinant);
            var distance = (-b - rootD) * rec;
            if (distance < 0) {
                if (noInner) {
                    return undefined
                }
                distance += rootD * 2 * rec;
                normalScale = -1
            }
            if (0 <= distance && distance < ray.maxFactor) {
                var hitX = ox + dx * distance - cx;
                var hitY = oy + dy * distance - cy;
                var scale = normalScale / radius;
                normal[0] = hitX * scale;
                normal[1] = hitY * scale;
                return distance
            } else {
                return undefined
            }
        };
        Physics2DCollisionUtils.prototype._contains = function(shape, x, y) {
            if (shape._type === 0) {
                return this._containsCircle(shape, x, y)
            } else {
                return this._containsPolygon(shape, x, y)
            }
        };
        Physics2DCollisionUtils.prototype._containsCircle = function(circle, x, y) {
            var data = circle._data;
            var dx = data[9] - x;
            var dy = data[9 + 1] - y;
            var rad = data[6];
            return dx * dx + dy * dy - rad * rad <= Physics2DConfig.CONTAINS_SQ_EPSILON
        };
        Physics2DCollisionUtils.prototype._containsPolygon = function(poly, x, y) {
            var data = poly._data;
            var index = 6;
            var limit = data.length;
            var EPS = Physics2DConfig.CONTAINS_EPSILON;
            for (; index < limit; index += 13) {
                var proj = data[index + 6] * x + data[index + 6 + 1] * y - data[index + 9];
                if (proj > EPS) {
                    return false
                }
            }
            return true
        };
        Physics2DCollisionUtils.prototype._dynamicSweep = function(toi, timeStep, negRadius, slowSweep) {
            var s1 = toi.shapeA;
            var s2 = toi.shapeB;
            var b1 = s1.body;
            var b2 = s2.body;
            var data1 = b1._data;
            var data2 = b2._data;
            var deltaX = data2[7] - data1[7];
            var deltaY = data2[7 + 1] - data1[7 + 1];
            var ang1 = data1[20];
            var ang2 = data2[20];
            var angBias = s1._data[5] * (ang1 < 0 ? -ang1 : ang1) + s2._data[5] * (ang2 < 0 ? -ang2 : ang2);
            if (!slowSweep) {
                if (deltaX * deltaX + deltaY * deltaY < Physics2DConfig.EQUAL_SQ_VEL && angBias < Physics2DConfig.ZERO_ANG_BIAS) {
                    toi._data[6] = undefined;
                    toi.failed = true;
                    return
                }
            }
            var curTOIAlpha = 0;
            var curIter = 0;
            var toiData = toi._data;
            var LIMIT = Physics2DConfig.SWEEP_LIMIT;
            var HALF_LIMIT = LIMIT * .5;
            var MIN_ADVANCE = Physics2DConfig.MINIMUM_SWEEP_ADVANCE;
            var MAX_ITER = Physics2DConfig.MAX_SWEEP_ITER;
            while (true) {
                b1._sweepIntegrate(curTOIAlpha * timeStep);
                b2._sweepIntegrate(curTOIAlpha * timeStep);
                var posX = data1[2];
                var posY = data1[2 + 1];
                s1._update(posX, posY, data1[5], data1[5 + 1], true);
                posX = data2[2];
                posY = data2[2 + 1];
                s2._update(posX, posY, data2[5], data2[5 + 1], true);
                var sep = this._distance(s1, s2, toiData) + negRadius;
                var axisX = toiData[0];
                var axisY = toiData[0 + 1];
                var dot = axisX * deltaX + axisY * deltaY;
                if (sep < LIMIT) {
                    if (slowSweep) {
                        break
                    } else {
                        var d1X = toiData[2] - posX;
                        var d1Y = toiData[2 + 1] - posY;
                        var proj = dot - ang1 * (d1X * axisY - d1Y * axisX);
                        if (proj > 0) {
                            toi.slipped = true
                        }
                        if (proj <= 0 || sep < HALF_LIMIT) {
                            break
                        }
                    }
                }
                var denom = (angBias - dot) * timeStep;
                if (denom <= 0) {
                    curTOIAlpha = -1;
                    break
                }
                var delta = sep / denom;
                if (delta < MIN_ADVANCE) {
                    delta = MIN_ADVANCE
                }
                curTOIAlpha += delta;
                if (curTOIAlpha >= 1) {
                    curTOIAlpha = -1;
                    break
                }
                curIter += 1;
                if (curIter >= MAX_ITER) {
                    if (sep > negRadius) {
                        toi.failed = true
                    } else if (slowSweep) {
                        curTOIAlpha = -1
                    }
                    break
                }
            }
            toiData[6] = curTOIAlpha;
            return curTOIAlpha
        };
        Physics2DCollisionUtils.prototype._staticSweep = function(toi, timeStep, negRadius) {
            var s1 = toi.shapeA;
            var s2 = toi.shapeB;
            var b1 = s1.body;
            var data1 = b1._data;
            var deltaX = -data1[7];
            var deltaY = -data1[7 + 1];
            var ang1 = data1[20];
            var angBias = s1._data[5] * (ang1 < 0 ? -ang1 : ang1);
            var curTOIAlpha = 0;
            var curIter = 0;
            var toiData = toi._data;
            var LIMIT = Physics2DConfig.SWEEP_LIMIT;
            var HALF_LIMIT = LIMIT * .5;
            var MIN_ADVANCE = Physics2DConfig.MINIMUM_SWEEP_ADVANCE;
            var MAX_ITER = Physics2DConfig.MAX_SWEEP_ITER;
            while (true) {
                b1._sweepIntegrate(curTOIAlpha * timeStep);
                var posX = data1[2];
                var posY = data1[2 + 1];
                s1._update(posX, posY, data1[5], data1[5 + 1], true);
                var sep = this._distance(s1, s2, toiData) + negRadius;
                var axisX = toiData[0];
                var axisY = toiData[0 + 1];
                var dot = axisX * deltaX + axisY * deltaY;
                if (sep < LIMIT) {
                    var d1X = toiData[2] - posX;
                    var d1Y = toiData[2 + 1] - posY;
                    var proj = dot - ang1 * (d1X * axisY - d1Y * axisX);
                    if (proj > 0) {
                        toi.slipped = true
                    }
                    if (proj <= 0 || sep < HALF_LIMIT) {
                        break
                    }
                }
                var denom = (angBias - dot) * timeStep;
                if (denom <= 0) {
                    curTOIAlpha = -1;
                    break
                }
                var delta = sep / denom;
                if (delta < MIN_ADVANCE) {
                    delta = MIN_ADVANCE
                }
                curTOIAlpha += delta;
                if (curTOIAlpha >= 1) {
                    curTOIAlpha = -1;
                    break
                }
                curIter += 1;
                if (curIter >= MAX_ITER) {
                    if (sep > negRadius) {
                        toi.failed = true
                    }
                    break
                }
            }
            toiData[6] = curTOIAlpha;
            return curTOIAlpha
        };
        Physics2DCollisionUtils.prototype._distance = function(shapeA, shapeB, toiData) {
            if (shapeA._type === 0) {
                if (shapeB._type === 0) {
                    return this._distanceCircle2Circle(shapeA, shapeB, toiData)
                } else {
                    return this._distanceCircle2Polygon(shapeA, shapeB, toiData)
                }
            } else {
                if (shapeB._type === 0) {
                    var ret = this._distanceCircle2Polygon(shapeB, shapeA, toiData);
                    toiData[0] = -toiData[0];
                    toiData[0 + 1] = -toiData[0 + 1];
                    var tmp = toiData[2];
                    toiData[2] = toiData[4];
                    toiData[4] = tmp;
                    tmp = toiData[2 + 1];
                    toiData[2 + 1] = toiData[4 + 1];
                    toiData[4 + 1] = tmp;
                    return ret
                } else {
                    return this._distancePolygon2Polygon(shapeA, shapeB, toiData)
                }
            }
        };
        Physics2DCollisionUtils.prototype._distanceCircle2Circle = function(circleA, circleB, toiData) {
            var dataA = circleA._data;
            var dataB = circleB._data;
            var cAX = dataA[9];
            var cAY = dataA[9 + 1];
            var cBX = dataB[9];
            var cBY = dataB[9 + 1];
            var radA = dataA[6];
            var radB = dataB[6];
            var dx = cBX - cAX;
            var dy = cBY - cAY;
            var rSum = radA + radB;
            var len = Math.sqrt(dx * dx + dy * dy);
            if (len === 0) {
                toiData[0] = dx = 1;
                toiData[0 + 1] = dy = 0
            } else {
                var rec = 1 / len;
                toiData[0] = dx *= rec;
                toiData[0 + 1] = dy *= rec
            }
            toiData[2] = cAX + dx * radA;
            toiData[2 + 1] = cAY + dy * radA;
            toiData[4] = cBX - dx * radB;
            toiData[4 + 1] = cBY - dy * radB;
            return len - rSum
        };
        Physics2DCollisionUtils.prototype._distanceCircle2Polygon = function(circle, polygon, toiData) {
            var dataC = circle._data;
            var dataP = polygon._data;
            var cx = dataC[9];
            var cy = dataC[9 + 1];
            var radius = dataC[6];
            var max = Number.NEGATIVE_INFINITY;
            var edge, proj;
            var index = 6;
            var limit = dataP.length;
            for (; index < limit; index += 13) {
                proj = dataP[index + 6] * cx + dataP[index + 6 + 1] * cy;
                var dist = proj - (radius + dataP[index + 9]);
                if (dist > max) {
                    max = dist;
                    edge = index
                }
            }
            var nx = dataP[edge + 6];
            var ny = dataP[edge + 6 + 1];
            proj = nx * cy - ny * cx;
            if (proj >= dataP[edge + 10]) {
                if (proj <= dataP[edge + 11]) {
                    toiData[0] = -nx;
                    toiData[0 + 1] = -ny;
                    toiData[2] = cx -= nx * radius;
                    toiData[2 + 1] = cy -= ny * radius;
                    toiData[4] = cx - nx * max;
                    toiData[4 + 1] = cy - ny * max;
                    return max
                } else {
                    edge += 13;
                    if (edge === limit) {
                        edge = 6
                    }
                }
            }
            var vX = dataP[edge + 2];
            var vY = dataP[edge + 2 + 1];
            var dx = vX - cx;
            var dy = vY - cy;
            var len = Math.sqrt(dx * dx + dy * dy);
            if (len === 0) {
                toiData[0] = dx = -nx;
                toiData[0 + 1] = dy = -ny
            } else {
                var rec = 1 / len;
                toiData[0] = dx *= rec;
                toiData[0 + 1] = dy *= rec
            }
            toiData[2] = cx + dx * radius;
            toiData[2 + 1] = cy + dy * radius;
            toiData[4] = vX;
            toiData[4 + 1] = vY;
            return len - radius
        };
        Physics2DCollisionUtils.prototype._distancePolygon2Polygon = function(polyA, polyB, toiData) {
            var inf = Number.POSITIVE_INFINITY;
            var dataA = polyA._data;
            var dataB = polyB._data;
            var limitA = dataA.length;
            var limitB = dataB.length;
            var i, j;
            var min, k, nx, ny;
            var max = -inf;
            var first, edge;
            for (i = 6; i < limitA; i += 13) {
                min = inf;
                nx = dataA[i + 6];
                ny = dataA[i + 6 + 1];
                for (j = 6; j < limitB; j += 13) {
                    k = nx * dataB[j + 2] + ny * dataB[j + 2 + 1];
                    if (k < min) {
                        min = k
                    }
                }
                min -= dataA[i + 9];
                if (min > max) {
                    max = min;
                    edge = i;
                    first = true
                }
            }
            for (j = 6; j < limitB; j += 13) {
                min = inf;
                nx = dataB[j + 6];
                ny = dataB[j + 6 + 1];
                for (i = 6; i < limitA; i += 13) {
                    k = nx * dataA[i + 2] + ny * dataA[i + 2 + 1];
                    if (k < min) {
                        min = k
                    }
                }
                min -= dataB[j + 9];
                if (min > max) {
                    max = min;
                    edge = j;
                    first = false
                }
            }
            var flip = first ? 1 : -1;
            var indA, indB;
            if (!first) {
                dataA = polyB._data;
                dataB = polyA._data;
                limitA = dataA.length;
                limitB = dataB.length;
                indA = 4;
                indB = 2
            } else {
                indA = 2;
                indB = 4
            }
            nx = dataA[edge + 6];
            ny = dataA[edge + 6 + 1];
            min = inf;
            var witness;
            for (j = 6; j < limitB; j += 13) {
                k = nx * dataB[j + 6] + ny * dataB[j + 6 + 1];
                if (k < min) {
                    min = k;
                    witness = j
                }
            }
            var next = witness + 13;
            if (next === limitB) {
                next = 6
            }
            var kX, kY;
            var k1, k2;
            var x3, y3;
            var x4, y4;
            var dL;
            var x1 = dataB[witness + 2];
            var y1 = dataB[witness + 2 + 1];
            var x2 = dataB[next + 2];
            var y2 = dataB[next + 2 + 1];
            var parallel = min < Physics2DConfig.COLLINEAR_EPSILON - 1;
            if (max < 0 && parallel) {
                toiData[0] = nx * flip;
                toiData[0 + 1] = ny * flip;
                kX = dataA[edge + 2];
                kY = dataA[edge + 2 + 1];
                dL = dataA[edge + 12];
                k1 = nx * (y1 - kY) - ny * (x1 - kX);
                if (k1 >= 0 && k1 <= dL) {
                    toiData[indB] = kX = x1;
                    toiData[indB + 1] = kY = y1
                } else {
                    k2 = nx * (y2 - kY) - ny * (x1 - kX);
                    if (k2 >= 0 && k2 <= dL) {
                        toiData[indB] = kX = x2;
                        toiData[indB + 1] = kY = y2
                    } else {
                        if (k1 < 0) {
                            k1 = -k1
                        } else if (k1 > dL) {
                            k1 = dL - k1
                        }
                        toiData[indB] = kX = x1 - ny * k1;
                        toiData[indB + 1] = kY = y1 + nx * k1
                    }
                }
                toiData[indA] = kX - nx * max;
                toiData[indA + 1] = kY - ny * max;
                return max
            } else {
                if (max <= 0) {
                    toiData[0] = nx * flip;
                    toiData[0 + 1] = ny * flip;
                    k1 = nx * x1 + ny * y1;
                    k2 = nx * x2 + ny * y2;
                    if (k2 < k1) {
                        witness = next
                    }
                    toiData[indB] = kX = dataB[witness + 2];
                    toiData[indB + 1] = kY = dataB[witness + 2 + 1];
                    toiData[indA] = kX - nx * max;
                    toiData[indA + 1] = kY - ny * max;
                    return max
                } else {
                    dL = dataA[edge + 12];
                    if (parallel) {
                        var dL2 = dataB[witness + 12];
                        if (dL2 > dL) {
                            dL = dL2;
                            next = edge;
                            edge = witness;
                            witness = next;
                            next = witness + 13;
                            if (next === limitA) {
                                next = 6
                            }
                            x1 = dataA[witness + 2];
                            y1 = dataA[witness + 2 + 1];
                            x2 = dataA[next + 2];
                            y2 = dataA[next + 2 + 1];
                            dataA = dataB;
                            nx *= -1;
                            ny *= -1;
                            flip *= -1;
                            var tmp = indA;
                            indA = indB;
                            indB = tmp
                        }
                    }
                    kX = dataA[edge + 2];
                    kY = dataA[edge + 2 + 1];
                    k1 = -(nx * (kY - y1) - ny * (kX - x1));
                    var in1 = true;
                    if (k1 < 0) {
                        k1 = 0;
                        in1 = false
                    } else if (k1 > dL) {
                        k1 = dL;
                        in1 = false
                    }
                    k2 = -(nx * (kY - y2) - ny * (kX - x2));
                    var in2 = true;
                    if (k2 < 0) {
                        k2 = 0;
                        in2 = false
                    } else if (k2 > dL) {
                        k2 = dL;
                        in2 = false
                    }
                    x3 = x1 - (kX - ny * k1);
                    y3 = y1 - (kY + nx * k1);
                    x4 = x2 - (kX - ny * k2);
                    y4 = y2 - (kY + nx * k2);
                    k1 = x3 * x3 + y3 * y3;
                    k2 = x4 * x4 + y4 * y4;
                    var rec;
                    if (k1 < k2) {
                        toiData[indB] = kX = x1;
                        toiData[indB + 1] = kY = y1;
                        max = Math.sqrt(k1);
                        if (in1 || max < Physics2DConfig.NORMALIZE_EPSILON) {
                            toiData[0] = nx *= flip;
                            toiData[0 + 1] = ny *= flip
                        } else {
                            rec = flip / max;
                            toiData[0] = nx = x3 * rec;
                            toiData[0 + 1] = ny = y3 * rec
                        }
                    } else {
                        toiData[indB] = kX = x2;
                        toiData[indB + 1] = kY = y2;
                        max = Math.sqrt(k2);
                        if (in2 || max < Physics2DConfig.NORMALIZE_EPSILON) {
                            toiData[0] = nx *= flip;
                            toiData[0 + 1] = ny *= flip
                        } else {
                            rec = flip / max;
                            toiData[0] = nx = x4 * rec;
                            toiData[0 + 1] = ny = y4 * rec
                        }
                    }
                    toiData[indA] = kX - nx * max * flip;
                    toiData[indA + 1] = kY - ny * max * flip;
                    return max
                }
            }
        };
        Physics2DCollisionUtils.prototype._collide = function(shapeA, shapeB, arb) {
            if (shapeA._type === 0) {
                if (shapeB._type === 0) {
                    return this._collideCircle2Circle(shapeA, shapeB, arb)
                } else {
                    return this._collideCircle2Polygon(shapeA, shapeB, arb, false)
                }
            } else {
                if (shapeB._type === 0) {
                    return this._collideCircle2Polygon(shapeB, shapeA, arb, true)
                } else {
                    return this._collidePolygon2Polygon(shapeA, shapeB, arb)
                }
            }
        };
        Physics2DCollisionUtils.prototype._collideCircle2Polygon = function(circle, polygon, arb, reverse) {
            var dataC = circle._data;
            var dataP = polygon._data;
            var cx = dataC[9];
            var cy = dataC[9 + 1];
            var radius = dataC[6];
            var max = Number.NEGATIVE_INFINITY;
            var edge, proj;
            var index = 6;
            var limit = dataP.length;
            for (; index < limit; index += 13) {
                proj = dataP[index + 6] * cx + dataP[index + 6 + 1] * cy - (dataP[index + 9] + radius);
                if (proj > 0) {
                    return false
                }
                if (proj > max) {
                    max = proj;
                    edge = index
                }
            }
            var adata = arb._data;
            var con, cdata;
            var nx = dataP[edge + 6];
            var ny = dataP[edge + 6 + 1];
            var vX, vY, lvX, lvY;
            var dx, dy;
            proj = nx * cy - ny * cx;
            if (proj >= dataP[edge + 10]) {
                if (proj <= dataP[edge + 11]) {
                    proj = radius + max * .5;
                    dx = nx * proj;
                    dy = ny * proj;
                    con = arb._injectContact(cx - dx, cy - dy, reverse ? nx : -nx, reverse ? ny : -ny, max, 0);
                    arb._faceType = reverse ? 1 : 2;
                    arb._reverse = !reverse;
                    adata[11] = dataP[edge + 4];
                    adata[11 + 1] = dataP[edge + 4 + 1];
                    adata[13] = dataP[edge + 8];
                    adata[14] = radius;
                    cdata = con._data;
                    cdata[13] = dataC[7];
                    cdata[13 + 1] = dataC[7 + 1];
                    return true
                } else {
                    var next = edge + 13;
                    if (next === limit) {
                        next = 6
                    }
                    vX = dataP[next + 2];
                    vY = dataP[next + 2 + 1];
                    lvX = dataP[next + 0];
                    lvY = dataP[next + 0 + 1]
                }
            } else {
                vX = dataP[edge + 2];
                vY = dataP[edge + 2 + 1];
                lvX = dataP[edge + 0];
                lvY = dataP[edge + 0 + 1]
            }
            dx = cx - vX;
            dy = cy - vY;
            var dsq = dx * dx + dy * dy;
            if (dsq > radius * radius) {
                return false
            }
            if (dsq < Physics2DConfig.NORMALIZE_SQ_EPSILON) {
                con = arb._injectContact(cx, cy, reverse ? nx : -nx, reverse ? ny : -ny, 0, 0)
            } else {
                var dist = Math.sqrt(dsq);
                var invDist = 1 / dist;
                var df = .5 + radius * invDist * .5;
                if (!reverse) {
                    invDist = -invDist
                }
                con = arb._injectContact(cx - dx * df, cy - dy * df, dx * invDist, dy * invDist, dist - radius, 0)
            }
            cdata = con._data;
            if (reverse) {
                cdata[13] = lvX;
                cdata[13 + 1] = lvY;
                cdata[15] = dataC[7];
                cdata[15 + 1] = dataC[7 + 1]
            } else {
                cdata[13] = dataC[7];
                cdata[13 + 1] = dataC[7 + 1];
                cdata[15] = lvX;
                cdata[15 + 1] = lvY
            }
            adata[14] = radius;
            arb._faceType = 0;
            arb._reverse = false;
            return true
        };
        Physics2DCollisionUtils.prototype._collidePolygon2Polygon = function(polyA, polyB, arb) {
            var inf = Number.POSITIVE_INFINITY;
            var dataA = polyA._data;
            var dataB = polyB._data;
            var limitA = dataA.length;
            var limitB = dataB.length;
            var i, j;
            var min, k, nx, ny;
            var max = -inf;
            var first, edge, proj;
            for (i = 6; i < limitA; i += 13) {
                min = inf;
                nx = dataA[i + 6];
                ny = dataA[i + 6 + 1];
                proj = dataA[i + 9];
                for (j = 6; j < limitB; j += 13) {
                    k = nx * dataB[j + 2] + ny * dataB[j + 2 + 1];
                    if (k < min) {
                        min = k
                    }
                    if (min - proj <= max) {
                        break
                    }
                }
                min -= proj;
                if (min >= 0) {
                    return false
                }
                if (min > max) {
                    max = min;
                    edge = i;
                    first = true
                }
            }
            for (j = 6; j < limitB; j += 13) {
                min = inf;
                nx = dataB[j + 6];
                ny = dataB[j + 6 + 1];
                proj = dataB[j + 9];
                for (i = 6; i < limitA; i += 13) {
                    k = nx * dataA[i + 2] + ny * dataA[i + 2 + 1];
                    if (k < min) {
                        min = k
                    }
                    if (min - proj <= max) {
                        break
                    }
                }
                min -= proj;
                if (min >= 0) {
                    return false
                }
                if (min > max) {
                    max = min;
                    edge = j;
                    first = false
                }
            }
            var flip = first ? 1 : -1;
            var bdata;
            if (!first) {
                dataA = polyB._data;
                dataB = polyA._data;
                limitA = dataA.length;
                limitB = dataB.length;
                bdata = polyA.body._data
            } else {
                bdata = polyB.body._data
            }
            nx = dataA[edge + 6];
            ny = dataA[edge + 6 + 1];
            min = inf;
            var witness;
            for (j = 6; j < limitB; j += 13) {
                k = nx * dataB[j + 6] + ny * dataB[j + 6 + 1];
                if (k < min) {
                    min = k;
                    witness = j
                }
            }
            var next = witness + 13;
            if (next === limitB) {
                next = 6
            }
            var c1X = dataB[witness + 2];
            var c1Y = dataB[witness + 2 + 1];
            var c2X = dataB[next + 2];
            var c2Y = dataB[next + 2 + 1];
            var dvX = c2X - c1X;
            var dvY = c2Y - c1Y;
            var d1 = c1X * ny - c1Y * nx;
            var d2 = c2X * ny - c2Y * nx;
            var den = 1 / (d2 - d1);
            var t = (-dataA[edge + 11] - d1) * den;
            if (t > Physics2DConfig.CLIP_EPSILON) {
                c1X += dvX * t;
                c1Y += dvY * t
            }
            t = (-dataA[edge + 10] - d2) * den;
            if (t < -Physics2DConfig.CLIP_EPSILON) {
                c2X += dvX * t;
                c2Y += dvY * t
            }
            var adata = arb._data;
            adata[11] = dataA[edge + 4];
            adata[11 + 1] = dataA[edge + 4 + 1];
            adata[13] = dataA[edge + 8];
            adata[14] = 0;
            arb._faceType = first ? 1 : 2;
            proj = dataA[edge + 9];
            var c1d = c1X * nx + c1Y * ny - proj;
            var c2d = c2X * nx + c2Y * ny - proj;
            var p1x = bdata[2];
            var p1y = bdata[2 + 1];
            var cos = bdata[5];
            var sin = bdata[5 + 1];
            if (c1d > 0 && c2d > 0) {
                return false
            }
            var rx = c1X - p1x;
            var ry = c1Y - p1y;
            c1X -= nx * c1d * .5;
            c1Y -= ny * c1d * .5;
            var con = arb._injectContact(c1X, c1Y, nx * flip, ny * flip, c1d, first ? 1 : 2, c1d > 0)._data;
            con[13] = cos * rx + sin * ry;
            con[13 + 1] = cos * ry - sin * rx;
            rx = c2X - p1x;
            ry = c2Y - p1y;
            c2X -= nx * c2d * .5;
            c2Y -= ny * c2d * .5;
            con = arb._injectContact(c2X, c2Y, nx * flip, ny * flip, c2d, first ? 2 : 1, c2d > 0)._data;
            con[13] = cos * rx + sin * ry;
            con[13 + 1] = cos * ry - sin * rx;
            arb._reverse = !first;
            return true
        };
        Physics2DCollisionUtils.prototype._collideCircle2Circle = function(circleA, circleB, arb) {
            var dataA = circleA._data;
            var dataB = circleB._data;
            var x1 = dataA[9];
            var y1 = dataA[9 + 1];
            var r1 = dataA[6];
            var dx = dataB[9] - x1;
            var dy = dataB[9 + 1] - y1;
            var rSum = r1 + dataB[6];
            var dsq = dx * dx + dy * dy;
            if (dsq > rSum * rSum) {
                return false
            }
            var con;
            if (dsq < Physics2DConfig.NORMALIZE_SQ_EPSILON) {
                con = arb._injectContact(x1 + dx * .5, y1 + dy * .5, 1, 0, -rSum, 0)
            } else {
                var dist = Math.sqrt(dsq);
                var invDist = 1 / dist;
                var df = .5 + (r1 - .5 * rSum) * invDist;
                con = arb._injectContact(x1 + dx * df, y1 + dy * df, dx * invDist, dy * invDist, dist - rSum, 0)
            }
            var data = con._data;
            data[13] = dataA[7];
            data[13 + 1] = dataA[7 + 1];
            data[15] = dataB[7];
            data[15 + 1] = dataB[7 + 1];
            data = arb._data;
            data[14] = rSum;
            arb._faceType = 0;
            return true
        };
        Physics2DCollisionUtils.prototype._test = function(shapeA, shapeB) {
            if (shapeA._type === 0) {
                if (shapeB._type === 0) {
                    return this._testCircle2Circle(shapeA, shapeB)
                } else {
                    return this._testCircle2Polygon(shapeA, shapeB)
                }
            } else {
                if (shapeB._type === 0) {
                    return this._testCircle2Polygon(shapeB, shapeA)
                } else {
                    return this._testPolygon2Polygon(shapeA, shapeB)
                }
            }
        };
        Physics2DCollisionUtils.prototype._testCircle2Circle = function(circleA, circleB) {
            var dataA = circleA._data;
            var dataB = circleB._data;
            var dx = dataA[9] - dataB[9];
            var dy = dataA[9 + 1] - dataB[9 + 1];
            var rSum = dataA[6] + dataB[6];
            return dx * dx + dy * dy <= rSum * rSum
        };
        Physics2DCollisionUtils.prototype._testCircle2Polygon = function(circle, polygon) {
            var dataC = circle._data;
            var dataP = polygon._data;
            var cx = dataC[9];
            var cy = dataC[9 + 1];
            var radius = dataC[6];
            var max = Number.NEGATIVE_INFINITY;
            var edge, proj;
            var index = 6;
            var limit = dataP.length;
            for (; index < limit; index += 13) {
                proj = dataP[index + 6] * cx + dataP[index + 6 + 1] * cy;
                var dist = proj - (radius + dataP[index + 9]);
                if (dist > 0) {
                    return false
                }
                if (dist > max) {
                    max = dist;
                    edge = index
                }
            }
            proj = dataP[edge + 6] * cy - dataP[edge + 6 + 1] * cx;
            if (proj >= dataP[edge + 10]) {
                if (proj <= dataP[edge + 11]) {
                    return true
                } else {
                    edge += 13;
                    if (edge === limit) {
                        edge = 6
                    }
                }
            }
            var dx = cx - dataP[edge + 2];
            var dy = cy - dataP[edge + 2 + 1];
            return dx * dx + dy * dy <= radius * radius
        };
        Physics2DCollisionUtils.prototype._testPolygon2Polygon = function(polyA, polyB) {
            var inf = Number.POSITIVE_INFINITY;
            var dataA = polyA._data;
            var dataB = polyB._data;
            var limitA = dataA.length;
            var limitB = dataB.length;
            var i, j;
            var min, proj, nx, ny;
            for (i = 6; i < limitA; i += 13) {
                min = inf;
                nx = dataA[i + 6];
                ny = dataA[i + 6 + 1];
                for (j = 6; j < limitB; j += 13) {
                    proj = nx * dataB[j + 2] + ny * dataB[j + 2 + 1];
                    if (proj < min) {
                        min = proj
                    }
                }
                if (min > dataA[i + 9]) {
                    return false
                }
            }
            for (j = 6; j < limitB; j += 13) {
                min = inf;
                nx = dataB[j + 6];
                ny = dataB[j + 6 + 1];
                for (i = 6; i < limitA; i += 13) {
                    proj = nx * dataA[i + 2] + ny * dataA[i + 2 + 1];
                    if (proj < min) {
                        min = proj
                    }
                }
                if (min > dataB[j + 9]) {
                    return false
                }
            }
            return true
        };
        Physics2DCollisionUtils.create = function() {
            var c = new Physics2DCollisionUtils;
            c._toi = Physics2DTOIEvent.allocate();
            return c
        };
        return Physics2DCollisionUtils
    }();
    var Physics2DDevice = function() {
        function Physics2DDevice() {
            this.vendor = "Turbulenz"
        }
        Physics2DDevice.prototype.getDefaultMaterial = function() {
            return Physics2DMaterial.defaultMaterial
        };
        Physics2DDevice.prototype.createCircleShape = function(params) {
            return Physics2DCircle.create(params)
        };
        Physics2DDevice.prototype.createPolygonShape = function(params) {
            return Physics2DPolygon.create(params, null)
        };
        Physics2DDevice.prototype.createRigidBody = function(params) {
            return Physics2DRigidBody.create(params)
        };
        Physics2DDevice.prototype.createWorld = function(params) {
            return Physics2DWorld.create(params)
        };
        Physics2DDevice.prototype.createMaterial = function(params) {
            return Physics2DMaterial.create(params)
        };
        Physics2DDevice.prototype.createSweepAndPruneBroadphase = function() {
            return Physics2DSweepAndPrune.create()
        };
        Physics2DDevice.prototype.createBoxTreeBroadphase = function() {
            return Physics2DBoxTreeBroadphase.create()
        };
        Physics2DDevice.prototype.createCollisionUtils = function() {
            return Physics2DCollisionUtils.create()
        };
        Physics2DDevice.prototype.createPointConstraint = function(params) {
            return Physics2DPointConstraint.create(params)
        };
        Physics2DDevice.prototype.createWeldConstraint = function(params) {
            return Physics2DWeldConstraint.create(params)
        };
        Physics2DDevice.prototype.createAngleConstraint = function(params) {
            return Physics2DAngleConstraint.create(params)
        };
        Physics2DDevice.prototype.createDistanceConstraint = function(params) {
            return Physics2DDistanceConstraint.create(params)
        };
        Physics2DDevice.prototype.createLineConstraint = function(params) {
            return Physics2DLineConstraint.create(params)
        };
        Physics2DDevice.prototype.createMotorConstraint = function(params) {
            return Physics2DMotorConstraint.create(params)
        };
        Physics2DDevice.prototype.createPulleyConstraint = function(params) {
            return Physics2DPulleyConstraint.create(params)
        };
        Physics2DDevice.prototype.createCustomConstraint = function(params) {
            return Physics2DCustomConstraint.create(params)
        };
        Physics2DDevice.prototype.createRectangleVertices = function(minX, minY, maxX, maxY) {
            var tmp;
            if (maxX < minX) {
                tmp = minX;
                minX = maxX;
                maxX = tmp
            }
            if (maxY < minY) {
                tmp = minY;
                minY = maxY;
                maxY = tmp
            }
            var v0 = new Physics2DDevice.prototype.floatArray(2);
            v0[0] = minX;
            v0[1] = minY;
            var v1 = new Physics2DDevice.prototype.floatArray(2);
            v1[0] = maxX;
            v1[1] = minY;
            var v2 = new Physics2DDevice.prototype.floatArray(2);
            v2[0] = maxX;
            v2[1] = maxY;
            var v3 = new Physics2DDevice.prototype.floatArray(2);
            v3[0] = minX;
            v3[1] = maxY;
            return [v0, v1, v2, v3]
        };
        Physics2DDevice.prototype.createBoxVertices = function(width, height) {
            var w = width * .5;
            var h = height * .5;
            var v0 = new Physics2DDevice.prototype.floatArray(2);
            v0[0] = -w;
            v0[1] = -h;
            var v1 = new Physics2DDevice.prototype.floatArray(2);
            v1[0] = w;
            v1[1] = -h;
            var v2 = new Physics2DDevice.prototype.floatArray(2);
            v2[0] = w;
            v2[1] = h;
            var v3 = new Physics2DDevice.prototype.floatArray(2);
            v3[0] = -w;
            v3[1] = h;
            return [v0, v1, v2, v3]
        };
        Physics2DDevice.prototype.createRegularPolygonVertices = function(diameterX, diameterY, numVertices) {
            var rX = diameterX * .5;
            var rY = diameterY * .5;
            var vertices = [];
            var num = numVertices;
            var angInc = Math.PI * 2 / num;
            var i;
            for (i = 0; i < num; i += 1) {
                var ang = angInc * i;
                var vec = vertices[vertices.length] = new Physics2DDevice.prototype.floatArray(2);
                vec[0] = rX * Math.cos(ang);
                vec[1] = rY * Math.sin(ang)
            }
            return vertices
        };
        Physics2DDevice.create = function() {
            var pd = new Physics2DDevice;
            return pd
        };
        Physics2DDevice.version = 1;
        return Physics2DDevice
    }();
    (function() {
        Physics2DDevice.prototype.floatArray = function(arg) {
            if (arguments.length === 0) {
                return []
            }
            var i, ret;
            if (typeof arg === "number") {
                ret = new Array(arg)
            } else {
                ret = [];
                for (i = 0; i < arg.length; i += 1) {
                    ret[i] = arg[i]
                }
            }
            return ret
        };
        Physics2DDevice.prototype.uint16Array = Physics2DDevice.prototype.floatArray;
        var testArray, textDescriptor;
        if (typeof Float32Array !== "undefined") {
            testArray = new Float32Array(4);
            textDescriptor = Object.prototype.toString.call(testArray);
            if (textDescriptor === "[object Float32Array]") {
                Physics2DDevice.prototype.floatArray = Float32Array
            }
        }
        if (typeof Uint16Array !== "undefined") {
            testArray = new Uint16Array(4);
            textDescriptor = Object.prototype.toString.call(testArray);
            if (textDescriptor === "[object Uint16Array]") {
                Physics2DDevice.prototype.uint16Array = Uint16Array
            }
        }
    })();
    Physics2DMaterial.defaultMaterial = Physics2DMaterial.create();
    var BoxTreeNode = function() {
        function BoxTreeNode(extents, escapeNodeOffset, externalNode) {
            this.escapeNodeOffset = escapeNodeOffset;
            this.externalNode = externalNode;
            this.extents = extents
        }
        BoxTreeNode.prototype.isLeaf = function() {
            return !!this.externalNode
        };
        BoxTreeNode.prototype.reset = function(minX, minY, maxX, maxY, escapeNodeOffset, externalNode) {
            this.escapeNodeOffset = escapeNodeOffset;
            this.externalNode = externalNode;
            var oldExtents = this.extents;
            oldExtents[0] = minX;
            oldExtents[1] = minY;
            oldExtents[2] = maxX;
            oldExtents[3] = maxY
        };
        BoxTreeNode.prototype.clear = function() {
            this.escapeNodeOffset = 1;
            this.externalNode = undefined;
            var oldExtents = this.extents;
            var maxNumber = Number.MAX_VALUE;
            oldExtents[0] = maxNumber;
            oldExtents[1] = maxNumber;
            oldExtents[2] = -maxNumber;
            oldExtents[3] = -maxNumber
        };
        BoxTreeNode.create = function(extents, escapeNodeOffset, externalNode) {
            return new BoxTreeNode(extents, escapeNodeOffset, externalNode)
        };
        BoxTreeNode.version = 1;
        return BoxTreeNode
    }();
    var BoxTree = function() {
        function BoxTree(highQuality) {
            this.numNodesLeaf = 4;
            this.nodes = [];
            this.endNode = 0;
            this.needsRebuild = false;
            this.needsRebound = false;
            this.numAdds = 0;
            this.numUpdates = 0;
            this.numExternalNodes = 0;
            this.startUpdate = 2147483647;
            this.endUpdate = -2147483647;
            this.highQuality = highQuality
        }
        BoxTree.prototype.add = function(externalNode, extents) {
            var endNode = this.endNode;
            externalNode.boxTreeIndex = endNode;
            var copyExtents = new this.arrayConstructor(4);
            copyExtents[0] = extents[0];
            copyExtents[1] = extents[1];
            copyExtents[2] = extents[2];
            copyExtents[3] = extents[3];
            this.nodes[endNode] = BoxTreeNode.create(copyExtents, 1, externalNode);
            this.endNode = endNode + 1;
            this.needsRebuild = true;
            this.numAdds += 1;
            this.numExternalNodes += 1
        };
        BoxTree.prototype.remove = function(externalNode) {
            var index = externalNode.boxTreeIndex;
            if (index !== undefined) {
                if (this.numExternalNodes > 1) {
                    var nodes = this.nodes;
                    nodes[index].clear();
                    var endNode = this.endNode;
                    if (index + 1 >= endNode) {
                        while (!nodes[endNode - 1].externalNode) {
                            endNode -= 1
                        }
                        this.endNode = endNode
                    } else {
                        this.needsRebuild = true
                    }
                    this.numExternalNodes -= 1
                } else {
                    this.clear()
                }
                externalNode.boxTreeIndex = undefined
            }
        };
        BoxTree.prototype.findParent = function(nodeIndex) {
            var nodes = this.nodes;
            var parentIndex = nodeIndex;
            var nodeDist = 0;
            var parent;
            do {
                parentIndex -= 1;
                nodeDist += 1;
                parent = nodes[parentIndex]
            } while (parent.escapeNodeOffset <= nodeDist);
            return parent
        };
        BoxTree.prototype.update = function(externalNode, extents) {
            var index = externalNode.boxTreeIndex;
            if (index !== undefined) {
                var min0 = extents[0];
                var min1 = extents[1];
                var max0 = extents[2];
                var max1 = extents[3];
                var needsRebuild = this.needsRebuild;
                var needsRebound = this.needsRebound;
                var nodes = this.nodes;
                var node = nodes[index];
                var nodeExtents = node.extents;
                var doUpdate = needsRebuild || needsRebound || nodeExtents[0] > min0 || nodeExtents[1] > min1 || nodeExtents[2] < max0 || nodeExtents[3] < max1;
                nodeExtents[0] = min0;
                nodeExtents[1] = min1;
                nodeExtents[2] = max0;
                nodeExtents[3] = max1;
                if (doUpdate) {
                    if (!needsRebuild && 1 < nodes.length) {
                        this.numUpdates += 1;
                        if (this.startUpdate > index) {
                            this.startUpdate = index
                        }
                        if (this.endUpdate < index) {
                            this.endUpdate = index
                        }
                        if (!needsRebound) {
                            if (2 * this.numUpdates > this.numExternalNodes) {
                                this.needsRebound = true
                            } else {
                                var parent = this.findParent(index);
                                var parentExtents = parent.extents;
                                if (parentExtents[0] > min0 || parentExtents[1] > min1 || parentExtents[2] < max0 || parentExtents[3] < max1) {
                                    this.needsRebound = true
                                }
                            }
                        } else {
                            if (this.numUpdates > 3 * this.numExternalNodes) {
                                this.needsRebuild = true;
                                this.numAdds = this.numUpdates
                            }
                        }
                    }
                }
            } else {
                this.add(externalNode, extents)
            }
        };
        BoxTree.prototype.needsFinalize = function() {
            return this.needsRebuild || this.needsRebound
        };
        BoxTree.prototype.finalize = function() {
            if (this.needsRebuild) {
                this.rebuild()
            } else if (this.needsRebound) {
                this.rebound()
            }
        };
        BoxTree.prototype.rebound = function() {
            var nodes = this.nodes;
            if (nodes.length > 1) {
                var startUpdateNodeIndex = this.startUpdate;
                var endUpdateNodeIndex = this.endUpdate;
                var nodesStack = [];
                var numNodesStack = 0;
                var topNodeIndex = 0;
                for (;;) {
                    var topNode = nodes[topNodeIndex];
                    var currentNodeIndex = topNodeIndex;
                    var currentEscapeNodeIndex = topNodeIndex + topNode.escapeNodeOffset;
                    var nodeIndex = topNodeIndex + 1;
                    var node;
                    do {
                        node = nodes[nodeIndex];
                        var escapeNodeIndex = nodeIndex + node.escapeNodeOffset;
                        if (nodeIndex < endUpdateNodeIndex) {
                            if (!node.externalNode) {
                                if (escapeNodeIndex > startUpdateNodeIndex) {
                                    nodesStack[numNodesStack] = topNodeIndex;
                                    numNodesStack += 1;
                                    topNodeIndex = nodeIndex
                                }
                            }
                        } else {
                            break
                        }
                        nodeIndex = escapeNodeIndex
                    } while (nodeIndex < currentEscapeNodeIndex);
                    if (topNodeIndex === currentNodeIndex) {
                        nodeIndex = topNodeIndex + 1;
                        node = nodes[nodeIndex];
                        var extents = node.extents;
                        var minX = extents[0];
                        var minY = extents[1];
                        var maxX = extents[2];
                        var maxY = extents[3];
                        nodeIndex = nodeIndex + node.escapeNodeOffset;
                        while (nodeIndex < currentEscapeNodeIndex) {
                            node = nodes[nodeIndex];
                            extents = node.extents;
                            if (minX > extents[0]) {
                                minX = extents[0]
                            }
                            if (minY > extents[1]) {
                                minY = extents[1]
                            }
                            if (maxX < extents[2]) {
                                maxX = extents[2]
                            }
                            if (maxY < extents[3]) {
                                maxY = extents[3]
                            }
                            nodeIndex = nodeIndex + node.escapeNodeOffset
                        }
                        extents = topNode.extents;
                        extents[0] = minX;
                        extents[1] = minY;
                        extents[2] = maxX;
                        extents[3] = maxY;
                        endUpdateNodeIndex = topNodeIndex;
                        if (0 < numNodesStack) {
                            numNodesStack -= 1;
                            topNodeIndex = nodesStack[numNodesStack]
                        } else {
                            break
                        }
                    }
                }
            }
            this.needsRebuild = false;
            this.needsRebound = false;
            this.numAdds = 0;
            this.startUpdate = 2147483647;
            this.endUpdate = -2147483647
        };
        BoxTree.prototype.rebuild = function() {
            if (this.numExternalNodes > 0) {
                var nodes = this.nodes;
                var buildNodes, numBuildNodes, endNodeIndex;
                if (this.numExternalNodes === nodes.length) {
                    buildNodes = nodes;
                    numBuildNodes = nodes.length;
                    nodes = [];
                    this.nodes = nodes
                } else {
                    buildNodes = [];
                    buildNodes.length = this.numExternalNodes;
                    numBuildNodes = 0;
                    endNodeIndex = this.endNode;
                    for (var n = 0; n < endNodeIndex; n += 1) {
                        var currentNode = nodes[n];
                        if (currentNode.externalNode) {
                            nodes[n] = undefined;
                            buildNodes[numBuildNodes] = currentNode;
                            numBuildNodes += 1
                        }
                    }
                    if (buildNodes.length > numBuildNodes) {
                        buildNodes.length = numBuildNodes
                    }
                }
                if (numBuildNodes > 1) {
                    if (numBuildNodes > this.numNodesLeaf && this.numAdds > 0) {
                        if (this.highQuality) {
                            this.sortNodesHighQuality(buildNodes)
                        } else {
                            this.sortNodes(buildNodes)
                        }
                    }
                    this.recursiveBuild(buildNodes, 0, numBuildNodes, 0);
                    endNodeIndex = nodes[0].escapeNodeOffset;
                    if (nodes.length > endNodeIndex) {
                        nodes.length = endNodeIndex
                    }
                    this.endNode = endNodeIndex
                } else {
                    var rootNode = buildNodes[0];
                    rootNode.externalNode.boxTreeIndex = 0;
                    nodes.length = 1;
                    nodes[0] = rootNode;
                    this.endNode = 1
                }
                buildNodes = null
            }
            this.needsRebuild = false;
            this.needsRebound = false;
            this.numAdds = 0;
            this.numUpdates = 0;
            this.startUpdate = 2147483647;
            this.endUpdate = -2147483647
        };
        BoxTree.prototype.sortNodes = function(nodes) {
            var numNodesLeaf = this.numNodesLeaf;
            var numNodes = nodes.length;
            var getkeyXfn = function getkeyXfnFn(node) {
                var extents = node.extents;
                return extents[0] + extents[2]
            };
            var getkeyYfn = function getkeyYfnFn(node) {
                var extents = node.extents;
                return extents[1] + extents[3]
            };
            var getreversekeyXfn = function getreversekeyXfnFn(node) {
                var extents = node.extents;
                return -(extents[0] + extents[2])
            };
            var getreversekeyYfn = function getreversekeyYfnFn(node) {
                var extents = node.extents;
                return -(extents[1] + extents[3])
            };
            var nthElement = this.nthElement;
            var reverse = false;
            var axis = 0;
            var sortNodesRecursive = function sortNodesRecursiveFn(nodes, startIndex, endIndex) {
                var splitNodeIndex = startIndex + endIndex >> 1;
                if (axis === 0) {
                    if (reverse) {
                        nthElement(nodes, startIndex, splitNodeIndex, endIndex, getreversekeyXfn)
                    } else {
                        nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyXfn)
                    }
                } else {
                    if (reverse) {
                        nthElement(nodes, startIndex, splitNodeIndex, endIndex, getreversekeyYfn)
                    } else {
                        nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyYfn)
                    }
                }
                if (axis === 0) {
                    axis = 2
                } else if (axis === 2) {
                    axis = 1
                } else {
                    axis = 0
                }
                reverse = !reverse;
                if (startIndex + numNodesLeaf < splitNodeIndex) {
                    sortNodesRecursive(nodes, startIndex, splitNodeIndex)
                }
                if (splitNodeIndex + numNodesLeaf < endIndex) {
                    sortNodesRecursive(nodes, splitNodeIndex, endIndex)
                }
            };
            sortNodesRecursive(nodes, 0, numNodes)
        };
        BoxTree.prototype.sortNodesHighQuality = function(nodes) {
            var numNodesLeaf = this.numNodesLeaf;
            var numNodes = nodes.length;
            var getkeyXfn = function getkeyXfnFn(node) {
                var extents = node.extents;
                return extents[0] + extents[2]
            };
            var getkeyYfn = function getkeyYfnFn(node) {
                var extents = node.extents;
                return extents[1] + extents[3]
            };
            var getkeyXYfn = function getkeyXYfnFn(node) {
                var extents = node.extents;
                return extents[0] + extents[1] + extents[2] + extents[3]
            };
            var getkeyYXfn = function getkeyYXfnFn(node) {
                var extents = node.extents;
                return extents[0] - extents[1] + extents[2] - extents[3]
            };
            var getreversekeyXfn = function getreversekeyXfnFn(node) {
                var extents = node.extents;
                return -(extents[0] + extents[2])
            };
            var getreversekeyYfn = function getreversekeyYfnFn(node) {
                var extents = node.extents;
                return -(extents[1] + extents[3])
            };
            var getreversekeyXYfn = function getreversekeyXYfnFn(node) {
                var extents = node.extents;
                return -(extents[0] + extents[1] + extents[2] + extents[3])
            };
            var getreversekeyYXfn = function getreversekeyYXfnFn(node) {
                var extents = node.extents;
                return -(extents[0] - extents[1] + extents[2] - extents[3])
            };
            var nthElement = this.nthElement;
            var calculateSAH = this.calculateSAH;
            var reverse = false;
            var sortNodesHighQualityRecursive = function sortNodesHighQualityRecursiveFn(nodes, startIndex, endIndex) {
                var splitNodeIndex = startIndex + endIndex >> 1;
                nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyXfn);
                var sahX = calculateSAH(nodes, startIndex, splitNodeIndex) + calculateSAH(nodes, splitNodeIndex, endIndex);
                nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyYfn);
                var sahY = calculateSAH(nodes, startIndex, splitNodeIndex) + calculateSAH(nodes, splitNodeIndex, endIndex);
                nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyXYfn);
                var sahXY = calculateSAH(nodes, startIndex, splitNodeIndex) + calculateSAH(nodes, splitNodeIndex, endIndex);
                nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyYXfn);
                var sahYX = calculateSAH(nodes, startIndex, splitNodeIndex) + calculateSAH(nodes, splitNodeIndex, endIndex);
                if (sahX <= sahY && sahX <= sahXY && sahX <= sahYX) {
                    if (reverse) {
                        nthElement(nodes, startIndex, splitNodeIndex, endIndex, getreversekeyXfn)
                    } else {
                        nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyXfn)
                    }
                } else if (sahY <= sahXY && sahY <= sahYX) {
                    if (reverse) {
                        nthElement(nodes, startIndex, splitNodeIndex, endIndex, getreversekeyYfn)
                    } else {
                        nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyYfn)
                    }
                } else if (sahXY <= sahYX) {
                    if (reverse) {
                        nthElement(nodes, startIndex, splitNodeIndex, endIndex, getreversekeyXYfn)
                    } else {
                        nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyXYfn)
                    }
                } else {
                    if (reverse) {
                        nthElement(nodes, startIndex, splitNodeIndex, endIndex, getreversekeyYXfn)
                    } else {
                        nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyYXfn)
                    }
                }
                reverse = !reverse;
                if (startIndex + numNodesLeaf < splitNodeIndex) {
                    sortNodesHighQualityRecursive(nodes, startIndex, splitNodeIndex)
                }
                if (splitNodeIndex + numNodesLeaf < endIndex) {
                    sortNodesHighQualityRecursive(nodes, splitNodeIndex, endIndex)
                }
            };
            sortNodesHighQualityRecursive(nodes, 0, numNodes)
        };
        BoxTree.prototype.calculateSAH = function(buildNodes, startIndex, endIndex) {
            var buildNode, extents, minX, minY, maxX, maxY;
            buildNode = buildNodes[startIndex];
            extents = buildNode.extents;
            minX = extents[0];
            minY = extents[1];
            maxX = extents[2];
            maxY = extents[3];
            for (var n = startIndex + 1; n < endIndex; n += 1) {
                buildNode = buildNodes[n];
                extents = buildNode.extents;
                if (minX > extents[0]) {
                    minX = extents[0]
                }
                if (minY > extents[1]) {
                    minY = extents[1]
                }
                if (maxX < extents[2]) {
                    maxX = extents[2]
                }
                if (maxY < extents[3]) {
                    maxY = extents[3]
                }
            }
            return maxX - minX + (maxY - minY)
        };
        BoxTree.prototype.nthElement = function(nodes, first, nth, last, getkey) {
            function medianFn(a, b, c) {
                if (a < b) {
                    if (b < c) {
                        return b
                    } else if (a < c) {
                        return c
                    } else {
                        return a
                    }
                } else if (a < c) {
                    return a
                } else if (b < c) {
                    return c
                }
                return b
            }

            function insertionSortFn(nodes, first, last, getkey) {
                var sorted = first + 1;
                while (sorted !== last) {
                    var tempNode = nodes[sorted];
                    var tempKey = getkey(tempNode);
                    var next = sorted;
                    var current = sorted - 1;
                    while (next !== first && tempKey < getkey(nodes[current])) {
                        nodes[next] = nodes[current];
                        next -= 1;
                        current -= 1
                    }
                    if (next !== sorted) {
                        nodes[next] = tempNode
                    }
                    sorted += 1
                }
            }
            while (last - first > 8) {
                var midValue = medianFn(getkey(nodes[first]), getkey(nodes[first + (last - first >> 1)]), getkey(nodes[last - 1]));
                var firstPos = first;
                var lastPos = last;
                var midPos;
                for (;; firstPos += 1) {
                    while (getkey(nodes[firstPos]) < midValue) {
                        firstPos += 1
                    }
                    do {
                        lastPos -= 1
                    } while (midValue < getkey(nodes[lastPos]));
                    if (firstPos >= lastPos) {
                        midPos = firstPos;
                        break
                    } else {
                        var temp = nodes[firstPos];
                        nodes[firstPos] = nodes[lastPos];
                        nodes[lastPos] = temp
                    }
                }
                if (midPos <= nth) {
                    first = midPos
                } else {
                    last = midPos
                }
            }
            insertionSortFn(nodes, first, last, getkey)
        };
        BoxTree.prototype.recursiveBuild = function(buildNodes, startIndex, endIndex, lastNodeIndex) {
            var nodes = this.nodes;
            var nodeIndex = lastNodeIndex;
            lastNodeIndex += 1;
            var minX, minY, maxX, maxY, extents;
            var buildNode, lastNode;
            if (startIndex + this.numNodesLeaf >= endIndex) {
                buildNode = buildNodes[startIndex];
                extents = buildNode.extents;
                minX = extents[0];
                minY = extents[1];
                maxX = extents[2];
                maxY = extents[3];
                buildNode.externalNode.boxTreeIndex = lastNodeIndex;
                nodes[lastNodeIndex] = buildNode;
                for (var n = startIndex + 1; n < endIndex; n += 1) {
                    buildNode = buildNodes[n];
                    extents = buildNode.extents;
                    if (minX > extents[0]) {
                        minX = extents[0]
                    }
                    if (minY > extents[1]) {
                        minY = extents[1]
                    }
                    if (maxX < extents[2]) {
                        maxX = extents[2]
                    }
                    if (maxY < extents[3]) {
                        maxY = extents[3]
                    }
                    lastNodeIndex += 1;
                    buildNode.externalNode.boxTreeIndex = lastNodeIndex;
                    nodes[lastNodeIndex] = buildNode
                }
                lastNode = nodes[lastNodeIndex]
            } else {
                var splitPosIndex = startIndex + endIndex >> 1;
                if (startIndex + 1 >= splitPosIndex) {
                    buildNode = buildNodes[startIndex];
                    buildNode.externalNode.boxTreeIndex = lastNodeIndex;
                    nodes[lastNodeIndex] = buildNode
                } else {
                    this.recursiveBuild(buildNodes, startIndex, splitPosIndex, lastNodeIndex)
                }
                lastNode = nodes[lastNodeIndex];
                extents = lastNode.extents;
                minX = extents[0];
                minY = extents[1];
                maxX = extents[2];
                maxY = extents[3];
                lastNodeIndex = lastNodeIndex + lastNode.escapeNodeOffset;
                if (splitPosIndex + 1 >= endIndex) {
                    buildNode = buildNodes[splitPosIndex];
                    buildNode.externalNode.boxTreeIndex = lastNodeIndex;
                    nodes[lastNodeIndex] = buildNode
                } else {
                    this.recursiveBuild(buildNodes, splitPosIndex, endIndex, lastNodeIndex)
                }
                lastNode = nodes[lastNodeIndex];
                extents = lastNode.extents;
                if (minX > extents[0]) {
                    minX = extents[0]
                }
                if (minY > extents[1]) {
                    minY = extents[1]
                }
                if (maxX < extents[2]) {
                    maxX = extents[2]
                }
                if (maxY < extents[3]) {
                    maxY = extents[3]
                }
            }
            var node = nodes[nodeIndex];
            if (node !== undefined) {
                node.reset(minX, minY, maxX, maxY, lastNodeIndex + lastNode.escapeNodeOffset - nodeIndex)
            } else {
                var parentExtents = new this.arrayConstructor(4);
                parentExtents[0] = minX;
                parentExtents[1] = minY;
                parentExtents[2] = maxX;
                parentExtents[3] = maxY;
                nodes[nodeIndex] = BoxTreeNode.create(parentExtents, lastNodeIndex + lastNode.escapeNodeOffset - nodeIndex)
            }
        };
        BoxTree.prototype.getVisibleNodes = function(planes, visibleNodes) {
            if (this.numExternalNodes > 0) {
                var nodes = this.nodes;
                var endNodeIndex = this.endNode;
                var numPlanes = planes.length;
                var numVisibleNodes = visibleNodes.length;
                var node, extents, endChildren;
                var n0, n1, p0, p1;
                var isInside, n, plane, d0, d1;
                var nodeIndex = 0;
                for (;;) {
                    node = nodes[nodeIndex];
                    extents = node.extents;
                    n0 = extents[0];
                    n1 = extents[1];
                    p0 = extents[2];
                    p1 = extents[3];
                    isInside = true;
                    n = 0;
                    do {
                        plane = planes[n];
                        d0 = plane[0];
                        d1 = plane[1];
                        if (d0 * (d0 < 0 ? n0 : p0) + d1 * (d1 < 0 ? n1 : p1) < plane[2]) {
                            isInside = false;
                            break
                        }
                        n += 1
                    } while (n < numPlanes);
                    if (isInside) {
                        if (node.externalNode) {
                            visibleNodes[numVisibleNodes] = node.externalNode;
                            numVisibleNodes += 1;
                            nodeIndex += 1;
                            if (nodeIndex >= endNodeIndex) {
                                break
                            }
                        } else {
                            isInside = true;
                            n = 0;
                            do {
                                plane = planes[n];
                                d0 = plane[0];
                                d1 = plane[1];
                                if (d0 * (d0 > 0 ? n0 : p0) + d1 * (d1 > 0 ? n1 : p1) < plane[2]) {
                                    isInside = false;
                                    break
                                }
                                n += 1
                            } while (n < numPlanes);
                            if (isInside) {
                                endChildren = nodeIndex + node.escapeNodeOffset;
                                nodeIndex += 1;
                                do {
                                    node = nodes[nodeIndex];
                                    if (node.externalNode) {
                                        visibleNodes[numVisibleNodes] = node.externalNode;
                                        numVisibleNodes += 1
                                    }
                                    nodeIndex += 1
                                } while (nodeIndex < endChildren);
                                if (nodeIndex >= endNodeIndex) {
                                    break
                                }
                            } else {
                                nodeIndex += 1
                            }
                        }
                    } else {
                        nodeIndex += node.escapeNodeOffset;
                        if (nodeIndex >= endNodeIndex) {
                            break
                        }
                    }
                }
            }
        };
        BoxTree.prototype.getOverlappingNodes = function(queryExtents, overlappingNodes, startIndex) {
            if (this.numExternalNodes > 0) {
                var queryMinX = queryExtents[0];
                var queryMinY = queryExtents[1];
                var queryMaxX = queryExtents[2];
                var queryMaxY = queryExtents[3];
                var nodes = this.nodes;
                var endNodeIndex = this.endNode;
                var node, extents, endChildren;
                var numOverlappingNodes = 0;
                var storageIndex = startIndex === undefined ? overlappingNodes.length : startIndex;
                var nodeIndex = 0;
                for (;;) {
                    node = nodes[nodeIndex];
                    extents = node.extents;
                    var minX = extents[0];
                    var minY = extents[1];
                    var maxX = extents[2];
                    var maxY = extents[3];
                    if (queryMinX <= maxX && queryMinY <= maxY && queryMaxX >= minX && queryMaxY >= minY) {
                        if (node.externalNode) {
                            overlappingNodes[storageIndex] = node.externalNode;
                            storageIndex += 1;
                            numOverlappingNodes += 1;
                            nodeIndex += 1;
                            if (nodeIndex >= endNodeIndex) {
                                break
                            }
                        } else {
                            if (queryMaxX >= maxX && queryMaxY >= maxY && queryMinX <= minX && queryMinY <= minY) {
                                endChildren = nodeIndex + node.escapeNodeOffset;
                                nodeIndex += 1;
                                do {
                                    node = nodes[nodeIndex];
                                    if (node.externalNode) {
                                        overlappingNodes[storageIndex] = node.externalNode;
                                        storageIndex += 1;
                                        numOverlappingNodes += 1
                                    }
                                    nodeIndex += 1
                                } while (nodeIndex < endChildren);
                                if (nodeIndex >= endNodeIndex) {
                                    break
                                }
                            } else {
                                nodeIndex += 1
                            }
                        }
                    } else {
                        nodeIndex += node.escapeNodeOffset;
                        if (nodeIndex >= endNodeIndex) {
                            break
                        }
                    }
                }
                return numOverlappingNodes
            } else {
                return 0
            }
        };
        BoxTree.prototype.getCircleOverlappingNodes = function(center, radius, overlappingNodes) {
            if (this.numExternalNodes > 0) {
                var radiusSquared = radius * radius;
                var centerX = center[0];
                var centerY = center[1];
                var nodes = this.nodes;
                var endNodeIndex = this.endNode;
                var node, extents;
                var numOverlappingNodes = overlappingNodes.length;
                var nodeIndex = 0;
                for (;;) {
                    node = nodes[nodeIndex];
                    extents = node.extents;
                    var minX = extents[0];
                    var minY = extents[1];
                    var maxX = extents[2];
                    var maxY = extents[3];
                    var totalDistance = 0,
                        sideDistance;
                    if (centerX < minX) {
                        sideDistance = minX - centerX;
                        totalDistance += sideDistance * sideDistance
                    } else if (centerX > maxX) {
                        sideDistance = centerX - maxX;
                        totalDistance += sideDistance * sideDistance
                    }
                    if (centerY < minY) {
                        sideDistance = minY - centerY;
                        totalDistance += sideDistance * sideDistance
                    } else if (centerY > maxY) {
                        sideDistance = centerY - maxY;
                        totalDistance += sideDistance * sideDistance
                    }
                    if (totalDistance <= radiusSquared) {
                        nodeIndex += 1;
                        if (node.externalNode) {
                            overlappingNodes[numOverlappingNodes] = node.externalNode;
                            numOverlappingNodes += 1;
                            if (nodeIndex >= endNodeIndex) {
                                break
                            }
                        }
                    } else {
                        nodeIndex += node.escapeNodeOffset;
                        if (nodeIndex >= endNodeIndex) {
                            break
                        }
                    }
                }
            }
        };
        BoxTree.prototype.getOverlappingPairs = function(overlappingPairs, startIndex) {
            if (this.numExternalNodes > 0) {
                var nodes = this.nodes;
                var endNodeIndex = this.endNode;
                var currentNode, currentExternalNode, node, extents;
                var numInsertions = 0;
                var storageIndex = startIndex === undefined ? overlappingPairs.length : startIndex;
                var currentNodeIndex = 0,
                    nodeIndex;
                for (;;) {
                    currentNode = nodes[currentNodeIndex];
                    while (!currentNode.externalNode) {
                        currentNodeIndex += 1;
                        currentNode = nodes[currentNodeIndex]
                    }
                    currentNodeIndex += 1;
                    if (currentNodeIndex < endNodeIndex) {
                        currentExternalNode = currentNode.externalNode;
                        extents = currentNode.extents;
                        var minX = extents[0];
                        var minY = extents[1];
                        var maxX = extents[2];
                        var maxY = extents[3];
                        nodeIndex = currentNodeIndex;
                        for (;;) {
                            node = nodes[nodeIndex];
                            extents = node.extents;
                            if (minX <= extents[2] && minY <= extents[3] && maxX >= extents[0] && maxY >= extents[1]) {
                                nodeIndex += 1;
                                if (node.externalNode) {
                                    overlappingPairs[storageIndex] = currentExternalNode;
                                    overlappingPairs[storageIndex + 1] = node.externalNode;
                                    storageIndex += 2;
                                    numInsertions += 2;
                                    if (nodeIndex >= endNodeIndex) {
                                        break
                                    }
                                }
                            } else {
                                nodeIndex += node.escapeNodeOffset;
                                if (nodeIndex >= endNodeIndex) {
                                    break
                                }
                            }
                        }
                    } else {
                        break
                    }
                }
                return numInsertions
            } else {
                return 0
            }
        };
        BoxTree.prototype.getRootNode = function() {
            return this.nodes[0]
        };
        BoxTree.prototype.getNodes = function() {
            return this.nodes
        };
        BoxTree.prototype.getEndNodeIndex = function() {
            return this.endNode
        };
        BoxTree.prototype.clear = function() {
            this.nodes = [];
            this.endNode = 0;
            this.needsRebuild = false;
            this.needsRebound = false;
            this.numAdds = 0;
            this.numUpdates = 0;
            this.numExternalNodes = 0;
            this.startUpdate = 2147483647;
            this.endUpdate = -2147483647
        };
        BoxTree.rayTest = function(trees, ray, callback) {
            var origin = ray.origin;
            var direction = ray.direction;
            var o0 = origin[0];
            var o1 = origin[1];
            var d0 = direction[0];
            var d1 = direction[1];
            var id0 = 1 / d0;
            var id1 = 1 / d1;
            var distanceExtents = function distanceExtentsFn(extents, upperBound) {
                var min0 = extents[0];
                var min1 = extents[1];
                var max0 = extents[2];
                var max1 = extents[3];
                if (min0 <= o0 && o0 <= max0 && min1 <= o1 && o1 <= max1) {
                    return 0
                }
                var tmin, tmax;
                var tymin, tymax;
                var del;
                if (d0 >= 0) {
                    del = min0 - o0;
                    tmin = del === 0 ? 0 : del * id0;
                    del = max0 - o0;
                    tmax = del === 0 ? 0 : del * id0
                } else {
                    tmin = (max0 - o0) * id0;
                    tmax = (min0 - o0) * id0
                }
                if (d1 >= 0) {
                    del = min1 - o1;
                    tymin = del === 0 ? 0 : del * id1;
                    del = max1 - o1;
                    tymax = del === 0 ? 0 : del * id1
                } else {
                    tymin = (max1 - o1) * id1;
                    tymax = (min1 - o1) * id1
                }
                if (tmin > tymax || tymin > tmax) {
                    return undefined
                }
                if (tymin > tmin) {
                    tmin = tymin
                }
                if (tymax < tmax) {
                    tmax = tymax
                }
                if (tmin < 0) {
                    tmin = tmax
                }
                return 0 <= tmin && tmin < upperBound ? tmin : undefined
            };
            var priorityList = [];
            var minimumResult = null;
            var processNode = function processNodeFn(tree, nodeIndex, upperBound) {
                var nodes = tree.getNodes();
                var node = nodes[nodeIndex];
                var distance = distanceExtents(node.extents, upperBound);
                if (distance === undefined) {
                    return upperBound
                }
                if (node.externalNode) {
                    var result = callback(tree, node.externalNode, ray, distance, upperBound);
                    if (result) {
                        minimumResult = result;
                        upperBound = result.factor
                    }
                } else {
                    var length = priorityList.length;
                    var i;
                    for (i = 0; i < length; i += 1) {
                        var curObj = priorityList[i];
                        if (distance > curObj.distance) {
                            break
                        }
                    }
                    priorityList.splice(i - 1, 0, {
                        tree: tree,
                        nodeIndex: nodeIndex,
                        distance: distance
                    })
                }
                return upperBound
            };
            var upperBound = ray.maxFactor;
            var tree;
            var i;
            for (i = 0; i < trees.length; i += 1) {
                tree = trees[i];
                if (tree.endNode !== 0) {
                    upperBound = processNode(tree, 0, upperBound)
                }
            }
            while (priorityList.length !== 0) {
                var nodeObj = priorityList.pop();
                if (nodeObj.distance >= upperBound) {
                    continue
                }
                var nodeIndex = nodeObj.nodeIndex;
                tree = nodeObj.tree;
                var nodes = tree.getNodes();
                var node = nodes[nodeIndex];
                var maxIndex = nodeIndex + node.escapeNodeOffset;
                var childIndex = nodeIndex + 1;
                do {
                    upperBound = processNode(tree, childIndex, upperBound);
                    childIndex += nodes[childIndex].escapeNodeOffset
                } while (childIndex < maxIndex)
            }
            return minimumResult
        };
        BoxTree.create = function(highQuality) {
            return new BoxTree(highQuality)
        };
        BoxTree.version = 1;
        return BoxTree
    }();
    (function() {
        BoxTree.prototype.arrayConstructor = Array;
        if (typeof Float32Array !== "undefined") {
            var testArray = new Float32Array(4);
            var textDescriptor = Object.prototype.toString.call(testArray);
            if (textDescriptor === "[object Float32Array]") {
                BoxTree.prototype.arrayConstructor = Float32Array
            }
        }
    })();
    var Physics2DDebugDraw = function() {
        function Physics2DDebugDraw() {}
        Physics2DDebugDraw.prototype.setPhysics2DViewport = function(viewport) {
            if (viewport) {
                var port = this._physics2DPort;
                port[0] = viewport[0];
                port[1] = viewport[1];
                port[2] = viewport[2];
                port[3] = viewport[3];
                this._physics2DPortEnabled = true
            } else {
                this._physics2DPortEnabled = false
            }
            this._invalidated = true
        };
        Physics2DDebugDraw.prototype.setScreenViewport = function(viewport) {
            if (viewport) {
                var port = this._screenPort;
                port[0] = viewport[0];
                port[1] = viewport[1];
                port[2] = viewport[2];
                port[3] = viewport[3];
                this._screenPortEnabled = true
            } else {
                this._screenPortEnabled = false
            }
            this._invalidated = true
        };
        Physics2DDebugDraw.prototype.drawLine = function(x1, y1, x2, y2, color) {
            var numVertices = this._numVertices;
            var vindex = numVertices * 6;
            var iindex = this._numLines * 2;
            this._prepare(2, 1);
            var data = this._vertexData;
            data[vindex] = x1;
            data[vindex + 1] = y1;
            data[vindex + 6] = x2;
            data[vindex + 7] = y2;
            data[vindex + 2] = data[vindex + 8] = color[0];
            data[vindex + 3] = data[vindex + 9] = color[1];
            data[vindex + 4] = data[vindex + 10] = color[2];
            data[vindex + 5] = data[vindex + 11] = color[3];
            data = this._indexData;
            data[iindex] = numVertices;
            data[iindex + 1] = numVertices + 1
        };
        Physics2DDebugDraw.prototype.drawLinearSpring = function(x1, y1, x2, y2, numCoils, radius, color) {
            if (numCoils <= 0) {
                this.drawLine(x1, y1, x2, y2, color);
                return
            }
            var dx = x2 - x1;
            var dy = y2 - y1;
            var lengthSq = dx * dx + dy * dy;
            var min = this.minSpringLength * this.screenToPhysics2D;
            if (lengthSq < min * min) {
                this.drawLine(x1, y1, x2, y2, color);
                return
            }
            var nx = -dy;
            var ny = dx;
            var nlsq = 2 * radius / Math.sqrt(nx * nx + ny * ny);
            nx *= nlsq;
            ny *= nlsq;
            var rec = 1 / (numCoils * 4);
            dx *= rec;
            dy *= rec;
            var i;
            for (i = 0; i < numCoils; i += 1) {
                x2 = x1 + dx * 2;
                y2 = y1 + dy * 2;
                this.drawCurve(x1, y1, x1 + dx + nx, y1 + dy + ny, x2, y2, color);
                x1 = x2;
                y1 = y2;
                x2 = x1 + dx * 2;
                y2 = y1 + dy * 2;
                this.drawCurve(x1, y1, x1 + dx - nx, y1 + dy - ny, x2, y2, color);
                x1 = x2;
                y1 = y2
            }
        };
        Physics2DDebugDraw.prototype._drawAngleIndicator = function(x, y, ang, rad, size, color) {
            var cos = Math.cos(ang);
            var sin = Math.sin(ang);
            this._drawAnchor(x + rad * cos, y + rad * sin, size, color)
        };
        Physics2DDebugDraw.prototype._drawAnchor = function(x, y, rad, color) {
            this.drawCircle(x, y, rad, color);
            this.drawCircle(x, y, rad * .75, color);
            this.drawCircle(x, y, rad * .5, color);
            this.drawCircle(x, y, rad * .25, color)
        };
        Physics2DDebugDraw.prototype.drawSpiral = function(x, y, ang1, ang2, rad1, rad2, color) {
            if (ang1 > ang2) {
                var tmp = ang1;
                ang1 = ang2;
                ang2 = tmp;
                tmp = rad1;
                rad1 = rad2;
                rad2 = tmp
            }
            if (ang1 === ang2) {
                return
            }
            var deltaRadius = rad2 - rad1;
            var deltaAngle = ang2 - ang1;
            var segmentCount = Math.ceil(deltaAngle / this.spiralMaxArc);
            var segmentDeltaRadius = deltaRadius / segmentCount;
            var segmentDeltaAngle = deltaAngle / segmentCount;
            var cosDelta = Math.cos(segmentDeltaAngle);
            var sinDelta = Math.sin(segmentDeltaAngle);
            var radialX = Math.cos(ang1);
            var radialY = Math.sin(ang1);
            var radius = rad1;
            var x1 = x + rad1 * radialX;
            var y1 = y + rad1 * radialY;
            var ux = deltaRadius * radialX - radius * deltaAngle * radialY;
            var uy = deltaRadius * radialY + radius * deltaAngle * radialX;
            var i;
            for (i = 0; i < segmentCount; i += 1) {
                var newRadius = radius + segmentDeltaRadius;
                var newRadialX = cosDelta * radialX - sinDelta * radialY;
                var newRadialY = sinDelta * radialX + cosDelta * radialY;
                var x2 = x + newRadius * newRadialX;
                var y2 = y + newRadius * newRadialY;
                var vx = deltaRadius * newRadialX - newRadius * deltaAngle * newRadialY;
                var vy = deltaRadius * newRadialY + newRadius * deltaAngle * newRadialX;
                var den = ux * vy - uy * vx;
                if (den * den < this.spiralEpsilon) {
                    this.drawLine(x1, y1, x2, y2, color)
                } else {
                    var t = ((x2 - x1) * vy + (y1 - y2) * vx) / den;
                    if (t <= 0) {
                        this.drawLine(x1, y1, x2, y2, color)
                    } else {
                        this.drawCurve(x1, y1, x1 + ux * t, y1 + uy * t, x2, y2, color)
                    }
                }
                radius = newRadius;
                radialX = newRadialX;
                radialY = newRadialY;
                ux = vx;
                uy = vy;
                x1 = x2;
                y1 = y2
            }
        };
        Physics2DDebugDraw.prototype.drawSpiralSpring = function(x, y, ang1, ang2, rad1, rad2, numCoils, color) {
            if (ang1 > ang2) {
                var tmp = ang1;
                ang1 = ang2;
                ang2 = tmp;
                tmp = rad1;
                rad1 = rad2;
                rad2 = tmp
            }
            if (ang1 === ang2) {
                return
            }
            var deltaRadius = rad2 - rad1;
            var deltaAngle = ang2 - ang1;
            var segmentCount = Math.max(Math.ceil(deltaAngle / (this.spiralMaxArc * 3)), 40 * numCoils);
            var segmentDeltaAngle = deltaAngle / segmentCount;
            var segmentDeltaTime = 1 / segmentCount;
            var cosDelta = Math.cos(segmentDeltaAngle);
            var sinDelta = Math.sin(segmentDeltaAngle);
            var spiralSpringSize = this.spiralSpringSize;
            var Delta = Math.abs(2 * Math.PI * deltaRadius / deltaAngle);
            var spiralA = spiralSpringSize * Delta;
            var spiralB = 2 * numCoils * Math.PI;
            var spiralAt = spiralA * spiralB;
            var radialX = Math.cos(ang1);
            var radialY = Math.sin(ang1);
            var radius = rad1;
            var x1 = x + radius * radialX;
            var y1 = y + radius * radialY;
            var gradient = deltaRadius + spiralAt;
            var ux = gradient * radialX - radius * deltaAngle * radialY;
            var uy = gradient * radialY + radius * deltaAngle * radialX;
            var i;
            for (i = 0; i < segmentCount; i += 1) {
                var t = (i + 1) * segmentDeltaTime;
                var newRadialX = cosDelta * radialX - sinDelta * radialY;
                var newRadialY = sinDelta * radialX + cosDelta * radialY;
                radius = rad1 + deltaRadius * t + spiralA * Math.sin(spiralB * t);
                var x2 = x + radius * newRadialX;
                var y2 = y + radius * newRadialY;
                gradient = deltaRadius + spiralAt * Math.cos(spiralB * t);
                var vx = gradient * newRadialX - radius * deltaAngle * newRadialY;
                var vy = gradient * newRadialY + radius * deltaAngle * newRadialX;
                var den = ux * vy - uy * vx;
                var dot = ux * vx + uy * vy;
                if (den * den < this.spiralEpsilon || dot < 0 || dot > 1 - this.spiralEpsilon) {
                    this.drawLine(x1, y1, x2, y2, color)
                } else {
                    t = ((x2 - x1) * vy + (y1 - y2) * vx) / den;
                    if (t <= 0) {
                        this.drawLine(x1, y1, x2, y2, color)
                    } else {
                        this.drawCurve(x1, y1, x1 + ux * t, y1 + uy * t, x2, y2, color)
                    }
                }
                radialX = newRadialX;
                radialY = newRadialY;
                ux = vx;
                uy = vy;
                x1 = x2;
                y1 = y2
            }
        };
        Physics2DDebugDraw.prototype.drawCurve = function(x1, y1, cx, cy, x2, y2, color) {
            var r = color[0];
            var g = color[1];
            var b = color[2];
            var a = color[3];
            var stack = this._curveStack;
            var verts = this._curveVerts;
            stack.push(x1, y1, cx, cy, x2, y2);
            while (stack.length > 0) {
                y2 = stack.pop();
                x2 = stack.pop();
                cy = stack.pop();
                cx = stack.pop();
                y1 = stack.pop();
                x1 = stack.pop();
                var qx = .25 * (x1 + 2 * cx + x2);
                var qy = .25 * (y1 + 2 * cy + y2);
                var lx = .5 * (x1 + x2);
                var ly = .5 * (y1 + y2);
                var dx = qx - lx;
                var dy = qy - ly;
                var err = this.curveMaxError * this.screenToPhysics2D;
                if (dx * dx + dy * dy < err * err) {
                    verts.push(x1, y1)
                } else {
                    var m1x = .5 * (x1 + cx);
                    var m1y = .5 * (y1 + cy);
                    var m2x = .5 * (x2 + cx);
                    var m2y = .5 * (y2 + cy);
                    var mmx = .5 * (m1x + m2x);
                    var mmy = .5 * (m1y + m2y);
                    stack.push(mmx, mmy, m2x, m2y, x2, y2);
                    stack.push(x1, y1, m1x, m1y, mmx, mmy)
                }
            }
            verts.push(x2, y2);
            var vCount = verts.length >> 1;
            var numVertices = this._numVertices;
            var vindex = numVertices * 6;
            var iindex = this._numLines * 2;
            this._prepare(vCount, vCount - 1);
            var vdata = this._vertexData;
            var idata = this._indexData;
            var i, j = 0;
            for (i = 0; i < vCount; i += 1) {
                vdata[vindex] = verts[j];
                vdata[vindex + 1] = verts[j + 1];
                vdata[vindex + 2] = r;
                vdata[vindex + 3] = g;
                vdata[vindex + 4] = b;
                vdata[vindex + 5] = a;
                j += 2;
                vindex += 6;
                if (i > 0) {
                    idata[iindex] = numVertices + i - 1;
                    idata[iindex + 1] = numVertices + i;
                    iindex += 2
                }
            }
            verts.length = 0
        };
        Physics2DDebugDraw.prototype.drawRectangle = function(x1, y1, x2, y2, color) {
            var numVertices = this._numVertices;
            var vindex = numVertices * 6;
            var iindex = this._numLines * 2;
            this._prepare(4, 4);
            var vdata = this._vertexData;
            var idata = this._indexData;
            vdata[vindex] = vdata[vindex + 18] = x1;
            vdata[vindex + 1] = vdata[vindex + 7] = y1;
            vdata[vindex + 6] = vdata[vindex + 12] = x2;
            vdata[vindex + 13] = vdata[vindex + 19] = y2;
            vdata[vindex + 2] = vdata[vindex + 8] = vdata[vindex + 14] = vdata[vindex + 20] = color[0];
            vdata[vindex + 3] = vdata[vindex + 9] = vdata[vindex + 15] = vdata[vindex + 21] = color[1];
            vdata[vindex + 4] = vdata[vindex + 10] = vdata[vindex + 16] = vdata[vindex + 22] = color[2];
            vdata[vindex + 5] = vdata[vindex + 11] = vdata[vindex + 17] = vdata[vindex + 23] = color[3];
            idata[iindex] = idata[iindex + 7] = numVertices;
            idata[iindex + 1] = idata[iindex + 2] = numVertices + 1;
            idata[iindex + 3] = idata[iindex + 4] = numVertices + 2;
            idata[iindex + 5] = idata[iindex + 6] = numVertices + 3
        };
        Physics2DDebugDraw.prototype.drawCircle = function(x, y, radius, color) {
            var r = color[0];
            var g = color[1];
            var b = color[2];
            var a = color[3];
            var maxError = this.circleMaxError;
            var rad = radius * this.physics2DToScreen;
            var vCount;
            if (rad < maxError / 2) {
                vCount = 3
            } else {
                vCount = Math.ceil(Math.PI / Math.acos(1 - maxError / rad));
                if (vCount < 3) {
                    vCount = 3
                }
            }
            var numVertices = this._numVertices;
            var vindex = numVertices * 6;
            var iindex = this._numLines * 2;
            this._prepare(vCount, vCount);
            var dx = radius;
            var dy = 0;
            var angInc = Math.PI * 2 / vCount;
            var cos = Math.cos(angInc);
            var sin = Math.sin(angInc);
            var vdata = this._vertexData;
            var idata = this._indexData;
            var i;
            for (i = 0; i < vCount; i += 1) {
                var nx = dx * cos - dy * sin;
                dy = dx * sin + dy * cos;
                dx = nx;
                vdata[vindex] = x + dx;
                vdata[vindex + 1] = y + dy;
                vdata[vindex + 2] = r;
                vdata[vindex + 3] = g;
                vdata[vindex + 4] = b;
                vdata[vindex + 5] = a;
                vindex += 6;
                idata[iindex] = numVertices + i;
                idata[iindex + 1] = numVertices + (i + 1) % vCount;
                iindex += 2
            }
        };
        Physics2DDebugDraw.prototype.drawRigidBody = function(body) {
            body._update();
            var shapes = body.shapes;
            var limit = shapes.length;
            var i;
            for (i = 0; i < limit; i += 1) {
                this._drawShape(shapes[i])
            }
            if (this.showBodyDetail) {
                var data = body._data;
                this.drawCircle(data[2], data[2 + 1], this.screenToPhysics2D * this.bodyPositionRadius, this.bodyDetailColor);
                this.drawLine(data[15], data[15 + 1], data[2], data[2 + 1], this.bodyDetailColor)
            }
        };
        Physics2DDebugDraw.prototype.drawConstraint = function(con) {
            if (con._draw) {
                con._draw(this, con._stiff)
            }
        };
        Physics2DDebugDraw.prototype.drawWorld = function(world) {
            var i, limit;
            if (this.showRigidBodies) {
                var bodies = world.rigidBodies;
                limit = bodies.length;
                for (i = 0; i < limit; i += 1) {
                    var body = bodies[i];
                    this.drawRigidBody(body)
                }
            }
            if (this.showContacts) {
                this._drawArbiters(world.dynamicArbiters);
                this._drawArbiters(world.staticArbiters)
            }
            if (this.showConstraints) {
                var constraints = world.constraints;
                limit = constraints.length;
                for (i = 0; i < limit; i += 1) {
                    var con = constraints[i];
                    if (con._active) {
                        this.drawConstraint(con)
                    }
                }
            }
        };
        Physics2DDebugDraw.prototype._drawArbiters = function(arbiters) {
            var rad = this.screenToPhysics2D * this.contactRadius;
            var imp = this.screenToPhysics2D * this.contactImpulseScale;
            var limit = arbiters.length;
            var i;
            for (i = 0; i < limit; i += 1) {
                var arb = arbiters[i];
                if (!arb.active) {
                    continue
                }
                var color = arb._static ? this.staticContactColor : this.dynamicContactColor;
                var nx, ny;
                if (arb.sensor) {
                    nx = 0;
                    ny = 0
                } else {
                    var adata = arb._data;
                    nx = adata[4];
                    ny = adata[4 + 1]
                }
                var c1 = arb._contact1._data;
                var x1 = c1[0];
                var y1 = c1[0 + 1];
                this.drawCircle(x1, y1, rad, color);
                var jn, jt;
                if (this.showContactImpulses && !arb._contact1.virtual) {
                    jn = c1[11] * imp;
                    jt = c1[12] * imp;
                    this.drawLine(x1, y1, x1 + nx * jn, y1 + ny * jn, this.normalImpulseColor);
                    this.drawLine(x1, y1, x1 - ny * jt, y1 + nx * jt, this.frictionImpulseColor)
                }
                if (arb._position2Contact) {
                    var c2 = arb._contact2._data;
                    var x2 = c2[0];
                    var y2 = c2[0 + 1];
                    if (this.showContactImpulses && !arb._contact2.virtual) {
                        jn = c2[11] * imp;
                        jt = c2[12] * imp;
                        this.drawLine(x2, y2, x2 + nx * jn, y2 + ny * jn, this.normalImpulseColor);
                        this.drawLine(x2, y2, x2 - ny * jt, y2 + nx * jt, this.frictionImpulseColor)
                    }
                    nx *= rad;
                    ny *= rad;
                    this.drawCircle(x2, y2, rad, color);
                    this.drawLine(x1 + nx, y1 + ny, x2 + nx, y2 + ny, color);
                    this.drawLine(x1 - nx, y1 - ny, x2 - nx, y2 - ny, color)
                }
            }
        };
        Physics2DDebugDraw.prototype._drawShape = function(shape) {
            var body = shape.body;
            if (shape.sensor && !this.showSensorsShapes || !shape.sensor && !this.showColliderShapes) {
                return
            }
            var color = this._colors[shape.body._type | (body.sleeping ? 4 : 0) | (shape.sensor ? 8 : 0) | (body._bullet ? 16 : 0)];
            if (shape._type === 0) {
                this._drawCircleShape(shape, color)
            } else {
                this._drawPolygonShape(shape, color)
            }
            if (this.showShapeDetail) {
                var data = shape._data;
                this.drawRectangle(data[0], data[0 + 1], data[0 + 2], data[0 + 3], this.shapeDetailColor)
            }
        };
        Physics2DDebugDraw.prototype._drawCircleShape = function(circle, color) {
            var body = circle.body._data;
            var data = circle._data;
            var cx = data[9];
            var cy = data[9 + 1];
            var rad = data[6];
            this.drawCircle(cx, cy, rad, color);
            if (circle.body._type !== 2) {
                var cos = body[5];
                var sin = body[5 + 1];
                this.drawLine(cx + rad * .333 * cos, cy + rad * .333 * sin, cx + rad * cos, cy + rad * sin, color)
            }
            if (this.showShapeDetail) {
                this.drawCircle(data[9], data[9 + 1], this.screenToPhysics2D * this.circleOriginRadius, this.shapeDetailColor)
            }
        };
        Physics2DDebugDraw.prototype._drawPolygonShape = function(polygon, color) {
            var r = color[0];
            var g = color[1];
            var b = color[2];
            var a = color[3];
            var numVertices = this._numVertices;
            var vindex = numVertices * 6;
            var iindex = this._numLines * 2;
            var pdata = polygon._data;
            var pindex = 6;
            var limit = pdata.length;
            var vCount = (limit - pindex) / 13;
            this._prepare(vCount, vCount);
            var vdata = this._vertexData;
            var idata = this._indexData;
            var i;
            for (i = 0; pindex < limit; pindex += 13, i += 1) {
                vdata[vindex] = pdata[pindex + 2];
                vdata[vindex + 1] = pdata[pindex + 2 + 1];
                vdata[vindex + 2] = r;
                vdata[vindex + 3] = g;
                vdata[vindex + 4] = b;
                vdata[vindex + 5] = a;
                vindex += 6;
                idata[iindex] = numVertices + i;
                idata[iindex + 1] = numVertices + (i + 1) % vCount;
                iindex += 2
            }
        };
        Physics2DDebugDraw.prototype.begin = function() {
            var gd = this._graphicsDevice;
            var width = gd.width;
            var height = gd.height;
            var screenX, screenY, screenW, screenH;
            var port;
            if (this._screenPortEnabled) {
                port = this._screenPort;
                screenX = port[0];
                screenY = port[1];
                screenW = port[2] - screenX;
                screenH = port[3] - screenY
            } else {
                screenX = 0;
                screenY = 0;
                screenW = width;
                screenH = height
            }
            if (width !== this._width || height !== this._height || this._invalidated) {
                this._width = width;
                this._height = height;
                this._invalidated = false;
                var physX, physY, physW, physH;
                if (this._physics2DPortEnabled) {
                    port = this._physics2DPort;
                    physX = port[0];
                    physY = port[1];
                    physW = port[2] - physX;
                    physH = port[3] - physY
                } else {
                    physX = 0;
                    physY = 0;
                    physW = width / 60;
                    physH = height / 60
                }
                var clip = this._techniqueParams["clipSpace"];
                clip[0] = 2 * screenW / (width * physW);
                clip[1] = -(2 * screenH) / (height * physH);
                clip[2] = -(2 * physX * screenW) / (width * physW) + 2 * screenX / width - 1;
                clip[3] = 2 * physY * screenH / (height * physH) - 2 * screenY / height + 1;
                var rx = clip[0] * .5 * width;
                var ry = -(clip[1] * .5 * height);
                this.physics2DToScreen = .5 * (rx + ry);
                this.screenToPhysics2D = 1 / this.physics2DToScreen
            }
            gd.setScissor(screenX, height - screenY - screenH, screenW, screenH);
            gd.setTechnique(this._technique);
            gd.setTechniqueParameters(this._techniqueParams)
        };
        Physics2DDebugDraw.prototype.end = function() {
            this._dispatch()
        };
        Physics2DDebugDraw.prototype._prepare = function(numVerts, numLines) {
            var size, newData, i;
            var index = this._numVertices * 6;
            var total = index + numVerts * 6;
            var data = this._vertexData;
            if (total > data.length) {
                size = this._bufferSizeAlgorithm(total);
                newData = this._vertexData = new Physics2DDevice.prototype.floatArray(size);
                for (i = 0; i < index; i += 1) {
                    newData[i] = data[i]
                }
            }
            this._numVertices += numVerts;
            index = this._numLines * 2;
            total = index + numLines * 2;
            data = this._indexData;
            if (total > data.length) {
                size = this._bufferSizeAlgorithm(total);
                newData = this._indexData = new Physics2DDevice.prototype.uint16Array(size);
                for (i = 0; i < index; i += 1) {
                    newData[i] = data[i]
                }
            }
            this._numLines += numLines
        };
        Physics2DDebugDraw.prototype._bufferSizeAlgorithm = function(target) {
            var factor = 1.25;
            var logf = Math.ceil(Math.log(target) / Math.log(factor));
            var size = Math.floor(Math.pow(factor, logf));
            return 6 * Math.ceil(size / 6)
        };
        Physics2DDebugDraw.prototype._dispatch = function() {
            var graphicsDevice = this._graphicsDevice;
            var vertexBuffer = this._vertexBuffer;
            var vertexBufferParameters = this._vertexBufferParameters;
            var vertexData = this._vertexData;
            var indexBuffer = this._indexBuffer;
            var indexBufferParameters = this._indexBufferParameters;
            var indexData = this._indexData;
            var count = this._numVertices;
            if (count === 0) {
                return
            }
            var newSize;
            if (count > vertexBufferParameters.numVertices) {
                newSize = this._bufferSizeAlgorithm(count);
                vertexBufferParameters.numVertices = newSize;
                this._vertexBuffer.destroy();
                this._vertexBuffer = vertexBuffer = graphicsDevice.createVertexBuffer(vertexBufferParameters)
            }
            vertexBuffer.setData(vertexData, 0, count);
            count = this._numLines * 2;
            if (count > indexBufferParameters.numIndices) {
                newSize = this._bufferSizeAlgorithm(count);
                indexBufferParameters.numIndices = newSize;
                this._indexBuffer.destroy();
                this._indexBuffer = indexBuffer = graphicsDevice.createIndexBuffer(indexBufferParameters)
            }
            indexBuffer.setData(indexData, 0, count);
            graphicsDevice.setStream(vertexBuffer, this._semantics);
            graphicsDevice.setIndexBuffer(indexBuffer);
            graphicsDevice.drawIndexed(graphicsDevice.PRIMITIVE_LINES, count);
            this._numVertices = 0;
            this._numLines = 0
        };
        Physics2DDebugDraw.prototype.destroy = function() {
            this._graphicsDevice = null;
            this._curveStack.length = 0;
            this._curveVerts.length = 0;
            this._colors.length = 0;
            this._vertexBuffer.destroy();
            this._indexBuffer.destroy()
        };
        Physics2DDebugDraw.create = function(params) {
            var o = new Physics2DDebugDraw;
            var gd = o._graphicsDevice = params.graphicsDevice;
            o._screenPort = new Physics2DDevice.prototype.floatArray(4);
            o._screenPortEnabled = false;
            o._physics2DPort = new Physics2DDevice.prototype.floatArray(4);
            o._physics2DPortEnabled = false;
            o._invalidated = true;
            o.physics2DToScreen = 0;
            o.screenToPhysics2D = 0;
            o.circleMaxError = .4;
            o.curveMaxError = .6;
            o.spiralMaxArc = Math.PI / 4;
            o.spiralEpsilon = 1e-5;
            o.spiralSpringSize = .75;
            o._curveStack = [];
            o._curveVerts = [];
            o.minSpringLength = .5;
            var v4Build = function v4BuildFn(r, g, b, a) {
                var ret = new Physics2DDevice.prototype.floatArray(4);
                ret[0] = r;
                ret[1] = g;
                ret[2] = b;
                ret[3] = a;
                return ret
            };
            var bulletColor = v4Build(1, 1, 1, 1);
            var staticColor = v4Build(1, .5, .5, 1);
            var staticSensorColor = v4Build(.9, .7, .7, .6);
            var kinematicColor = v4Build(.8, .3, .8, 1);
            var kinematicSensorColor = v4Build(.8, .4, .8, .6);
            var dynamicColor = v4Build(.5, 1, .5, 1);
            var dynamicSensorColor = v4Build(.7, .9, .7, .6);
            var sleepingDynamicColor = v4Build(.5, 1, .5, .5);
            var sleepingDynamicSensorColor = v4Build(.7, .9, .7, .4);
            var sleepingKinematicColor = v4Build(.8, .4, .8, .5);
            var sleepingKinematicSensorColor = v4Build(.8, .5, .8, .4);
            o.showConstraints = true;
            o.constraintAnchorRadius = 3;
            o.constraintSpringRadius = 3;
            o.constraintSpringNumCoils = 3;
            o.constraintSpiralMinRadius = 10;
            o.constraintSpiralDeltaRadius = 2.5 / Math.PI;
            o.constraintSpiralNumCoils = 4;
            o.constraintColorA = v4Build(1, 0, 0, .8);
            o.constraintSleepingColorA = v4Build(.7, .2, .2, .6);
            o.constraintColorB = v4Build(0, 0, 1, .8);
            o.constraintSleepingColorB = v4Build(.2, .2, .7, .6);
            o.constraintColorC = v4Build(0, 1, 0, .8);
            o.constraintSleepingColorC = v4Build(.2, .7, .2, .6);
            o.constraintColorD = v4Build(1, 0, 1, .8);
            o.constraintSleepingColorD = v4Build(.7, .2, .7, .6);
            o.constraintErrorColorA = v4Build(1, 1, .5, .8);
            o.constraintErrorSleepingColorA = v4Build(.7, .7, .5, .6);
            o.constraintErrorColorB = v4Build(.5, 1, 1, .8);
            o.constraintErrorSleepingColorB = v4Build(.5, .7, .7, .6);
            o.constraintErrorColorC = v4Build(.4, 1, .4, .8);
            o.constraintErrorSleepingColorC = v4Build(.4, .7, .4, .6);
            o.constraintErrorColorD = v4Build(1, .4, 1, .8);
            o.constraintErrorSleepingColorD = v4Build(.7, .4, .7, .6);
            o.showContacts = false;
            o.showContactImpulses = false;
            o.contactRadius = 3;
            o.contactImpulseScale = 30;
            o.dynamicContactColor = v4Build(1, 0, .5, .7);
            o.staticContactColor = v4Build(.5, 0, 1, .7);
            o.normalImpulseColor = v4Build(1, 0, 0, 1);
            o.frictionImpulseColor = v4Build(0, 0, 1, 1);
            o.showRigidBodies = true;
            o.showColliderShapes = true;
            o.showSensorsShapes = true;
            o.showBodyDetail = false;
            o.showShapeDetail = false;
            o.bodyPositionRadius = .5;
            o.circleOriginRadius = .5;
            o.bodyDetailColor = v4Build(0, 1, 1, .5);
            o.shapeDetailColor = v4Build(1, 1, 0, .5);
            var colors = o._colors = [];
            colors[2 + 4] = staticColor;
            colors[2 + 12] = staticSensorColor;
            colors[0] = dynamicColor;
            colors[0 + 8] = dynamicSensorColor;
            colors[0 + 4] = sleepingDynamicColor;
            colors[0 + 12] = sleepingDynamicSensorColor;
            colors[0 + 16] = bulletColor;
            colors[1] = kinematicColor;
            colors[1 + 8] = kinematicSensorColor;
            colors[1 + 4] = sleepingKinematicColor;
            colors[1 + 12] = sleepingKinematicSensorColor;
            var shader = gd.createShader({
                version: 1,
                name: "lines.cgfx",
                parameters: {
                    clipSpace: {
                        type: "float",
                        columns: 4
                    }
                },
                techniques: {
                    alpha: [{
                        parameters: ["clipSpace"],
                        semantics: ["POSITION", "COLOR"],
                        states: {
                            DepthTestEnable: false,
                            DepthMask: false,
                            CullFaceEnable: false,
                            BlendEnable: true,
                            BlendFunc: [770, 771]
                        },
                        programs: ["vp_draw2dlines", "fp_draw2dlines"]
                    }]
                },
                programs: {
                    fp_draw2dlines: {
                        type: "fragment",
                        code: "#ifdef GL_ES\n#define TZ_LOWP lowp\nprecision mediump float;\nprecision mediump int;\n#else\n#define TZ_LOWP\n#endif\nvarying TZ_LOWP vec4 tz_Color;\nvoid main()\n{gl_FragColor=tz_Color;}"
                    },
                    vp_draw2dlines: {
                        type: "vertex",
                        code: "#ifdef GL_ES\n#define TZ_LOWP lowp\nprecision mediump float;\nprecision mediump int;\n#else\n#define TZ_LOWP\n#endif\nvarying TZ_LOWP vec4 tz_Color;attribute vec4 ATTR3;attribute vec4 ATTR0;\nvec4 _outpos1;vec4 _outcol1;uniform vec4 clipSpace;void main()\n{vec2 _TMP1;_TMP1=ATTR0.xy*clipSpace.xy+clipSpace.zw;_outpos1=vec4(_TMP1.x,_TMP1.y,0.0,1.0);_outcol1=ATTR3;tz_Color=ATTR3;gl_Position=_outpos1;}"
                    }
                }
            });
            o._techniqueParams = gd.createTechniqueParameters({
                clipSpace: new Physics2DDevice.prototype.floatArray(4)
            });
            o._technique = shader.getTechnique("alpha");
            var initialVertices = 4;
            var initialIndices = 4;
            o._vertexBufferParameters = {
                numVertices: initialVertices,
                attributes: [gd.VERTEXFORMAT_FLOAT2, gd.VERTEXFORMAT_FLOAT4],
                "transient": true
            };
            o._vertexBuffer = gd.createVertexBuffer(o._vertexBufferParameters);
            o._semantics = gd.createSemantics([gd.SEMANTIC_POSITION, gd.SEMANTIC_COLOR]);
            o._indexBufferParameters = {
                numIndices: initialIndices,
                format: gd.INDEXFORMAT_USHORT,
                "transient": true
            };
            o._indexBuffer = gd.createIndexBuffer(o._indexBufferParameters);
            o._vertexData = new Physics2DDevice.prototype.floatArray(60);
            o._indexData = new Physics2DDevice.prototype.uint16Array(60);
            o._numVertices = 0;
            o._numLines = 0;
            return o
        };
        Physics2DDebugDraw.version = 1;
        return Physics2DDebugDraw
    }();
    Physics2DPulleyConstraint.prototype._draw = function _pulleyDrawFn(debug) {
        var colA = this.sleeping ? debug.constraintSleepingColorA : debug.constraintColorA;
        var colB = this.sleeping ? debug.constraintSleepingColorB : debug.constraintColorB;
        var colC = this.sleeping ? debug.constraintSleepingColorC : debug.constraintColorC;
        var colD = this.sleeping ? debug.constraintSleepingColorD : debug.constraintColorD;
        var colSA = this.sleeping ? debug.constraintErrorSleepingColorA : debug.constraintErrorColorA;
        var colSB = this.sleeping ? debug.constraintErrorSleepingColorB : debug.constraintErrorColorB;
        var colSC = this.sleeping ? debug.constraintErrorSleepingColorC : debug.constraintErrorColorC;
        var colSD = this.sleeping ? debug.constraintErrorSleepingColorD : debug.constraintErrorColorD;
        var data = this._data;
        var b1 = this.bodyA._data;
        var b2 = this.bodyB._data;
        var b3 = this.bodyC._data;
        var b4 = this.bodyD._data;
        var x1 = b1[2] + data[19];
        var y1 = b1[2 + 1] + data[19 + 1];
        var x2 = b2[2] + data[21];
        var y2 = b2[2 + 1] + data[21 + 1];
        var x3 = b3[2] + data[23];
        var y3 = b3[2 + 1] + data[23 + 1];
        var x4 = b4[2] + data[25];
        var y4 = b4[2 + 1] + data[25 + 1];
        var n12x = x2 - x1;
        var n12y = y2 - y1;
        var n34x = x4 - x3;
        var n34y = y4 - y3;
        var nL12 = Math.sqrt(n12x * n12x + n12y * n12y);
        var nL34 = Math.sqrt(n34x * n34x + n34y * n34y);
        var ratio = data[7];
        this._drawLink(debug, x1, y1, x2, y2, n12x, n12y, nL12, nL34 * ratio, 1, colSA, colSB);
        this._drawLink(debug, x3, y3, x4, y4, n34x, n34y, nL34, nL12, 1 / ratio, colSC, colSD);
        var rad = debug.constraintAnchorRadius * debug.screenToPhysics2D;
        debug._drawAnchor(x1, y1, rad, colA);
        debug._drawAnchor(x2, y2, rad, colB);
        debug._drawAnchor(x3, y3, rad, colC);
        debug._drawAnchor(x4, y4, rad, colD)
    };
    Physics2DPulleyConstraint.prototype._drawLink = function _drawLinkFn(debug, x1, y1, x2, y2, nx, ny, nl, bias, scale, colSA, colSB) {
        if (nl > Physics2DConfig.NORMALIZE_EPSILON) {
            var rec = 1 / nl;
            nx *= rec;
            ny *= rec;
            var midX = .5 * (x1 + x2);
            var midY = .5 * (y1 + y2);
            var data = this._data;
            var jointMin = (data[5] - bias) * scale;
            if (jointMin < 0) {
                jointMin = 0
            }
            var jointMax = (data[6] - bias) * scale;
            if (jointMax < 0) {
                jointMax = 0
            }
            var minX1 = midX - nx * (jointMin * .5);
            var minY1 = midY - ny * (jointMin * .5);
            var minX2 = midX + nx * (jointMin * .5);
            var minY2 = midY + ny * (jointMin * .5);
            debug.drawLine(minX1, minY1, minX2, minY2, colSA);
            if (isFinite(jointMax)) {
                var maxX1 = midX - nx * (jointMax * .5);
                var maxY1 = midY - ny * (jointMax * .5);
                var maxX2 = midX + nx * (jointMax * .5);
                var maxY2 = midY + ny * (jointMax * .5);
                debug.drawLine(maxX1, maxY1, minX1, minY1, colSB);
                debug.drawLine(maxX2, maxY2, minX2, minY2, colSB)
            }
            if (!this._stiff) {
                var numCoils = debug.constraintSpringNumCoils;
                var radius = debug.constraintSpringRadius * debug.screenToPhysics2D;
                if (nl > jointMax) {
                    debug.drawLinearSpring(maxX1, maxY1, x1, y1, numCoils, radius, colSB);
                    debug.drawLinearSpring(maxX2, maxY2, x2, y2, numCoils, radius, colSB)
                } else if (nl < jointMin) {
                    debug.drawLinearSpring(minX1, minY1, x1, y1, numCoils, radius, colSA);
                    debug.drawLinearSpring(minX2, minY2, x2, y2, numCoils, radius, colSA)
                }
            }
        }
    };
    Physics2DLineConstraint.prototype._draw = function lineDrawFn(debug) {
        var colA = this.sleeping ? debug.constraintSleepingColorA : debug.constraintColorA;
        var colB = this.sleeping ? debug.constraintSleepingColorB : debug.constraintColorB;
        var colSA = this.sleeping ? debug.constraintErrorSleepingColorA : debug.constraintErrorColorA;
        var colSB = this.sleeping ? debug.constraintErrorSleepingColorB : debug.constraintErrorColorB;
        var colSC = this.sleeping ? debug.constraintErrorSleepingColorC : debug.constraintErrorColorC;
        var data = this._data;
        var b1 = this.bodyA._data;
        var b2 = this.bodyB._data;
        var x1 = b1[2] + data[13];
        var y1 = b1[2 + 1] + data[13 + 1];
        var x2 = b2[2] + data[15];
        var y2 = b2[2 + 1] + data[15 + 1];
        var dx = data[17];
        var dy = data[17 + 1];
        var jointMin = data[5];
        var jointMax = data[6];
        if (jointMin === Number.NEGATIVE_INFINITY) {
            jointMin = -1e20
        }
        if (jointMax === Number.POSITIVE_INFINITY) {
            jointMax = 1e20
        }
        var delX = x2 - x1;
        var delY = y2 - y1;
        var pn = delX * dx + delY * dy;
        var ex1 = x1 + dx * jointMin;
        var ey1 = y1 + dy * jointMin;
        var ex2 = x1 + dx * jointMax;
        var ey2 = y1 + dy * jointMax;
        var t;
        if (pn > jointMin) {
            t = Math.min(pn, jointMax);
            debug.drawLine(ex1, ey1, x1 + dx * t, y1 + dy * t, colSA)
        }
        if (pn < jointMax) {
            t = Math.max(pn, jointMin);
            debug.drawLine(ex2, ey2, x1 + dx * t, y1 + dy * t, colSB)
        }
        if (!this._stiff) {
            var anchX = pn < jointMin ? ex1 : pn > jointMax ? ex2 : x1 + dx * pn;
            var anchY = pn < jointMin ? ey1 : pn > jointMax ? ey2 : y1 + dy * pn;
            var numCoils = debug.constraintSpringNumCoils;
            var radius = debug.constraintSpringRadius * debug.screenToPhysics2D;
            debug.drawLinearSpring(anchX, anchY, x2, y2, numCoils, radius, colSC)
        }
        var rad = debug.constraintAnchorRadius * debug.screenToPhysics2D;
        debug._drawAnchor(x1, y1, rad, colA);
        debug._drawAnchor(x2, y2, rad, colB)
    };
    Physics2DDistanceConstraint.prototype._draw = function distanceDrawFn(debug) {
        var colA = this.sleeping ? debug.constraintSleepingColorA : debug.constraintColorA;
        var colB = this.sleeping ? debug.constraintSleepingColorB : debug.constraintColorB;
        var colSA = this.sleeping ? debug.constraintErrorSleepingColorA : debug.constraintErrorColorA;
        var colSB = this.sleeping ? debug.constraintErrorSleepingColorB : debug.constraintErrorColorB;
        var data = this._data;
        var b1 = this.bodyA._data;
        var b2 = this.bodyB._data;
        var x1 = b1[2] + data[11];
        var y1 = b1[2 + 1] + data[11 + 1];
        var x2 = b2[2] + data[13];
        var y2 = b2[2 + 1] + data[13 + 1];
        var nx = x2 - x1;
        var ny = y2 - y1;
        var nlsq = nx * nx + ny * ny;
        if (nlsq > Physics2DConfig.NORMALIZE_SQ_EPSILON) {
            var nl = Math.sqrt(nlsq);
            var rec = 1 / nl;
            nx *= rec;
            ny *= rec;
            var midX = .5 * (x1 + x2);
            var midY = .5 * (y1 + y2);
            var jointMin = data[5];
            var jointMax = data[6];
            var minX1 = midX - nx * (jointMin * .5);
            var minY1 = midY - ny * (jointMin * .5);
            var minX2 = midX + nx * (jointMin * .5);
            var minY2 = midY + ny * (jointMin * .5);
            debug.drawLine(minX1, minY1, minX2, minY2, colSA);
            if (isFinite(jointMax)) {
                var maxX1 = midX - nx * (jointMax * .5);
                var maxY1 = midY - ny * (jointMax * .5);
                var maxX2 = midX + nx * (jointMax * .5);
                var maxY2 = midY + ny * (jointMax * .5);
                debug.drawLine(maxX1, maxY1, minX1, minY1, colSB);
                debug.drawLine(maxX2, maxY2, minX2, minY2, colSB)
            }
            if (!this._stiff) {
                var numCoils = debug.constraintSpringNumCoils;
                var radius = debug.constraintSpringRadius * debug.screenToPhysics2D;
                if (nl > jointMax) {
                    debug.drawLinearSpring(maxX1, maxY1, x1, y1, numCoils, radius, colSB);
                    debug.drawLinearSpring(maxX2, maxY2, x2, y2, numCoils, radius, colSB)
                } else if (nl < jointMin) {
                    debug.drawLinearSpring(minX1, minY1, x1, y1, numCoils, radius, colSA);
                    debug.drawLinearSpring(minX2, minY2, x2, y2, numCoils, radius, colSA)
                }
            }
        }
        var rad = debug.constraintAnchorRadius * debug.screenToPhysics2D;
        debug._drawAnchor(x1, y1, rad, colA);
        debug._drawAnchor(x2, y2, rad, colB)
    };
    Physics2DAngleConstraint.prototype._draw = function angleDrawFn(debug) {
        var colA = this.sleeping ? debug.constraintSleepingColorA : debug.constraintColorA;
        var colB = this.sleeping ? debug.constraintSleepingColorB : debug.constraintColorB;
        var colSA = this.sleeping ? debug.constraintErrorSleepingColorA : debug.constraintErrorColorA;
        var colSB = this.sleeping ? debug.constraintErrorSleepingColorB : debug.constraintErrorColorB;
        var data = this._data;
        var b1 = this.bodyA._data;
        var b2 = this.bodyB._data;
        var ratio = data[7];
        this._drawForBody(debug, b1, b2, ratio, -1, colSA, colSB, colA);
        this._drawForBody(debug, b2, b1, 1 / ratio, 1 / ratio, colSA, colSB, colB)
    };
    Physics2DAngleConstraint.prototype._drawForBody = function _drawForBodyFn(debug, b1, b2, bodyScale, limitScale, colA, colB, col) {
        var data = this._data;
        var jointMin = data[5];
        var jointMax = data[6];
        var min = b2[2 + 2] * bodyScale + jointMin * limitScale;
        var max = b2[2 + 2] * bodyScale + jointMax * limitScale;
        if (min > max) {
            var tmp = min;
            min = max;
            max = tmp
        }
        var minRadius = debug.constraintSpiralMinRadius * debug.screenToPhysics2D;
        var deltaRadius = debug.constraintSpiralDeltaRadius * debug.screenToPhysics2D;
        var indicatorSize = debug.constraintAnchorRadius * debug.screenToPhysics2D;
        var numCoils = debug.constraintSpiralNumCoils;
        var x = b1[2];
        var y = b1[2 + 1];
        var rot = b1[2 + 2];
        var dr;
        if (rot > min) {
            dr = Math.min(rot, max);
            debug.drawSpiral(x, y, min, dr, minRadius, minRadius + (dr - min) * deltaRadius, colA)
        } else if (!this._stiff && rot < min) {
            debug.drawSpiralSpring(x, y, rot, min, minRadius + (rot - min) * deltaRadius, minRadius, numCoils, colA)
        }
        if (rot < max) {
            dr = Math.max(rot, min);
            debug.drawSpiral(x, y, dr, max, minRadius + (dr - min) * deltaRadius, minRadius + (max - min) * deltaRadius, colB)
        } else if (!this._stiff && rot > max) {
            debug.drawSpiralSpring(x, y, rot, max, minRadius + (rot - min) * deltaRadius, minRadius + (max - min) * deltaRadius, numCoils, colB)
        }
        debug._drawAngleIndicator(x, y, rot, minRadius + (rot - min) * deltaRadius, indicatorSize, col)
    };
    Physics2DWeldConstraint.prototype._draw = function weldDrawFn(debug) {
        var colA = this.sleeping ? debug.constraintSleepingColorA : debug.constraintColorA;
        var colB = this.sleeping ? debug.constraintSleepingColorB : debug.constraintColorB;
        var colE = this.sleeping ? debug.constraintErrorSleepingColorC : debug.constraintErrorColorC;
        var data = this._data;
        var b1 = this.bodyA._data;
        var b2 = this.bodyB._data;
        var x1 = b1[2] + data[9];
        var y1 = b1[2 + 1] + data[9 + 1];
        var x2 = b2[2] + data[11];
        var y2 = b2[2 + 1] + data[11 + 1];
        var rad = debug.constraintAnchorRadius * debug.screenToPhysics2D;
        debug._drawAnchor(x1, y1, rad, colA);
        debug._drawAnchor(x2, y2, rad, colB);
        if (this._stiff) {
            debug.drawLine(x1, y1, x2, y2, colE)
        } else {
            var numCoils = debug.constraintSpringNumCoils;
            var radius = debug.constraintSpringRadius * debug.screenToPhysics2D;
            debug.drawLinearSpring(x1, y1, x2, y2, numCoils, radius, colE);
            var minRadius = debug.constraintSpiralMinRadius * debug.screenToPhysics2D;
            var deltaRadius = debug.constraintSpiralDeltaRadius * debug.screenToPhysics2D;
            var indicatorSize = debug.constraintAnchorRadius * debug.screenToPhysics2D;
            numCoils = debug.constraintSpiralNumCoils;
            var target, min;
            min = b1[2 + 2];
            target = b2[2 + 2] - data[13];
            var colSA = this.sleeping ? debug.constraintErrorSleepingColorA : debug.constraintErrorColorA;
            var colSB = this.sleeping ? debug.constraintErrorSleepingColorB : debug.constraintErrorColorB;
            debug.drawSpiralSpring(b1[2], b1[2 + 1], min, target, minRadius, minRadius + (target - min) * deltaRadius, numCoils, colSB);
            debug._drawAngleIndicator(b1[2], b1[2 + 1], min, minRadius, indicatorSize, colSA);
            min = b2[2 + 2];
            target = data[13] + b1[2 + 2];
            debug.drawSpiralSpring(b2[2], b2[2 + 1], min, target, minRadius, minRadius + (target - min) * deltaRadius, numCoils, colSA);
            debug._drawAngleIndicator(b2[2], b2[2 + 1], min, minRadius, indicatorSize, colSB)
        }
    };
    Physics2DPointConstraint.prototype._draw = function pointDrawFn(debug) {
        var colA = this.sleeping ? debug.constraintSleepingColorA : debug.constraintColorA;
        var colB = this.sleeping ? debug.constraintSleepingColorB : debug.constraintColorB;
        var colE = this.sleeping ? debug.constraintErrorSleepingColorC : debug.constraintErrorColorC;
        var data = this._data;
        var b1 = this.bodyA._data;
        var b2 = this.bodyB._data;
        var x1 = b1[2] + data[9];
        var y1 = b1[2 + 1] + data[9 + 1];
        var x2 = b2[2] + data[11];
        var y2 = b2[2 + 1] + data[11 + 1];
        var rad = debug.constraintAnchorRadius * debug.screenToPhysics2D;
        debug._drawAnchor(x1, y1, rad, colA);
        debug._drawAnchor(x2, y2, rad, colB);
        if (this._stiff) {
            debug.drawLine(x1, y1, x2, y2, colE)
        } else {
            var numCoils = debug.constraintSpringNumCoils;
            var radius = debug.constraintSpringRadius * debug.screenToPhysics2D;
            debug.drawLinearSpring(x1, y1, x2, y2, numCoils, radius, colE)
        }
    };

    function Debug() {}
    Debug.prototype = {};
    Debug.Log = function Log(logString, arg, arg2, arg3, arg4) {
        var console = window.console;
        if (console) {
            if (arg4) {
                console.log(logString, arg, arg2, arg3, arg4)
            } else {
                if (arg3) {
                    console.log(logString, arg, arg2, arg3)
                } else {
                    if (arg2) {
                        console.log(logString, arg, arg2)
                    } else {
                        if (arg) {
                            console.log(logString, arg)
                        } else {
                            console.log(logString)
                        }
                    }
                }
            }
        }
    };
    Debug.Assert = function Assert(exp, message) {
        if (!exp) {
            var console = window.console;
            if (console) {
                console.log("*************** Assert:" + message)
            }
        }
    };
    Debug.ShowTurbulenzUsage = function ShowObjectUsageFn() {
        TurbulenzEngine.flush();
        var Object = TurbulenzEngine.getObjectStats();
        Debug.Log(Object);
        Object = null
    };

    function JamInputManager() {}
    JamInputManager.prototype = {};
    JamInputManager.Create = function JamInputManagerCreateFn(TurbulenzEngine, errorCallback, log, KeyDownUserCallback, MouseCallback) {
        var MyInputManager;
        var MouseX, MouseY;
        var MouseXBuffer, MouseYBuffer;
        var MouseMoveX, MouseMoveY;
        var MouseMoveXBuffer, MouseMoveYBuffer;
        var MouseButtonPressed;
        var MouseButtonPressedBuffer;
        var MouseButtonReleased;
        var MouseButtonReleasedBuffer;
        var MouseButtonHeld;
        var MouseButtonHeldBuffer;
        var MouseZ;
        var MouseZBuffer;
        var MouseLeftScreen;
        var PadX, PadY;
        var PadXBuffer, PadYBuffer;
        var PadMoveX, PadMoveY;
        var PadMoveXBuffer, PadMoveYBuffer;
        var PadButtonsHeld;
        var PadButtonsHeldBuffer;
        var PadButtonsPressed;
        var PadButtonsPressedBuffer;
        var Focus;
        var TouchX, TouchY;
        var TouchXBuffer, TouchYBuffer;
        var TouchMoveX, TouchMoveY;
        var TouchMoveXBuffer, TouchMoveYBuffer;
        var TouchPressed;
        var TouchPressedBuffer;
        var TouchReleased;
        var TouchReleasedBuffer;
        var TouchHeld;
        var TouchHeldBuffer;
        var TouchMapping;
        var TouchMapped;
        var KeysHeld, KeysHeldBuffer, KeysPressed, KeysPressedBuffer;
        var KeyCapsLock = false;
        var UnicodeCharacters;

        function GetKeyPressedFn(Key) {
            if (KeysPressed[Key] !== undefined) {
                var Pressed = KeysPressed[Key];
                KeysPressed[Key] = false;
                return Pressed
            }
            return false
        }

        function GetKeyHeldFn(Key) {
            if (KeysHeld[Key] !== undefined) {
                return KeysHeld[Key]
            }
            return false
        }

        function GetMouseLeftScreenFn() {
            var Left = MouseLeftScreen;
            MouseLeftScreen = false;
            return Left
        }

        function GetMouseButtonPressedFn(Button) {
            if (JamSystem.GetSystemInfo().osName === "Android" || JamSystem.GetSystemInfo().osName === "Tizen" || JamSystem.GetSystemInfo().osName === "iOS") {
                return GetTouchPressedFn(Button)
            }
            var Pressed = MouseButtonPressed[Button];
            MouseButtonPressed[Button] = false;
            return Pressed
        }

        function GetMouseButtonHeldFn(Button) {
            if (JamSystem.GetSystemInfo().osName === "Android" || JamSystem.GetSystemInfo().osName === "Tizen" || JamSystem.GetSystemInfo().osName === "iOS") {
                return GetTouchHeldFn(Button)
            }
            return MouseButtonHeld[Button]
        }

        function GetMouseButtonReleasedFn(Button) {
            if (JamSystem.GetSystemInfo().osName === "Android" || JamSystem.GetSystemInfo().osName === "Tizen" || JamSystem.GetSystemInfo().osName === "iOS") {
                return GetTouchReleasedFn(Button)
            }
            var Released = MouseButtonReleased[Button];
            MouseButtonReleased[Button] = false;
            return Released
        }

        function GetMouseXFn() {
            if (JamSystem.GetSystemInfo().osName === "Android" || JamSystem.GetSystemInfo().osName === "Tizen" || JamSystem.GetSystemInfo().osName === "iOS") {
                return GetTouchXFn(0)
            }
            return MouseX
        }

        function GetMouseYFn() {
            if (JamSystem.GetSystemInfo().osName === "Android" || JamSystem.GetSystemInfo().osName === "Tizen" || JamSystem.GetSystemInfo().osName === "iOS") {
                return GetTouchYFn(0)
            }
            return MouseY
        }

        function GetMouseZFn() {
            var HoldZ = MouseZ;
            MouseZ = 0;
            return HoldZ
        }

        function GetMouseMoveXFn() {
            if (JamSystem.GetSystemInfo().osName === "Android" || JamSystem.GetSystemInfo().osName === "Tizen" || JamSystem.GetSystemInfo().osName === "iOS") {
                return GetTouchMoveXFn(0)
            }
            return MouseMoveX
        }

        function GetMouseMoveYFn() {
            if (JamSystem.GetSystemInfo().osName === "Android" || JamSystem.GetSystemInfo().osName === "Tizen" || JamSystem.GetSystemInfo().osName === "iOS") {
                return GetTouchMoveYFn(0)
            }
            return MouseMoveY
        }

        function GetPadButtonPressedFn(PadButton) {
            if (PadButtonsPressed[PadButton] !== undefined) {
                var Pressed = PadButtonsPressed[PadButton];
                PadButtonsPressed[PadButton] = false;
                return Pressed
            }
            return false
        }

        function IsCapsLockOnFn() {
            return KeyCapsLock
        }

        function GetPadButtonHeldFn(PadButton) {
            if (PadButtonsHeld[PadButton] !== undefined) {
                return PadButtonsHeld[PadButton]
            }
            return false
        }

        function GetPadXFn(Stick) {
            return PadX[Stick]
        }

        function GetPadYFn(Stick) {
            return PadY[Stick]
        }

        function GetIsInFocusFn() {
            if (JamSystem.GetSystemInfo().osName === "Android" || JamSystem.GetSystemInfo().osName === "Tizen" || JamSystem.GetSystemInfo().osName === "iOS") {
                return true
            }
            return Focus
        }

        function GetKeyUnicodeFn() {
            var i;
            for (i = 0; i < KeysPressed.length; i += 1) {
                if (KeysPressed[i]) {
                    return UnicodeCharacters[i]
                }
            }
        }

        function GetBackPressedFn() {
            var i;
            for (i = 0; i < KeysPressed.length; i += 1) {
                if (KeysPressed[i]) {
                    if (UnicodeCharacters[i] === "BACK") {
                        return true
                    }
                }
            }
            return false
        }

        function GetAnyKeyFn() {
            var i;
            for (i = 0; i < KeysPressed.length; i += 1) {
                if (KeysPressed[i]) {
                    KeysPressed[i] = false;
                    return true
                }
            }
            return false
        }

        function GetAnyKeyAvailableFn(Stringy) {
            var Pressed = false;
            var i;
            for (i = 0; i < KeysPressed.length; i += 1) {
                if (KeysPressed[i]) {
                    Pressed = true
                }
            }
            return Pressed
        }

        function GetTouchPressedFn(Index) {
            var Pressed = TouchPressed[Index];
            TouchPressed[Index] = false;
            return Pressed
        }

        function GetTouchHeldFn(Index) {
            return TouchHeld[Index]
        }

        function GetTouchReleasedFn(Index) {
            var Released = TouchReleased[Index];
            TouchReleased[Index] = false;
            return Released
        }

        function GetTouchXFn(Index) {
            return TouchX[Index]
        }

        function GetTouchYFn(Index) {
            return TouchY[Index]
        }

        function GetTouchMoveXFn(Index) {
            return TouchMoveX[Index]
        }

        function GetTouchMoveYFn(Index) {
            return TouchMoveY[Index]
        }

        function TurbulenzonkeydownFn(keyCode) {
            if (KeyDownUserCallback(keyCode)) {
                KeysHeldBuffer[keyCode] = true;
                KeysPressedBuffer[keyCode] = true
            }
        }

        function TurbulenzonkeyupFn(keyCode) {
            KeysHeldBuffer[keyCode] = false
        }

        function TurbulenzonmousedownFn(mouseCode, x, y) {
            if (mouseCode === MyInputManager.mouseCodes.BUTTON_0) {
                if (MouseCallback()) {
                    MouseButtonHeldBuffer[0] = true;
                    MouseButtonPressedBuffer[0] = true
                }
            }
            if (mouseCode === MyInputManager.mouseCodes.BUTTON_1) {
                MouseButtonHeldBuffer[1] = true;
                MouseButtonPressedBuffer[1] = true
            }
        }

        function TurbulenzonmouseupFn(mouseCode, x, y) {
            if (mouseCode === MyInputManager.mouseCodes.BUTTON_0) {
                MouseButtonHeldBuffer[0] = false;
                MouseButtonReleasedBuffer[0] = true
            }
            if (mouseCode === MyInputManager.mouseCodes.BUTTON_1) {
                MouseButtonHeldBuffer[1] = false;
                MouseButtonReleasedBuffer[1] = true
            }
        }

        function TurbulenzonmousemoveFn(deltaX, deltaY) {
            var ViewportScaleX = JamSystem.RenderManager.TurbulenzGraphicsDevice.width / JamSystem.RenderManager.GetScreenWidth();
            var ViewportScaleY = JamSystem.RenderManager.TurbulenzGraphicsDevice.height / JamSystem.RenderManager.GetScreenHeight();
            deltaX /= ViewportScaleX;
            deltaY /= ViewportScaleY;
            MouseMoveXBuffer = deltaX;
            MouseXBuffer += deltaX;
            if (MouseXBuffer < 0) {
                MouseXBuffer = 0
            }
            if (MouseXBuffer >= JamSystem.RenderManager.GetScreenWidth()) {
                MouseXBuffer = JamSystem.RenderManager.GetScreenWidth() - 1
            }
            MouseMoveYBuffer = deltaX;
            MouseYBuffer -= deltaY;
            if (MouseYBuffer < 0) {
                MouseYBuffer = 0
            }
            if (MouseYBuffer >= JamSystem.RenderManager.GetScreenHeight()) {
                MouseYBuffer = JamSystem.RenderManager.GetScreenHeight() - 1
            }
        }

        function TurbulenzonmouseoverFn(x, y) {
            var ViewportScaleX = JamSystem.RenderManager.TurbulenzGraphicsDevice.width / JamSystem.RenderManager.GetScreenWidth();
            var ViewportScaleY = JamSystem.RenderManager.TurbulenzGraphicsDevice.height / JamSystem.RenderManager.GetScreenHeight();
            x /= ViewportScaleX;
            y /= ViewportScaleY;
            MouseMoveXBuffer = x - MouseXBuffer;
            MouseMoveYBuffer = y - MouseYBuffer;
            MouseXBuffer = x;
            MouseYBuffer = y
        }

        function TurbulenzonmousewheelFn(deltaZ) {
            MouseZBuffer = deltaZ
        }

        function TurbulenzonpaddownFn(padCode) {
            PadButtonsHeldBuffer[padCode] = true;
            PadButtonsPressedBuffer[padCode] = true
        }

        function TurbulenzonpadupFn(padCode) {
            PadButtonsHeldBuffer[padCode] = false
        }

        function TurbulenzonpadmoveFn(lX, lY, lZ, rX, rY, rZ, dpad) {
            PadMoveXBuffer[0] = lX;
            PadXBuffer[0] = lX;
            PadMoveYBuffer[0] = lY;
            PadYBuffer[0] = lY
        }

        function TurbulenzonmouseleaveFn() {
            MouseLeftScreen = true
        }

        function TurbulenzonmouseenterFn() {
            MouseLeftScreen = false
        }

        function TurbulenzonfocusFn() {
            Focus = true
        }

        function TurbulenzonblurFn() {
            Focus = false
        }

        function TurbulenzLockFn(Lock) {
            if (Lock) {
                MyInputManager.lockMouse()
            } else {
                MyInputManager.unlockMouse()
            }
        }

        function TurbulenzIsLockedFn() {
            return MyInputManager.isLocked()
        }

        function TurbulenzontouchstartFn(touchEvent) {
            Focus = true;
            var Touch = touchEvent.changedTouches;
            var i;
            for (i = 0; i < Touch.length; i += 1) {
                var Id = Touch[i].identifier;
                var x = Touch[i].positionX;
                var y = Touch[i].positionY;
                var ViewportScaleX = JamSystem.RenderManager.TurbulenzGraphicsDevice.width / JamSystem.RenderManager.GetScreenWidth();
                var ViewportScaleY = JamSystem.RenderManager.TurbulenzGraphicsDevice.height / JamSystem.RenderManager.GetScreenHeight();
                x /= ViewportScaleX;
                y /= ViewportScaleY;
                var Index = 0;
                while (Index < 10) {
                    if (!TouchMapped[Index]) {
                        break
                    }
                    Index += 1
                }
                if (Index === 10) {
                    continue
                }
                TouchMapping[Id] = Index;
                TouchMapped[Index] = true;
                TouchHeldBuffer[Index] = true;
                TouchPressedBuffer[Index] = true;
                if (TouchMoveXBuffer[Index] === undefined) {
                    TouchMoveXBuffer[Index] = 0;
                    TouchMoveYBuffer[Index] = 0
                }
                TouchMoveXBuffer[Index] = x - TouchMoveXBuffer[Index];
                TouchMoveYBuffer[Index] = y - TouchMoveYBuffer[Index];
                TouchXBuffer[Index] = x;
                TouchYBuffer[Index] = y
            }
        }

        function TurbulenzontouchendFn(touchEvent) {
            var Touch = touchEvent.changedTouches;
            var i;
            for (i = 0; i < Touch.length; i += 1) {
                var Index = TouchMapping[Touch[i].identifier];
                if (Index === undefined) {
                    continue
                }
                var x = Touch[i].positionX;
                var y = Touch[i].positionY;
                var ViewportScaleX = JamSystem.RenderManager.TurbulenzGraphicsDevice.width / JamSystem.RenderManager.GetScreenWidth();
                var ViewportScaleY = JamSystem.RenderManager.TurbulenzGraphicsDevice.height / JamSystem.RenderManager.GetScreenHeight();
                x /= ViewportScaleX;
                y /= ViewportScaleY;
                TouchHeldBuffer[Index] = false;
                TouchReleasedBuffer[Index] = true;
                delete TouchMapping[Touch[i].identifier];
                TouchMapped[Index] = false
            }
        }

        function TurbulenzontouchmoveFn(touchEvent) {
            var Touch = touchEvent.changedTouches;
            var i;
            for (i = 0; i < Touch.length; i += 1) {
                var Index = TouchMapping[Touch[i].identifier];
                var x = Touch[i].positionX;
                var y = Touch[i].positionY;
                var ViewportScaleX = JamSystem.RenderManager.TurbulenzGraphicsDevice.width / JamSystem.RenderManager.GetScreenWidth();
                var ViewportScaleY = JamSystem.RenderManager.TurbulenzGraphicsDevice.height / JamSystem.RenderManager.GetScreenHeight();
                x /= ViewportScaleX;
                y /= ViewportScaleY;
                TouchMoveXBuffer[Index] = x - TouchMoveXBuffer[Index];
                TouchMoveYBuffer[Index] = y - TouchMoveYBuffer[Index];
                TouchXBuffer[Index] = x;
                TouchYBuffer[Index] = y
            }
        }

        function UpdateFn() {
            var i;
            var NotFocussed = !this.GetIsInFocus();
            for (i = 0; i < KeysPressedBuffer.length; i += 1) {
                if (KeysPressedBuffer[i] !== undefined) {
                    KeysPressed[i] = KeysPressedBuffer[i];
                    KeysPressedBuffer[i] = false
                }
            }
            for (i = 0; i < KeysHeldBuffer.length; i += 1) {
                if (KeysHeldBuffer[i] !== undefined) {
                    KeysHeld[i] = KeysHeldBuffer[i];
                    if (NotFocussed) {
                        KeysHeldBuffer[i] = false
                    }
                    KeysHeldBuffer[i] = undefined
                }
            }
            for (i = 0; i < PadButtonsPressedBuffer.length; i += 1) {
                if (PadButtonsPressedBuffer[i] !== undefined) {
                    PadButtonsPressed[i] = PadButtonsPressedBuffer[i];
                    PadButtonsPressedBuffer[i] = false
                }
            }
            for (i = 0; i < PadButtonsHeldBuffer.length; i += 1) {
                if (PadButtonsHeldBuffer[i] !== undefined) {
                    PadButtonsHeld[i] = PadButtonsHeldBuffer[i];
                    if (NotFocussed) {
                        PadButtonsHeldBuffer[i] = false
                    }
                }
            }
            for (i = 0; i < 3; i += 1) {
                PadX[i] = PadXBuffer[i];
                PadY[i] = PadYBuffer[i];
                PadMoveX[i] = PadMoveXBuffer[i];
                PadMoveY[i] = PadMoveYBuffer[i];
                PadMoveXBuffer[i] = 0;
                PadMoveYBuffer[i] = 0
            }
            MouseX = MouseXBuffer;
            MouseY = MouseYBuffer;
            MouseZ = MouseZBuffer;
            MouseMoveX = MouseMoveXBuffer;
            MouseMoveY = MouseMoveYBuffer;
            MouseMoveXBuffer = 0;
            MouseMoveYBuffer = 0;
            MouseZBuffer = 0;
            for (i = 0; i < 2; i += 1) {
                MouseButtonHeld[i] = MouseButtonHeldBuffer[i];
                if (NotFocussed) {
                    MouseButtonHeldBuffer[i] = false
                }
                MouseButtonPressed[i] = MouseButtonPressedBuffer[i];
                MouseButtonPressedBuffer[i] = false;
                MouseButtonReleased[i] = MouseButtonReleasedBuffer[i];
                MouseButtonReleasedBuffer[i] = false
            }
            for (i = 0; i < TouchHeldBuffer.length; i += 1) {
                TouchX[i] = TouchXBuffer[i];
                TouchY[i] = TouchYBuffer[i];
                TouchMoveX[i] = TouchMoveXBuffer[i];
                TouchMoveY[i] = TouchMoveYBuffer[i];
                TouchMoveXBuffer[i] = 0;
                TouchMoveYBuffer[i] = 0;
                TouchHeld[i] = TouchHeldBuffer[i];
                TouchPressed[i] = TouchPressedBuffer[i];
                TouchPressedBuffer[i] = false;
                TouchReleased[i] = TouchReleasedBuffer[i];
                TouchReleasedBuffer[i] = false
            }
            MyInputManager.update()
        }

        function initFn() {
            MouseXBuffer = 0;
            MouseX = 0;
            MouseYBuffer = 0;
            MouseY = 0;
            MouseZBuffer = 0;
            MouseZ = 0;
            MouseMoveXBuffer = 0;
            MouseMoveX = 0;
            MouseMoveYBuffer = 0;
            MouseMoveY = 0;
            Focus = false;
            MouseButtonPressedBuffer = [];
            MouseButtonPressedBuffer[0] = false;
            MouseButtonPressedBuffer[1] = false;
            MouseButtonPressed = [];
            MouseButtonHeldBuffer = [];
            MouseButtonHeldBuffer[0] = false;
            MouseButtonHeldBuffer[1] = false;
            MouseButtonHeld = [];
            MouseButtonReleasedBuffer = [];
            MouseButtonReleasedBuffer[0] = false;
            MouseButtonReleasedBuffer[1] = false;
            MouseButtonReleased = [];
            KeysHeld = [];
            KeysHeldBuffer = [];
            KeysPressed = [];
            KeysPressedBuffer = [];
            PadXBuffer = [];
            PadX = [];
            PadYBuffer = [];
            PadY = [];
            PadMoveXBuffer = [];
            PadMoveX = [];
            PadMoveYBuffer = [];
            PadMoveY = [];
            var i;
            for (i = 0; i < 3; i += 1) {
                PadXBuffer[i] = 0;
                PadX[i] = 0;
                PadYBuffer[i] = 0;
                PadY[i] = 0;
                PadMoveXBuffer[i] = 0;
                PadMoveX[i] = 0;
                PadMoveYBuffer[i] = 0;
                PadMoveY[i] = 0
            }
            PadButtonsHeld = [];
            PadButtonsHeldBuffer = [];
            PadButtonsPressed = [];
            PadButtonsPressedBuffer = [];
            TouchX = [];
            TouchY = [];
            TouchXBuffer = [];
            TouchYBuffer = [];
            TouchMoveX = [];
            TouchMoveY = [];
            TouchMoveXBuffer = [];
            TouchMoveYBuffer = [];
            TouchHeld = [];
            TouchHeldBuffer = [];
            TouchPressed = [];
            TouchPressedBuffer = [];
            TouchReleased = [];
            TouchReleasedBuffer = [];
            TouchMapping = {};
            TouchMapped = [];
            for (i = 0; i < 10; i += 1) {
                TouchX[i] = 0;
                TouchY[i] = 0;
                TouchXBuffer[i] = 0;
                TouchYBuffer[i] = 0;
                TouchMoveX[i] = 0;
                TouchMoveY[i] = 0;
                TouchMoveXBuffer[i] = 0;
                TouchMoveYBuffer[i] = 0;
                TouchHeld[i] = 0;
                TouchHeldBuffer[i] = 0;
                TouchPressed[i] = 0;
                TouchPressedBuffer[i] = 0;
                TouchReleased[i] = 0;
                TouchReleasedBuffer[i] = 0;
                TouchMapped[i] = false
            }
            var TurbulenzInputDeviceParameters = {};
            MyInputManager = TurbulenzEngine.createInputDevice(TurbulenzInputDeviceParameters);
            MyInputManager.addEventListener("keydown", TurbulenzonkeydownFn);
            MyInputManager.addEventListener("keyup", TurbulenzonkeyupFn);
            MyInputManager.addEventListener("mousedown", TurbulenzonmousedownFn);
            MyInputManager.addEventListener("mouseup", TurbulenzonmouseupFn);
            MyInputManager.addEventListener("mousemove", TurbulenzonmousemoveFn);
            MyInputManager.addEventListener("mouseover", TurbulenzonmouseoverFn);
            MyInputManager.addEventListener("mousewheel", TurbulenzonmousewheelFn);
            MyInputManager.addEventListener("mouseleave", TurbulenzonmouseleaveFn);
            MyInputManager.addEventListener("mouseenter", TurbulenzonmouseenterFn);
            MyInputManager.addEventListener("padup", TurbulenzonpadupFn);
            MyInputManager.addEventListener("paddown", TurbulenzonpaddownFn);
            MyInputManager.addEventListener("padmove", TurbulenzonpadmoveFn);
            MyInputManager.addEventListener("focus", TurbulenzonfocusFn);
            MyInputManager.addEventListener("blur", TurbulenzonblurFn);
            MyInputManager.addEventListener("touchstart", TurbulenzontouchstartFn);
            MyInputManager.addEventListener("touchend", TurbulenzontouchendFn);
            MyInputManager.addEventListener("touchmove", TurbulenzontouchmoveFn);
            var FullKeyCodeArray = [];
            FullKeyCodeArray[0] = MyInputManager.keyCodes.A;
            FullKeyCodeArray[1] = MyInputManager.keyCodes.B;
            FullKeyCodeArray[2] = MyInputManager.keyCodes.C;
            FullKeyCodeArray[3] = MyInputManager.keyCodes.D;
            FullKeyCodeArray[4] = MyInputManager.keyCodes.E;
            FullKeyCodeArray[5] = MyInputManager.keyCodes.F;
            FullKeyCodeArray[6] = MyInputManager.keyCodes.G;
            FullKeyCodeArray[7] = MyInputManager.keyCodes.H;
            FullKeyCodeArray[8] = MyInputManager.keyCodes.I;
            FullKeyCodeArray[9] = MyInputManager.keyCodes.J;
            FullKeyCodeArray[10] = MyInputManager.keyCodes.K;
            FullKeyCodeArray[11] = MyInputManager.keyCodes.L;
            FullKeyCodeArray[12] = MyInputManager.keyCodes.M;
            FullKeyCodeArray[13] = MyInputManager.keyCodes.N;
            FullKeyCodeArray[14] = MyInputManager.keyCodes.O;
            FullKeyCodeArray[15] = MyInputManager.keyCodes.P;
            FullKeyCodeArray[16] = MyInputManager.keyCodes.Q;
            FullKeyCodeArray[17] = MyInputManager.keyCodes.R;
            FullKeyCodeArray[18] = MyInputManager.keyCodes.S;
            FullKeyCodeArray[19] = MyInputManager.keyCodes.T;
            FullKeyCodeArray[20] = MyInputManager.keyCodes.U;
            FullKeyCodeArray[21] = MyInputManager.keyCodes.V;
            FullKeyCodeArray[22] = MyInputManager.keyCodes.W;
            FullKeyCodeArray[23] = MyInputManager.keyCodes.X;
            FullKeyCodeArray[24] = MyInputManager.keyCodes.Y;
            FullKeyCodeArray[25] = MyInputManager.keyCodes.Z;
            FullKeyCodeArray[26] = MyInputManager.keyCodes.NUMBER_0;
            FullKeyCodeArray[27] = MyInputManager.keyCodes.NUMBER_1;
            FullKeyCodeArray[28] = MyInputManager.keyCodes.NUMBER_2;
            FullKeyCodeArray[29] = MyInputManager.keyCodes.NUMBER_3;
            FullKeyCodeArray[30] = MyInputManager.keyCodes.NUMBER_4;
            FullKeyCodeArray[31] = MyInputManager.keyCodes.NUMBER_5;
            FullKeyCodeArray[32] = MyInputManager.keyCodes.NUMBER_6;
            FullKeyCodeArray[33] = MyInputManager.keyCodes.NUMBER_7;
            FullKeyCodeArray[34] = MyInputManager.keyCodes.NUMBER_8;
            FullKeyCodeArray[35] = MyInputManager.keyCodes.NUMBER_9;
            FullKeyCodeArray[36] = MyInputManager.keyCodes.SPACE;
            FullKeyCodeArray[37] = MyInputManager.keyCodes.BACKSPACE;
            FullKeyCodeArray[38] = MyInputManager.keyCodes.COMMA;
            FullKeyCodeArray[39] = MyInputManager.keyCodes.APOSTROPHE;
            FullKeyCodeArray[40] = MyInputManager.keyCodes.SEMI_COLON;
            FullKeyCodeArray[41] = MyInputManager.keyCodes.RETURN;
            FullKeyCodeArray[42] = MyInputManager.keyCodes.PERIOD;
            FullKeyCodeArray[43] = MyInputManager.keyCodes.LEFT_SHIFT;
            FullKeyCodeArray[44] = MyInputManager.keyCodes.RIGHT_SHIFT;
            FullKeyCodeArray[45] = MyInputManager.keyCodes.LEFT_CONTROL;
            FullKeyCodeArray[46] = MyInputManager.keyCodes.RIGHT_CONTROL;
            FullKeyCodeArray[47] = MyInputManager.keyCodes.LEFT_ALT;
            FullKeyCodeArray[48] = MyInputManager.keyCodes.RIGHT_ALT;
            FullKeyCodeArray[49] = MyInputManager.keyCodes.MINUS;
            FullKeyCodeArray[50] = MyInputManager.keyCodes.EQUALS;
            FullKeyCodeArray[51] = MyInputManager.keyCodes.NUMPAD_0;
            FullKeyCodeArray[52] = MyInputManager.keyCodes.NUMPAD_1;
            FullKeyCodeArray[53] = MyInputManager.keyCodes.NUMPAD_2;
            FullKeyCodeArray[54] = MyInputManager.keyCodes.NUMPAD_3;
            FullKeyCodeArray[55] = MyInputManager.keyCodes.NUMPAD_4;
            FullKeyCodeArray[56] = MyInputManager.keyCodes.NUMPAD_5;
            FullKeyCodeArray[57] = MyInputManager.keyCodes.NUMPAD_6;
            FullKeyCodeArray[58] = MyInputManager.keyCodes.NUMPAD_7;
            FullKeyCodeArray[59] = MyInputManager.keyCodes.NUMPAD_8;
            FullKeyCodeArray[60] = MyInputManager.keyCodes.NUMPAD_9;
            FullKeyCodeArray[61] = MyInputManager.keyCodes.NUMPAD_ENTER;
            FullKeyCodeArray[62] = MyInputManager.keyCodes.NUMPAD_ADD;
            FullKeyCodeArray[63] = MyInputManager.keyCodes.NUMPAD_SUBTRACT;
            FullKeyCodeArray[64] = MyInputManager.keyCodes.DELETE;
            FullKeyCodeArray[65] = MyInputManager.keyCodes.ESCAPE;
            FullKeyCodeArray[66] = MyInputManager.keyCodes.BACK;
            UnicodeCharacters = MyInputManager.convertToUnicode(FullKeyCodeArray)
        }

        function DestroyFn() {}
        initFn();
        var NewObject = new JamInputManager;
        NewObject.GetKeyPressed = GetKeyPressedFn;
        NewObject.GetKeyValue = GetKeyUnicodeFn;
        NewObject.GetBackPressed = GetBackPressedFn;
        NewObject.GetAnyKey = GetAnyKeyFn;
        NewObject.GetAnyKeyAvailable = GetAnyKeyAvailableFn;
        NewObject.GetKeyHeld = GetKeyHeldFn;
        NewObject.GetMouseButtonPressed = GetMouseButtonPressedFn;
        NewObject.GetMouseLeftScreen = GetMouseLeftScreenFn;
        NewObject.GetMouseButtonHeld = GetMouseButtonHeldFn;
        NewObject.GetMouseButtonReleased = GetMouseButtonReleasedFn;
        NewObject.GetMouseX = GetMouseXFn;
        NewObject.GetMouseY = GetMouseYFn;
        NewObject.GetMouseZ = GetMouseZFn;
        NewObject.GetMouseMoveX = GetMouseMoveXFn;
        NewObject.GetMouseMoveY = GetMouseMoveYFn;
        NewObject.GetIsInFocus = GetIsInFocusFn;
        NewObject.GetPadX = GetPadXFn;
        NewObject.GetPadY = GetPadYFn;
        NewObject.GetPadButtonHeld = GetPadButtonHeldFn;
        NewObject.GetPadButtonPressed = GetPadButtonPressedFn;
        NewObject.IsCapsLockOn = IsCapsLockOnFn;
        NewObject.LockMouse = TurbulenzLockFn;
        NewObject.IsMouseLocked = TurbulenzIsLockedFn;
        NewObject.GetTouchButtonPressed = GetTouchPressedFn;
        NewObject.GetTouchButtonHeld = GetTouchHeldFn;
        NewObject.GetTouchButtonReleased = GetTouchReleasedFn;
        NewObject.GetTouchX = GetTouchXFn;
        NewObject.GetTouchY = GetTouchYFn;
        NewObject.GetTouchMoveX = GetTouchMoveXFn;
        NewObject.GetTouchMoveY = GetTouchMoveYFn;
        NewObject.Update = UpdateFn;
        NewObject.Destroy = DestroyFn;
        return NewObject
    };

    function File() {}
    File.prototype = {};
    File.OnLoad = function FileOnLoad() {
        var ThisFile = this.File;
        if (this.response) {
            Debug.Log("File Loading Success : " + ThisFile.pszFileName);
            ThisFile.bFinished = true;
            ThisFile.bSuccess = true;
            if (ThisFile.pszFileName.substring(ThisFile.pszFileName.length - 3) !== "xml") {
                ThisFile.psData = this.response
            } else {
                ThisFile.psData = this.responseXML
            }
            ThisFile.iDataSize = this.response.length;
            if (ThisFile.psCallBack) {
                ThisFile.psCallBack(ThisFile.psData, ThisFile.iDataSize, ThisFile.psCallBackData)
            }
        } else {
            Debug.Log("**** File Loading Failed : " + ThisFile.pszFileName);
            ThisFile.bFinished = true;
            if (ThisFile.psCallBack) {
                ThisFile.psCallBack(null, 0, ThisFile.psCallBackData)
            }
        }
    };
    File.Load = function FileLoadFn(pszFileName, psCallBack, psCallBackData, AbsolutePath) {
        var NewObject = new File;
        NewObject.bFinished = false;
        NewObject.bSuccess = false;
        NewObject.psData = 0;
        NewObject.iDataSize = 0;
        NewObject.pszFileName = pszFileName;
        NewObject.psCallBack = psCallBack;
        NewObject.psCallBackData = psCallBackData;
        if (!AbsolutePath) {
            var TurbulenzMappingTable = JamSystem.TurbulenzMappingTable;
            var pszOldFileName = pszFileName;
            pszFileName = TurbulenzMappingTable.urlMapping[pszFileName];
            if (pszFileName === undefined) {
                Debug.Log("**** Unable to find file " + pszOldFileName + " in mapping table");
                if (psCallBack) {
                    psCallBack(null, 0, psCallBackData)
                }
                return
            }
        }
        if (pszFileName.substring(pszFileName.length - 3) !== "bin" && pszFileName.substring(pszFileName.length - 3) !== "xml") {
            var onLoadedData = function onLoadedDataFn(responseText, status) {
                if (responseText && status === 200) {
                    Debug.Log("File Loading Success : " + pszFileName);
                    NewObject.bFinished = true;
                    NewObject.bSuccess = true;
                    NewObject.psData = responseText;
                    NewObject.iDataSize = responseText.length;
                    if (psCallBack) {
                        psCallBack(NewObject.psData, NewObject.iDataSize, psCallBackData)
                    }
                } else {
                    Debug.Log("**** File Loading Failed : " + pszFileName);
                    NewObject.bFinished = true;
                    if (psCallBack) {
                        psCallBack(null, 0, psCallBackData)
                    }
                }
            };
            Debug.Log("File Load : " + pszFileName);
            TurbulenzEngine.request(pszFileName, onLoadedData)
        } else {
            NewObject.xhr = new window.XMLHttpRequest;
            NewObject.xhr.open("GET", pszFileName, false);
            if (pszFileName.substring(pszFileName.length - 3) !== "xml" && NewObject.xhr.overrideMimeType) {
                NewObject.xhr.overrideMimeType("text/plain; charset=x-user-defined")
            }
            Debug.Log("File Load : " + pszFileName);
            NewObject.xhr.File = NewObject;
            NewObject.xhr.onload = File.OnLoad;
            NewObject.xhr.send()
        }
        return NewObject
    };
    File.Save = function FileSaveFn(FileName, Data, AbsolutePath) {
        var NewObject = new File;
        NewObject.bFinished = false;
        NewObject.bSuccess = false;
        if (AbsolutePath === undefined) {
            var TurbulenzMappingTable = JamSystem.TurbulenzMappingTable;
            FileName = TurbulenzMappingTable.urlMapping[FileName]
        }
        var FinalName = "http://127.0.0.1:8070/local/v1/save/" + JamSystem.TurbulenzGameSlug + "/" + FileName;
        NewObject.xhr = new window.XMLHttpRequest;
        NewObject.xhr.open("POST", FinalName, true);
        NewObject.xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
        NewObject.xhr.Handler = NewObject;
        NewObject.xhr.onreadystatechange = function() {
            if (this.readyState === 4) {
                this.Handler.bFinished = true;
                this.Handler.bSuccess = false;
                if (this.status === 200) {
                    if (this.responseText !== null) {
                        this.Handler.bSuccess = true
                    } else {
                        Debug.Assert(false, "Ajax error: No data received")
                    }
                } else {
                    Debug.Assert(false, "Ajax error: " + this.statusText)
                }
            }
        };
        var params = "content=" + Data;
        NewObject.xhr.send(params);
        return NewObject
    };

    function FrameInstance() {}
    FrameInstance.prototype = {};
    FrameInstance.Create = function FrameInstanceCreate() {
        var NewFrameInstance = new FrameInstance;
        NewFrameInstance.PageIndex = 0;
        NewFrameInstance.Width = 0;
        NewFrameInstance.Height = 0;
        NewFrameInstance.u = 0;
        NewFrameInstance.v = 0;
        return NewFrameInstance
    };

    function JamTexture() {}
    JamTexture.prototype = {
        GetFrameIndexFromName: function GetFrameIndexFromNameFn(FrameName) {
            if (this.Ready) {
                return this.FrameNames.indexOf(FrameName)
            }
            return -1
        },
        GetFrameNameFromIndex: function GetFrameNameFromIndexFn(Index) {
            if (this.Ready) {
                return this.FrameNames[Index]
            }
            return -1
        },
        GetFrame: function GetFrame(FrameIndex) {
            if (this.Ready) {
                return this.Frames[FrameIndex]
            }
            return null
        },
        GetPixelInFrame: function GetPixelInFrame(FrameIndex, u, v) {
            var frame = this.Frames[FrameIndex];
            var PixelData = this.ImageData[frame.PageIndex];
            var Image = this.Images[frame.PageIndex];
            var FinalOffset = (Math.floor(v) + frame.v) * Image.width + (Math.floor(u) + frame.u);
            if (this.LoadDataPacked) {
                var OffsetPacked = Math.floor(FinalOffset / 8);
                var OffsetBitMask = 1 << FinalOffset - OffsetPacked * 8;
                var PackedByte = PixelData.charCodeAt(OffsetPacked);
                var FinalBit = PackedByte & OffsetBitMask;
                if (FinalBit) {
                    return true
                }
                return false
            } else {
                var Pixel = PixelData[FinalOffset];
                return Pixel
            }
        },
        GetImage: function GetImageFn(FrameIndex) {
            var frame = this.Frames[FrameIndex];
            return this.Images[frame.PageIndex]
        },
        SetImages: function SetImagesFn(Frames, FrameNames, Images, ImageDataFiles) {
            this.Frames = Frames;
            this.FrameNames = FrameNames;
            this.Images = Images;
            this.ImageDataFiles = ImageDataFiles;
            this.Ready = true
        },
        FinaliseFrames: function FinaliseFramesFn() {
            var i;
            for (i = 0; i < this.Frames.length; i += 1) {
                var ThisFrame = this.Frames[i];
                var texture = this.Images[ThisFrame.PageIndex];
                if (!texture.width) {
                    i = i
                }
                ThisFrame.tx = ThisFrame.u / texture.width;
                ThisFrame.ty = ThisFrame.v / texture.height;
                ThisFrame.tx2 = ThisFrame.tx + ThisFrame.Width / texture.width;
                ThisFrame.ty2 = ThisFrame.ty + ThisFrame.Height / texture.height
            }
        },
        SetNumImages: function SetNumImagesFn(iNumImages) {
            var i;
            for (i = 0; i < iNumImages; i += 1) {
                this.ImageLoaded[i] = false
            }
            this.FilesLeft = iNumImages
        },
        TextureLoaded: function TextureLoadedFn(psTexture) {
            var j;
            for (j = 0; j < this.Images.length; j += 1) {
                if (this.Images[j] === psTexture) {
                    this.ImageLoaded[j] = true;
                    this.FilesLeft -= 1;
                    if (!this.FilesLeft) {
                        this.FinaliseFrames()
                    }
                    return
                }
            }
        }
    };
    JamTexture.Create = function JamTextureCreate(FileName, Index, DDS) {
        var textureInstance = new JamTexture;
        textureInstance.Frames = 0;
        textureInstance.FrameNames = 0;
        textureInstance.Images = [];
        textureInstance.ImageLoaded = [];
        textureInstance.FilesLeft = 0;
        textureInstance.ImageDataFiles = 0;
        textureInstance.ImageData = [];
        textureInstance.FileName = FileName;
        textureInstance.File = 0;
        textureInstance.LoadData = false;
        textureInstance.LoadDataPacked = false;
        textureInstance.Ready = false;
        textureInstance.Index = Index;
        textureInstance.DDS = DDS;
        return textureInstance
    };

    function TextureFrameInfo() {}
    TextureFrameInfo.prototype = {};

    function SoundBankInfo() {}
    SoundBankInfo.prototype = {};

    function AssetManager() {}
    AssetManager.prototype = {};
    AssetManager.Create = function AssetManagerCreateFn(graphicsDevice, soundDevice, mathDevice, requestHandler, errorCallback, log) {
        var Textures;
        var JamPacksRemaining;
        var TexturesRemaining;
        var ImageDataRemaining;
        var TextureInfo;
        var TextureIndex;
        var TexturesLoaded;
        var UseDDS;
        var Shaders;
        var ShadersRemaining;
        var SoundBanks;
        var SoundBanksRemaining;
        var Fonts;
        var TextRemaining;
        var AudioInfoRemaining;
        var TurbulenzTextureManager;
        var TurbulenzShaderManager;
        var TurbulenzMappingTable;

        function UpdateMappingFn(newMappingTable) {
            TurbulenzMappingTable = newMappingTable;
            TurbulenzTextureManager.setPathRemapping(TurbulenzMappingTable.urlMapping, TurbulenzMappingTable.assetPrefix);
            TurbulenzShaderManager.setPathRemapping(TurbulenzMappingTable.urlMapping, TurbulenzMappingTable.assetPrefix)
        }

        function TextureLoadedFn(psTexture) {
            Debug.Log("Texture loaded : ", psTexture.name);
            TexturesLoaded[TexturesLoaded.length] = psTexture
        }

        function ImageDataLoaded(psData, iDataSize, psTextureInfo) {
            if (psData) {
                var Texture = psTextureInfo[0];
                var ImageIndex = psTextureInfo[1];
                Texture.ImageData[ImageIndex] = psData
            }
        }

        function ProcessJamPackFn(psData, iDataSize, psTexture) {
            var i;
            Debug.Log("FileProcessJamPack : " + psTexture.FileName);
            JamPacksRemaining -= 1;
            if (psData === null) {
                return
            }
            var JSONObject = JSON.parse(psData);
            var iNumImages = JSONObject.images;
            var NumFrames = JSONObject.frames.length;
            var Frames = [];
            var Names = [];
            for (i = 0; i < NumFrames; i += 1) {
                var NewFrame = FrameInstance.Create();
                NewFrame.PageIndex = JSONObject.frames[i].image;
                NewFrame.Width = JSONObject.frames[i].width;
                NewFrame.Height = JSONObject.frames[i].height;
                NewFrame.u = JSONObject.frames[i].u;
                NewFrame.v = JSONObject.frames[i].v;
                Names[i] = JSONObject.frames[i].name;
                Frames[i] = NewFrame
            }
            psTexture.SetNumImages(iNumImages);
            var Images = [];
            var ImageDataFiles = [];
            for (i = 0; i < iNumImages; i += 1) {
                var Extension = ".png";
                if (psTexture.DDS) {
                    Extension = ".dds"
                }
                if (i < 10) {
                    var FileName = psTexture.FileName.substring(0, psTexture.FileName.length - 5) + "0" + i + Extension
                } else {
                    var FileName = psTexture.FileName.substring(0, psTexture.FileName.length - 5) + i + Extension
                }
                var loadTextureParameters = {
                    src: TurbulenzMappingTable.getURL(FileName),
                    mipmaps: false,
                    onload: TextureLoadedFn
                };
                TexturesRemaining += 1;
                Images[i] = graphicsDevice.createTexture(loadTextureParameters);
                if (psTexture.LoadData) {
                    FileName = psTexture.FileName.substring(0, psTexture.FileName.length - 5) + "0" + i + ".bin";
                    ImageDataFiles[i] = File.Load(FileName, ImageDataLoaded, [psTexture, i], false)
                }
            }
            psTexture.SetImages(Frames, Names, Images, ImageDataFiles)
        }
        var ShaderLoaded = function ShaderLoadedFn(shaderText) {
            Debug.Log("Shader loaded");
            ShadersRemaining -= 1;
            if (shaderText) {
                var shaderParameters = JSON.parse(shaderText);
                Shaders[Shaders.length] = graphicsDevice.createShader(shaderParameters)
            }
        };

        function ProcessTextFn(psData, iDataSize, FileName) {
            Debug.Log("ProcessText : " + FileName);
            var JSONObject = JSON.parse(psData);
            JamSystem.TextManager.AddText(JSONObject);
            TextRemaining -= 1
        }

        function ProcessAudioInfoFn(psData, iDataSize, FileName) {
            Debug.Log("ProcessAudioInfo : " + FileName);
            var JSONObject = JSON.parse(psData);
            JamSystem.SoundManager.SetAudioInfo(JSONObject);
            AudioInfoRemaining -= 1
        }

        function initFn() {
            Textures = [];
            JamPacksRemaining = 0;
            TexturesRemaining = 0;
            ImageDataRemaining = 0;
            TextureInfo = [];
            TextureIndex = 0;
            TexturesLoaded = [];
            UseDDS = false;
            Shaders = [];
            ShadersRemaining = 0;
            Fonts = [];
            SoundBanks = [];
            SoundBanksRemaining = 0;
            TextRemaining = 0;
            AudioInfoRemaining = 0;
            TurbulenzTextureManager = TextureManager.create(graphicsDevice, requestHandler, null, errorCallback);
            TurbulenzShaderManager = ShaderManager.create(graphicsDevice, requestHandler, null, errorCallback)
        }

        function DestroyFn() {
            TurbulenzTextureManager.destroy();
            TurbulenzTextureManager = 0;
            TurbulenzShaderManager.destroy();
            TurbulenzShaderManager = 0;
            var i, j;
            for (i = 0; i < Textures.length; i += 1) {
                for (j = 0; j < Textures[i].Images.length; j += 1) {
                    Textures[i].Images[j].destroy()
                }
            }
            for (i = 0; i < Shaders.length; i += 1) {
                Shaders[i].destroy()
            }
        }

        function SetUseDDSFn(NewUseDDS) {
            UseDDS = NewUseDDS
        }

        function LoadTextureFn(Name, LoadData, LoadDataPacked, DDS) {
            var OldTexture = Textures[Name];
            if (OldTexture) {
                return OldTexture
            }
            Debug.Log("AssetManager:LoadTexture ", Name);
            var NewTexture = JamTexture.Create(Name, TextureIndex, DDS | UseDDS);
            TextureIndex += 1;
            if (LoadData !== undefined) {
                NewTexture.LoadData = LoadData
            }
            if (LoadDataPacked !== undefined) {
                NewTexture.LoadDataPacked = LoadDataPacked
            }
            Textures[Name] = NewTexture;
            JamPacksRemaining += 1;
            NewTexture.File = File.Load(Name, ProcessJamPackFn, NewTexture, false);
            return NewTexture
        }

        function CreateTextureFn(Name, FrameName, TextureName) {
            var OldTexture = Textures[Name];
            if (OldTexture) {
                return OldTexture
            }
            Debug.Log("AssetManager:CreateTexture ", Name);
            var NewTexture = JamTexture.Create(Name, TextureIndex, false);
            TextureIndex += 1;
            Textures[Name] = NewTexture;
            var Frames = [];
            var NewFrame = FrameInstance.Create();
            NewFrame.PageIndex = 0;
            NewFrame.Width = 0;
            NewFrame.Height = 0;
            NewFrame.u = 0;
            NewFrame.v = 0;
            NewFrame.tx = 0;
            NewFrame.ty = 0;
            NewFrame.tx2 = 1;
            NewFrame.ty2 = 1;
            Frames[0] = NewFrame;
            var Images = [];
            var loadTextureParameters = {
                src: TurbulenzMappingTable.getURL(TextureName),
                mipmaps: false,
                onload: function TextureLoadedFn(psTexture) {
                    TexturesRemaining -= 1;
                    NewFrame.Width = psTexture.width;
                    NewFrame.Height = psTexture.height;
                    Debug.Log("Texture loaded : ", psTexture.name)
                }
            };
            TexturesRemaining += 1;
            Images[0] = graphicsDevice.createTexture(loadTextureParameters);
            var Names = [FrameName];
            NewTexture.SetImages(Frames, Names, Images, null);
            return NewTexture
        }

        function DestroyTextureFn(Name) {
            if (Textures[Name]) {
                delete Textures[Name]
            }
        }

        function GetTextureFn(Name) {
            var i;
            for (i in Textures) {
                if (Textures.hasOwnProperty(i)) {
                    var SubName = i.substring(i.length - 5 - Name.length, i.length - 5);
                    if (SubName === Name) {
                        return Textures[i]
                    }
                }
            }
            Debug.Log("**** AssetManager.GetTextureFn failed : ", Name);
            return null
        }

        function GetTextureInfoFromImageNameFn(ImageName) {
            var i;
            for (i in Textures) {
                if (Textures.hasOwnProperty(i)) {
                    var texture = Textures[i];
                    var Frame = texture.GetFrameIndexFromName(ImageName);
                    if (Frame !== -1) {
                        var NewInfo = new TextureFrameInfo;
                        NewInfo.Texture = texture;
                        NewInfo.Frame = Frame;
                        return NewInfo
                    }
                }
            }
            Debug.Log("**** AssetManager.GetTextureFromImageName failed : ", ImageName);
            return null
        }

        function LoadShaderFn(filename) {
            Debug.Log("Load Shader " + filename);
            ShadersRemaining += 1;
            TurbulenzEngine.request(TurbulenzMappingTable.getURL(filename), ShaderLoaded)
        }

        function GetShaderFn(techniquename) {
            var i;
            for (i = 0; i < Shaders.length; i += 1) {
                var technique = Shaders[i].getTechnique(techniquename);
                if (technique) {
                    return technique
                }
            }
            return 0
        }

        function LoadSoundBankFn(FileName, Uncompress) {
            if (soundDevice === null) {
                return null
            }
            if (!soundDevice.isSupported("FILEFORMAT_OGG")) {
                if (!soundDevice.isSupported("FILEFORMAT_MP3")) {
                    return null
                }
                FileName = FileName.substring(0, FileName.length - 4) + "MP3.tar"
            }
            var OldBank = SoundBanks[FileName];
            if (OldBank) {
                return OldBank
            }
            Debug.Log("AssetManager:LoadSoundBank ", FileName);
            var NewBank = SoundBank.Create(FileName);
            SoundBanks[FileName] = NewBank;
            SoundBanksRemaining += 1;
            var SoundArchiveParams = {
                src: JamSystem.TurbulenzMappingTable.getURL(FileName),
                uncompress: Uncompress,
                onsoundload: function(sound) {
                    if (sound) {
                        NewBank.Sounds[NewBank.Sounds.length] = sound;
                        NewBank.Names[NewBank.Names.length] = sound.name
                    }
                },
                onload: function(success, status) {
                    SoundBanksRemaining -= 1;
                    if (!success) {
                        Debug.Log("**** " + FileName + " sound bank failed to load : " + status)
                    } else {
                        Debug.Log(FileName + " sound bank loaded")
                    }
                }
            };
            soundDevice.loadSoundsArchive(SoundArchiveParams);
            return NewBank
        }

        function CreateSoundBankFn(FileName) {
            if (soundDevice === null) {
                return null
            }
            if (!soundDevice.isSupported("FILEFORMAT_OGG")) {
                if (!soundDevice.isSupported("FILEFORMAT_MP3")) {
                    return null
                }
                FileName = FileName.substring(0, FileName.length - 3) + "mp3"
            }
            var OldBank = SoundBanks[FileName];
            if (OldBank) {
                return OldBank
            }
            Debug.Log("AssetManager:CreateSoundBank ", FileName);
            var NewBank = SoundBank.Create(FileName);
            SoundBanks[FileName] = NewBank;
            var soundLoaded = function soundLoadedFn(loadedSound, status) {
                if (status === 200) {
                    NewBank.Sounds[NewBank.Sounds.length] = loadedSound;
                    NewBank.Names[NewBank.Names.length] = FileName;
                    Debug.Log(FileName + " sound loaded")
                } else {
                    Debug.Log("**** " + FileName + " sound failed to load : " + status)
                }
                SoundBanksRemaining -= 1
            };
            SoundBanksRemaining += 1;
            var FinalFileName = JamSystem.TurbulenzMappingTable.getURL(FileName);
            soundDevice.createSound({
                src: FinalFileName,
                uncompress: false,
                onload: soundLoaded
            })
        }

        function DestroySoundBankFn(FileName) {
            if (SoundBanks[FileName]) {
                delete SoundBanks[FileName]
            }
        }

        function DoesSoundBankExistFn(FileName) {
            if (SoundBanks[FileName]) {
                return true
            }
            return false
        }

        function GetSoundInfoFromSoundNameFn(SoundName) {
            var i;
            for (i in SoundBanks) {
                if (SoundBanks.hasOwnProperty(i)) {
                    var Bank = SoundBanks[i];
                    var Index = Bank.GetSoundIndexFromName(SoundName);
                    if (Index !== -1) {
                        var NewInfo = new SoundBankInfo;
                        NewInfo.Bank = Bank;
                        NewInfo.Index = Index;
                        return NewInfo
                    }
                }
            }
            return null
        }

        function CreateBitmapFontFn(FontName, TextureName, CharToImageTable, CharSpacing, LineSpacing, DefaultChar, Scale) {
            var Texture = LoadTextureFn(TextureName);
            var Font = BitmapFont.Create(FontName, Texture, CharToImageTable, CharSpacing, LineSpacing, DefaultChar, Scale);
            Fonts[FontName] = Font;
            return Font
        }

        function DestroyBitmapFontFn(FontName) {
            if (Fonts[FontName]) {
                delete Fonts[FontName]
            }
        }

        function GetBitmapFontFn(FontName) {
            if (Fonts[FontName]) {
                return Fonts[FontName]
            }
            Debug.Log("AssetManager.GetBitmapFont : ", FontName);
            return null
        }

        function LoadTextFn(Name, AbsolutePath) {
            Debug.Log("AssetManager:LoadText ", Name);
            TextRemaining += 1;
            File.Load(Name, ProcessTextFn, Name, AbsolutePath)
        }

        function LoadAudioInfoFn(Name, AbsolutePath) {
            Debug.Log("AssetManager:LoadAudioInfo ", Name);
            AudioInfoRemaining += 1;
            File.Load(Name, ProcessAudioInfoFn, Name, AbsolutePath)
        }

        function GetTexturesLeftFn() {
            return TexturesRemaining;
            var Left = 0;
            var i;
            for (i in Textures) {
                if (Textures.hasOwnProperty(i)) {
                    if (!Textures[i].Images || Textures[i].FilesLeft) {
                        Left += 1
                    }
                }
            }
            return Left
        }

        function GetSoundBanksLeftFn() {
            return SoundBanksRemaining
        }

        function GetIsAllLoadedFn() {
            if (ShadersRemaining) {
                return false
            }
            if (TexturesRemaining) {
                var i;
                for (i = 0; i < TexturesLoaded.length; i += 1) {
                    var Found = false;
                    var psTexture = TexturesLoaded[i];
                    var i;
                    for (i in Textures) {
                        if (Textures.hasOwnProperty(i)) {
                            var CurrentTexture = Textures[i];
                            var j;
                            for (j = 0; j < CurrentTexture.Images.length; j += 1) {
                                if (CurrentTexture.Images[j] === psTexture) {
                                    CurrentTexture.TextureLoaded(psTexture);
                                    TexturesLoaded.splice(TexturesLoaded.indexOf(psTexture), 1);
                                    TexturesRemaining -= 1;
                                    i -= 1;
                                    Found = true;
                                    break
                                }
                            }
                            if (Found) {
                                break
                            }
                        }
                    }
                }
                return false
            }
            if (ImageDataRemaining) {
                return false
            }
            if (JamPacksRemaining) {
                return false
            }
            if (SoundBanksRemaining) {
                return false
            }
            if (TextRemaining) {
                return false
            }
            if (AudioInfoRemaining) {
                return false
            }
            return true
        }
        initFn();
        var NewAssetManager = new AssetManager;
        NewAssetManager.SetUseDDS = SetUseDDSFn;
        NewAssetManager.LoadTexture = LoadTextureFn;
        NewAssetManager.CreateTexture = CreateTextureFn;
        NewAssetManager.DestroyTexture = DestroyTextureFn;
        NewAssetManager.GetTexture = GetTextureFn;
        NewAssetManager.GetTextureInfoFromImageName = GetTextureInfoFromImageNameFn;
        NewAssetManager.LoadShader = LoadShaderFn;
        NewAssetManager.GetShader = GetShaderFn;
        NewAssetManager.LoadSoundBank = LoadSoundBankFn;
        NewAssetManager.CreateSoundBank = CreateSoundBankFn;
        NewAssetManager.DestroySoundBank = DestroySoundBankFn;
        NewAssetManager.DoesSoundBankExist = DoesSoundBankExistFn;
        NewAssetManager.GetSoundInfoFromSoundName = GetSoundInfoFromSoundNameFn;
        NewAssetManager.CreateBitmapFont = CreateBitmapFontFn;
        NewAssetManager.DestroyBitmapFont = DestroyBitmapFontFn;
        NewAssetManager.GetBitmapFont = GetBitmapFontFn;
        NewAssetManager.LoadText = LoadTextFn;
        NewAssetManager.LoadAudioInfo = LoadAudioInfoFn;
        NewAssetManager.GetTexturesLeft = GetTexturesLeftFn;
        NewAssetManager.GetSoundBanksLeft = GetSoundBanksLeftFn;
        NewAssetManager.GetIsAllLoaded = GetIsAllLoadedFn;
        NewAssetManager.UpdateMapping = UpdateMappingFn;
        NewAssetManager.Destroy = DestroyFn;
        return NewAssetManager
    };

    function RenderTree() {}
    RenderTree.prototype = {
        AddChild: function AddChildFn(Child) {
            Child.SetParent(this);
            this.Children[this.Children.length] = Child
        },
        RemoveChild: function RemoveChildFn(Child) {
            var i;
            var Found;
            if (Child.Parent === this) {
                Found = false;
                for (i = 0; i < this.Children.length; i += 1) {
                    if (this.Children[i] === Child) {
                        this.Children.splice(i, 1);
                        Found = true;
                        break
                    }
                }
                Debug.Assert(Found, "Couldn't find child in parent object");
                Child.SetParent(null)
            } else {
                if (Child.Parent) {
                    Debug.Log("The child isn't attached to this")
                } else {
                    Debug.Log("No parent set")
                }
            }
        },
        GetIsAt: function GetIsAtFn(x, y) {
            var Local = new Vector2;
            Local.x = x;
            Local.y = y;
            Local.x -= this.x;
            Local.y -= this.y;
            var CosAngle = Math.cos(-this.Rotation);
            var SinAngle = Math.sin(-this.Rotation);
            var Rotated = new Vector2;
            Rotated.x = Local.x * CosAngle - Local.y * SinAngle;
            Rotated.y = Local.x * SinAngle + Local.y * CosAngle;
            var Scaled = new Vector2;
            Scaled.x = Rotated.x / this.ScaleX;
            Scaled.y = Rotated.y / this.ScaleY;
            var i;
            for (i = 0; i < this.Children.length; i += 1) {
                if (this.Children[i].GetIsAt(Scaled.x, Scaled.y)) {
                    return true
                }
            }
            return false
        },
        SetColour: function SetColourFn(Colour) {
            var i;
            for (i = 0; i < this.Children.length; i += 1) {
                this.Children[i].SetColour(Colour)
            }
        },
        GetWidth: function GetWidthFn(Colour) {
            var BestWidth = 0;
            var i;
            for (i = 0; i < this.Children.length; i += 1) {
                var TestWidth = this.Children[i].GetWidth();
                if (TestWidth > BestWidth) {
                    BestWidth = TestWidth
                }
            }
            return BestWidth
        },
        GetHeight: function GetHeightFn(Colour) {
            var BestHeight = 0;
            var i;
            for (i = 0; i < this.Children.length; i += 1) {
                var TestHeight = this.Children[i].GetHeight();
                if (TestHeight > BestHeight) {
                    BestHeight = TestHeight
                }
            }
            return BestHeight
        },
        SortChildrenByDepth: function SortChildrenByDepthFn(Up) {
            if (Up) {
                this.Children.sort(RenderTree.DepthSortUp)
            } else {
                this.Children.sort(RenderTree.DepthSortDown)
            }
        },
        UpdateMatrix: function UpdateMatrixFn() {
            var i;
            if (this.MatrixDirty) {
                this.MatrixDirty = false;
                var MathDevice = JamSystem.TurbulenzMathDevice;
                if (this.LocalMatrixDirty) {
                    MathDevice.quatFromAxisRotation(JamSystem.RenderManager.UpVector, this.Rotation, JamSystem.RenderManager.Quaternion);
                    MathDevice.v3Build(this.x, -this.y, 0, JamSystem.RenderManager.TranslationVector);
                    MathDevice.v3Build(this.ScaleX, this.ScaleY, 1, JamSystem.RenderManager.ScaleVector);
                    MathDevice.m43FromRTS(JamSystem.RenderManager.Quaternion, JamSystem.RenderManager.TranslationVector, JamSystem.RenderManager.ScaleVector, this.LocalMatrix);
                    this.LocalMatrixDirty = false
                }
                if (this.Parent) {
                    MathDevice.m43MulM44(this.LocalMatrix, this.Parent.GetMatrix(), this.Matrix)
                } else {
                    MathDevice.m43MulM44(this.LocalMatrix, JamSystem.RenderManager.TopMatrix, this.Matrix)
                }
                for (i = 0; i < this.Children.length; i += 1) {
                    this.Children[i].SetParentDirty()
                }
            }
        },
        Render: function RenderFn() {
            var i;
            if (this.bVisible) {
                this.UpdateMatrix();
                for (i = 0; i < this.Children.length; i += 1) {
                    this.Children[i].Render()
                }
            }
        },
        Destroy: function DestroyFn() {
            var i;
            for (i = 0; i < this.Children.length; i += 1) {
                this.Children[i].SetParent(null)
            }
            this.Children = [];
            Renderable.Destroy(this)
        }
    };
    RenderTree.DepthSortUp = function DepthSortUpFn(A, B) {
        return A.Depth - B.Depth
    };
    RenderTree.DepthSortDown = function DepthSortDownFn(A, B) {
        return B.Depth - A.Depth
    };
    RenderTree.Create = function RenderTreeCreate(x, y) {
        var NewTree = Renderable.Create(x, y);
        NewTree.AddChild = RenderTree.prototype.AddChild;
        NewTree.RemoveChild = RenderTree.prototype.RemoveChild;
        NewTree.GetIsAt = RenderTree.prototype.GetIsAt;
        NewTree.SetColour = RenderTree.prototype.SetColour;
        NewTree.SortChildrenByDepth = RenderTree.prototype.SortChildrenByDepth;
        NewTree.UpdateMatrix = RenderTree.prototype.UpdateMatrix;
        NewTree.Render = RenderTree.prototype.Render;
        NewTree.Children = [];
        return NewTree
    };

    function Misc() {}
    Misc.prototype = {};
    Misc.D = new Date;
    Misc.Seed = 2345678901 + Misc.D.getSeconds() * 16777215 + Misc.D.getMinutes() * 65535;
    Misc.A = 48271;
    Misc.M = 2147483647;
    Misc.Q = Misc.M / Misc.A;
    Misc.R = Misc.M % Misc.A;
    Misc.oneOverM = 1 / Misc.M;
    Misc.Random = function Random() {
        var hi = Misc.Seed / Misc.Q;
        var lo = Misc.Seed % Misc.Q;
        var test = Misc.A * lo - Misc.R * hi;
        if (test > 0) {
            Misc.Seed = test
        } else {
            Misc.Seed = test + Misc.M
        }
        return Misc.Seed * Misc.oneOverM
    };
    Misc.GetSeed = function GetSeed() {
        return Misc.Seed
    };
    Misc.SetSeed = function SetSeed(Seed) {
        Misc.Seed = Seed
    };
    Misc.InsertCommasIntoNumberString = function InsertCommasIntoNumberString(InString) {
        var NewString = "";
        if (InString.charAt(0) === "-") {
            NewString = "-";
            InString = InString.substring(1)
        }
        var Mod = 3 - InString.length % 3;
        var i;
        for (i = 0; i < InString.length; i += 1) {
            if (i && (i + Mod) % 3 === 0) {
                NewString += ","
            }
            NewString += InString.charAt(i)
        }
        return NewString
    };
    Misc.dateFormatMasks = {
        "default": "ddd mmm dd yyyy HH:MM:ss",
        shortDate: "m/d/yy",
        mediumDate: "mmm d, yyyy",
        longDate: "mmmm d, yyyy",
        fullDate: "dddd, mmmm d, yyyy",
        shortTime: "h:MM TT",
        mediumTime: "h:MM:ss TT",
        longTime: "h:MM:ss TT Z",
        isoDate: "yyyy-mm-dd",
        isoTime: "HH:MM:ss",
        isoDateTime: "yyyy-mm-dd'T'HH:MM:ss",
        isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
    };
    Misc.dateFormatI18n = {
        dayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        monthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
    };
    Misc.DateFormat = function DateFormatFn(date, mask, utc) {
        var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g,
            timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
            timezoneClip = /[^-+\dA-Z]/g,
            pad = function(val, len) {
                val = String(val);
                len = len || 2;
                while (val.length < len) {
                    val = "0" + val
                }
                return val
            };
        Debug.Log("Argh");
        if (arguments.length === 1 && Object.prototype.toString.call(date) === "[object String]" && !/\d/.test(date)) {
            mask = date;
            date = undefined
        }
        date = date ? new Date(date) : new Date;
        if (isNaN(date)) {
            throw SyntaxError("invalid date")
        }
        mask = String(Misc.dateFormatMasks[mask] || mask || Misc.dateFormatMasks["default"]);
        if (mask.slice(0, 4) === "UTC:") {
            mask = mask.slice(4);
            utc = true
        }
        var _ = utc ? "getUTC" : "get",
            d = date[_ + "Date"](),
            D = date[_ + "Day"](),
            m = date[_ + "Month"](),
            y = date[_ + "FullYear"](),
            H = date[_ + "Hours"](),
            M = date[_ + "Minutes"](),
            s = date[_ + "Seconds"](),
            L = date[_ + "Milliseconds"](),
            o = utc ? 0 : date.getTimezoneOffset(),
            flags = {
                d: d,
                dd: pad(d),
                ddd: Misc.dateFormatI18n.dayNames[D],
                dddd: Misc.dateFormatI18n.dayNames[D + 7],
                m: m + 1,
                mm: pad(m + 1),
                mmm: Misc.dateFormatI18n.monthNames[m],
                mmmm: Misc.dateFormatI18n.monthNames[m + 12],
                yy: String(y).slice(2),
                yyyy: y,
                h: H % 12 || 12,
                hh: pad(H % 12 || 12),
                H: H,
                HH: pad(H),
                M: M,
                MM: pad(M),
                s: s,
                ss: pad(s),
                l: pad(L, 3),
                L: pad(L > 99 ? Math.round(L / 10) : L),
                t: H < 12 ? "a" : "p",
                tt: H < 12 ? "am" : "pm",
                T: H < 12 ? "A" : "P",
                TT: H < 12 ? "AM" : "PM",
                Z: utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, ""),
                o: (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
                S: ["th", "st", "nd", "rd"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]
            };
        return mask.replace(token, function($0) {
            return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1)
        })
    };

    function Vector2(x, y) {
        if (x === undefined) {
            x = 0
        }
        if (y === undefined) {
            y = 0
        }
        this.x = x;
        this.y = y
    }
    Vector2.prototype = {
        Length: function Length() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        },
        Normalise: function Normalise() {
            var Len = Math.sqrt(this.x * this.x + this.y * this.y);
            this.x /= Len;
            this.y /= Len
        },
        Dot: function Dot(x, y) {
            return this.x * x + this.y * y
        }
    };

    function Maths() {}
    Maths.prototype = {};
    Maths.DegToRad = function DegToRad(Degrees) {
        return Degrees * Math.PI / 180
    };
    Maths.RadToDeg = function RadToDeg(Radians) {
        return Radians * 180 / Math.PI
    };
    Maths.M33Identity = function M33Identity() {
        var Matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
        return Matrix
    };
    Maths.M33BuildTranslation = function M33BuildTranslation(x, y) {
        var Matrix = [1, 0, 0, 0, 1, 0, x, y, 1];
        return Matrix
    };
    Maths.M33BuildScale = function M33BuildScale(ScaleX, ScaleY) {
        var Matrix = [ScaleX, 0, 0, 0, ScaleY, 0, 0, 0, 1];
        return Matrix
    };
    Maths.M33BuildRotation = function M33BuildRotation(Rotation) {
        var Cos = Math.cos(Rotation);
        var Sin = Math.sin(Rotation);
        var Matrix = [Cos, Sin, 0, -Sin, Cos, 0, 0, 0, 1];
        return Matrix
    };
    Maths.M33BuildRTS = function M33BuildRTS(Rotation, x, y, ScaleX, ScaleY) {
        var Cos = Math.cos(-Rotation);
        var Sin = Math.sin(-Rotation);
        var Matrix = [Cos, Sin, 0, -Sin, Cos, 0, -x, -y, 1];
        return Matrix
    };
    Maths.M33Mul = function M33Mul(Matrix1, Matrix2) {
        var Matrix = [];
        Matrix[0] = Matrix1[0] * Matrix2[0] + Matrix1[3] * Matrix2[1] + Matrix1[6] * Matrix2[2];
        Matrix[1] = Matrix1[1] * Matrix2[0] + Matrix1[4] * Matrix2[1] + Matrix1[7] * Matrix2[2];
        Matrix[2] = Matrix1[2] * Matrix2[0] + Matrix1[5] * Matrix2[1] + Matrix1[8] * Matrix2[2];
        Matrix[3] = Matrix1[0] * Matrix2[3] + Matrix1[3] * Matrix2[4] + Matrix1[6] * Matrix2[5];
        Matrix[4] = Matrix1[1] * Matrix2[3] + Matrix1[4] * Matrix2[4] + Matrix1[7] * Matrix2[5];
        Matrix[5] = Matrix1[2] * Matrix2[3] + Matrix1[5] * Matrix2[4] + Matrix1[8] * Matrix2[5];
        Matrix[6] = Matrix1[0] * Matrix2[6] + Matrix1[3] * Matrix2[7] + Matrix1[6] * Matrix2[8];
        Matrix[7] = Matrix1[1] * Matrix2[6] + Matrix1[4] * Matrix2[7] + Matrix1[7] * Matrix2[8];
        Matrix[8] = Matrix1[2] * Matrix2[6] + Matrix1[5] * Matrix2[7] + Matrix1[8] * Matrix2[8];
        return Matrix
    };
    Maths.M33Transform = function M33Transform(Matrix1, x, y) {
        var VertexOut = [];
        VertexOut[0] = x * Matrix1[0] + y * Matrix1[3] + Matrix1[6];
        VertexOut[1] = x * Matrix1[1] + y * Matrix1[4] + Matrix1[7];
        return VertexOut
    };
    Maths.InverseMatrix = function InverseMatrix(Matrix) {
        var InvMatrix = JamSystem.TurbulenzMathDevice.m44Inverse(Matrix);
        return InvMatrix
    };
    Maths.TransformPoint = function TransformPoint(Matrix, x, y) {
        var VectorIn = JamSystem.TurbulenzMathDevice.v3Build(x, y, 0);
        var VectorOut = JamSystem.TurbulenzMathDevice.m43TransformPoint(Matrix, VectorIn);
        return new Vector2(VectorOut[0], VectorOut[1])
    };

    function Line() {}
    Line.prototype = {
        SetIsVisible: function SetIsVisibleFn(bVisible) {
            this.bVisible = bVisible
        },
        GetIsVisible: function GetIsVisibleFn() {
            return this.bVisible
        },
        SetStartCoord: function SetStartCoordFn(x, y) {
            this.x1 = x;
            this.y1 = y;
            this.VertsDirty = true
        },
        SetEndCoord: function SetEndCoordFn(x, y) {
            this.x2 = x;
            this.y2 = y;
            this.VertsDirty = true
        },
        SetColour: function SetColourFn(Colour) {
            this.techniqueParameters.constantColor = Colour
        },
        SetParent: function SetParentFn(Parent) {
            this.Parent = Parent
        },
        SetParentDirty: function SetParentDirtyFn() {
            this.VertsDirty = true
        },
        UpdateVerts: function UpdateVertsFn() {
            this.MathDevice.v4Build(this.x1, -this.y1, 0, 1, this.Vertex1);
            this.MathDevice.v4Build(this.x2, -this.y2, 0, 1, this.Vertex2)
        },
        Render: function RenderFn() {
            if (this.bVisible) {
                if (this.VertsDirty) {
                    this.VertsDirty = false;
                    this.UpdateVerts()
                }
                JamSystem.RenderManager.SetShader(JamSystem.RenderManager.DefaultLineShader);
                this.graphicsDevice.setTechniqueParameters(this.techniqueParameters);
                var writer = this.graphicsDevice.beginDraw(this.primitive, 2, this.vertexFormats, this.positionSemantics);
                if (writer) {
                    writer(this.Vertex1[0], this.Vertex1[1], 0);
                    writer(this.Vertex2[0], this.Vertex2[1], 0);
                    this.graphicsDevice.endDraw(writer)
                }
            }
        },
        RenderDebug: function RenderDebugFn(x1, y1, x2, y2, Colour, Matrix) {
            JamSystem.RenderManager.SetShader(JamSystem.RenderManager.DefaultLineShader);
            this.MathDevice.v4Build(x1, -y1, 0, 1, JamSystem.RenderManager.Vertex1);
            this.MathDevice.v4Build(x2, -y2, 0, 1, JamSystem.RenderManager.Vertex2);
            if (Matrix) {
                this.techniqueParameters.TransformMatrix = Matrix
            }
            this.techniqueParameters.constantColor = Colour;
            this.graphicsDevice.setTechniqueParameters(this.techniqueParameters);
            var writer = this.graphicsDevice.beginDraw(this.primitive, 2, this.vertexFormats, this.positionSemantics);
            if (writer) {
                writer(JamSystem.RenderManager.Vertex1[0], JamSystem.RenderManager.Vertex1[1], 0);
                writer(JamSystem.RenderManager.Vertex2[0], JamSystem.RenderManager.Vertex2[1], 0);
                this.graphicsDevice.endDraw(writer)
            }
        },
        Destroy: function DestroyFn() {
            if (this.Parent) {
                this.Parent.RemoveChild(this)
            }
        }
    };
    Line.Create = function LineCreateFn(TurbulenzGraphicsDevice, MathDevice, positionSemantics, x, y, endX, endY, Colour) {
        var NewObject = new Line;
        NewObject.bVisible = true;
        NewObject.VertsDirty = true;
        NewObject.Parent = 0;
        NewObject.x1 = 0;
        NewObject.x2 = 0;
        NewObject.y1 = 0;
        NewObject.y2 = 0;
        if (x !== undefined) {
            NewObject.x1 = x
        }
        if (endX !== undefined) {
            NewObject.x2 = endX
        }
        if (y !== undefined) {
            NewObject.y1 = y
        }
        if (endY !== undefined) {
            NewObject.y2 = endY
        }
        if (Colour === undefined) {
            Colour = [1, 1, 1, 1]
        }
        NewObject.FinalVertex1 = MathDevice.v4Build(0, 0, 0, 0);
        NewObject.FinalVertex2 = MathDevice.v4Build(0, 0, 0, 0);
        NewObject.Vertex1 = MathDevice.v4Build(0, 0, 0, 0);
        NewObject.Vertex2 = MathDevice.v4Build(0, 0, 0, 0);
        NewObject.MathDevice = MathDevice;
        NewObject.graphicsDevice = TurbulenzGraphicsDevice;
        NewObject.Matrix = JamSystem.TurbulenzMathDevice.m44BuildIdentity();
        NewObject.techniqueParameters = NewObject.graphicsDevice.createTechniqueParameters({
            constantColor: Colour,
            TransformMatrix: NewObject.Matrix
        });
        NewObject.primitive = NewObject.graphicsDevice.PRIMITIVE_LINES;
        NewObject.positionSemantics = positionSemantics;
        NewObject.vertexFormats = [NewObject.graphicsDevice.VERTEXFORMAT_FLOAT3];
        return NewObject
    };

    function LineList() {}
    LineList.DebugRenderCount = 0;
    LineList.prototype = {
        SetColour: function SetColourFn(Colour) {
            this.techniqueParameters.constantColor = Colour
        },
        GetColour: function GetColourFn() {
            return this.techniqueParameters.constantColor
        },
        SetPositionArray: function SetPositionArrayFn(PositionArray) {
            var i;
            for (i = 0; i < this.NumLines + 1; i += 1) {
                this.VertexArray[i * 3 + 0] = PositionArray[i].x;
                this.VertexArray[i * 3 + 1] = -PositionArray[i].y
            }
            this.positionVertexBuffer.setData(this.VertexArray, 0, this.NumLines + 1)
        },
        SetIsVisible: function SetIsVisibleFn(bVisible) {
            this.bVisible = bVisible
        },
        GetIsVisible: function GetIsVisibleFn() {
            return this.bVisible
        },
        SetParent: function SetParentFn(Parent) {
            this.Parent = Parent;
            this.SetParentDirty()
        },
        SetParentDirty: function SetParentDirtyFn() {
            if (this.Parent) {
                this.techniqueParameters.TransformMatrix = this.Parent.GetMatrix()
            }
        },
        CreateVertexBuffer: function CreateVertexBuffer() {
            var i;
            var writer;
            var TurbulenzGraphicsDevice = JamSystem.RenderManager.TurbulenzGraphicsDevice;
            var positionsParameters = {
                numVertices: this.NumLines + 1,
                attributes: ["FLOAT3"],
                dynamic: true
            };
            this.positionVertexBuffer = TurbulenzGraphicsDevice.createVertexBuffer(positionsParameters);
            for (i = 0; i < (this.NumLines + 1) * 3; i += 1) {
                this.VertexArray[i] = 0
            }
            this.positionVertexBuffer.setData(this.VertexArray, 0, this.NumLines + 1);
            var indexBufferParameters = {
                numIndices: this.NumLines + 1,
                format: "USHORT"
            };
            this.indexBuffer = TurbulenzGraphicsDevice.createIndexBuffer(indexBufferParameters);
            var Buffer = new Uint16Array(this.NumLines + 1);
            for (i = 0; i < this.NumLines + 1; i += 1) {
                Buffer[i] = i
            }
            this.indexBuffer.setData(Buffer, 0, this.NumLines + 1)
        },
        Render: function RenderFn() {
            if (this.bVisible) {
                JamSystem.RenderManager.DefaultLineShader.SetIsActive();
                this.graphicsDevice.setTechniqueParameters(this.techniqueParameters);
                this.graphicsDevice.setStream(this.positionVertexBuffer, this.positionSemantics);
                this.graphicsDevice.setIndexBuffer(this.indexBuffer);
                this.graphicsDevice.drawIndexed(this.primitive, this.NumLines + 1);
                LineList.DebugRenderCount += 1
            }
        },
        Destroy: function DestroyFn() {
            if (this.Parent) {
                this.Parent.RemoveChild(this)
            }
            this.indexBuffer.destroy();
            this.positionVertexBuffer.destroy()
        }
    };
    LineList.Create = function LineListCreate(MaxLines, Colour, positionSemantics) {
        var NewLineList = new LineList;
        NewLineList.Parent = 0;
        NewLineList.bVisible = true;
        NewLineList.MaxLines = MaxLines;
        NewLineList.NumLines = MaxLines;
        NewLineList.graphicsDevice = JamSystem.RenderManager.TurbulenzGraphicsDevice;
        NewLineList.techniqueParameters = NewLineList.graphicsDevice.createTechniqueParameters({
            constantColor: Colour,
            TransformMatrix: JamSystem.TurbulenzMathDevice.m44BuildIdentity()
        });
        NewLineList.primitive = NewLineList.graphicsDevice.PRIMITIVE_LINE_STRIP;
        NewLineList.positionSemantics = positionSemantics;
        NewLineList.positionVertexBuffer = null;
        NewLineList.indexBuffer = null;
        NewLineList.VertexArray = new Float32Array((MaxLines + 1) * 3);
        NewLineList.CreateVertexBuffer();
        return NewLineList
    };

    function Sprite() {}
    Sprite.DebugRenderCount = 0;
    Sprite.DestroyedList = [];
    Sprite.prototype = {
        SetTexture: function SetTextureFn(psTexture, Frame) {
            this.psTexture = psTexture;
            this.Frame = Frame;
            this.VerticesDirty = true
        },
        GetTexture: function GetTextureFn() {
            return this.psTexture
        },
        SetTexture2: function SetTexture2Fn(psTexture, Frame) {
            this.psTexture2 = psTexture;
            this.Frame2 = Frame;
            this.VerticesDirty = true
        },
        SetFrame: function SetFrameFn(Frame) {
            this.Frame = Frame;
            this.VerticesDirty = true
        },
        SetFrameByName: function SetFrameByNameFn(FrameName, x, y, x2, y2) {
            this.Frame = this.psTexture.GetFrameIndexFromName(FrameName);
            this.VerticesDirty = true;
            this.LocalMatrixDirty = true;
            this.MatrixDirty = true;
            if (x !== undefined) {
                this.UpdateVertices();
                this.VerticesDirty = false;
                var Object = this.psTexture.GetImage(this.Frame);
                var FrameObject = this.psTexture.GetFrame(this.Frame);
                var tx = (x + FrameObject.u) / Object.width;
                var ty = (y + FrameObject.v) / Object.height;
                var tx2 = (x + x2 + FrameObject.u) / Object.width;
                var ty2 = (y + y2 + FrameObject.v) / Object.height;
                this.VertexArray[3] = tx;
                this.VertexArray[4] = ty;
                this.VertexArray[10] = tx2;
                this.VertexArray[11] = ty;
                this.VertexArray[17] = tx;
                this.VertexArray[18] = ty2;
                this.VertexArray[24] = tx2;
                this.VertexArray[25] = ty2;
                this.Width = x2;
                this.Height = y2;
                this.VertexArray[7] = this.Width;
                this.VertexArray[15] = -this.Height;
                this.VertexArray[21] = this.Width;
                this.VertexArray[22] = -this.Height;
                this.positionVertexBuffer.setData(this.VertexArray, 0, 4)
            }
        },
        GetFrame: function GetFrameFn() {
            return this.Frame
        },
        SetFrame2: function SetFrame2Fn(Frame) {
            this.Frame2 = Frame;
            this.VerticesDirty = true
        },
        SetUVInfo: function SetUVInfoFn(UOffset, VOffset, UScale, VScale) {
            this.UOffset = UOffset;
            this.VOffset = VOffset;
            this.UScale = UScale;
            this.VScale = VScale;
            this.VerticesDirty = true;
            this.UVDirty = true
        },
        SetColour: function SetColourFn(ColourArray) {
            this.ColourArray = ColourArray;
            var i, j;
            for (i = 0; i < 4; i += 1) {
                this.ColourVertexArray.set(ColourArray, i * 4)
            }
            this.ColourDirty = true;
            if (ColourArray[0] !== 1 || ColourArray[1] !== 1 || ColourArray[2] !== 1 || ColourArray[3] !== 1) {
                this.ColourNormal = false
            } else {
                this.ColourNormal = true
            }
        },
        GetColour: function GetColourFn() {
            return this.ColourArray
        },
        SetOpacity: function SetOpacityFn(Opacity) {
            this.ColourArray[3] = Opacity;
            var i, j;
            for (i = 0; i < 4; i += 1) {
                this.ColourVertexArray.set([Opacity], i * 4 + 3)
            }
            this.ColourDirty = true;
            if (this.ColourArray[3] !== 1) {
                this.ColourNormal = false
            } else {
                this.ColourNormal = true
            }
        },
        GetOpacity: function GetOpacityFn() {
            return this.ColourArray[3]
        },
        GetIsAt: function GetIsAtFn(x, y) {
            var xt = x - this.x;
            var yt = y - this.y;
            var RotMat = Maths.M33BuildRotation(-this.Rotation);
            var PosRot = Maths.M33Transform(RotMat, xt, yt);
            var LocalX = PosRot[0] / this.ScaleX;
            var LocalY = PosRot[1] / this.ScaleY;
            var frame = this.psTexture.GetFrame(this.Frame);
            LocalX -= this.AnchorX * frame.Width;
            LocalY += this.AnchorY * frame.Height;
            if (LocalX >= 0 && LocalX < frame.Width && LocalY >= 0 && LocalY < frame.Height) {
                if (this.psTexture.ImageData.length !== 0) {
                    var IsOpaque = this.psTexture.GetPixelInFrame(this.Frame, LocalX, LocalY);
                    if (IsOpaque) {
                        return true
                    }
                } else {
                    return true
                }
            }
            return false
        },
        GetIsOnEdge: function GetIsOnEdgeFn(x, y) {
            var xt = x - this.x;
            var yt = y - this.y;
            var RotMat = Maths.M33BuildRotation(-this.Rotation);
            var PosRot = Maths.M33Transform(RotMat, xt, yt);
            var LocalX = PosRot[0] / this.ScaleX;
            var LocalY = PosRot[1] / this.ScaleY;
            var frame = this.psTexture.GetFrame(this.Frame);
            LocalX -= this.AnchorX * frame.Width;
            LocalY += this.AnchorY * frame.Height;
            var PercentX = LocalX / frame.Width;
            var PercentY = LocalY / frame.Height;
            var Tolerance = .1;
            if (PercentX < Tolerance && PercentX > -Tolerance) {
                if (PercentY < Tolerance && PercentY > -Tolerance) {
                    return EA.TopLeft
                } else if (PercentY > 1 - Tolerance && PercentY < 1 + Tolerance) {
                    return EA.BottomLeft
                }
                return EA.MiddleLeft
            } else if (PercentX > 1 - Tolerance && PercentX < 1 + Tolerance) {
                if (PercentY < Tolerance && PercentY > -Tolerance) {
                    return EA.TopRight
                } else if (PercentY > 1 - Tolerance && PercentY < 1 + Tolerance) {
                    return EA.BottomRight
                }
                return EA.MiddleRight
            } else {
                if (PercentY < Tolerance && PercentY > -Tolerance) {
                    return EA.TopMiddle
                } else if (PercentY > 1 - Tolerance && PercentY < 1 + Tolerance) {
                    return EA.BottomMiddle
                }
            }
            return EA.MiddleMiddle
        },
        GetWidth: function GetWidthFn() {
            var psFrameData = this.psTexture.GetFrame(this.Frame);
            return psFrameData.Width
        },
        GetHeight: function GetHeightFn() {
            var psFrameData = this.psTexture.GetFrame(this.Frame);
            return psFrameData.Height
        },
        CreateVertexBuffer: function CreateVertexBuffer() {
            var i;
            var TurbulenzGraphicsDevice = JamSystem.RenderManager.TurbulenzGraphicsDevice;
            var positionsParameters = {
                numVertices: 4,
                attributes: ["FLOAT3", "FLOAT2", "FLOAT2"],
                dynamic: true
            };
            this.positionVertexBuffer = TurbulenzGraphicsDevice.createVertexBuffer(positionsParameters);
            this.positionVertexBuffer.setData(this.VertexArray, 0, 4);
            var colorsParameters = {
                numVertices: 4,
                attributes: ["UBYTE4N"],
                dynamic: true
            };
            this.colorVertexBuffer = TurbulenzGraphicsDevice.createVertexBuffer(colorsParameters);
            this.colorVertexBuffer.setData(this.ColourVertexArray, 0, 4)
        },
        UpdateVertices: function UpdateVerticesFn() {
            if (!this.techniqueParameters) {
                this.techniqueParameters = JamSystem.RenderManager.TurbulenzGraphicsDevice.createTechniqueParameters({
                    diffuse: null,
                    diffuse2: null,
                    TransformMatrix: this.Matrix
                })
            }
            if (!this.positionVertexBuffer) {
                this.CreateVertexBuffer()
            }
            var texture;
            var frame;
            if (this.Frame < 0) {
                var ImageIndex = -this.Frame - 1;
                texture = this.psTexture.Images[ImageIndex];
                frame = FrameInstance.Create();
                frame.PageIndex = ImageIndex;
                frame.Width = texture.width;
                frame.Height = texture.height;
                frame.u = 0;
                frame.v = 0
            } else {
                texture = this.psTexture.GetImage(this.Frame);
                frame = this.psTexture.GetFrame(this.Frame)
            }
            this.techniqueParameters.diffuse = texture;
            if (this.Width !== frame.Width || this.Height !== frame.Height) {
                this.LocalMatrixDirty = true;
                this.MatrixDirty = true
            }
            this.Width = frame.Width;
            this.Height = frame.Height;
            var tx = frame.u / texture.width;
            var ty = frame.v / texture.height;
            var tx2 = tx + frame.Width / texture.width;
            var ty2 = ty + frame.Height / texture.height;
            if (this.UVDirty) {
                tx = tx * this.UScale + this.UOffset;
                ty = ty * this.VScale + this.VOffset;
                tx2 = tx2 * this.UScale + this.UOffset;
                ty2 = ty2 * this.VScale + this.VOffset
            }
            var t2x = 0;
            var t2y = 0;
            var t2x2 = 0;
            var t2y2 = 0;
            if (this.psTexture2) {
                var texture2 = this.psTexture2.GetImage(this.Frame2);
                var frame2 = this.psTexture2.GetFrame(this.Frame2);
                t2x = frame2.u / texture2.width;
                t2y = frame2.v / texture2.height;
                t2x2 = t2x + frame2.Width / texture2.width;
                t2y2 = t2y + frame2.Height / texture2.height;
                this.techniqueParameters.diffuse2 = texture2
            }
            this.VertexArray[0] = 0;
            this.VertexArray[1] = 0;
            this.VertexArray[2] = 0;
            this.VertexArray[3] = tx;
            this.VertexArray[4] = ty;
            this.VertexArray[5] = t2x;
            this.VertexArray[6] = t2y;
            this.VertexArray[7] = this.Width;
            this.VertexArray[8] = 0;
            this.VertexArray[9] = 0;
            this.VertexArray[10] = tx2;
            this.VertexArray[11] = ty;
            this.VertexArray[12] = t2x2;
            this.VertexArray[13] = t2y;
            this.VertexArray[14] = 0;
            this.VertexArray[15] = -this.Height;
            this.VertexArray[16] = 0;
            this.VertexArray[17] = tx;
            this.VertexArray[18] = ty2;
            this.VertexArray[19] = t2x;
            this.VertexArray[20] = t2y2;
            this.VertexArray[21] = this.Width;
            this.VertexArray[22] = -this.Height;
            this.VertexArray[23] = 0;
            this.VertexArray[24] = tx2;
            this.VertexArray[25] = ty2;
            this.VertexArray[26] = t2x2;
            this.VertexArray[27] = t2y2;
            this.positionVertexBuffer.setData(this.VertexArray, 0, 4)
        },
        BuildLocalMatrix: function BuildLocalMatrixFn() {
            if (!this.techniqueParameters) {
                this.techniqueParameters = JamSystem.RenderManager.TurbulenzGraphicsDevice.createTechniqueParameters({
                    diffuse: null,
                    diffuse2: null,
                    TransformMatrix: this.Matrix
                })
            }
            var MathDevice = JamSystem.TurbulenzMathDevice;
            JamSystem.RenderManager.AnchorTranslationMatrix = MathDevice.m43BuildTranslation(this.AnchorX * this.Width, this.AnchorY * this.Height, 0);
            MathDevice.quatFromAxisRotation(JamSystem.RenderManager.UpVector, this.Rotation, JamSystem.RenderManager.Quaternion);
            MathDevice.v3Build(this.x, -this.y, 0, JamSystem.RenderManager.TranslationVector);
            MathDevice.v3Build(this.ScaleX, this.ScaleY, 1, JamSystem.RenderManager.ScaleVector);
            MathDevice.m43FromRTS(JamSystem.RenderManager.Quaternion, JamSystem.RenderManager.TranslationVector, JamSystem.RenderManager.ScaleVector, JamSystem.RenderManager.ScaleAnchorRotationMatrix);
            MathDevice.m43Mul(JamSystem.RenderManager.AnchorTranslationMatrix, JamSystem.RenderManager.ScaleAnchorRotationMatrix, this.LocalMatrix)
        },
        UpdateMatrix: function UpdateMatrixFn() {
            var MathDevice = JamSystem.TurbulenzMathDevice;
            if (this.LocalMatrixDirty) {
                this.BuildLocalMatrix();
                this.LocalMatrixDirty = false
            }
            MathDevice.m43MulM44(this.LocalMatrix, this.Parent.GetMatrix(), this.techniqueParameters.TransformMatrix)
        },
        Render: function RenderFn() {
            if (this.bVisible) {
                if (this.VerticesDirty) {
                    this.VerticesDirty = false;
                    this.UpdateVertices()
                }
                if (this.ColourDirty) {
                    this.ColourDirty = false;
                    this.colorVertexBuffer.setData(this.ColourVertexArray, 0, 4)
                }
                if (this.MatrixDirty) {
                    this.MatrixDirty = false;
                    this.UpdateMatrix()
                }
                this.Shader.SetIsActive();
                var GraphicsDevice = JamSystem.RenderManager.TurbulenzGraphicsDevice;
                GraphicsDevice.setTechniqueParameters(this.techniqueParameters);
                GraphicsDevice.setStream(this.colorVertexBuffer, this.colorSemantics);
                GraphicsDevice.setStream(this.positionVertexBuffer, this.positionSemantics);
                GraphicsDevice.draw(this.primitive, 4, 0);
                Sprite.DebugRenderCount += 1
            }
        },
        RenderDebug: function RenderDebugFn(x, y, ScaleX, ScaleY, Rotation, ImageName, ColourArray, Matrix) {
            this.x = x;
            this.y = y;
            this.ScaleX = ScaleX;
            this.ScaleY = ScaleY;
            this.Rotation = Rotation;
            var Info = JamSystem.AssetManager.GetTextureInfoFromImageName(ImageName);
            this.SetTexture(Info.Texture, Info.Frame);
            this.SetColour(ColourArray);
            this.UpdateVertices();
            this.VerticesDirty = false;
            this.BuildLocalMatrix();
            var MathDevice = JamSystem.TurbulenzMathDevice;
            MathDevice.m43MulM44(this.LocalMatrix, Matrix, this.techniqueParameters.TransformMatrix);
            this.MatrixDirty = false;
            this.bVisible = true;
            this.Render();
            this.bVisible = false
        },
        Destroy: function DestroyFn() {
            if (this.Parent) {
                this.Parent.RemoveChild(this)
            }
            Sprite.DestroyedList[Sprite.DestroyedList] = this
        }
    };
    Sprite.Create = function SpriteCreate(x, y, psTexture, Frame, positionSemantics, colorSemantics) {
        var NewSprite, i;
        if (Sprite.DestroyedList.length) {
            NewSprite = Sprite.DestroyedList[Sprite.DestroyedList.length - 1];
            Sprite.DestroyedList.length -= 1;
            Renderable.Init(NewSprite, x, y)
        } else {
            NewSprite = Renderable.Create(x, y);
            NewSprite.SetTexture = Sprite.prototype.SetTexture;
            NewSprite.GetTexture = Sprite.prototype.GetTexture;
            NewSprite.SetTexture2 = Sprite.prototype.SetTexture2;
            NewSprite.SetFrame = Sprite.prototype.SetFrame;
            NewSprite.SetFrameByName = Sprite.prototype.SetFrameByName;
            NewSprite.GetFrame = Sprite.prototype.GetFrame;
            NewSprite.SetUVInfo = Sprite.prototype.SetUVInfo;
            NewSprite.SetColour = Sprite.prototype.SetColour;
            NewSprite.GetColour = Sprite.prototype.GetColour;
            NewSprite.SetOpacity = Sprite.prototype.SetOpacity;
            NewSprite.GetOpacity = Sprite.prototype.GetOpacity;
            NewSprite.GetIsAt = Sprite.prototype.GetIsAt;
            NewSprite.GetWidth = Sprite.prototype.GetWidth;
            NewSprite.GetHeight = Sprite.prototype.GetHeight;
            NewSprite.CreateVertexBuffer = Sprite.prototype.CreateVertexBuffer;
            NewSprite.UpdateVertices = Sprite.prototype.UpdateVertices;
            NewSprite.BuildLocalMatrix = Sprite.prototype.BuildLocalMatrix;
            NewSprite.UpdateMatrix = Sprite.prototype.UpdateMatrix;
            NewSprite.Render = Sprite.prototype.Render;
            NewSprite.RenderDebug = Sprite.prototype.RenderDebug;
            NewSprite.GetIsOnEdge = Sprite.prototype.GetIsOnEdge;
            NewSprite.colorSemantics = colorSemantics;
            NewSprite.positionSemantics = positionSemantics;
            NewSprite.primitive = JamSystem.RenderManager.TurbulenzGraphicsDevice.PRIMITIVE_TRIANGLE_STRIP;
            NewSprite.techniqueParameters = null;
            NewSprite.colorVertexBuffer = null;
            NewSprite.positionVertexBuffer = null;
            NewSprite.VertexArray = new Float32Array(28);
            NewSprite.ColourVertexArray = new Float32Array(16);
            NewSprite.ColourArray = [];
            for (i = 0; i < 28; i += 1) {
                NewSprite.VertexArray[i] = 0
            }
        }
        NewSprite.VerticesDirty = true;
        NewSprite.psTexture = psTexture;
        NewSprite.Frame = Frame;
        NewSprite.Depth = 0;
        NewSprite.ColourDirty = false;
        NewSprite.ColourNormal = true;
        NewSprite.UScale = 1;
        NewSprite.VScale = 1;
        NewSprite.UOffset = 0;
        NewSprite.VOffset = 0;
        NewSprite.UVDirty = false;
        NewSprite.Sprite = true;
        for (i = 0; i < 4; i += 1) {
            NewSprite.ColourArray[i] = 1
        }
        for (i = 0; i < 16; i += 1) {
            NewSprite.ColourVertexArray[i] = 1
        }
        return NewSprite
    };

    function SpriteAnimation() {}
    SpriteAnimation.prototype = {
        SetData: function SetDataFn(AnimationData) {
            this.FrameTime = 0;
            this.CurrentFrame = 0;
            this.AnimationData = AnimationData;
            var Frame = AnimationData.Frames[0].FrameIndex;
            if (this.SpriteIndex) {
                this.TargetSprite.SetFrame(this.SpriteIndex, Frame)
            } else {
                this.TargetSprite.SetFrame(Frame)
            }
            this.Playing = true
        },
        GetData: function GetDataFn(AnimationData) {
            return this.AnimationData
        },
        Update: function UpdateFn(TimeDelta) {
            if (this.Playing) {
                var Data = this.AnimationData;
                this.FrameTime += TimeDelta;
                while (this.FrameTime > Data.Frames[this.CurrentFrame].Delay) {
                    this.FrameTime -= Data.Frames[this.CurrentFrame].Delay;
                    this.CurrentFrame += 1;
                    if (this.CurrentFrame === Data.Frames.length) {
                        if (Data.Looped) {
                            this.CurrentFrame = 0
                        } else {
                            this.Playing = false;
                            return
                        }
                    }
                    var Frame = Data.Frames[this.CurrentFrame].FrameIndex;
                    if (this.SpriteIndex) {
                        this.TargetSprite.SetFrame(this.SpriteIndex, Frame)
                    } else {
                        this.TargetSprite.SetFrame(Frame)
                    }
                }
            }
        },
        Destroy: function DestroyFn() {}
    };
    SpriteAnimation.Create = function SpriteAnimationCreate(TargetSprite, SpriteIndex) {
        var NewSpriteAnimation = new SpriteAnimation;
        NewSpriteAnimation.SetAnimation = SpriteAnimation.prototype.SetAnimation;
        NewSpriteAnimation.Update = SpriteAnimation.prototype.Update;
        NewSpriteAnimation.Destroy = SpriteAnimation.prototype.Destroy;
        NewSpriteAnimation.TargetSprite = TargetSprite;
        NewSpriteAnimation.SpriteIndex = SpriteIndex;
        NewSpriteAnimation.AnimationData = null;
        NewSpriteAnimation.FrameTime = 0;
        NewSpriteAnimation.CurrentFrame = 0;
        NewSpriteAnimation.Playing = false;
        return NewSpriteAnimation
    };

    function SpriteList() {}
    SpriteList.DebugRenderCount = 0;
    SpriteList.Vertex = [
        [0, 0],
        [1, 0],
        [0, 1],
        [1, 1]
    ];
    SpriteList.FinalVertex = [
        [0, 0],
        [1, 0],
        [0, -1],
        [1, -1]
    ];
    SpriteList.SharedIndexBuffer = null;
    SpriteList.SharedIndexBufferRefs = 0;
    SpriteList.prototype = {
        SetTexture: function SetTextureFn(ThisTexture, Image) {
            this.techniqueParameters.diffuse = ThisTexture.Images[Image];
            this.Texture = ThisTexture
        },
        GetTexture: function GetTextureFn() {
            return this.Texture
        },
        SetTexture2: function SetTexture2Fn(ThisTexture, Image) {
            if (ThisTexture) {
                this.techniqueParameters.diffuse2 = ThisTexture.Images[Image]
            }
            this.Texture2 = ThisTexture
        },
        SetUVInfo: function SetUVInfoFn(Index, UOffset, VOffset, UScale, VScale) {
            this.UOffset[Index] = UOffset;
            this.VOffset[Index] = VOffset;
            this.UScale[Index] = UScale;
            this.VScale[Index] = VScale;
            this.UVDirty[Index] = true;
            var texture = this.Texture.GetImage(this.Frame[Index]);
            var frame = this.Texture.GetFrame(this.Frame[Index]);
            var tx = frame.u / texture.width;
            var ty = frame.v / texture.height;
            var tx2 = tx + frame.Width / texture.width;
            var ty2 = ty + frame.Height / texture.height;
            tx = tx * this.UScale[Index] + this.UOffset[Index];
            ty = ty * this.VScale[Index] + this.VOffset[Index];
            tx2 = tx2 * this.UScale[Index] + this.UOffset[Index];
            ty2 = ty2 * this.VScale[Index] + this.VOffset[Index];
            this.OldVertex[Index][0].tx = tx;
            this.OldVertex[Index][0].ty = ty;
            this.OldVertex[Index][1].tx = tx2;
            this.OldVertex[Index][1].ty = ty;
            this.OldVertex[Index][2].tx = tx;
            this.OldVertex[Index][2].ty = ty2;
            this.OldVertex[Index][3].tx = tx2;
            this.OldVertex[Index][3].ty = ty2
        },
        SetColour: function SetColourFn(Index, ColourArray) {
            this.ColourVertexArray.set(ColourArray, Index * 16 + 0 * 4);
            this.ColourVertexArray.set(ColourArray, Index * 16 + 1 * 4);
            this.ColourVertexArray.set(ColourArray, Index * 16 + 2 * 4);
            this.ColourVertexArray.set(ColourArray, Index * 16 + 3 * 4);
            this.ColourDirty = true;
            this.ColourArray[Index] = ColourArray;
            if (ColourArray[0] !== 1 || ColourArray[1] !== 1 || ColourArray[2] !== 1 || ColourArray[3] !== 1) {
                this.ColourNormal[Index] = false
            } else {
                this.ColourNormal[Index] = true
            }
        },
        GetColour: function GetColourFn(Index) {
            return this.ColourArray[Index]
        },
        SetPosition: function SetPositionFn(SpriteIndex, x, y) {
            this.x[SpriteIndex] = x;
            this.y[SpriteIndex] = y;
            this.VerticesDirty[SpriteIndex] = true;
            this.AnyVertexDirty = true
        },
        GetPositionX: function GetPositionXFn(SpriteIndex) {
            return this.x[SpriteIndex]
        },
        GetPositionY: function GetPositionYFn(SpriteIndex) {
            return this.y[SpriteIndex]
        },
        SetScale: function SetScaleFn(SpriteIndex, x, y) {
            this.ScaleX[SpriteIndex] = x;
            this.ScaleY[SpriteIndex] = y;
            this.VerticesDirty[SpriteIndex] = true;
            this.AnyVertexDirty = true
        },
        GetScaleX: function GetScaleXFn(SpriteIndex) {
            return this.ScaleX[SpriteIndex]
        },
        GetScaleY: function GetScaleYFn(SpriteIndex) {
            return this.ScaleY[SpriteIndex]
        },
        SetRotation: function SetRotationFn(SpriteIndex, r) {
            this.Rotation[SpriteIndex] = r;
            this.VerticesDirty[SpriteIndex] = true;
            this.AnyVertexDirty = true
        },
        GetRotation: function GetRotationFn(SpriteIndex) {
            return this.Rotation[SpriteIndex]
        },
        SetFrame: function SetFrameFn(SpriteIndex, Frame) {
            this.Frame[SpriteIndex] = Frame;
            this.VerticesDirty[SpriteIndex] = true;
            this.AnyVertexDirty = true
        },
        GetFrame: function GetFrameFn(SpriteIndex) {
            return this.Frame[SpriteIndex]
        },
        SetFrame2: function SetFrame2Fn(SpriteIndex, Frame) {
            this.Frame2[SpriteIndex] = Frame;
            this.VerticesDirty[SpriteIndex] = true;
            this.AnyVertexDirty = true
        },
        SetAnchor: function SetAnchorFn(SpriteIndex, Anchor) {
            switch (Anchor) {
                case EA.Default:
                case EA.Middle:
                case EA.TopMiddle:
                case EA.MiddleMiddle:
                case EA.BottomMiddle:
                    this.AnchorX[SpriteIndex] = -.5;
                    break;
                case EA.TopRight:
                case EA.MiddleRight:
                case EA.BottomRight:
                    this.AnchorX[SpriteIndex] = -1;
                    break;
                case EA.TopLeft:
                case EA.MiddleLeft:
                case EA.BottomLeft:
                    this.AnchorX[SpriteIndex] = 0;
                    break
            }
            switch (Anchor) {
                case EA.Default:
                case EA.MiddleLeft:
                case EA.MiddleMiddle:
                case EA.MiddleRight:
                case EA.Middle:
                    this.AnchorY[SpriteIndex] = .5;
                    break;
                case EA.BottomLeft:
                case EA.BottomMiddle:
                case EA.BottomRight:
                    this.AnchorY[SpriteIndex] = 1;
                    break;
                case EA.TopLeft:
                case EA.TopMiddle:
                case EA.TopRight:
                    this.AnchorY[SpriteIndex] = 0;
                    break
            }
            this.Anchor[SpriteIndex] = Anchor;
            this.VerticesDirty[SpriteIndex] = true
        },
        SetIsVisible: function SetIsVisibleFn(bVisible) {
            this.bVisible = bVisible
        },
        GetIsVisible: function GetIsVisibleFn() {
            return this.bVisible
        },
        GetIsAnyAt: function GetIsAnyAtFn(x, y) {
            var i;
            for (i = this.NumSprites - 1; i >= 0; i -= 1) {
                var xt = x - this.x[i];
                var yt = y - this.y[i];
                var RotMat = Maths.M33BuildRotation(-this.Rotation[i]);
                var PosRot = Maths.M33Transform(RotMat, xt, yt);
                var LocalX = PosRot[0] / this.ScaleX[i];
                var LocalY = PosRot[1] / this.ScaleY[i];
                var frame = this.Texture.GetFrame(this.Frame[i]);
                LocalX -= this.AnchorX[i] * frame.Width;
                LocalY += this.AnchorY[i] * frame.Height;
                if (LocalX >= 0 && LocalX < frame.Width && LocalY >= 0 && LocalY < frame.Height) {
                    if (this.Texture.ImageData.length !== 0) {
                        var IsOpaque = this.Texture.GetPixelInFrame(this.Frame[i], LocalX, LocalY);
                        if (IsOpaque) {
                            return i
                        }
                    } else {
                        return i
                    }
                }
            }
            return -1
        },
        GetIsOnEdge: function GetIsOnEdgeFn(SpriteIndex, x, y) {
            var xt = x - this.x[SpriteIndex];
            var yt = y - this.y[SpriteIndex];
            var RotMat = Maths.M33BuildRotation(-this.Rotation[SpriteIndex]);
            var PosRot = Maths.M33Transform(RotMat, xt, yt);
            var LocalX = PosRot[0] / this.ScaleX[SpriteIndex];
            var LocalY = PosRot[1] / this.ScaleY[SpriteIndex];
            var frame = this.Texture.GetFrame(this.Frame[SpriteIndex]);
            LocalX -= this.AnchorX[SpriteIndex] * frame.Width;
            LocalY += this.AnchorY[SpriteIndex] * frame.Height;
            var PercentX = LocalX / frame.Width;
            var PercentY = LocalY / frame.Height;
            var Tolerance = .1;
            if (PercentX < Tolerance && PercentX > -Tolerance) {
                if (PercentY < Tolerance && PercentY > -Tolerance) {
                    return EA.TopLeft
                } else if (PercentY > 1 - Tolerance && PercentY < 1 + Tolerance) {
                    return EA.BottomLeft
                }
                return EA.MiddleLeft
            } else if (PercentX > 1 - Tolerance && PercentX < 1 + Tolerance) {
                if (PercentY < Tolerance && PercentY > -Tolerance) {
                    return EA.TopRight
                } else if (PercentY > 1 - Tolerance && PercentY < 1 + Tolerance) {
                    return EA.BottomRight
                }
                return EA.MiddleRight
            } else {
                if (PercentY < Tolerance && PercentY > -Tolerance) {
                    return EA.TopMiddle
                } else if (PercentY > 1 - Tolerance && PercentY < 1 + Tolerance) {
                    return EA.BottomMiddle
                }
            }
            return EA.MiddleMiddle
        },
        GetWidth: function GetWidthFn(SpriteIndex) {
            var psFrameData = this.Texture.GetFrame(this.Frame[SpriteIndex]);
            return psFrameData.Width
        },
        GetHeight: function GetHeightFn(SpriteIndex) {
            var psFrameData = this.Texture.GetFrame(this.Frame[SpriteIndex]);
            return psFrameData.Height
        },
        Lock: function LockFn() {
            this.NumSprites = 0;
            this.AllVertexDirty = false;
            this.AnyVertexDirty = false
        },
        UnLock: function UnLockFn() {
            if (this.NumSprites > 0) {
                this.positionVertexBuffer.setData(this.VertexArray, 0, this.NumSprites * 4)
            }
            this.AllVertexDirty = false
        },
        OutputSprite: function OutputSpriteFn(TheSprite) {
            if (this.NumSprites === this.MaxSprites) {
                Debug.Assert(this.NumSprites !== this.MaxSprites, "Maximum sprites reached for list : " + this.MaxSprites);
                return
            }
            this.NumSprites += 1;
            if (TheSprite.LocalMatrixDirty || TheSprite.VerticesDirty) {
                var frame = this.Texture.Frames[TheSprite.Frame];
                if (TheSprite.VerticesDirty) {
                    var tx = frame.tx;
                    var ty = frame.ty;
                    var tx2 = frame.tx2;
                    var ty2 = frame.ty2;
                    if (TheSprite.UVDirty) {
                        tx = tx * TheSprite.UScale + TheSprite.UOffset;
                        ty = ty * TheSprite.VScale + TheSprite.VOffset;
                        tx2 = tx2 * TheSprite.UScale + TheSprite.UOffset;
                        ty2 = ty2 * TheSprite.VScale + TheSprite.VOffset
                    }
                    TheSprite.VertexArray[3] = tx;
                    TheSprite.VertexArray[4] = ty;
                    TheSprite.VertexArray[10] = tx2;
                    TheSprite.VertexArray[11] = ty;
                    TheSprite.VertexArray[17] = tx;
                    TheSprite.VertexArray[18] = ty2;
                    TheSprite.VertexArray[24] = tx2;
                    TheSprite.VertexArray[25] = ty2;
                    if (TheSprite.Frame2) {
                        var frame2 = this.Texture2.Frames[TheSprite.Frame2];
                        TheSprite.VertexArray[5] = frame2.tx;
                        TheSprite.VertexArray[6] = frame2.ty;
                        TheSprite.VertexArray[12] = frame2.tx2;
                        TheSprite.VertexArray[13] = frame2.ty;
                        TheSprite.VertexArray[19] = frame2.tx;
                        TheSprite.VertexArray[20] = frame2.ty2;
                        TheSprite.VertexArray[26] = frame2.tx2;
                        TheSprite.VertexArray[27] = frame2.ty2
                    }
                }
                if (TheSprite.LocalMatrixDirty || TheSprite.VerticesDirty) {
                    var SX = frame.Width * TheSprite.ScaleX;
                    var SY = frame.Height * TheSprite.ScaleY;
                    if (TheSprite.Rotation) {
                        var CosAngle = Math.cos(TheSprite.Rotation);
                        var SinAngle = Math.sin(TheSprite.Rotation);
                        var j, k = 0;
                        for (j = 0; j < 4; j += 1) {
                            var fx = (SpriteList.Vertex[j][0] + TheSprite.AnchorX) * SX;
                            var fy = (SpriteList.Vertex[j][1] - TheSprite.AnchorY) * SY;
                            TheSprite.VertexArray[k + 0] = fx * CosAngle - fy * SinAngle + TheSprite.x;
                            TheSprite.VertexArray[k + 1] = -(fx * SinAngle + fy * CosAngle + TheSprite.y);
                            k += 7
                        }
                    } else {
                        var x1 = TheSprite.AnchorX * SX + TheSprite.x;
                        var x2 = (1 + TheSprite.AnchorX) * SX + TheSprite.x;
                        var y1 = -(-TheSprite.AnchorY * SY + TheSprite.y);
                        var y2 = -((1 - TheSprite.AnchorY) * SY + TheSprite.y);
                        TheSprite.VertexArray[0] = x1;
                        TheSprite.VertexArray[1] = y1;
                        TheSprite.VertexArray[7] = x2;
                        TheSprite.VertexArray[8] = y1;
                        TheSprite.VertexArray[14] = x1;
                        TheSprite.VertexArray[15] = y2;
                        TheSprite.VertexArray[21] = x2;
                        TheSprite.VertexArray[22] = y2
                    }
                }
                TheSprite.LocalMatrixDirty = false;
                TheSprite.VerticesDirty = false
            }
            this.VertexArray.set(TheSprite.VertexArray, (this.NumSprites - 1) * 28)
        },
        OutputStaticSprite: function OutputStaticSpriteFn(VertexArray) {
            if (this.NumSprites === this.MaxSprites) {
                Debug.Assert(this.NumSprites !== this.MaxSprites, "Maximum sprites reached for list : " + this.MaxSprites);
                return
            }
            this.NumSprites += 1;
            var Offset = (this.NumSprites - 1) * 28;
            this.VertexArray.set(VertexArray, Offset)
        },
        LockColour: function LockColourFn() {
            this.ColourCount = 0;
            this.ColourDirty = false
        },
        UnLockColour: function UnLockColourFn() {
            if (this.ColourCount > 0) {
                this.colorVertexBuffer.setData(this.ColourVertexArray, 0, this.ColourCount * 4)
            }
        },
        OutputColour: function OutputColourFn(ColourArray) {
            if (this.ColourCount === this.MaxSprites) {
                Debug.Assert(this.ColourCount !== this.MaxSprites, "Maximum sprites reached for list : " + this.MaxSprites);
                return
            }
            this.ColourCount += 1;
            var Offset = (this.ColourCount - 1) * 16;
            var i, j;
            for (i = 0; i < 4; i += 1) {
                this.ColourVertexArray.set(ColourArray, Offset + i * 4)
            }
        },
        SetShader: function SetShaderFn(Shader) {
            this.Shader = Shader
        },
        GetShader: function GetShaderFn() {
            return this.Shader
        },
        SetParent: function SetParentFn(Parent) {
            this.Parent = Parent;
            this.SetParentDirty()
        },
        SetParentDirty: function SetParentDirtyFn() {
            if (this.Parent) {
                this.techniqueParameters.TransformMatrix = this.Parent.GetMatrix()
            }
        },
        CreateVertexBuffer: function CreateVertexBuffer() {
            var i;
            var writer;
            var TurbulenzGraphicsDevice = JamSystem.RenderManager.TurbulenzGraphicsDevice;
            var positionsParameters = {
                numVertices: 4 * this.NumSprites,
                attributes: ["FLOAT3", "FLOAT2", "FLOAT2"],
                dynamic: true
            };
            this.positionVertexBuffer = TurbulenzGraphicsDevice.createVertexBuffer(positionsParameters);
            for (i = 0; i < this.NumSprites * 28; i += 1) {
                this.VertexArray[i] = 0
            }
            this.positionVertexBuffer.setData(this.VertexArray, 0, this.NumSprites * 4);
            var colorsParameters = {
                numVertices: 4 * this.NumSprites,
                attributes: ["UBYTE4N"],
                dynamic: true
            };
            this.colorVertexBuffer = TurbulenzGraphicsDevice.createVertexBuffer(colorsParameters);
            for (i = 0; i < this.NumSprites * 16; i += 1) {
                this.ColourVertexArray[i] = 1
            }
            this.colorVertexBuffer.setData(this.ColourVertexArray, 0, this.NumSprites * 4);
            if (!SpriteList.SharedIndexBuffer || SpriteList.SharedIndexBuffer.numIndices < 6 * this.NumSprites) {
                if (SpriteList.SharedIndexBuffer) {
                    SpriteList.SharedIndexBuffer.destroy()
                }
                var indexBufferParameters = {
                    numIndices: 6 * this.NumSprites,
                    format: "USHORT"
                };
                SpriteList.SharedIndexBuffer = TurbulenzGraphicsDevice.createIndexBuffer(indexBufferParameters);
                var Buffer = new Uint16Array(this.NumSprites * 6);
                for (i = 0; i < this.NumSprites; i += 1) {
                    Buffer[i * 6 + 0] = i * 4 + 0;
                    Buffer[i * 6 + 1] = i * 4 + 1;
                    Buffer[i * 6 + 2] = i * 4 + 2;
                    Buffer[i * 6 + 3] = i * 4 + 1;
                    Buffer[i * 6 + 4] = i * 4 + 3;
                    Buffer[i * 6 + 5] = i * 4 + 2
                }
                SpriteList.SharedIndexBuffer.setData(Buffer, 0, this.NumSprites * 6);
                SpriteList.SharedIndexBufferRefs += 1
            }
        },
        UpdateVertices: function UpdateVerticesFn() {
            var i, j;
            var writer;
            for (i = 0; i < this.NumSprites; i += 1) {
                {
                    var texture = this.Texture.GetImage(this.Frame[i]);
                    var frame = this.Texture.GetFrame(this.Frame[i]);
                    var tx = frame.u / texture.width;
                    var ty = frame.v / texture.height;
                    var tx2 = tx + frame.Width / texture.width;
                    var ty2 = ty + frame.Height / texture.height;
                    if (this.UVDirty[i]) {
                        tx = tx * this.UScale[i] + this.UOffset[i];
                        ty = ty * this.VScale[i] + this.VOffset[i];
                        tx2 = tx2 * this.UScale[i] + this.UOffset[i];
                        ty2 = ty2 * this.VScale[i] + this.VOffset[i]
                    }
                    var ScaleX = frame.Width * this.ScaleX[i];
                    var ScaleY = frame.Height * this.ScaleY[i];
                    var CosAngle = 1;
                    var SinAngle = 0;
                    if (this.Rotation[i]) {
                        CosAngle = Math.cos(this.Rotation[i]);
                        SinAngle = Math.sin(this.Rotation[i])
                    }
                    for (j = 0; j < 4; j += 1) {
                        var fx = SpriteList.Vertex[j][0] + this.AnchorX[i];
                        var fy = SpriteList.Vertex[j][1] - this.AnchorY[i];
                        fx *= ScaleX;
                        fy *= ScaleY;
                        if (this.Rotation[i]) {
                            var rx = fx;
                            var ry = fy;
                            fx = rx * CosAngle - ry * SinAngle;
                            fy = rx * SinAngle + ry * CosAngle
                        }
                        SpriteList.FinalVertex[j][0] = fx + this.x[i];
                        SpriteList.FinalVertex[j][1] = fy + this.y[i]
                    }
                    this.AABB_Top[i] = SpriteList.FinalVertex[0][1];
                    this.AABB_Bottom[i] = SpriteList.FinalVertex[0][1];
                    this.AABB_Left[i] = SpriteList.FinalVertex[0][0];
                    this.AABB_Right[i] = SpriteList.FinalVertex[0][0];
                    for (j = 1; j < 4; j += 1) {
                        if (this.AABB_Top[i] > SpriteList.FinalVertex[j][1]) {
                            this.AABB_Top[i] = SpriteList.FinalVertex[j][1]
                        }
                        if (this.AABB_Bottom[i] < SpriteList.FinalVertex[j][1]) {
                            this.AABB_Bottom[i] = SpriteList.FinalVertex[j][1]
                        }
                        if (this.AABB_Left[i] > SpriteList.FinalVertex[j][0]) {
                            this.AABB_Left[i] = SpriteList.FinalVertex[j][0]
                        }
                        if (this.AABB_Right[i] < SpriteList.FinalVertex[j][0]) {
                            this.AABB_Right[i] = SpriteList.FinalVertex[j][0]
                        }
                    }
                    var t2x = 0;
                    var t2y = 0;
                    var t2x2 = 0;
                    var t2y2 = 0;
                    if (this.Texture2) {
                        texture = this.Texture2.GetImage(this.Frame2[i]);
                        frame = this.Texture2.GetFrame(this.Frame2[i]);
                        t2x = frame.u / texture.width;
                        t2y = frame.v / texture.height;
                        t2x2 = t2x + frame.Width / texture.width;
                        t2y2 = t2y + frame.Height / texture.height
                    }
                    if (this.OldVertex[i] === undefined) {
                        this.OldVertex[i] = new Float32Array(28)
                    }
                    this.OldVertex[i][0] = SpriteList.FinalVertex[0][0];
                    this.OldVertex[i][1] = -SpriteList.FinalVertex[0][1];
                    this.OldVertex[i][2] = 0;
                    this.OldVertex[i][3] = tx;
                    this.OldVertex[i][4] = ty;
                    this.OldVertex[i][5] = t2x;
                    this.OldVertex[i][6] = t2y;
                    this.OldVertex[i][7] = SpriteList.FinalVertex[1][0];
                    this.OldVertex[i][8] = -SpriteList.FinalVertex[1][1];
                    this.OldVertex[i][9] = 0;
                    this.OldVertex[i][10] = tx2;
                    this.OldVertex[i][11] = ty;
                    this.OldVertex[i][12] = t2x2;
                    this.OldVertex[i][13] = t2y;
                    this.OldVertex[i][14] = SpriteList.FinalVertex[2][0];
                    this.OldVertex[i][15] = -SpriteList.FinalVertex[2][1];
                    this.OldVertex[i][16] = 0;
                    this.OldVertex[i][17] = tx;
                    this.OldVertex[i][18] = ty2;
                    this.OldVertex[i][19] = t2x;
                    this.OldVertex[i][20] = t2y2;
                    this.OldVertex[i][21] = SpriteList.FinalVertex[3][0];
                    this.OldVertex[i][22] = -SpriteList.FinalVertex[3][1];
                    this.OldVertex[i][23] = 0;
                    this.OldVertex[i][24] = tx2;
                    this.OldVertex[i][25] = ty2;
                    this.OldVertex[i][26] = t2x2;
                    this.OldVertex[i][27] = t2y2;
                    this.VerticesDirty[i] = false;
                    var Offset = i * 28;
                    this.VertexArray.set(this.OldVertex[i], Offset)
                }
            }
        },
        Render: function RenderFn() {
            if (this.bVisible) {
                if (this.AnyVertexDirty) {
                    this.UpdateVertices();
                    this.AnyVertexDirty = false;
                    this.positionVertexBuffer.setData(this.VertexArray, 0, this.NumSprites * 4)
                }
                if (this.ColourDirty) {
                    this.ColourDirty = false;
                    this.colorVertexBuffer.setData(this.ColourVertexArray, 0, this.NumSprites * 4)
                }
                if (JamSystem.RenderManager.CurrentShader !== this.Shader) {
                    this.Shader.SetIsActive()
                }
                this.graphicsDevice.setTechniqueParameters(this.techniqueParameters);
                this.graphicsDevice.setStream(this.colorVertexBuffer, this.colorSemantics);
                this.graphicsDevice.setStream(this.positionVertexBuffer, this.positionSemantics);
                this.graphicsDevice.setIndexBuffer(SpriteList.SharedIndexBuffer);
                this.graphicsDevice.drawIndexed(this.primitive, this.NumSprites * 6);
                SpriteList.DebugRenderCount += 1
            }
        },
        Destroy: function DestroyFn() {
            if (this.Parent) {
                this.Parent.RemoveChild(this)
            }
            if (SpriteList.SharedIndexBufferRefs === 1) {
                SpriteList.SharedIndexBuffer.destroy();
                SpriteList.SharedIndexBuffer = null
            }
            SpriteList.SharedIndexBufferRefs -= 1;
            this.colorVertexBuffer.destroy();
            this.positionVertexBuffer.destroy()
        }
    };
    SpriteList.Create = function SpriteListCreate(MaxSprites, Texture1, Texture2, positionSemantics, colorSemantics) {
        var NewSpriteList = new SpriteList;
        NewSpriteList.Parent = 0;
        NewSpriteList.bVisible = true;
        NewSpriteList.MaxSprites = MaxSprites;
        NewSpriteList.NumSprites = MaxSprites;
        NewSpriteList.OutputCount = 0;
        NewSpriteList.ColourCount = 0;
        NewSpriteList.Depth = 0;
        NewSpriteList.Texture = Texture1;
        NewSpriteList.Texture2 = Texture2;
        NewSpriteList.Anchor = [];
        NewSpriteList.AnchorX = [];
        NewSpriteList.AnchorY = [];
        NewSpriteList.x = [];
        NewSpriteList.y = [];
        NewSpriteList.ScaleX = [];
        NewSpriteList.ScaleY = [];
        NewSpriteList.Rotation = [];
        NewSpriteList.Frame = [];
        NewSpriteList.Frame2 = [];
        NewSpriteList.AABB_Top = [];
        NewSpriteList.AABB_Bottom = [];
        NewSpriteList.AABB_Left = [];
        NewSpriteList.AABB_Right = [];
        NewSpriteList.ColourArray = [];
        NewSpriteList.ColourNormal = [];
        NewSpriteList.UScale = [];
        NewSpriteList.VScale = [];
        NewSpriteList.UOffset = [];
        NewSpriteList.VOffset = [];
        NewSpriteList.UVDirty = [];
        NewSpriteList.VerticesDirty = [];
        NewSpriteList.OldVertex = [];
        NewSpriteList.VertexArray = new Float32Array(MaxSprites * 28);
        NewSpriteList.ColourVertexArray = new Float32Array(MaxSprites * 16);
        NewSpriteList.AnyVertexDirty = true;
        NewSpriteList.AllVertexDirty = true;
        NewSpriteList.ColourDirty = false;
        NewSpriteList.graphicsDevice = JamSystem.RenderManager.TurbulenzGraphicsDevice;
        if (Texture2 !== undefined) {
            NewSpriteList.techniqueParameters = NewSpriteList.graphicsDevice.createTechniqueParameters({
                diffuse: null,
                diffuse2: null,
                TransformMatrix: null
            })
        } else {
            NewSpriteList.techniqueParameters = NewSpriteList.graphicsDevice.createTechniqueParameters({
                diffuse: null,
                TransformMatrix: null
            })
        }
        if (Texture1) {
            NewSpriteList.techniqueParameters.diffuse = Texture1.GetImage(0)
        }
        if (Texture2) {
            NewSpriteList.techniqueParameters.diffuse2 = Texture2.GetImage(0)
        }
        NewSpriteList.primitive = NewSpriteList.graphicsDevice.PRIMITIVE_TRIANGLES;
        NewSpriteList.colorSemantics = colorSemantics;
        NewSpriteList.colorVertexBuffer = null;
        NewSpriteList.positionSemantics = positionSemantics;
        NewSpriteList.positionVertexBuffer = null;
        NewSpriteList.Shader = JamSystem.RenderManager.DefaultSpriteShader;
        NewSpriteList.CreateVertexBuffer();
        var i;
        for (i = 0; i < MaxSprites; i += 1) {
            NewSpriteList.SetPosition(i, 0, 0);
            NewSpriteList.SetScale(i, 0, 0);
            NewSpriteList.SetRotation(i, 0);
            NewSpriteList.SetFrame(i, 0);
            NewSpriteList.SetAnchor(i, EA.Default);
            NewSpriteList.ColourArray[i] = [1, 1, 1, 1];
            NewSpriteList.ColourVertexArray[i * 4 + 0] = 1;
            NewSpriteList.ColourVertexArray[i * 4 + 1] = 1;
            NewSpriteList.ColourVertexArray[i * 4 + 2] = 1;
            NewSpriteList.ColourVertexArray[i * 4 + 3] = 1;
            NewSpriteList.ColourNormal[i] = true;
            NewSpriteList.UScale[i] = 1;
            NewSpriteList.VScale[i] = 1;
            NewSpriteList.UOffset[i] = 0;
            NewSpriteList.VOffset[i] = 0;
            NewSpriteList.UVDirty[i] = false
        }
        return NewSpriteList
    };

    function Strip() {}
    Strip.DebugRenderCount = 0;
    Strip.prototype = {
        SetTexture: function SetTextureFn(ThisTexture, Image) {
            this.techniqueParameters.diffuse = ThisTexture.GetImage(Image);
            this.Texture = ThisTexture
        },
        GetTexture: function GetTextureFn() {
            return this.Texture
        },
        SetColour: function SetColourFn(Colour) {
            this.Colour = Colour;
            var writer = this.colorVertexBuffer.map(0, this.MaxPoints * 2);
            var i;
            if (writer) {
                for (i = 0; i < this.MaxPoints * 2; i += 1) {
                    writer(Colour[0], Colour[1], Colour[2], Colour[3])
                }
                this.colorVertexBuffer.unmap(writer)
            }
        },
        GetColour: function GetColourFn(Index) {
            return this.Colour
        },
        SetPointArray: function SetPointArrayFn(PointArrayX, PointArrayY, Length, Thickness) {
            if (Length > this.MaxPoints) {
                Length = this.MaxPoints
            }
            this.NumPoints = Length;
            this.x = PointArrayX;
            this.y = PointArrayY;
            this.AnyVertexDirty = true;
            this.Thickness = Thickness
        },
        SetFrame: function SetFrameFn(Frame) {
            this.Frame = Frame;
            this.AnyVertexDirty = true
        },
        GetFrame: function GetFrameFn() {
            return this.Frame
        },
        SetIsVisible: function SetIsVisibleFn(bVisible) {
            this.bVisible = bVisible
        },
        GetIsVisible: function GetIsVisibleFn() {
            return this.bVisible
        },
        SetShader: function SetShaderFn(Shader) {
            this.Shader = Shader
        },
        GetShader: function GetShaderFn() {
            return this.Shader
        },
        SetParent: function SetParentFn(Parent) {
            this.Parent = Parent;
            this.SetParentDirty()
        },
        SetParentDirty: function SetParentDirtyFn() {
            if (this.Parent) {
                this.techniqueParameters.TransformMatrix = this.Parent.GetMatrix()
            }
        },
        CreateVertexBuffer: function CreateVertexBuffer() {
            var i;
            var writer;
            var TurbulenzGraphicsDevice = JamSystem.RenderManager.TurbulenzGraphicsDevice;
            var positionsParameters = {
                numVertices: this.MaxPoints * 2,
                attributes: ["FLOAT3", "FLOAT2"],
                dynamic: true
            };
            this.positionVertexBuffer = TurbulenzGraphicsDevice.createVertexBuffer(positionsParameters);
            writer = this.positionVertexBuffer.map();
            if (writer) {
                for (i = 0; i < this.MaxPoints * 2; i += 1) {
                    writer(0, 0, 0, 0, 0)
                }
                this.positionVertexBuffer.unmap(writer)
            }
            var colorsParameters = {
                numVertices: this.MaxPoints * 2,
                attributes: ["UBYTE4N"],
                dynamic: true
            };
            this.colorVertexBuffer = TurbulenzGraphicsDevice.createVertexBuffer(colorsParameters);
            writer = this.colorVertexBuffer.map();
            if (writer) {
                for (i = 0; i < this.MaxPoints * 2; i += 1) {
                    writer(1, 1, 1, 1)
                }
                this.colorVertexBuffer.unmap(writer)
            }
            var indexBufferParameters = {
                numIndices: this.MaxPoints * 2,
                format: "USHORT"
            };
            this.indexBuffer = TurbulenzGraphicsDevice.createIndexBuffer(indexBufferParameters);
            writer = this.indexBuffer.map();
            if (writer) {
                for (i = 0; i < this.MaxPoints * 2; i += 1) {
                    writer(i)
                }
                this.indexBuffer.unmap(writer)
            }
        },
        UpdateVertices: function UpdateVerticesFn() {
            var i, j;
            var writer;
            writer = this.positionVertexBuffer.map();
            var texture = this.Texture.GetImage(this.Frame);
            var frame = this.Texture.GetFrame(this.Frame);
            var ty = frame.v / texture.height;
            var ty2 = ty + frame.Height / texture.height;
            var tx = frame.u / texture.width;
            var tx2 = tx + frame.Width / texture.width;
            var txd = (tx2 - tx) / (this.NumPoints - 1);
            var PreviousAngle;
            for (i = 0; i < this.NumPoints; i += 1) {
                var Angle;
                var xd, yd;
                if (i === 0) {
                    xd = this.x[i + 1] - this.x[i];
                    yd = this.y[i + 1] - this.y[i];
                    Angle = -Math.atan2(xd, yd);
                    PreviousAngle = Angle
                } else if (i === this.NumPoints - 1) {
                    xd = this.x[i] - this.x[i - 1];
                    yd = this.y[i] - this.y[i - 1];
                    Angle = -Math.atan2(xd, yd);
                    PreviousAngle = Angle
                } else {
                    xd = this.x[i + 1] - this.x[i];
                    yd = this.y[i + 1] - this.y[i];
                    Angle = -Math.atan2(xd, yd);
                    var TempAngle = PreviousAngle - Angle;
                    PreviousAngle = Angle;
                    if (TempAngle > Math.PI) {
                        TempAngle -= Math.PI / 2
                    }
                    if (TempAngle < -Math.PI) {
                        TempAngle += Math.PI / 2
                    }
                    Angle = Angle + TempAngle / 2
                }
                var DeltaX = Math.cos(Angle) * this.Thickness;
                var DeltaY = Math.sin(Angle) * this.Thickness;
                writer(this.x[i] - DeltaX, -(this.y[i] - DeltaY), 0, tx, ty2);
                writer(this.x[i] + DeltaX, -(this.y[i] + DeltaY), 0, tx, ty);
                tx += txd
            }
            this.positionVertexBuffer.unmap(writer)
        },
        Render: function RenderFn() {
            if (this.bVisible && this.NumPoints > 1) {
                if (this.AnyVertexDirty) {
                    this.UpdateVertices();
                    this.AnyVertexDirty = false
                }
                this.Shader.SetIsActive();
                this.graphicsDevice.setTechniqueParameters(this.techniqueParameters);
                this.graphicsDevice.setStream(this.colorVertexBuffer, this.colorSemantics);
                this.graphicsDevice.setStream(this.positionVertexBuffer, this.positionSemantics);
                this.graphicsDevice.setIndexBuffer(this.indexBuffer);
                this.graphicsDevice.drawIndexed(this.primitive, this.NumPoints * 2);
                Strip.DebugRenderCount += 1
            }
        },
        Destroy: function DestroyFn() {
            if (this.Parent) {
                this.Parent.RemoveChild(this)
            }
            this.indexBuffer.destroy();
            this.colorVertexBuffer.destroy();
            this.positionVertexBuffer.destroy()
        }
    };
    Strip.Create = function StripCreate(MaxPoints, NewTexture, Frame, positionSemantics, colorSemantics) {
        var NewStrip = new Strip;
        NewStrip.Parent = 0;
        NewStrip.bVisible = true;
        NewStrip.MaxPoints = MaxPoints;
        NewStrip.NumPoints = MaxPoints;
        NewStrip.OutputCount = 0;
        NewStrip.Depth = 0;
        NewStrip.Texture = NewTexture;
        NewStrip.Frame = Frame;
        NewStrip.Thickness = 5;
        NewStrip.x = 0;
        NewStrip.y = 0;
        NewStrip.AnyVertexDirty = true;
        NewStrip.graphicsDevice = JamSystem.RenderManager.TurbulenzGraphicsDevice;
        NewStrip.techniqueParameters = NewStrip.graphicsDevice.createTechniqueParameters({
            diffuse: null,
            TransformMatrix: null
        });
        if (NewTexture) {
            NewStrip.techniqueParameters.diffuse = NewTexture.GetImage(Frame)
        }
        NewStrip.primitive = NewStrip.graphicsDevice.PRIMITIVE_TRIANGLE_STRIP;
        NewStrip.colorSemantics = colorSemantics;
        NewStrip.colorVertexBuffer = null;
        NewStrip.positionSemantics = positionSemantics;
        NewStrip.positionVertexBuffer = null;
        NewStrip.indexBuffer = null;
        NewStrip.Shader = JamSystem.RenderManager.DefaultSpriteShader;
        NewStrip.CreateVertexBuffer();
        return NewStrip
    };

    function BitmapText() {}
    BitmapText.DebugRenderCount = 0;
    BitmapText.prototype = {
        SetText: function SetTextFn(pszText) {
            if (this.pszText !== pszText) {
                var pszOldText = this.pszText;
                this.pszText = pszText;
                this.Width = 0;
                this.Height = 0;
                this.VerticesDirty = true;
                this.MatrixDirty = true;
                this.LocalMatrixDirty = true;
                if (pszText === "" || pszText === 0) {
                    if (this.colorVertexBuffer) {
                        this.colorVertexBuffer.destroy();
                        this.colorVertexBuffer = null
                    }
                    if (this.positionVertexBuffer) {
                        this.positionVertexBuffer.destroy();
                        this.positionVertexBuffer = null
                    }
                    if (this.indexBuffer) {
                        this.indexBuffer.destroy();
                        this.indexBuffer = null
                    }
                    this.NumChars = 0
                } else {
                    if (pszOldText === null || pszOldText === "" || pszOldText.length !== this.pszText.length) {
                        this.CreateVertexBuffer()
                    }
                }
            }
        },
        GetText: function GetTextFn() {
            return this.pszText
        },
        SetFont: function SetFontFn(NewFont) {
            this.Font = JamSystem.AssetManager.GetBitmapFont(NewFont);
            var OldText = this.pszText;
            this.pszText = "";
            this.SetText(OldText)
        },
        GetFont: function GetFontFn() {
            return this.Font
        },
        SetColour: function SetColourFn(ColourArray) {
            var i, j;
            for (i = 0; i < 4; i += 1) {
                this.Colour[i] = ColourArray[i]
            }
            if (this.indexBuffer === null) {
                return
            }
            for (i = 0; i < this.NumChars * 4; i += 1) {
                this.ColourVertexArray.set(ColourArray, i * 4)
            }
            this.colorVertexBuffer.setData(this.ColourVertexArray, 0, this.NumChars * 4)
        },
        GetColour: function GetColourFn() {
            return this.Colour
        },
        SetOpacity: function SetOpacityFn(Opacity) {
            this.Colour[3] = Opacity;
            if (this.indexBuffer === null) {
                return
            }
            for (i = 0; i < this.NumChars * 4; i += 1) {
                this.ColourVertexArray.set([Opacity], i * 4 + 3)
            }
            this.colorVertexBuffer.setData(this.ColourVertexArray, 0, this.NumChars * 4)
        },
        GetOpacity: function GetOpacityFn() {
            return this.Colour[3]
        },
        GetWidth: function GetWidthFn() {
            this.ForceUpdate();
            return this.Width
        },
        GetHeight: function GetHeightFn() {
            this.ForceUpdate();
            return this.Height
        },
        GetSpecificWidth: function GetSpecWidthFn(Slice) {
            var OverallWidth = 0,
                i = 0;
            if (Slice > this.pszText.length) {
                Slice = this.pszText.length
            }
            for (i = 0; i < Slice; i += 1) {
                var charCode = this.pszText.charCodeAt(i);
                var FrameID = this.Font.CharToImageTable[charCode];
                if (FrameID === undefined) {
                    FrameID = this.Font.CharToImageTable[this.Font.DefaultChar]
                }
                var frame = this.Font.Texture.GetFrame(FrameID);
                OverallWidth += frame.Width * this.Font.Scale;
                OverallWidth += this.Font.CharSpacing * this.Font.Scale
            }
            return OverallWidth
        },
        GetIndexFromWidth: function GetIndexFromWidthFn(Width) {
            var CurrentWidth = 0,
                i = 0;
            Width = Math.floor(Width);
            if (Width < 0) {
                return 0
            }
            if (Width > this.GetWidth()) {
                return this.pszText.length
            }
            for (i = 0; i < this.pszText.length; i += 1) {
                var charCode = this.pszText.charCodeAt(i);
                var FrameID = this.Font.CharToImageTable[charCode];
                if (FrameID === undefined) {
                    FrameID = this.Font.CharToImageTable[this.Font.DefaultChar]
                }
                var frame = this.Font.Texture.GetFrame(FrameID);
                CurrentWidth += frame.Width * this.Font.Scale;
                CurrentWidth += this.Font.CharSpacing * this.Font.Scale;
                if (CurrentWidth > Width) {
                    return i
                }
            }
            return this.pszText.length - 1
        },
        CreateVertexBuffer: function CreateVertexBufferFn() {
            if (this.colorVertexBuffer) {
                this.colorVertexBuffer.destroy();
                this.colorVertexBuffer = null
            }
            if (this.positionVertexBuffer) {
                this.positionVertexBuffer.destroy();
                this.positionVertexBuffer = null
            }
            if (this.indexBuffer) {
                this.indexBuffer.destroy();
                this.indexBuffer = null
            }
            var i;
            var writer;
            var TurbulenzGraphicsDevice = JamSystem.RenderManager.TurbulenzGraphicsDevice;
            this.NumChars = 0;
            for (i = 0; i < this.pszText.length; i += 1) {
                charCode = this.pszText.charCodeAt(i);
                if (charCode !== 10) {
                    this.NumChars += 1
                }
            }
            this.VertexArray = new Float32Array(this.NumChars * 20);
            this.ColourVertexArray = new Float32Array(this.NumChars * 16);
            var positionsParameters = {
                numVertices: 4 * this.NumChars,
                attributes: ["FLOAT3", "FLOAT2"],
                dynamic: true
            };
            this.positionVertexBuffer = TurbulenzGraphicsDevice.createVertexBuffer(positionsParameters);
            for (i = 0; i < this.NumChars * 20; i += 1) {
                this.VertexArray[i] = 0
            }
            this.positionVertexBuffer.setData(this.VertexArray, 0, this.NumChars * 4);
            var colorsParameters = {
                numVertices: 4 * this.NumChars,
                attributes: ["UBYTE4N"],
                dynamic: true
            };
            this.colorVertexBuffer = TurbulenzGraphicsDevice.createVertexBuffer(colorsParameters);
            for (i = 0; i < this.NumChars * 4; i += 1) {
                this.ColourVertexArray[i * 4 + 0] = this.Colour[0];
                this.ColourVertexArray[i * 4 + 1] = this.Colour[1];
                this.ColourVertexArray[i * 4 + 2] = this.Colour[2];
                this.ColourVertexArray[i * 4 + 3] = this.Colour[3]
            }
            this.colorVertexBuffer.setData(this.ColourVertexArray, 0, this.NumChars * 4);
            var indexBufferParameters = {
                numIndices: 6 * this.NumChars,
                format: "USHORT"
            };
            this.indexBuffer = TurbulenzGraphicsDevice.createIndexBuffer(indexBufferParameters);
            var Buffer = new Uint16Array(this.NumChars * 6);
            for (i = 0; i < this.NumChars; i += 1) {
                Buffer[i * 6 + 0] = i * 4 + 0;
                Buffer[i * 6 + 1] = i * 4 + 1;
                Buffer[i * 6 + 2] = i * 4 + 2;
                Buffer[i * 6 + 3] = i * 4 + 1;
                Buffer[i * 6 + 4] = i * 4 + 3;
                Buffer[i * 6 + 5] = i * 4 + 2
            }
            this.indexBuffer.setData(Buffer, 0, this.NumChars * 6)
        },
        UpdateVertices: function UpdateVerticesFn() {
            if (this.indexBuffer === null) {
                return
            }
            var i;
            var texture = this.Font.Texture.GetImage(0);
            this.techniqueParameters.diffuse = texture;
            var frame = this.Font.Texture.GetFrame(0);
            this.Width = 0;
            this.Height = frame.Height * this.Font.Scale;
            var Width = 0;
            var LineWidths = [];
            var charCode;
            var FrameID;
            for (i = 0; i < this.pszText.length; i += 1) {
                charCode = this.pszText.charCodeAt(i);
                if (charCode === 10) {
                    LineWidths[LineWidths.length] = Width;
                    Width = 0;
                    this.Height += (frame.Height + this.Font.LineSpacing) * this.Font.Scale
                } else {
                    FrameID = this.Font.CharToImageTable[charCode];
                    if (FrameID === undefined) {
                        FrameID = this.Font.CharToImageTable[this.Font.DefaultChar]
                    }
                    frame = this.Font.Texture.GetFrame(FrameID);
                    Width += (frame.Width + this.Font.CharSpacing) * this.Font.Scale;
                    if (Width > this.Width) {
                        this.Width = Width
                    }
                }
            }
            LineWidths[LineWidths.length] = Width;
            var CurrentLine = 0;
            var x;
            if (this.AnchorX === 0) {
                x = 0
            } else if (this.AnchorX === -.5) {
                x = this.Width / 2 - LineWidths[CurrentLine] / 2
            } else if (this.AnchorX === -1) {
                x = this.Width - LineWidths[CurrentLine]
            }
            var y = 0;
            var NumChars = 0;
            for (i = 0; i < this.pszText.length; i += 1) {
                charCode = this.pszText.charCodeAt(i);
                if (charCode === 10) {
                    CurrentLine += 1;
                    if (this.AnchorX === 0) {
                        x = 0
                    } else if (this.AnchorX === -.5) {
                        x = this.Width / 2 - LineWidths[CurrentLine] / 2
                    } else if (this.AnchorX === -1) {
                        x = this.Width - LineWidths[CurrentLine]
                    }
                    y += (frame.Height + this.Font.LineSpacing) * this.Font.Scale
                } else {
                    FrameID = this.Font.CharToImageTable[charCode];
                    if (FrameID === undefined) {
                        FrameID = this.Font.CharToImageTable[this.Font.DefaultChar]
                    }
                    frame = this.Font.Texture.GetFrame(FrameID);
                    var tx = frame.u / texture.width;
                    var ty = frame.v / texture.height;
                    var tx2 = tx + frame.Width / texture.width;
                    var ty2 = ty + frame.Height / texture.height;
                    var Offset = NumChars * 20;
                    this.VertexArray[Offset + 0] = x;
                    this.VertexArray[Offset + 1] = -y;
                    this.VertexArray[Offset + 2] = 0;
                    this.VertexArray[Offset + 3] = tx;
                    this.VertexArray[Offset + 4] = ty;
                    this.VertexArray[Offset + 5] = x + frame.Width * this.Font.Scale;
                    this.VertexArray[Offset + 6] = -y;
                    this.VertexArray[Offset + 7] = 0;
                    this.VertexArray[Offset + 8] = tx2;
                    this.VertexArray[Offset + 9] = ty;
                    this.VertexArray[Offset + 10] = x;
                    this.VertexArray[Offset + 11] = -y - frame.Height * this.Font.Scale;
                    this.VertexArray[Offset + 12] = 0;
                    this.VertexArray[Offset + 13] = tx;
                    this.VertexArray[Offset + 14] = ty2;
                    this.VertexArray[Offset + 15] = x + frame.Width * this.Font.Scale;
                    this.VertexArray[Offset + 16] = -y - frame.Height * this.Font.Scale;
                    this.VertexArray[Offset + 17] = 0;
                    this.VertexArray[Offset + 18] = tx2;
                    this.VertexArray[Offset + 19] = ty2;
                    NumChars += 1;
                    x += (frame.Width + this.Font.CharSpacing) * this.Font.Scale
                }
            }
            this.positionVertexBuffer.setData(this.VertexArray, 0, NumChars * 4)
        },
        BuildLocalMatrix: function BuildLocalMatrixFn() {
            var MathDevice = JamSystem.TurbulenzMathDevice;
            MathDevice.m43Build(this.ScaleX, 0, 0, 0, this.ScaleY, 0, 0, 0, 1, 0, 0, 0, JamSystem.RenderManager.ScaleMatrix);
            var AnchorX = this.AnchorX * this.Width * this.ScaleX;
            var AnchorY = this.AnchorY * this.Height * this.ScaleY;
            MathDevice.m43BuildTranslation(AnchorX, AnchorY, 0, JamSystem.RenderManager.AnchorTranslationMatrix);
            MathDevice.m43FromAxisRotation(JamSystem.RenderManager.UpVector, this.Rotation, JamSystem.RenderManager.RotationMatrix);
            MathDevice.m43BuildTranslation(this.x, -this.y, 0, JamSystem.RenderManager.TranslationMatrix);
            MathDevice.m43Mul(JamSystem.RenderManager.ScaleMatrix, JamSystem.RenderManager.AnchorTranslationMatrix, JamSystem.RenderManager.ScaleAnchorMatrix);
            MathDevice.m43Mul(JamSystem.RenderManager.ScaleAnchorMatrix, JamSystem.RenderManager.RotationMatrix, JamSystem.RenderManager.ScaleAnchorRotationMatrix);
            MathDevice.m43Mul(JamSystem.RenderManager.ScaleAnchorRotationMatrix, JamSystem.RenderManager.TranslationMatrix, this.LocalMatrix)
        },
        UpdateMatrix: function UpdateMatrixFn() {
            var MathDevice = JamSystem.TurbulenzMathDevice;
            if (this.LocalMatrixDirty) {
                this.BuildLocalMatrix();
                this.LocalMatrixDirty = false
            }
            MathDevice.m43MulM44(this.LocalMatrix, this.Parent.GetMatrix(), this.techniqueParameters.TransformMatrix)
        },
        ForceUpdate: function ForceFn() {
            if (this.VerticesDirty) {
                this.VerticesDirty = false;
                this.UpdateVertices()
            }
            if (this.MatrixDirty) {
                this.MatrixDirty = false;
                this.UpdateMatrix()
            }
        },
        Render: function RenderFn() {
            if (this.bVisible && this.indexBuffer) {
                this.ForceUpdate();
                this.Shader.SetIsActive();
                this.graphicsDevice.setTechniqueParameters(this.techniqueParameters);
                this.graphicsDevice.setStream(this.colorVertexBuffer, this.colorSemantics);
                this.graphicsDevice.setStream(this.positionVertexBuffer, this.positionSemantics);
                this.graphicsDevice.setIndexBuffer(this.indexBuffer);
                this.graphicsDevice.drawIndexed(this.primitive, this.NumChars * 6);
                BitmapText.DebugRenderCount += 1
            }
        },
        RenderDebug: function RenderDebugFn(x, y, ScaleX, ScaleY, Rotation, Text, FontName, ColourArray, Matrix) {
            this.x = x;
            this.y = y;
            this.ScaleX = ScaleX;
            this.ScaleY = ScaleY;
            this.Rotation = Rotation;
            this.Font = JamSystem.AssetManager.GetBitmapFont(FontName);
            this.SetText(Text);
            this.SetColour(ColourArray);
            this.UpdateVertices();
            this.VerticesDirty = false;
            this.BuildLocalMatrix();
            var MathDevice = JamSystem.TurbulenzMathDevice;
            MathDevice.m43MulM44(this.LocalMatrix, Matrix, this.techniqueParameters.TransformMatrix);
            this.MatrixDirty = false;
            this.bVisible = true;
            this.Render();
            this.bVisible = false
        },
        Destroy: function DestroyFn() {
            Renderable.Destroy(this);
            this.indexBuffer.destroy();
            this.colorVertexBuffer.destroy();
            this.positionVertexBuffer.destroy()
        }
    };
    BitmapText.Create = function BitmapTextCreate(x, y, Font, pszText, positionSemantics, colorSemantics) {
        var NewText = Renderable.Create(x, y);
        NewText.SetText = BitmapText.prototype.SetText;
        NewText.GetText = BitmapText.prototype.GetText;
        NewText.SetFont = BitmapText.prototype.SetFont;
        NewText.GetFont = BitmapText.prototype.GetFont;
        NewText.SetColour = BitmapText.prototype.SetColour;
        NewText.GetColour = BitmapText.prototype.GetColour;
        NewText.SetOpacity = BitmapText.prototype.SetOpacity;
        NewText.GetOpacity = BitmapText.prototype.GetOpacity;
        NewText.GetWidth = BitmapText.prototype.GetWidth;
        NewText.GetHeight = BitmapText.prototype.GetHeight;
        NewText.GetSpecificWidth = BitmapText.prototype.GetSpecificWidth;
        NewText.GetIndexFromWidth = BitmapText.prototype.GetIndexFromWidth;
        NewText.CreateVertexBuffer = BitmapText.prototype.CreateVertexBuffer;
        NewText.UpdateVertices = BitmapText.prototype.UpdateVertices;
        NewText.BuildLocalMatrix = BitmapText.prototype.BuildLocalMatrix;
        NewText.UpdateMatrix = BitmapText.prototype.UpdateMatrix;
        NewText.ForceUpdate = BitmapText.prototype.ForceUpdate;
        NewText.Render = BitmapText.prototype.Render;
        NewText.RenderDebug = BitmapText.prototype.RenderDebug;
        NewText.NumChars = 0;
        NewText.Font = Font;
        NewText.pszText = null;
        NewText.VerticesDirty = true;
        NewText.Colour = [1, 1, 1, 1];
        NewText.VertexArray = null;
        NewText.ColourVertexArray = null;
        NewText.graphicsDevice = JamSystem.RenderManager.TurbulenzGraphicsDevice;
        NewText.techniqueParameters = NewText.graphicsDevice.createTechniqueParameters({
            diffuse: null,
            TransformMatrix: NewText.Matrix
        });
        NewText.primitive = NewText.graphicsDevice.PRIMITIVE_TRIANGLES;
        NewText.colorSemantics = colorSemantics;
        NewText.colorVertexBuffer = null;
        NewText.positionSemantics = positionSemantics;
        NewText.positionVertexBuffer = null;
        NewText.indexBuffer = null;
        NewText.SetText(pszText);
        return NewText
    };

    function BitmapFont() {}
    BitmapFont.prototype = {};
    BitmapFont.Create = function BitmapFontCreate(FontName, Texture, CharToImageTable, CharSpacing, LineSpacing, DefaultChar, Scale) {
        var NewText = new BitmapFont;
        NewText.FontName = FontName;
        NewText.Texture = Texture;
        NewText.CharToImageTable = CharToImageTable;
        NewText.CharSpacing = CharSpacing;
        NewText.LineSpacing = LineSpacing;
        NewText.DefaultChar = DefaultChar.charCodeAt(0);
        NewText.Scale = Scale;
        return NewText
    };

    function RenderManager() {}
    RenderManager.prototype = {};
    RenderManager.Create = function RenderManagerCreateFn(TurbulenzMathDevice, Application, DesiredScreenWidth, DesiredScreenHeight, errorCallback, log) {
        var SemanticsTypes;
        var ClearColour;
        var RenderManagerRoot;
        var CurrentDesiredScreenWidth;
        var CurrentDesiredScreenHeight;
        var ShaderList;
        var CurrentShader;
        var ShaderIndex;
        var TurbulenzGraphicsDevice;
        var UserApplication;
        var DebugLine;
        var DebugSprite;
        var DebugText;
        var DoFullScreenFix;
        var TreeCount;
        var SpriteCount;
        var SpriteAnimationCount;
        var SpriteListCount;
        var BitmapTextCount;

        function SetClearColourFn(r, g, b) {
            ClearColour = [r, g, b, 1]
        }

        function SetRootFn(psObject) {
            RenderManagerRoot = psObject
        }

        function GetRootFn() {
            return RenderManagerRoot
        }

        function GetScreenWidthFn() {
            return CurrentDesiredScreenWidth
        }

        function GetScreenHeightFn() {
            return CurrentDesiredScreenHeight
        }

        function CreateTreeFn(x, y) {
            TreeCount += 1;
            var NewRenderTree = RenderTree.Create(x, y);
            return NewRenderTree
        }

        function DestroyTreeFn(NewRenderTree) {
            TreeCount -= 1;
            NewRenderTree.Destroy()
        }

        function CreateSpriteFn(x, y, psTexture, iImage) {
            SpriteCount += 1;
            var psSprite = Sprite.Create(x, y, psTexture, iImage, SemanticsTypes.positionAnd2Texture, SemanticsTypes.color);
            return psSprite
        }

        function DestroySpriteFn(psSprite) {
            SpriteCount -= 1;
            psSprite.Destroy()
        }

        function CreateSpriteAnimationFn(TargetSprite, SpriteIndex) {
            SpriteAnimationCount += 1;
            var psSpriteAnimation = SpriteAnimation.Create(TargetSprite, SpriteIndex);
            return psSpriteAnimation
        }

        function DestroySpriteAnimationFn(psSpriteAnimation) {
            SpriteAnimationCount -= 1;
            psSpriteAnimation.Destroy()
        }

        function CreateSpriteListFn(NumSprites, Texture1, Texture2) {
            SpriteListCount += 1;
            var psSpriteList = SpriteList.Create(NumSprites, Texture1, Texture2, SemanticsTypes.positionAnd2Texture, SemanticsTypes.color);
            return psSpriteList
        }

        function DestroySpriteListFn(psSpriteList) {
            SpriteListCount -= 1;
            psSpriteList.Destroy()
        }

        function CreateLineFn(x, y, endX, endY, Colour) {
            var psLine = Line.Create(TurbulenzGraphicsDevice, TurbulenzMathDevice, SemanticsTypes.position, x, y, endX, endY, Colour);
            return psLine
        }

        function DestroyLineFn(psLine) {
            psLine.Destroy()
        }

        function CreateLineListFn(NumLines, Colour) {
            var psLineList = LineList.Create(NumLines, Colour, SemanticsTypes.position);
            return psLineList
        }

        function DestroyLineListFn(psLineList) {
            psLineList.Destroy()
        }

        function CreateStripFn(NumLines, NewTexture, Frame) {
            var psStrip = Strip.Create(NumLines, NewTexture, Frame, SemanticsTypes.positionAndTexture, SemanticsTypes.color);
            return psStrip
        }

        function DestroyStripFn(psStrip) {
            psStrip.Destroy()
        }

        function CreateBitmapTextFn(x, y, psTexture, pachText) {
            BitmapTextCount += 1;
            var psText = BitmapText.Create(x, y, psTexture, pachText, SemanticsTypes.positionAndTexture, SemanticsTypes.color);
            return psText
        }

        function DestroyBitmapTextFn(psText) {
            BitmapTextCount -= 1;
            psText.Destroy()
        }

        function CreateRenderTargetFn() {
            return JamRenderTarget.Create(2048, 2048)
        }

        function DestroyRenderTargetFn(Target) {
            Target.Destroy()
        }

        function CreateShaderFn(ShaderName, DefaultParameters) {
            var ThisShader = ShaderJam.Create(ShaderName, DefaultParameters, ShaderIndex);
            ShaderIndex += 1;
            ShaderList[ShaderList.length] = ThisShader;
            return ThisShader
        }

        function DestroyShaderFn(ThisShader) {
            var Index = ShaderList.indexOf(ThisShader);
            if (Index !== -1) {
                ShaderList.splice(Index, 1)
            }
            ThisShader.Destroy()
        }

        function SetShaderFn(ThisShader) {
            ThisShader.SetIsActive()
        }

        function DrawDebugLineFn(x1, y1, x2, y2, Colour, Matrix) {
            DebugLine.RenderDebug(x1, y1, x2, y2, Colour, Matrix)
        }

        function DrawDebugSpriteFn(x, y, ScaleX, ScaleY, Rotation, ImageName, ColourArray, Matrix) {
            DebugSprite.RenderDebug(x, y, ScaleX, ScaleY, Rotation, ImageName, ColourArray, Matrix)
        }

        function DrawDebugTextFn(x, y, ScaleX, ScaleY, Rotation, Text, Font, ColourArray, Matrix) {
            DebugText.RenderDebug(x, y, ScaleX, ScaleY, Rotation, Text, Font, ColourArray, Matrix)
        }

        function GetFullScreenFn() {
            return TurbulenzGraphicsDevice.fullscreen
        }

        function SetFullScreenFn(fullscreen) {
            TurbulenzGraphicsDevice.fullscreen = fullscreen;
            DoFullScreenFix = 10
        }

        function RenderFn(currentTime) {
            if (TurbulenzGraphicsDevice.beginFrame()) {
                JamSystem.RenderManager.CurrentShader = null;
                TurbulenzGraphicsDevice.clear(ClearColour);
                if (DoFullScreenFix) {
                    DoFullScreenFix -= 1;
                    var x, y, NewWidth, NewHeight;
                    if (TurbulenzGraphicsDevice.fullscreen) {
                        var Width = TurbulenzGraphicsDevice.width;
                        var Height = TurbulenzGraphicsDevice.height;
                        var Percent = DesiredScreenWidth / DesiredScreenHeight;
                        NewWidth = Height * Percent;
                        NewHeight = Height;
                        x = (Width - NewWidth) / 2;
                        y = (Height - NewHeight) / 2
                    } else {
                        x = 0;
                        y = 0;
                        NewWidth = DesiredScreenWidth;
                        NewHeight = DesiredScreenHeight
                    }
                    TurbulenzGraphicsDevice.setViewport(x, y, NewWidth, NewHeight);
                    TurbulenzGraphicsDevice.setViewport(x, y, NewWidth, NewHeight)
                }
                if (RenderManagerRoot) {
                    Sprite.DebugRenderCount = 0;
                    SpriteList.DebugRenderCount = 0;
                    BitmapText.DebugRenderCount = 0;
                    UserApplication.Render();
                    RenderManagerRoot.Render()
                }
                TurbulenzGraphicsDevice.endFrame()
            }
        }

        function SetActiveShaderFn(Shader) {
            if (JamSystem.RenderManager.CurrentShader !== Shader) {
                JamSystem.RenderManager.CurrentShader = Shader;
                var Device = TurbulenzGraphicsDevice;
                TurbulenzGraphicsDevice.setTechnique(Shader.Technique);
                TurbulenzGraphicsDevice.setTechniqueParameters(Shader.Parameters)
            }
        }

        function initFn() {
            UserApplication = Application;
            CurrentDesiredScreenWidth = DesiredScreenWidth;
            CurrentDesiredScreenHeight = DesiredScreenHeight;
            DoFullScreenFix = false;
            CurrentShader = null;
            ShaderIndex = 0;
            TreeCount = 0;
            SpriteCount = 0;
            SpriteAnimationCount = 0;
            SpriteListCount = 0;
            BitmapTextCount = 0;
            ClearColour = [1, 1, 1, 1];
            ShaderList = [];
            var TurbulenzGraphicsDeviceParameters = {};
            TurbulenzGraphicsDevice = TurbulenzEngine.createGraphicsDevice(TurbulenzGraphicsDeviceParameters);
            Debug.Log("Screen res = ", TurbulenzGraphicsDevice.width, TurbulenzGraphicsDevice.height);
            SemanticsTypes = {};
            SemanticsTypes.position = TurbulenzGraphicsDevice.createSemantics([TurbulenzGraphicsDevice.SEMANTIC_POSITION]);
            SemanticsTypes.color = TurbulenzGraphicsDevice.createSemantics([TurbulenzGraphicsDevice.SEMANTIC_COLOR]);
            SemanticsTypes.positionAndTexture = TurbulenzGraphicsDevice.createSemantics([TurbulenzGraphicsDevice.SEMANTIC_POSITION, TurbulenzGraphicsDevice.SEMANTIC_TEXCOORD]);
            SemanticsTypes.positionAnd2Texture = TurbulenzGraphicsDevice.createSemantics([TurbulenzGraphicsDevice.SEMANTIC_POSITION0, TurbulenzGraphicsDevice.SEMANTIC_TEXCOORD0, TurbulenzGraphicsDevice.SEMANTIC_TEXCOORD1])
        }

        function CreateDefaultsFn() {
            JamSystem.RenderManager.DefaultSpriteShader = JamSystem.RenderManager.CreateShader("vertexColorTextured2D", {});
            JamSystem.RenderManager.DefaultSpriteShader2 = JamSystem.RenderManager.CreateShader("vertexColorTextured22D", {});
            JamSystem.RenderManager.DefaultLineShader = JamSystem.RenderManager.CreateShader("constantColor2D", {});
            DebugLine = Line.Create(TurbulenzGraphicsDevice, TurbulenzMathDevice, SemanticsTypes.position);
            DebugSprite = Sprite.Create(0, 0, null, 0, SemanticsTypes.positionAndTexture, SemanticsTypes.color);
            DebugSprite.bVisible = false;
            DebugText = BitmapText.Create(0, 0, null, null, SemanticsTypes.positionAndTexture, SemanticsTypes.color);
            DebugText.bVisible = false
        }

        function FixViewPortFn() {
            var i;
            for (i = 0; i < ShaderList.length; i += 1) {
                ShaderList[i].UpdateViewport()
            }
        }

        function DestroyFn() {
            window.onresize = JamSystem.RenderManager.OldResize;
            TurbulenzGraphicsDevice = null
        }
        initFn();
        var NewRenderManager = new RenderManager;
        NewRenderManager.SetClearColour = SetClearColourFn;
        NewRenderManager.SetRoot = SetRootFn;
        NewRenderManager.GetRoot = GetRootFn;
        NewRenderManager.GetScreenWidth = GetScreenWidthFn;
        NewRenderManager.GetScreenHeight = GetScreenHeightFn;
        NewRenderManager.CreateTree = CreateTreeFn;
        NewRenderManager.DestroyTree = DestroyTreeFn;
        NewRenderManager.CreateSprite = CreateSpriteFn;
        NewRenderManager.DestroySprite = DestroySpriteFn;
        NewRenderManager.CreateSpriteAnimation = CreateSpriteAnimationFn;
        NewRenderManager.DestroySpriteAnimation = DestroySpriteAnimationFn;
        NewRenderManager.CreateSpriteList = CreateSpriteListFn;
        NewRenderManager.DestroySpriteList = DestroySpriteListFn;
        NewRenderManager.CreateLine = CreateLineFn;
        NewRenderManager.DestroyLine = DestroyLineFn;
        NewRenderManager.CreateLineList = CreateLineListFn;
        NewRenderManager.DestroyLineList = DestroyLineListFn;
        NewRenderManager.CreateStrip = CreateStripFn;
        NewRenderManager.DestroyStrip = DestroyStripFn;
        NewRenderManager.CreateBitmapText = CreateBitmapTextFn;
        NewRenderManager.DestroyBitmapText = DestroyBitmapTextFn;
        NewRenderManager.CreateRenderTarget = CreateRenderTargetFn;
        NewRenderManager.DestroyRenderTarget = DestroyRenderTargetFn;
        NewRenderManager.CreateShader = CreateShaderFn;
        NewRenderManager.DestroyShader = DestroyShaderFn;
        NewRenderManager.SetShader = SetShaderFn;
        NewRenderManager.DrawDebugSprite = DrawDebugSpriteFn;
        NewRenderManager.DrawDebugLine = DrawDebugLineFn;
        NewRenderManager.DrawDebugText = DrawDebugTextFn;
        NewRenderManager.GetFullScreen = GetFullScreenFn;
        NewRenderManager.SetFullScreen = SetFullScreenFn;
        NewRenderManager.Render = RenderFn;
        NewRenderManager.SetActiveShader = SetActiveShaderFn;
        NewRenderManager.CreateDefaults = CreateDefaultsFn;
        NewRenderManager.FixViewPort = FixViewPortFn;
        NewRenderManager.Destroy = DestroyFn;
        NewRenderManager.CurrentShader = null;
        NewRenderManager.Vertex1 = TurbulenzMathDevice.v4Build(1, 1, 1, 1);
        NewRenderManager.Vertex2 = TurbulenzMathDevice.v4Build(1, 1, 1, 1);
        NewRenderManager.FinalVertex1 = TurbulenzMathDevice.v4Build(1, 1, 1, 1);
        NewRenderManager.FinalVertex2 = TurbulenzMathDevice.v4Build(1, 1, 1, 1);
        NewRenderManager.UpVector = TurbulenzMathDevice.v3BuildZAxis();
        NewRenderManager.Quaternion = TurbulenzMathDevice.quatBuild(0, 0, 0, 1);
        NewRenderManager.TranslationVector = TurbulenzMathDevice.v3Build(0, 0, 0);
        NewRenderManager.ScaleVector = TurbulenzMathDevice.v3Build(1, 1, 1);
        NewRenderManager.TopMatrix = TurbulenzMathDevice.m44BuildIdentity();
        NewRenderManager.AnchorTranslationMatrix = TurbulenzMathDevice.m43BuildIdentity();
        NewRenderManager.ScaleMatrix = TurbulenzMathDevice.m43BuildIdentity();
        NewRenderManager.TranslationMatrix = TurbulenzMathDevice.m43BuildIdentity();
        NewRenderManager.RotationMatrix = TurbulenzMathDevice.m43BuildIdentity();
        NewRenderManager.ScaleAnchorMatrix = TurbulenzMathDevice.m43BuildIdentity();
        NewRenderManager.ScaleAnchorRotationMatrix = TurbulenzMathDevice.m43BuildIdentity();
        NewRenderManager.TurbulenzGraphicsDevice = TurbulenzGraphicsDevice;
        NewRenderManager.OldResize = window.onresize;
        window.onresize = function(event) {
            JamSystem.RenderManager.FixViewPort();
            JamSystem.ViewportChanged()
        };
        return NewRenderManager
    };

    function SoundBank() {}
    SoundBank.prototype = {
        GetSoundIndexFromName: function GetSoundIndexFromNameFn(SoundName) {
            var i;
            for (i = 0; i < this.Sounds.length; i += 1) {
                var SoundFileName = this.Names[i];
                var j = SoundFileName.length - 1;
                while (j && SoundFileName.charAt(j) !== "\\" && SoundFileName.charAt(j) !== "/") {
                    j -= 1
                }
                j += 1;
                var TestName = SoundFileName.substring(j, SoundFileName.length - 4);
                if (SoundName === TestName) {
                    return i
                }
            }
            return -1
        }
    };
    SoundBank.Create = function SoundBankCreate(FileName) {
        var NewObject = new SoundBank;
        NewObject.Sounds = [];
        NewObject.Names = [];
        NewObject.FileName = FileName;
        NewObject.File = 0;
        return NewObject
    };

    function SoundManagerHandle() {}
    SoundManagerHandle.prototype = {};
    SoundManagerHandle.Create = function CreateFn() {
        var NewObject = new SoundManagerHandle;
        NewObject.Valid = false;
        NewObject.Source = null;
        NewObject.Locked = false;
        return NewObject
    };

    function SoundManager() {}
    SoundManager.prototype = {};
    SoundManager.Create = function SoundManagerCreateFn(mathDevice, NumSources) {
        var AudioInfo = [];
        var Sources = [];
        var CategoryVolumes = [];
        var TurbulenzSoundDevice;
        var MasterVolume = 1;

        function PlaySoundFn(SoundName, Handle) {
            JamSystem.SoundManager.PlaySoundDetailed(SoundName, 0, 1, 1, false, Handle)
        }

        function PlaySoundDetailedFn(SoundName, Position, Pitch, Volume, Looped, Handle) {
            if (!TurbulenzSoundDevice) {
                return
            }
            if (Handle) {
                Handle.Source = null;
                Handle.Valid = false
            }
            var Info = AudioInfo[SoundName];
            if (!Info) {
                Debug.Log("**** Sound not found : " + SoundName);
                return
            }
            if (Info.SoundData === undefined) {
                Debug.Log("**** Sound data not found for : " + SoundName);
                return
            }
            var Source = this.GetFreeSource();
            if (Source) {
                var SoundIndex = 0;
                if (Info.SoundData.length > 1) {
                    SoundIndex = Math.floor(Math.random() * Info.SoundData.length)
                }
                var SoundData = Info.SoundData[SoundIndex];
                if (SoundData === null) {
                    Debug.Log("**** Sound data not found for : " + SoundName + " " + SoundIndex);
                    return
                }
                Debug.Assert(CategoryVolumes[Info.Category] !== undefined, "Audio category " + Info.Category + " is undefined.");
                if (Volume < 0) {
                    Volume = 0
                }
                Source.StartPlay = true;
                Source.Category = Info.Category;
                Source.Handle = Handle;
                Source.SoundName = SoundName;
                Source.StartVolume = Math.random() * (Info.VolumeMax - Info.VolumeMin) + Info.VolumeMin;
                if (Source.StartVolume < 0) {
                    Source.StartVolume = 0
                }
                Source.Volume = Source.StartVolume * Volume;
                if (Source.Volume >= 0 && Source.Volume <= 10) {} else {
                    Source.Volume = Source.Volume
                }
                var TurbulenzSource = Source.TurbulenzSource;
                Source.OriginalGain = CategoryVolumes[Info.Category] * Source.Volume;
                TurbulenzSource.gain = Source.OriginalGain * MasterVolume;
                TurbulenzSource.looping = Info.Looped | Looped;
                TurbulenzSource.pitch = (Math.random() * (Info.PitchMax - Info.PitchMin) + Info.PitchMin) * Pitch;
                var StartPosition = Info.Position;
                if (Position) {
                    StartPosition = Position
                }
                TurbulenzSource.play(SoundData.Bank.Sounds[SoundData.Index], StartPosition);
                if (Handle) {
                    Handle.Source = Source;
                    Handle.Valid = true
                }
            }
        }

        function StopSoundFn(SoundName) {
            if (!TurbulenzSoundDevice) {
                return
            }
            var i = 0;
            for (i = 0; i < Sources.length; i += 1) {
                var Source = Sources[i];
                if (Source.SoundName === SoundName) {
                    if (Source.Handle) {
                        Source.Handle.Valid = false;
                        Source.Handle.Source = null;
                        Source.Handle = null
                    }
                    var TurbulenzSource = Source.TurbulenzSource;
                    TurbulenzSource.stop()
                }
            }
        }

        function GetIsSoundPlayingFn(SoundName) {
            if (!TurbulenzSoundDevice) {
                return false
            }
            var i = 0;
            for (i = 0; i < Sources.length; i += 1) {
                var Source = Sources[i];
                var TurbulenzSource = Source.TurbulenzSource;
                if (Source.SoundName === SoundName) {
                    if (TurbulenzSource.playing || Source.StartPlay) {
                        return true
                    }
                }
            }
            return false
        }

        function SetSoundVolumeFn(SoundName, Volume) {
            if (!TurbulenzSoundDevice) {
                return
            }
            Debug.Assert(Volume >= 0, "Trying to set a volume < 0");
            var i = 0;
            for (i = 0; i < Sources.length; i += 1) {
                var Source = Sources[i];
                var TurbulenzSource = Source.TurbulenzSource;
                if (Source.SoundName === SoundName) {
                    if (TurbulenzSource.playing || Source.StartPlay) {
                        Source.Volume = Source.StartVolume * Volume;
                        Source.OriginalGain = CategoryVolumes[Source.Category] * Source.Volume;
                        TurbulenzSource.gain = Source.OriginalGain * MasterVolume
                    }
                }
            }
        }

        function SetSoundPitchFn(SoundName, Pitch) {
            if (!TurbulenzSoundDevice) {
                return
            }
            var i = 0;
            for (i = 0; i < Sources.length; i += 1) {
                var Source = Sources[i];
                var TurbulenzSource = Source.TurbulenzSource;
                if (Source.SoundName === SoundName) {
                    if (TurbulenzSource.playing || Source.StartPlay) {
                        TurbulenzSource.pitch = Pitch
                    }
                }
            }
        }

        function StopSoundHandleFn(SourceHandle) {
            if (!TurbulenzSoundDevice) {
                return
            }
            if (!SourceHandle.Valid) {
                return
            }
            var Source = SourceHandle.Source;
            Source.Handle = null;
            Source.StartPlay = false;
            var TurbulenzSource = Source.TurbulenzSource;
            TurbulenzSource.stop();
            SourceHandle.Valid = false;
            SourceHandle.Source = null
        }

        function LockSoundHandleFn(SourceHandle, Locked) {
            if (!TurbulenzSoundDevice) {
                return
            }
            if (!SourceHandle.Valid) {
                return
            }
            SourceHandle.Locked = Locked
        }

        function GetIsSoundPlayingHandleFn(SourceHandle) {
            if (!TurbulenzSoundDevice) {
                return false
            }
            if (!SourceHandle.Valid) {
                return false
            }
            var Source = SourceHandle.Source;
            var TurbulenzSource = Source.TurbulenzSource;
            if (TurbulenzSource.playing || Source.StartPlay) {
                return true
            }
            return false
        }

        function SetSoundVolumeHandleFn(SourceHandle, Volume) {
            if (!TurbulenzSoundDevice) {
                return
            }
            if (!SourceHandle.Valid) {
                return
            }
            Debug.Assert(Volume >= 0, "Trying to set a volume < 0");
            var Source = SourceHandle.Source;
            var TurbulenzSource = Source.TurbulenzSource;
            if (TurbulenzSource.playing || Source.StartPlay) {
                Source.Volume = Volume * Source.StartVolume;
                Source.OriginalGain = CategoryVolumes[Source.Category] * Source.Volume;
                TurbulenzSource.gain = Source.OriginalGain * MasterVolume
            }
            return false
        }

        function SetSoundPitchHandleFn(SourceHandle, Pitch) {
            if (!TurbulenzSoundDevice) {
                return
            }
            if (!SourceHandle.Valid) {
                return
            }
            var Source = SourceHandle.Source;
            var TurbulenzSource = Source.TurbulenzSource;
            if (TurbulenzSource.playing || Source.StartPlay) {
                TurbulenzSource.pitch = Pitch
            }
            return false
        }

        function GetSoundOffsetHandleFn(SourceHandle, Offset) {
            if (!TurbulenzSoundDevice) {
                return 0
            }
            if (!SourceHandle.Valid) {
                return 0
            }
            var Source = SourceHandle.Source;
            var TurbulenzSource = Source.TurbulenzSource;
            if (TurbulenzSource.playing || Source.StartPlay) {
                return TurbulenzSource.tell
            }
            return 0
        }

        function PauseAllFn(Pause) {
            if (!TurbulenzSoundDevice) {
                return
            }
            var i;
            for (i = 0; i < Sources.length; i += 1) {
                var Source = Sources[i];
                var TurbulenzSource = Source.TurbulenzSource;
                if (Pause && (TurbulenzSource.playing || Source.StartPlay)) {
                    TurbulenzSource.pause()
                } else {
                    if (!Pause && TurbulenzSource.paused) {
                        TurbulenzSource.resume()
                    }
                }
            }
        }

        function StopAllFn(Category) {
            if (!TurbulenzSoundDevice) {
                return
            }
            var i;
            for (i = 0; i < Sources.length; i += 1) {
                var Source = Sources[i];
                if ((Category === undefined || Source.Category === Category) && (!Source.Handle || !Source.Handle.Locked)) {
                    if (Source.Handle) {
                        Source.Handle.Valid = false;
                        Source.Handle.Source = null;
                        Source.Handle = null
                    }
                    Source.StartPlay = false;
                    var TurbulenzSource = Source.TurbulenzSource;
                    TurbulenzSource.stop()
                }
            }
        }

        function SetCategoryVolumeFn(Category, Volume) {
            if (!TurbulenzSoundDevice) {
                return
            }
            CategoryVolumes[Category] = Volume;
            var i = 0;
            for (i = 0; i < Sources.length; i += 1) {
                var Source = Sources[i];
                if (Source.Category === Category) {
                    var TurbulenzSource = Source.TurbulenzSource;
                    if (TurbulenzSource.playing || Source.StartPlay) {
                        Source.OriginalGain = CategoryVolumes[Category] * Source.Volume;
                        TurbulenzSource.gain = Source.OriginalGain * MasterVolume
                    }
                }
            }
        }

        function GetCategoryVolumeFn(Category) {
            return CategoryVolumes[Category]
        }

        function SetMasterVolumeFn(Volume) {
            if (TurbulenzSoundDevice) {
                MasterVolume = Volume;
                var i = 0;
                for (i = 0; i < Sources.length; i += 1) {
                    var Source = Sources[i];
                    var TurbulenzSource = Source.TurbulenzSource;
                    if (TurbulenzSource.playing || Source.StartPlay) {
                        TurbulenzSource.gain = Source.OriginalGain * MasterVolume
                    }
                }
            }
        }

        function GetMasterVolumeFn() {
            if (TurbulenzSoundDevice) {
                return MasterVolume
            }
            return 0
        }

        function FinialiseAudioInfoFn() {
            if (!TurbulenzSoundDevice) {
                return
            }
            var InfoName;
            for (InfoName in AudioInfo) {
                if (AudioInfo.hasOwnProperty(InfoName)) {
                    var Info = AudioInfo[InfoName];
                    Info.SoundData = [];
                    if (Info.Sample) {
                        Info.SoundData[0] = JamSystem.AssetManager.GetSoundInfoFromSoundName(Info.Sample)
                    } else {
                        var i;
                        for (i = 0; i < Info.Samples.length; i += 1) {
                            Info.SoundData[i] = JamSystem.AssetManager.GetSoundInfoFromSoundName(Info.Samples[i])
                        }
                    }
                }
            }
        }

        function SetAudioInfoFn(NewAudioInfo) {
            if (!TurbulenzSoundDevice) {
                return
            }
            AudioInfo = [];
            var i;
            for (i = 0; i < NewAudioInfo.Sounds.length; i += 1) {
                var Info = NewAudioInfo.Sounds[i];
                Debug.Assert(Info.Name, "Audio Info " + i + " has no name");
                Debug.Assert(Info.Sample || Info.Samples, "Audio Info " + Info.Name + " has no sample");
                if (Info.VolumeMin === undefined) {
                    Info.VolumeMin = 1
                }
                if (Info.VolumeMax === undefined) {
                    Info.VolumeMax = 1
                }
                if (Info.PitchMin === undefined) {
                    Info.PitchMin = 1
                }
                if (Info.PitchMax === undefined) {
                    Info.PitchMax = 1
                }
                if (Info.Looped === undefined) {
                    Info.Looped = false
                }
                if (Info.Position === undefined) {
                    Info.Position = 0
                }
                if (Info.Category === undefined) {
                    Info.Category = 0
                }
                AudioInfo[Info.Name] = Info
            }
        }

        function GetFreeSourceFn() {
            if (!TurbulenzSoundDevice) {
                return
            }
            var i = 0;
            for (i = 0; i < Sources.length; i += 1) {
                var Source = Sources[i];
                var TurbulenzSource = Source.TurbulenzSource;
                if (!Source.Handle && !TurbulenzSource.playing && !TurbulenzSource.paused && !Source.StartPlay) {
                    return Source
                }
            }
            return null
        }

        function UpdateFn() {
            if (TurbulenzSoundDevice) {
                TurbulenzSoundDevice.update()
            }
            var i;
            for (i = 0; i < Sources.length; i += 1) {
                Sources[i].StartPlay = false
            }
        }

        function initFn() {
            var soundDeviceOptions = {
                linearDistance: true
            };
            TurbulenzSoundDevice = TurbulenzEngine.createSoundDevice(soundDeviceOptions);
            if (TurbulenzSoundDevice) {
                var i = 0;
                for (i = 0; i < NumSources; i += 1) {
                    Sources[i] = {};
                    Sources[i].Handle = null;
                    Sources[i].StartPlay = false;
                    Sources[i].Category = 0;
                    Sources[i].Volume = 1;
                    Sources[i].Index = i;
                    Sources[i].SoundName = "";
                    Sources[i].TurbulenzSource = TurbulenzSoundDevice.createSource({
                        position: mathDevice.v3Build(0, 0, 0),
                        direction: mathDevice.v3Build(1, 0, 0),
                        velocity: mathDevice.v3Build(0, 0, 0),
                        gain: 1,
                        minDistance: 1,
                        maxDistance: 100,
                        rollOff: 1,
                        relative: false,
                        looping: false,
                        pitch: 1
                    })
                }
            } else {
                Debug.Log("Couldn't create TurbulenzSoundDevice")
            }
            CategoryVolumes[0] = 1
        }

        function DestroyFn() {
            if (!TurbulenzSoundDevice) {
                return
            }
            TurbulenzSoundDevice = null;
            var i = 0;
            for (i = 0; i < Sources.length; i += 1) {
                Sources[i].TurbulenzSource.destroy()
            }
        }
        initFn();
        var NewSoundManager = new SoundManager;
        NewSoundManager.TurbulenzSoundDevice = TurbulenzSoundDevice;
        NewSoundManager.PlaySound = PlaySoundFn;
        NewSoundManager.PlaySoundDetailed = PlaySoundDetailedFn;
        NewSoundManager.StopSound = StopSoundFn;
        NewSoundManager.GetIsSoundPlaying = GetIsSoundPlayingFn;
        NewSoundManager.SetSoundVolume = SetSoundVolumeFn;
        NewSoundManager.SetSoundPitch = SetSoundPitchFn;
        NewSoundManager.StopSoundHandle = StopSoundHandleFn;
        NewSoundManager.LockSoundHandle = LockSoundHandleFn;
        NewSoundManager.GetIsSoundPlayingHandle = GetIsSoundPlayingHandleFn;
        NewSoundManager.SetSoundVolumeHandle = SetSoundVolumeHandleFn;
        NewSoundManager.SetSoundPitchHandle = SetSoundPitchHandleFn;
        NewSoundManager.GetSoundOffsetHandle = GetSoundOffsetHandleFn;
        NewSoundManager.PauseAll = PauseAllFn;
        NewSoundManager.StopAll = StopAllFn;
        NewSoundManager.SetCategoryVolume = SetCategoryVolumeFn;
        NewSoundManager.GetCategoryVolume = GetCategoryVolumeFn;
        NewSoundManager.SetMasterVolume = SetMasterVolumeFn;
        NewSoundManager.GetMasterVolume = GetMasterVolumeFn;
        NewSoundManager.FinialiseAudioInfo = FinialiseAudioInfoFn;
        NewSoundManager.SetAudioInfo = SetAudioInfoFn;
        NewSoundManager.GetFreeSource = GetFreeSourceFn;
        NewSoundManager.Update = UpdateFn;
        NewSoundManager.Destroy = DestroyFn;
        return NewSoundManager
    };

    function StoreShopManager() {}
    StoreShopManager.prototype = {
        GetItems: function GetItemsFn() {
            if (!this.StoreManagerReady) {
                Debug.Log("STORE NOT INITIALISED YET [A]");
                return
            }
            return this.TurbulenzStoreShopManager.getItems()
        },
        GetUserItems: function GetUserItemsFn() {
            if (!this.StoreManagerReady) {
                Debug.Log("STORE NOT INITIALISED YET [B]");
                return
            }
            return this.TurbulenzStoreShopManager.getUserItems()
        },
        AddToBasket: function AddToBasketFn(key, amount) {
            if (!this.StoreManagerReady) {
                Debug.Log("STORE NOT INITIALISED YET [C]");
                return
            }
            return this.TurbulenzStoreShopManager.addToBasket(key, amount)
        },
        RemoveFromBasket: function RemoveFromBasketFn(key, amount) {
            if (!this.StoreManagerReady) {
                Debug.Log("STORE NOT INITIALISED YET [D]");
                return
            }
            return this.TurbulenzStoreShopManager.removeFromBasket(key, amount)
        },
        EmptyBasket: function EmptyBasketFn() {
            if (!this.StoreManagerReady) {
                Debug.Log("STORE NOT INITIALISED YET [E]");
                return
            }
            this.TurbulenzStoreShopManager.emptyBasket()
        },
        IsBasketEmpty: function IsBasketEmptyFn() {
            if (!this.StoreManagerReady) {
                Debug.Log("STORE NOT INITIALISED YET [F]");
                return
            }
            return this.TurbulenzStoreShopManager.isBasketEmpty()
        },
        ShowConfirmPurchase: function ShowConfirmPurchaseFn() {
            if (!this.StoreManagerReady) {
                Debug.Log("STORE NOT INITIALISED YET [G]");
                return
            }
            this.CheckoutComplete = false;
            return this.TurbulenzStoreShopManager.showConfirmPurchase()
        },
        Consume: function ConsumeFn(key, amount) {
            if (!this.StoreManagerReady) {
                Debug.Log("STORE NOT INITIALISED YET [H]");
                return
            }
            return this.TurbulenzStoreShopManager.consume(key, amount, this.ConsumeCallback, this.ErrorCallback)
        },
        GetCurrency: function GetCurrencyFn() {
            if (!this.StoreManagerReady) {
                Debug.Log("STORE NOT INITIALISED YET [I]");
                return
            }
            return this.TurbulenzStoreShopManager.currency
        },
        GetBasketInfo: function GetBasketInfoFn() {
            if (!this.StoreManagerReady) {
                Debug.Log("STORE NOT INITIALISED YET [J]");
                return
            }
            return this.TurbulenzStoreShopManager.basket
        },
        ErrorCallback: function ErrorCallbackFn(errorMsg, httpStatus, calledByFn, calledByParams) {
            Debug.Log("***** StoreShopManager Error : " + errorMsg);
            Debug.Log("httpStatus : " + httpStatus);
            Debug.Log("calledByFn : " + calledByFn);
            Debug.Log("calledByParams : " + calledByParams)
        },
        StoreMetaCallback: function StoreMetaCallbackFn(storeManager) {
            Debug.Log("Store Manager Created");
            JamSystem.StoreShopManager.StoreManagerReady = true
        },
        ConsumeCallback: function ConsumeCallbackFn(consumed) {
            Debug.Log("Item Consumed " + (consumed ? "Successfully" : "Unsuccessully"))
        },
        Destroy: function Destroy() {}
    };
    StoreShopManager.onBasketUpdate = function onBasketUpdateFn() {
        Debug.Log("BASKET UPDATED")
    };
    StoreShopManager.onSitePurchaseConfirmed = function onSitePurchaseConfirmedFn() {
        Debug.Log("PURCHASE COMPLETE");
        JamSystem.StoreShopManager.CheckoutComplete = true;
        JamSystem.StoreShopManager.PurchaseSuccess = true
    };
    StoreShopManager.onSitePurchaseRejected = function onSitePurchaseRejectedFn() {
        Debug.Log("PURCHASE REJECTED");
        JamSystem.StoreShopManager.CheckoutComplete = true;
        JamSystem.StoreShopManager.PurchaseSuccess = false
    };
    StoreShopManager.Create = function Create(requestHandler, GameSession) {
        var NewObject = new StoreShopManager;
        NewObject.TurbulenzStoreShopManager = TurbulenzServices.createStoreManager(requestHandler, GameSession, NewObject.StoreMetaCallback, NewObject.ErrorCallback);
        NewObject.StoreManagerReady = false;
        NewObject.CheckoutComplete = true;
        NewObject.PurchaseSuccess = false;
        if (NewObject.TurbulenzStoreShopManager) {
            NewObject.TurbulenzStoreShopManager.onBasketUpdate = StoreShopManager.onBasketUpdate;
            NewObject.TurbulenzStoreShopManager.onSitePurchaseConfirmed = StoreShopManager.onSitePurchaseConfirmed;
            NewObject.TurbulenzStoreShopManager.onSitePurchaseRejected = StoreShopManager.onSitePurchaseRejected
        }
        return NewObject
    };
    var ProfileCounter = 0;
    var JamSystem = null;

    function System() {}
    System.prototype = {};
    System.Create = function SystemCreateFn(Application, TurbulenzGameSlug, DesiredScreenWidth, DesiredScreenHeight, KeyDownUserCallback, MouseCallback) {
        var IntervalID;
        var IsLoading;
        var PreviousFrameTime;
        var UserApplication;
        var JamJamInputManager;
        var JamRenderManager;
        var JamAssetManager;
        var JamSoundManager;
        var JamSaveDataManager;
        var JamPublicDataManager;
        var JamStoreShopManager;
        var JamNetworkManager;
        var JamLeaderboardsManager;
        var JamAchievementsManager;
        var JamScriptManager;
        var JamTextManager;
        var JamUserProfile;
        var TurbulenzMappingTableLoaded;
        var TurbulenzMappingTable;
        var TurbulenzMathDevice;
        var TurbulenzGameSession;
        var TurbulenzCanvasMode;
        var errorCallback = function errorCallback(msg) {
            Debug.Log("******** errorCallback : " + msg)
        };
        var warningCallback = function warningCallback(msg) {
            window.alert(msg)
        };
        var TurbulenzServicesErrorCallback = function TurbulenzServicesErrorCallback(errorMsg, httpStatus) {
            Debug.Log("TurbulenzServices.defaultErrorCallback : " + errorMsg);
            Debug.Log("httpStatus " + httpStatus)
        };
        var requestHandler = RequestHandler.create({
            onRequestTimeout: function onRequestTimeoutFn() {
                Debug.Log("Connection lost or service busy")
            },
            onReconnected: function onReconnectedFn() {
                Debug.Log("Reconnected")
            }
        });
        var MappingTableReceived = function MappingTableReceivedFn(MappingTable) {
            Debug.Log("Loading Mapping table : Loaded");
            JamSystem.TurbulenzMappingTable = MappingTable;
            TurbulenzMappingTable = MappingTable;
            TurbulenzMappingTableLoaded = true;
            JamAssetManager.UpdateMapping(MappingTable);
            JamAssetManager.LoadShader("../Jake/assets/working/generic2D.cgfx.json")
        };
        var TurbulenzGameSessionCreated = function TurbulenzGameSessionCreatedFn(GameSession) {
            Debug.Log("Loading Mapping table : Start");
            var DefaultMappingSettings = {
                mappingTablePrefix: "staticmax/",
                assetPrefix: "missing/",
                mappingTableURL: "mapping_table.json"
            };
            TurbulenzMappingTable = TurbulenzServices.createMappingTable(requestHandler, GameSession, MappingTableReceived, DefaultMappingSettings);
            Debug.Log("Creating User Data Manager");
            JamSaveDataManager = SaveDataManager.Create(requestHandler, GameSession);
            JamSystem.SaveDataManager = JamSaveDataManager;
            Debug.Log("Creating Public Data Manager");
            JamPublicDataManager = PublicDataManager.Create(requestHandler, GameSession);
            JamSystem.PublicDataManager = JamPublicDataManager;
            Debug.Log("Creating Store Manager");
            JamStoreShopManager = StoreShopManager.Create(requestHandler, GameSession);
            JamSystem.StoreShopManager = JamStoreShopManager;
            Debug.Log("Creating Network Manager");
            JamNetworkManager = NetworkManager.Create(requestHandler, GameSession);
            JamSystem.NetworkManager = JamNetworkManager;
            Debug.Log("Creating Leaderboard Manager");
            JamLeaderboardsManager = LeaderboardsManager.Create(requestHandler, GameSession);
            JamSystem.LeaderboardsManager = JamLeaderboardsManager;
            Debug.Log("Creating Badge Manager");
            JamAchievementsManager = AchievementsManager.Create(requestHandler, GameSession);
            JamSystem.AchievementsManager = JamAchievementsManager;
            Debug.Log("Creating User Profile");
            JamUserProfile = TurbulenzServices.createUserProfile(requestHandler, profileRecievedFn);
            JamSystem.UserProfile = JamUserProfile
        };

        function profileRecievedFn(userProfile) {}

        function UpdateFn() {
            var CurrentTime = TurbulenzEngine.time;
            var DeltaTime = CurrentTime - PreviousFrameTime;
            PreviousFrameTime = CurrentTime;
            if (DeltaTime > .05) {
                DeltaTime = .05
            }
            if (IsLoading) {
                if (JamRenderManager.TurbulenzGraphicsDevice.beginFrame()) {
                    JamRenderManager.TurbulenzGraphicsDevice.clear([1, 1, 1, 1]);
                    JamRenderManager.TurbulenzGraphicsDevice.endFrame()
                }
                if (TurbulenzMappingTableLoaded && JamAssetManager.GetIsAllLoaded()) {
                    JamRenderManager.CreateDefaults();
                    UserApplication.FirstTime();
                    IsLoading = false
                }
            } else {
                var Process = UserApplication.Update(DeltaTime);
                if (Process) {
                    JamJamInputManager.Update()
                }
                JamRenderManager.Render(CurrentTime)
            }
            JamSoundManager.Update()
        }

        function getRealTimeFn() {
            return TurbulenzEngine.time
        }

        function ViewportChangedFn() {
            UserApplication.ViewportChanged()
        }

        function initFn() {
            Debug.Log("System.initFn");
            TurbulenzEngine.onerror = errorCallback;
            TurbulenzEngine.onwarning = warningCallback;
            TurbulenzServices.defaultErrorCallback = TurbulenzServicesErrorCallback;
            var MathDeviceParameters = {};
            TurbulenzMathDevice = TurbulenzEngine.createMathDevice(MathDeviceParameters);
            JamJamInputManager = JamInputManager.Create(TurbulenzEngine, errorCallback, null, KeyDownUserCallback, MouseCallback);
            JamRenderManager = RenderManager.Create(TurbulenzMathDevice, Application, DesiredScreenWidth, DesiredScreenHeight, errorCallback);
            JamSoundManager = SoundManager.Create(TurbulenzMathDevice, 16);
            JamAssetManager = AssetManager.Create(JamRenderManager.TurbulenzGraphicsDevice, JamSoundManager.TurbulenzSoundDevice, TurbulenzMathDevice, requestHandler, errorCallback);
            JamSaveDataManager = null;
            JamPublicDataManager = null;
            JamStoreShopManager = null;
            JamNetworkManager = null;
            JamAchievementsManager = null;
            JamLeaderboardsManager = null;
            JamUserProfile = null;
            JamScriptManager = ScriptManager.Create();
            JamTextManager = TextManager.Create();
            IsLoading = true;
            TurbulenzMappingTableLoaded = false;
            TurbulenzGameSession = TurbulenzServices.createGameSession(requestHandler, TurbulenzGameSessionCreated);
            PreviousFrameTime = TurbulenzEngine.time;
            UserApplication = Application;
            if (TurbulenzEngine.canvas) {
                TurbulenzCanvasMode = true
            } else {
                TurbulenzCanvasMode = false
            }
            IntervalID = TurbulenzEngine.setInterval(UpdateFn, 1e3 / 60)
        }

        function GetCanvasModeFn() {
            return TurbulenzCanvasMode
        }

        function GetFPSFn() {
            return Math.floor(JamRenderManager.TurbulenzGraphicsDevice.fps)
        }

        function ErrorCallbackFn(errorMsg, httpStatus, calledByFn, calledByParams) {
            Debug.Log("Metric Error : " + errorMsg);
            Debug.Log("httpStatus : " + httpStatus);
            Debug.Log("calledByFn : " + calledByFn);
            Debug.Log("calledByParams : " + calledByParams)
        }

        function SendMetricEventFn(Key, Value) {
            Debug.Log("SendMetricEvent " + Key + " :  " + Value);
            TurbulenzServices.sendCustomMetricEvent(Key, Value, requestHandler, TurbulenzGameSession, ErrorCallbackFn)
        }

        function FlushFn() {
            TurbulenzEngine.flush()
        }

        function GetSystemInfoFn() {
            return TurbulenzEngine.getSystemInfo()
        }

        function StopFn() {
            Debug.Log("System.Stop");
            TurbulenzEngine.clearInterval(IntervalID)
        }

        function DestroyFn() {
            Debug.Log("System.Destroy");
            if (JamStoreShopManager) {
                JamStoreShopManager.Destroy()
            }
            if (JamNetworkManager) {
                JamNetworkManager.Destroy()
            }
            if (TurbulenzGameSession) {
                TurbulenzGameSession.destroy()
            }
            if (JamTextManager) {
                JamTextManager.Destroy()
            }
            if (JamScriptManager) {
                JamScriptManager.Destroy()
            }
            if (JamSaveDataManager) {
                JamSaveDataManager.Destroy()
            }
            if (JamPublicDataManager) {
                JamPublicDataManager.Destroy()
            }
            if (JamLeaderboardsManager) {
                JamLeaderboardsManager.Destroy()
            }
            if (JamAchievementsManager) {
                JamAchievementsManager.Destroy()
            }
            if (JamSoundManager) {
                JamSoundManager.Destroy()
            }
            if (JamJamInputManager) {
                JamJamInputManager.Destroy()
            }
            if (JamAssetManager) {
                JamAssetManager.Destroy()
            }
            TurbulenzEngine.flush();
            if (JamRenderManager) {
                JamRenderManager.Destroy()
            }
        }
        initFn();
        var NewSystem = new System;
        NewSystem.GetCanvasMode = GetCanvasModeFn;
        NewSystem.GetFPS = GetFPSFn;
        NewSystem.SendMetricEvent = SendMetricEventFn;
        NewSystem.Flush = FlushFn;
        NewSystem.GetSystemInfo = GetSystemInfoFn;
        NewSystem.Stop = StopFn;
        NewSystem.Destroy = DestroyFn;
        NewSystem.GetTrueTime = getRealTimeFn;
        NewSystem.ViewportChanged = ViewportChangedFn;
        NewSystem.InputManager = JamJamInputManager;
        NewSystem.AssetManager = JamAssetManager;
        NewSystem.RenderManager = JamRenderManager;
        NewSystem.SoundManager = JamSoundManager;
        NewSystem.AchievementsManager = JamAchievementsManager;
        NewSystem.LeaderboardsManager = JamLeaderboardsManager;
        NewSystem.SaveDataManager = JamSaveDataManager;
        NewSystem.PublicDataManager = JamPublicDataManager;
        NewSystem.StoreShopManager = JamStoreShopManager;
        NewSystem.NetworkManager = JamNetworkManager;
        NewSystem.ScriptManager = JamScriptManager;
        NewSystem.TextManager = JamTextManager;
        NewSystem.UserProfile = JamUserProfile;
        NewSystem.TurbulenzMathDevice = TurbulenzMathDevice;
        NewSystem.TurbulenzMappingTable = TurbulenzMappingTable;
        NewSystem.TurbulenzGameSlug = TurbulenzGameSlug;
        JamSystem = NewSystem;
        JamRenderManager.SetRoot(JamRenderManager.CreateTree(0, 0));
        JamRenderManager.FixViewPort();
        ScriptBasicFunctions.Init();
        return NewSystem
    };

    function Helpers() {}
    Helpers.prototype = {};
    Helpers.CreateTree = function CreateTree(x, y, psParent) {
        var NewTree = JamSystem.RenderManager.CreateTree(x, y);
        if (psParent) {
            psParent.AddChild(NewTree)
        }
        return NewTree
    };
    Helpers.DestroyTree = function DestroyTree(Tree) {
        JamSystem.RenderManager.DestroyTree(Tree)
    };
    Helpers.GetTexture = function GetTexture(psTextureName) {
        return JamSystem.AssetManager.GetTexture(psTextureName)
    };
    Helpers.GetTextureInfoFromImageName = function GetTextureInfoFromImageName(psImageName) {
        var Info = JamSystem.AssetManager.GetTextureInfoFromImageName(psImageName);
        if (Info === null) {
            Info = JamSystem.AssetManager.GetTextureInfoFromImageName("InvalidTexture")
        }
        return Info
    };
    Helpers.CreateSprite = function CreateSprite(x, y, eAnchor, psImageName, psParent) {
        var psSprite;
        if (psImageName) {
            var TextureInfo = Helpers.GetTextureInfoFromImageName(psImageName);
            psSprite = JamSystem.RenderManager.CreateSprite(x, y, TextureInfo.Texture, TextureInfo.Frame)
        } else {
            psSprite = JamSystem.RenderManager.CreateSprite(x, y, null, null)
        }
        psSprite.SetAnchor(eAnchor);
        if (psParent) {
            psParent.AddChild(psSprite)
        }
        return psSprite
    };
    Helpers.CreateSpriteWithInfo = function CreateSpriteWithInfo(x, y, eAnchor, psTexture, Image, psParent) {
        var psSprite = JamSystem.RenderManager.CreateSprite(x, y, psTexture, Image);
        psSprite.SetAnchor(eAnchor);
        if (psParent) {
            psParent.AddChild(psSprite)
        }
        return psSprite
    };
    Helpers.DestroySprite = function DestroySprite(psSprite) {
        JamSystem.RenderManager.DestroySprite(psSprite)
    };
    Helpers.CreateLine = function CreateLine(x, y, endX, endY, Colour, psParent) {
        var psLine = JamSystem.RenderManager.CreateLine(x, y, endX, endY, Colour);
        if (psParent) {
            psParent.AddChild(psLine)
        }
        return psLine
    };
    Helpers.DestroyLine = function DestroyLine(psLine) {
        JamSystem.RenderManager.DestroyLine(psLine)
    };
    Helpers.CreateSpriteList = function CreateSpriteList(NumSprites, psTexture, psParent) {
        var psSpriteList = JamSystem.RenderManager.CreateSpriteList(NumSprites, psTexture, undefined);
        if (psParent) {
            psParent.AddChild(psSpriteList)
        }
        return psSpriteList
    };
    Helpers.DestroySpriteList = function DestroySpriteList(psSpriteList) {
        JamSystem.RenderManager.DestroySpriteList(psSpriteList)
    };
    Helpers.CreateBitmapText = function CreateBitmapText(pachText, x, y, eAnchor, FontName, psParent) {
        var Font = JamSystem.AssetManager.GetBitmapFont(FontName);
        var psText = JamSystem.RenderManager.CreateBitmapText(x, y, Font, pachText);
        psText.SetAnchor(eAnchor);
        if (psParent) {
            psParent.AddChild(psText)
        }
        return psText
    };
    Helpers.DestroyBitmapText = function DestroyBitmapText(psText) {
        JamSystem.RenderManager.DestroyBitmapText(psText)
    };
    Helpers.CreateLineList = function CreateLineList(NumLines, Colour, psParent) {
        var psLineList = JamSystem.RenderManager.CreateLineList(NumLines, Colour);
        if (psParent) {
            psParent.AddChild(psLineList)
        }
        return psLineList
    };
    Helpers.DestroyLineList = function DestroyLineList(psLineList) {
        JamSystem.RenderManager.DestroyLineList(psLineList)
    };
    Helpers.CreateStrip = function CreateStrip(NumPoints, psImageName, psParent) {
        var TextureInfo = Helpers.GetTextureInfoFromImageName(psImageName);
        var psStrip = JamSystem.RenderManager.CreateStrip(NumPoints, TextureInfo.Texture, TextureInfo.Frame);
        if (psParent) {
            psParent.AddChild(psStrip)
        }
        return psStrip
    };
    Helpers.DestroyStrip = function DestroyStrip(psStrip) {
        JamSystem.RenderManager.DestroyStrip(psStrip)
    };
    Helpers.PlaySound = function PlaySound(SoundName) {
        JamSystem.SoundManager.PlaySound(SoundName, null)
    };
    Helpers.PlaySoundDetailed = function PlaySoundDetailed(SoundName, Pitch, Volume, Looped) {
        JamSystem.SoundManager.PlaySoundDetailed(SoundName, 0, Pitch, Volume, Looped, null)
    };
    Helpers.StopSound = function StopSound(SoundName) {
        JamSystem.SoundManager.StopSound(SoundName)
    };
    Helpers.GetIsSoundPlaying = function GetIsSoundPlaying(SoundName) {
        return JamSystem.SoundManager.GetIsSoundPlaying(SoundName)
    };
    Helpers.SetSoundVolume = function SetSoundVolume(SoundName, Volume) {
        JamSystem.SoundManager.SetSoundVolume(SoundName, Volume)
    };
    Helpers.SetSoundPitch = function SetSoundPitch(SoundName, Pitch) {
        JamSystem.SoundManager.SetSoundPitch(SoundName, Pitch)
    };

    function ShaderJam() {}
    ShaderJam.prototype = {
        SetIsActive: function SetIsActiveFn() {
            JamSystem.RenderManager.SetActiveShader(this)
        },
        UpdateViewport: function UpdateViewportFn() {
            var Width = JamSystem.RenderManager.GetScreenWidth();
            var Height = JamSystem.RenderManager.GetScreenHeight();
            this.Parameters.clipSpace = JamSystem.TurbulenzMathDevice.v4Build(1 / Width * 2, 1 / Height * 2, -1, 1)
        },
        Destroy: function DestroyFn() {
            this.Parameters = null;
            this.Technique = null
        }
    };
    ShaderJam.Create = function ShaderCreate(ShaderName, DefaultParameters, Index) {
        var NewObject = new ShaderJam;
        var Width = JamSystem.RenderManager.GetScreenWidth();
        var Height = JamSystem.RenderManager.GetScreenHeight();
        DefaultParameters.clipSpace = JamSystem.TurbulenzMathDevice.v4Build(1 / Width * 2, 1 / Height * 2, -1, 1);
        DefaultParameters.ambient = [1, 1, 1, 1];
        NewObject.Parameters = JamSystem.RenderManager.TurbulenzGraphicsDevice.createTechniqueParameters(DefaultParameters);
        NewObject.Technique = JamSystem.AssetManager.GetShader(ShaderName);
        NewObject.Index = Index;
        return NewObject
    };

    function EA() {}
    EA.TopLeft = 0;
    EA.TopMiddle = 1;
    EA.TopRight = 2;
    EA.MiddleLeft = 3;
    EA.MiddleMiddle = 4;
    EA.Middle = 4;
    EA.Default = 4;
    EA.MiddleRight = 5;
    EA.BottomLeft = 6;
    EA.BottomMiddle = 7;
    EA.BottomRight = 8;

    function Renderable() {}
    Renderable.prototype = {
        SetPosition: function SetPositionFn(x, y) {
            this.x = x;
            this.y = y;
            this.MatrixDirty = true;
            this.LocalMatrixDirty = true
        },
        SetPositionX: function SetPositionXFn(x) {
            this.x = x;
            this.MatrixDirty = true;
            this.LocalMatrixDirty = true
        },
        SetPositionY: function SetPositionYFn(y) {
            this.y = y;
            this.MatrixDirty = true;
            this.LocalMatrixDirty = true
        },
        SetScale: function SetScaleFn(x, y) {
            this.ScaleX = x;
            this.ScaleY = y;
            this.MatrixDirty = true;
            this.LocalMatrixDirty = true
        },
        SetScaleX: function SetScaleXFn(x) {
            this.ScaleX = x;
            this.MatrixDirty = true;
            this.LocalMatrixDirty = true
        },
        SetScaleY: function SetScaleYFn(y) {
            this.ScaleY = y;
            this.MatrixDirty = true;
            this.LocalMatrixDirty = true
        },
        SetRotation: function SetRotationFn(r) {
            this.Rotation = r;
            this.MatrixDirty = true;
            this.LocalMatrixDirty = true
        },
        GetScaleX: function GetScaleXFn() {
            return this.ScaleX
        },
        GetScaleY: function GetScaleYFn() {
            return this.ScaleY
        },
        GetPosition: function GetPosFn() {
            return new Vector2(this.x, this.y)
        },
        GetPositionX: function GetPosXFn() {
            return this.x
        },
        GetPositionY: function GetPosYFn() {
            return this.y
        },
        GetRotation: function GetRotationFn() {
            return this.Rotation
        },
        SetIsVisible: function SetIsVisibleFn(bVisible) {
            this.bVisible = bVisible
        },
        GetIsVisible: function GetIsVisibleFn() {
            return this.bVisible
        },
        SetAnchor: function SetAnchorFn(Anchor) {
            switch (Anchor) {
                case EA.Default:
                case EA.Middle:
                case EA.TopMiddle:
                case EA.MiddleMiddle:
                case EA.BottomMiddle:
                    this.AnchorX = -.5;
                    break;
                case EA.TopRight:
                case EA.MiddleRight:
                case EA.BottomRight:
                    this.AnchorX = -1;
                    break;
                case EA.TopLeft:
                case EA.MiddleLeft:
                case EA.BottomLeft:
                    this.AnchorX = 0;
                    break
            }
            switch (Anchor) {
                case EA.Default:
                case EA.MiddleLeft:
                case EA.MiddleMiddle:
                case EA.MiddleRight:
                case EA.Middle:
                    this.AnchorY = .5;
                    break;
                case EA.BottomLeft:
                case EA.BottomMiddle:
                case EA.BottomRight:
                    this.AnchorY = 1;
                    break;
                case EA.TopLeft:
                case EA.TopMiddle:
                case EA.TopRight:
                    this.AnchorY = 0;
                    break
            }
            this.Anchor = Anchor;
            this.MatrixDirty = true;
            this.LocalMatrixDirty = true
        },
        GetAnchor: function GetAnchorFn() {
            return this.Anchor
        },
        AddToParent: function AddToParentFn(Parent) {
            if (Parent) {
                Parent.AddChild(this)
            }
        },
        RemoveFromParent: function RemoveFromParentFn() {
            if (this.Parent) {
                this.Parent.RemoveChild(this)
            }
        },
        GetMatrix: function GetMatrixFn() {
            return this.Matrix
        },
        SetShader: function SetShaderFn(Shader) {
            this.Shader = Shader
        },
        GetShader: function GetShaderFn() {
            return this.Shader
        },
        SetParent: function SetParentFn(Parent) {
            this.Parent = Parent;
            this.SetParentDirty()
        },
        SetParentDirty: function SetParentDirtyFn() {
            this.MatrixDirty = true
        },
        Destroy: function DestroyFn() {
            Renderable.Destroy(this)
        }
    };
    Renderable.Destroy = function DestroyFn(thisRenderable) {
        if (thisRenderable.Parent) {
            thisRenderable.Parent.RemoveChild(thisRenderable)
        }
    };
    Renderable.Init = function InitFn(NewRenderable, x, y) {
        NewRenderable.Parent = 0;
        NewRenderable.bVisible = true;
        NewRenderable.x = x;
        NewRenderable.y = y;
        NewRenderable.Width = 0;
        NewRenderable.Height = 0;
        NewRenderable.ScaleX = 1;
        NewRenderable.ScaleY = 1;
        NewRenderable.Rotation = 0;
        NewRenderable.Anchor = EA.Default;
        NewRenderable.AnchorX = -.5;
        NewRenderable.AnchorY = .5;
        NewRenderable.MatrixDirty = true;
        NewRenderable.LocalMatrixDirty = true;
        NewRenderable.Shader = JamSystem.RenderManager.DefaultSpriteShader
    };
    Renderable.Create = function RenderableCreate(x, y) {
        var NewRenderable = new Renderable;
        NewRenderable.LocalMatrix = JamSystem.TurbulenzMathDevice.m43BuildIdentity();
        NewRenderable.Matrix = JamSystem.TurbulenzMathDevice.m44BuildIdentity();
        Renderable.Init(NewRenderable, x, y);
        return NewRenderable
    };

    function AchievementsManager() {}
    AchievementsManager.prototype = {
        GetInfo: function GetInfoFn(Callback) {
            function ErrorCallbackFn(errorMsg, httpStatus, calledByFn, calledByParams) {
                Debug.Log("***** AchievementsManager GetInfo Error : " + errorMsg);
                Debug.Log("httpStatus : " + httpStatus);
                Callback(null)
            }
            this.TurbulenzBadgeManager.listBadges(Callback, ErrorCallbackFn)
        },
        GetAwarded: function GetAwardedFn(Callback) {
            function ErrorCallbackFn(errorMsg, httpStatus, calledByFn, calledByParams) {
                Debug.Log("***** AchievementsManager GetAwarded Error : " + errorMsg);
                Debug.Log("httpStatus : " + httpStatus);
                Callback(null)
            }
            if (this.TurbulenzBadgeManager) {
                this.TurbulenzBadgeManager.listUserBadges(Callback, ErrorCallbackFn)
            }
        },
        Award: function AwardFn(AchievementTag) {
            this.TurbulenzBadgeManager.awardUserBadge(AchievementTag, this.BadgeAddCallback, this.ErrorCallback)
        },
        Update: function UpdateFn(AchievementTag, ProgressValue) {
            this.TurbulenzBadgeManager.updateUserBadgeProgress(AchievementTag, ProgressValue, this.BadgeUpdateCallback, this.ErrorCallback)
        },
        ErrorCallback: function ErrorCallbackFn(errorMsg, httpStatus, calledByFn, calledByParams) {
            Debug.Log("Achievement Error : " + errorMsg);
            Debug.Log("httpStatus : " + httpStatus);
            Debug.Log("calledByFn : " + calledByFn);
            Debug.Log("calledByParams : " + calledByParams)
        },
        BadgeAddCallback: function BadgeAddCallbackFn(userbadge) {
            Debug.Log("Achievement awarded " + userbadge.badge_key + ":" + userbadge.current + ":" + userbadge.username)
        },
        BadgeUpdateCallback: function BadgeUpdateCallbackFn(userbadge) {
            Debug.Log("Achievement updated " + userbadge.badge_key + ":" + userbadge.current + ":" + userbadge.username)
        },
        BadgeGetCallback: function BadgeGetCallbackFn(badges) {
            var badgesLength = badges.length;
            for (var i = 0; i < badgesLength; i += 1) {
                var badge = badges[i];
                Debug.Log(badge.title + ": gives you " + badge.points + " points and has a total score of " + badge.total)
            }
        },
        BadgeListCallback: function BadgeListCallbackFn(userbadges) {
            for (var i in userbadges) {
                if (userbadges.hasOwnProperty(i)) {
                    Debug.Log(userbadges[i].username + " owns " + userbadges[i].badge_key + " and the current progress is " + userbadges[i].current + " points")
                }
            }
        },
        Destroy: function Destroy() {}
    };
    AchievementsManager.Create = function Create(requestHandler, GameSession) {
        var NewObject = new AchievementsManager;
        NewObject.TurbulenzBadgeManager = TurbulenzServices.createBadgeManager(requestHandler, GameSession);
        return NewObject
    };

    function LeaderboardsManager() {}
    LeaderboardsManager.prototype = {
        GetIsReady: function GetIsReadyFn() {
            return this.TurbulenzLeaderboardsReady
        },
        Get: function GetFn(LeaderboardTag, TopScores, NumEntries, FriendsOnly, Callback) {
            if (!this.TurbulenzLeaderboardsReady) {
                Callback(LeaderboardTag, null);
                return
            }
            var spec = {
                type: "near",
                size: NumEntries,
                friendsOnly: FriendsOnly
            };
            if (TopScores) {
                spec.type = "top"
            }
            this.TurbulenzLeaderboardManager.get(LeaderboardTag, spec, Callback, this.ErrorCallback)
        },
        Set: function SetFn(LeaderboardTag, Score) {
            if (!this.TurbulenzLeaderboardsReady) {
                return
            }
            Debug.Log("Submit " + Score + " to Leaderboard " + LeaderboardTag);
            this.TurbulenzLeaderboardManager.set(LeaderboardTag, Score, this.SetCallback, this.ErrorCallback)
        },
        ErrorCallback: function ErrorCallbackFn(errorMsg, httpStatus, calledByFn, calledByParams) {
            Debug.Log("****** Leaderboard Error : " + errorMsg);
            Debug.Log("httpStatus : " + httpStatus);
            Debug.Log("calledByFn : " + calledByFn);
            Debug.Log("calledByParams : " + calledByParams)
        },
        SetCallback: function SetCallbackFn(key, score, bestScore) {},
        LeaderboardsReceived: function LeaderboardsReceivedFn(leaderboardManager) {
            Debug.Log("Leaderboard Manager Created");
            JamSystem.LeaderboardsManager.TurbulenzLeaderboardsReady = true
        },
        LeaderboardsGetCallback: function LeaderboardsGetCallbackFn(key, leaderboard) {
            if (leaderboard) {
                var leaderboardString = JamSystem.LeaderboardsManager.TurbulenzLeaderboardManager.meta[key].title + "\n\n";
                var ranking = leaderboard.ranking;
                var numScores = ranking.length;
                for (var i = 0; i < numScores; i += 1) {
                    var s = ranking[i];
                    leaderboardString += s.rank.toString(10) + ",";
                    leaderboardString += s.score.toString(10) + ",";
                    leaderboardString += s.user.username + "\n"
                }
            }
        },
        Destroy: function Destroy() {}
    };
    LeaderboardsManager.Create = function Create(requestHandler, GameSession) {
        var NewObject = new LeaderboardsManager;
        NewObject.TurbulenzLeaderboardsReady = false;
        NewObject.TurbulenzLeaderboardManager = TurbulenzServices.createLeaderboardManager(requestHandler, GameSession, NewObject.LeaderboardsReceived, NewObject.ErrorCallback);
        return NewObject
    };

    function SaveDataManager() {}
    SaveDataManager.prototype = {
        SaveData: function SaveDataFn(Key, Object, Callback) {
            if (!this.TurbulenzUserDataManager) {
                Callback(Key, false);
                return
            }

            function stringSavedFn(key) {
                JamSystem.SaveDataManager.PendingSaves -= 1;
                Callback(Key, true)
            }

            function ErrorCallbackFn(errorMsg, httpStatus, calledByFn, calledByParams) {
                Debug.Log("***** SaveDataManager SaveData Error : " + errorMsg);
                Debug.Log("httpStatus : " + httpStatus);
                JamSystem.SaveDataManager.PendingSaves -= 1;
                Callback(Key, false)
            }
            this.PendingSaves += 1;
            this.TurbulenzUserDataManager.set(Key, JSON.stringify(Object), stringSavedFn, ErrorCallbackFn)
        },
        LoadData: function LoadDataFn(Key, CallBack) {
            if (!this.TurbulenzUserDataManager) {
                CallBack(Key, null);
                return
            }

            function stringLoadedFn(key, value) {
                JamSystem.SaveDataManager.PendingLoads -= 1;
                var complexObject = null;
                if (value) {
                    complexObject = JSON.parse(value)
                }
                CallBack(key, complexObject)
            }

            function ErrorCallbackFn(errorMsg, httpStatus, calledByFn, calledByParams) {
                Debug.Log("***** SaveDataManager LoadData Error : " + errorMsg);
                Debug.Log("httpStatus : " + httpStatus);
                JamSystem.SaveDataManager.PendingLoads -= 1;
                CallBack(Key, null)
            }
            this.PendingLoads += 1;
            this.TurbulenzUserDataManager.get(Key, stringLoadedFn, ErrorCallbackFn)
        },
        ClearAll: function ClearAllFn() {
            if (!this.TurbulenzUserDataManager) {
                return
            }

            function ClearedFn() {}
            this.TurbulenzUserDataManager.removeAll(ClearedFn)
        },
        GetAllFinished: function GetAllFinishedFn() {
            if (this.PendingGets === 0 && this.PendingSets === 0) {
                return true
            }
            return false
        },
        ErrorCallback: function ErrorCallbackFn(errorMsg, httpStatus, calledByFn, calledByParams) {
            Debug.Log("***** SaveDataManager Error : " + errorMsg);
            Debug.Log("httpStatus : " + httpStatus);
            Debug.Log("calledByFn : " + calledByFn);
            Debug.Log("calledByParams : " + calledByParams)
        },
        Destroy: function Destroy() {}
    };
    SaveDataManager.Create = function Create(requestHandler, GameSession) {
        var NewObject = new SaveDataManager;
        NewObject.TurbulenzUserDataManager = UserDataManager.create(requestHandler, GameSession, NewObject.ErrorCallback);
        NewObject.PendingLoads = 0;
        NewObject.PendingSaves = 0;
        return NewObject
    };

    function PublicDataManager() {}
    PublicDataManager.prototype = {
        SaveData: function SaveDataFn(Value, Callback) {
            if (!this.TurbulenzPublicDataManager) {
                Callback(Value, false);
                return
            }

            function stringSavedFn(key) {
                JamSystem.PublicDataManager.PendingSaves -= 1;
                Callback(Value, true)
            }

            function ErrorCallbackFn(errorMsg, httpStatus, calledByFn, calledByParams) {
                Debug.Log("***** PublicDataManager SaveData Error : " + errorMsg);
                Debug.Log("httpStatus : " + httpStatus);
                JamSystem.PublicDataManager.PendingSaves -= 1;
                Callback(Value, false)
            }
            this.PendingSaves += 1;
            return this.TurbulenzPublicDataManager.set(JSON.stringify(Value), stringSavedFn, ErrorCallbackFn)
        },
        LoadData: function LoadDataFn(Username, CallBack) {
            if (!this.TurbulenzPublicDataManager) {
                CallBack(Username, null);
                return
            }

            function stringLoadedFn(Username, GameProfile) {
                JamSystem.PublicDataManager.PendingLoads -= 1;
                CallBack(Username, GameProfile)
            }

            function ErrorCallbackFn(errorMsg, httpStatus, calledByFn, calledByParams) {
                Debug.Log("***** PublicDataManager LoadData Error : " + errorMsg);
                Debug.Log("httpStatus : " + httpStatus);
                JamSystem.PublicDataManager.PendingLoads -= 1;
                CallBack(Username, null)
            }
            this.PendingLoads += 1;
            this.TurbulenzPublicDataManager.get(Username, stringLoadedFn, ErrorCallbackFn)
        },
        LoadMultipleData: function LoadMultipleDataFn(Usernames, CallBack) {
            if (!this.TurbulenzPublicDataManager) {
                CallBack(null);
                return
            }

            function stringLoadedFn(GameProfiles) {
                JamSystem.PublicDataManager.PendingLoads -= 1;
                CallBack(GameProfiles)
            }

            function ErrorCallbackFn(errorMsg, httpStatus, calledByFn, calledByParams) {
                Debug.Log("***** PublicDataManager LoadData Error : " + errorMsg);
                Debug.Log("httpStatus : " + httpStatus);
                JamSystem.PublicDataManager.PendingLoads -= 1;
                CallBack(null)
            }
            this.PendingLoads += 1;
            return this.TurbulenzPublicDataManager.getList(Usernames, stringLoadedFn, ErrorCallbackFn)
        },
        Clear: function ClearAllFn() {
            if (!this.TurbulenzPublicDataManager) {
                return
            }

            function ClearedFn() {}
            this.TurbulenzPublicDataManager.remove(ClearedFn)
        },
        ErrorCallback: function ErrorCallbackFn(errorMsg, httpStatus, calledByFn, calledByParams) {
            Debug.Log("***** PublicDataManager Error : " + errorMsg);
            Debug.Log("httpStatus : " + httpStatus);
            Debug.Log("calledByFn : " + calledByFn);
            Debug.Log("calledByParams : " + calledByParams)
        },
        Destroy: function Destroy() {}
    };
    PublicDataManager.Create = function Create(requestHandler, GameSession) {
        var NewObject = new PublicDataManager;
        NewObject.TurbulenzPublicDataManager = GameProfileManager.create(requestHandler, GameSession, NewObject.ErrorCallback);
        NewObject.PendingLoads = 0;
        NewObject.PendingSaves = 0;
        return NewObject
    };

    function JamRenderTarget() {}
    JamRenderTarget.prototype = {
        GetTexture: function GetTextureFn() {
            return this.Texture
        },
        GetRenderTexture: function GetRenderTextureFn() {
            return this.RenderTexture
        },
        Begin: function BeginFn() {
            return JamSystem.RenderManager.TurbulenzGraphicsDevice.beginRenderTarget(this.RenderTarget)
        },
        End: function EndFn() {
            JamSystem.RenderManager.TurbulenzGraphicsDevice.endRenderTarget()
        },
        Destroy: function DestroyFn() {
            this.RenderTextureParameters = {};
            this.RenderTexture.destroy();
            this.RenderTexture = null;
            this.RenderTargetParams = {};
            this.RenderTarget.destroy();
            this.RenderTarget = null
        }
    };
    JamRenderTarget.Create = function JamRenderTargetCreate(Width, Height) {
        var NewObject = new JamRenderTarget;
        NewObject.RenderTextureParameters = {
            name: "rendertexture",
            width: Width,
            height: Height,
            depth: 1,
            format: "R8G8B8A8",
            cubemap: false,
            mipmaps: false,
            renderable: true
        };
        NewObject.RenderTexture = JamSystem.RenderManager.TurbulenzGraphicsDevice.createTexture(NewObject.RenderTextureParameters);
        if (!NewObject.RenderTexture) {
            Debug.Log("***** Render Texture not created.")
        }
        NewObject.RenderTargetParams = {
            colorTexture0: null
        };
        if (NewObject.RenderTexture) {
            NewObject.RenderTargetParams.colorTexture0 = NewObject.RenderTexture;
            NewObject.RenderTarget = JamSystem.RenderManager.TurbulenzGraphicsDevice.createRenderTarget(NewObject.RenderTargetParams)
        }
        var NewTexture = JamTexture.Create("RenderTexture", -1, false);
        var Frames = [];
        var NewFrame = FrameInstance.Create();
        NewFrame.PageIndex = 0;
        NewFrame.Width = Width;
        NewFrame.Height = Height;
        NewFrame.u = 0;
        NewFrame.v = 0;
        Frames[0] = NewFrame;
        var Names = ["RenderTexture"];
        var Images = [NewObject.RenderTexture];
        NewTexture.SetImages(Frames, Names, Images, null);
        NewObject.Texture = NewTexture;
        return NewObject
    };

    function ScriptManager() {}
    ScriptManager.prototype = {
        SetRootTree: function SetRootTreeFn(RootTree) {
            this.RootTree = RootTree
        },
        AddFunctions: function AddFunctionsFn(FunctionDefinitions) {
            var i;
            for (i = 0; i < FunctionDefinitions.length; i += 1) {
                this.RegisteredFunctions[this.RegisteredFunctions.length] = FunctionDefinitions[i]
            }
        },
        AddScript: function AddScriptFn(ScriptObject) {
            var Index = this.ScriptFiles.length;
            this.ScriptFiles[Index] = {};
            this.ParseScriptObject(ScriptObject, Index)
        },
        LoadScriptFile: function LoadScriptFileFn(FileName, AbsolutePath) {
            var Index = this.ScriptFiles.length;
            this.ScriptFiles[Index] = {};
            this.ScriptFiles[Index].FileName = FileName;
            this.ScriptFiles[Index].AbsolutePath = AbsolutePath;
            this.LoadAndParseScriptFile(Index)
        },
        ReloadScriptFiles: function ReloadScriptFilesFn() {
            var i;
            for (i = 0; i < this.ScriptFiles.length; i += 1) {
                if (this.ScriptFiles[i].FileName) {
                    this.LoadAndParseScriptFile(i)
                }
            }
        },
        GetIsReady: function GetIsReadyFn() {
            var i;
            for (i = 0; i < this.ScriptFiles.length; i += 1) {
                if (!this.ScriptFiles[i].File.bFinished) {
                    return false
                }
            }
            return true
        },
        StartScript: function StartScriptFn(ScriptName, TextFifo) {
            var i, j;
            var ScriptData = null;
            for (i = 0; i < this.ScriptFiles.length; i += 1) {
                var Scripts = this.ScriptFiles[i].Scripts;
                if (Scripts) {
                    for (j = 0; j < Scripts.length; j += 1) {
                        if (ScriptName === Scripts[j].Name) {
                            ScriptData = Scripts[j];
                            break
                        }
                    }
                }
                if (ScriptData) {
                    break
                }
            }
            var NewScript = null;
            if (ScriptData === null) {
                Debug.Log("*************** couldn't find script \"" + ScriptName + '"')
            } else {
                NewScript = ScriptThread.Create(ScriptData, ScriptName);
                if (TextFifo) {
                    var i;
                    for (i = 0; i < TextFifo.length; i += 1) {
                        NewScript.PushText(TextFifo[i])
                    }
                }
                NewScript.Update(0);
                if (!NewScript.Finished) {
                    this.ScriptThreads[this.ScriptThreads.length] = NewScript
                }
            }
            return NewScript
        },
        StopScript: function StopScriptFn(Script) {
            Script.Stop();
            var Index = this.ScriptThreads.indexOf(Script);
            if (Index !== -1) {
                this.ScriptThreads.splice(Index, 1)
            }
        },
        StopAll: function StopAllFn(StopAll) {
            var i;
            for (i = 0; i < this.ScriptThreads.length; i += 1) {
                this.ScriptThreads[i].Stop()
            }
            this.ScriptThreads = []
        },
        ParseScriptObject: function ParseScriptObjectFn(JSONObject, Index) {
            this.ScriptFiles[Index].Scripts = JSONObject.Scripts;
            var Scripts = this.ScriptFiles[Index].Scripts;
            var i, j, k;
            for (i = 0; i < Scripts.length; i += 1) {
                Debug.Log('Parsing script "' + Scripts[i].Name + '"');
                var Code = Scripts[i].Code;
                for (j = 0; j < Code.length; j += 1) {
                    var CodeName = Code[j].Func;
                    for (k = 0; k < this.RegisteredFunctions.length; k += 1) {
                        if (CodeName === this.RegisteredFunctions[k].Name) {
                            Code[j].Function = this.RegisteredFunctions[k].Function;
                            break
                        }
                    }
                    if (k === this.RegisteredFunctions.length) {
                        Debug.Log("************ Couldn't find function \"" + CodeName + '" in script "' + Scripts[i].Name + '"')
                    }
                }
            }
        },
        LoadAndParseScriptFile: function LoadAndParseScriptFileFn(Index) {
            var Object = this;
            var ParseScriptFile = function ParseScriptFileFn(psData, iDataSize, psUserData) {
                if (psData === null) {
                    return
                }
                Debug.Log('Parsing script file "' + Object.ScriptFiles[Index].FileName + '"');
                var JSONObject = JSON.parse(psData);
                Object.ParseScriptObject(JSONObject, Index)
            };
            this.ScriptFiles[Index].File = File.Load(this.ScriptFiles[Index].FileName, ParseScriptFile, null, this.ScriptFiles[Index].AbsolutePath)
        },
        Update: function UpdateFn(TimeDelta) {
            var i;
            for (i = 0; i < this.ScriptThreads.length; i += 1) {
                this.ScriptThreads[i].Update(TimeDelta);
                if (this.ScriptThreads[i].Finished) {
                    this.ScriptThreads[i].Stop();
                    this.ScriptThreads.splice(i, 1);
                    i -= 1
                }
            }
        },
        Destroy: function DestroyFn() {
            this.StopAll()
        }
    };
    ScriptManager.Create = function ScriptManagerCreateFn() {
        var NewObject = new ScriptManager;
        NewObject.ScriptThreads = [];
        NewObject.RegisteredFunctions = [];
        NewObject.ScriptFiles = [];
        NewObject.RootTree = null;
        return NewObject
    };

    function ScriptThread() {}
    ScriptThread.prototype = {
        GetIsFinished: function GetIsFinishedFn() {
            return this.Finished
        },
        Stop: function StopFn() {
            var i;
            for (i in this.LocalVariables) {
                if (this.LocalVariables.hasOwnProperty(i)) {
                    var Variable = this.LocalVariables[i];
                    if (Variable && Variable.CleanUp) {
                        var Object = {};
                        Object.Name = i;
                        Variable.CleanUp(this, Object)
                    }
                    this.LocalVariables[i] = undefined
                }
            }
            this.Finished = true
        },
        PushText: function PushTextFn(Text) {
            this.TextFifo[this.TextFifo.length] = Text
        },
        Wait: function WaitFn(Delay) {
            this.WaitDelay += this.TimeDelta;
            if (this.WaitDelay >= Delay) {
                this.WaitDelay = 0;
                return true
            }
            return false
        },
        Update: function UpdateFn(TimeDelta) {
            this.TimeDelta = TimeDelta;
            var Code = this.ScriptData.Code;
            var Continue;
            do {
                var Function = Code[this.CurrentInstruction].Function;
                if (Function) {
                    Continue = Function(this, Code[this.CurrentInstruction]);
                    if (this.Error) {
                        Debug.Log("******* Script " + this.Name + " line " + this.CurrentInstruction + " : " + this.Error);
                        this.Error = null
                    }
                } else {
                    Continue = true
                }
                if (Continue) {
                    this.CurrentInstruction += 1;
                    if (this.CurrentInstruction === Code.length) {
                        this.Finished = true
                    }
                }
            } while (Continue && !this.Finished);
            var i;
            for (i in this.LocalVariables) {
                if (this.LocalVariables.hasOwnProperty(i)) {
                    var Variable = this.LocalVariables[i];
                    if (Variable && Variable.Update && !Variable.ScriptData) {
                        Variable.Update(Variable, TimeDelta)
                    }
                }
            }
        },
        Destroy: function DestroyFn() {
            this.Stop()
        }
    };
    ScriptThread.Create = function ScriptThreadCreateFn(ScriptData, ScriptName) {
        var NewObject = new ScriptThread;
        NewObject.WaitDelay = 0;
        NewObject.TimeDelta = 0;
        NewObject.CurrentInstruction = 0;
        NewObject.Finished = false;
        NewObject.ScriptData = ScriptData;
        NewObject.LocalVariables = {};
        NewObject.Error = null;
        NewObject.Name = ScriptName;
        NewObject.TextFifo = [];
        NewObject.Labels = [];
        var i;
        for (i = 0; i < ScriptData.length; i += 1) {
            var Function = ScriptData[i].Function;
            if (Function === ScriptBasicFunctions.SetLabel) {
                NewObject.Labels[Function.Label] = i
            }
        }
        return NewObject
    };

    function ScriptBasicFunctions() {}
    ScriptBasicFunctions.prototype = {};
    ScriptBasicFunctions.Wait = function WaitFn(ThisScript, Object) {
        return ThisScript.Wait(Object.Delay)
    };
    ScriptBasicFunctions.Log = function LogFn(ThisScript, Object) {
        Debug.Log(Object.Text);
        return true
    };
    ScriptBasicFunctions.StartScript = function StartScriptFn(ThisScript, Object) {
        ThisScript.LocalVariables[Object.Handle] = JamSystem.ScriptManager.StartScript(Object.Name);
        return true
    };
    ScriptBasicFunctions.WaitScript = function WaitScriptFn(ThisScript, Object) {
        return ThisScript.LocalVariables[Object.Handle].GetIsFinished()
    };
    ScriptBasicFunctions.SetLabel = function SetLabelFn(ThisScript, Object) {
        return true
    };
    ScriptBasicFunctions.SetVariableImmediate = function SetVariableImmediateFn(ThisScript, Object) {
        ThisScript.LocalVariables[Object.Name] = Object.Value;
        return true
    };
    ScriptBasicFunctions.SetVariableVariable = function SetVariableVariableFn(ThisScript, Object) {
        ThisScript.LocalVariables[Object.Name] = ThisScript.LocalVariables[Object.SetName];
        return true
    };
    ScriptBasicFunctions.AddVariableImmediate = function AddVariableImmediateFn(ThisScript, Object) {
        ThisScript.LocalVariables[Object.Name] += Object.Value;
        return true
    };
    ScriptBasicFunctions.AddVariableVariable = function AddVariableVariableFn(ThisScript, Object) {
        ThisScript.LocalVariables[Object.Name] += ThisScript.LocalVariables[Object.AddName];
        return true
    };
    ScriptBasicFunctions.CmpVariable = function CmpVariableFn(ThisScript, Object) {
        var Jump = false;
        if (Object.CmpType === "=") {
            if (ThisScript.LocalVariables[Object.Name] === Object.CmpValue) {
                Jump = true
            }
        } else if (Object.CmpType === "<") {
            if (ThisScript.LocalVariables[Object.Name] < Object.CmpValue) {
                Jump = true
            }
        } else if (Object.CmpType === ">") {
            if (ThisScript.LocalVariables[Object.Name] > Object.CmpValue) {
                Jump = true
            }
        } else if (Object.CmpType === "<=") {
            if (ThisScript.LocalVariables[Object.Name] <= Object.CmpValue) {
                Jump = true
            }
        } else if (Object.CmpType === ">=") {
            if (ThisScript.LocalVariables[Object.Name] >= Object.CmpValue) {
                Jump = true
            }
        } else {
            ThisScript.Error = "Unknown compare type: " + Object.CmpValue
        }
        if (Jump) {
            var Instruction = ThisScript.Labels[Object.Label];
            if (Instruction) {
                ThisScript.CurrentInstruction = Instruction
            } else {
                ThisScript.Error = "Unknown Label: " + Object.Label
            }
        }
        return true
    };
    ScriptBasicFunctions.SpriteCreate = function SpriteCreateFn(ThisScript, Object) {
        var NewObject = {};
        NewObject.Update = ScriptBasicFunctions.RenderableUpdate;
        NewObject.PositionTweener = new Tweener;
        NewObject.ScaleTweener = new Tweener;
        NewObject.RotationTweener = new Tweener;
        NewObject.BlinkDuration = 0;
        NewObject.BlinkOnDelay = 0;
        NewObject.BlinkOffDelay = 0;
        NewObject.CleanUp = ScriptBasicFunctions.SpriteDestroy;
        NewObject.Renderable = Helpers.CreateSprite(Object.x, Object.y, EA.Default, Object.Image, JamSystem.ScriptManager.RootTree);
        ThisScript.LocalVariables[Object.Name] = NewObject;
        return true
    };
    ScriptBasicFunctions.SpriteDestroy = function SpriteDestroyFn(ThisScript, Object) {
        if (ThisScript.LocalVariables[Object.Name]) {
            var Renderable = ThisScript.LocalVariables[Object.Name].Renderable;
            Helpers.DestroySprite(Renderable);
            ThisScript.LocalVariables[Object.Name].CleanUp = null
        } else {
            ThisScript.Error = "SpriteDestroy : Couldn't find " + Object.Name
        }
        return true
    };
    ScriptBasicFunctions.TextCreate = function TextCreateFn(ThisScript, Object) {
        var Text = JamSystem.TextManager.GetText(Object.Text, ThisScript.TextFifo);
        var NewObject = {};
        NewObject.Update = ScriptBasicFunctions.RenderableUpdate;
        NewObject.PositionTweener = new Tweener;
        NewObject.ScaleTweener = new Tweener;
        NewObject.RotationTweener = new Tweener;
        NewObject.BlinkDuration = 0;
        NewObject.BlinkOnDelay = 0;
        NewObject.BlinkOffDelay = 0;
        NewObject.CleanUp = ScriptBasicFunctions.TextDestroy;
        NewObject.Renderable = Helpers.CreateBitmapText(Text, Object.x, Object.y, EA.Default, Object.Font, JamSystem.ScriptManager.RootTree);
        ThisScript.LocalVariables[Object.Name] = NewObject;
        return true
    };
    ScriptBasicFunctions.TextDestroy = function TextDestroyFn(ThisScript, Object) {
        if (ThisScript.LocalVariables[Object.Name]) {
            var Renderable = ThisScript.LocalVariables[Object.Name].Renderable;
            Helpers.DestroyBitmapText(Renderable);
            ThisScript.LocalVariables[Object.Name].CleanUp = null
        } else {
            ThisScript.Error = "TextDestroy : Couldn't find " + Object.Name
        }
        return true
    };
    ScriptBasicFunctions.RenderableUpdate = function RenderablePositionSetFn(Object, TimeDelta) {
        var Renderable = Object.Renderable;
        if (Object.PositionTweener.Update(TimeDelta)) {
            Renderable.SetPosition(Object.PositionTweener.VariableX, Object.PositionTweener.VariableY)
        }
        if (Object.ScaleTweener.Update(TimeDelta)) {
            Renderable.SetScale(Object.ScaleTweener.VariableX, Object.ScaleTweener.VariableY)
        }
        if (Object.RotationTweener.Update(TimeDelta)) {
            Renderable.SetRotation(Object.RotationTweener.VariableX)
        }
        if (this.BlinkDuration) {
            this.BlinkDuration -= 1;
            if (this.BlinkDuration <= 0) {
                Renderable.SetIsVisible(true);
                this.BlinkDuration = 0
            } else {
                if (this.BlinkDuration % (this.BlinkOnDelay + this.BlinkOffDelay) < this.BlinkOffDelay) {
                    Renderable.SetIsVisible(false)
                } else {
                    Renderable.SetIsVisible(true)
                }
            }
        }
    };
    ScriptBasicFunctions.RenderablePositionSet = function RenderablePositionSetFn(ThisScript, Object) {
        var NewObject = ThisScript.LocalVariables[Object.Name];
        var Renderable = NewObject.Renderable;
        NewObject.PositionTweener.Reset();
        Renderable.SetPosition(Object.x, Object.y);
        return true
    };
    ScriptBasicFunctions.RenderablePositionTo = function RenderablePositionToFn(ThisScript, Object) {
        var NewObject = ThisScript.LocalVariables[Object.Name];
        var Renderable = NewObject.Renderable;
        NewObject.PositionTweener.Set(Object.Delay, Renderable.x, Object.x, Renderable.y, Object.y);
        return true
    };
    ScriptBasicFunctions.RenderableScaleSet = function RenderableScaleSetFn(ThisScript, Object) {
        var NewObject = ThisScript.LocalVariables[Object.Name];
        var Renderable = NewObject.Renderable;
        NewObject.ScaleTweener.Reset();
        Renderable.SetScale(Object.x, Object.y);
        return true
    };
    ScriptBasicFunctions.RenderableScaleTo = function RenderableScaleToFn(ThisScript, Object) {
        var NewObject = ThisScript.LocalVariables[Object.Name];
        var Renderable = NewObject.Renderable;
        NewObject.ScaleTweener.Set(Object.Delay, Renderable.ScaleX, Object.x, Renderable.ScaleY, Object.y);
        return true
    };
    ScriptBasicFunctions.RenderableRotationSet = function RenderableRotationSetFn(ThisScript, Object) {
        var NewObject = ThisScript.LocalVariables[Object.Name];
        var Renderable = NewObject.Renderable;
        NewObject.RotationTweener.Reset();
        Renderable.SetRotation(Object.Rotation);
        return true
    };
    ScriptBasicFunctions.RenderableRotationTo = function RenderableRotationToFn(ThisScript, Object) {
        var NewObject = ThisScript.LocalVariables[Object.Name];
        var Renderable = NewObject.Renderable;
        NewObject.RotationTweener.Set(Object.Delay, Renderable.Rotation, Object.Rotation, 0, 0);
        return true
    };
    ScriptBasicFunctions.RenderableColourSet = function RenderableColourSetFn(ThisScript, Object) {
        var NewObject = ThisScript.LocalVariables[Object.Name];
        var Renderable = NewObject.Renderable;
        Renderable.SetColour([Object.r, Object.g, Object.b, Object.a]);
        return true
    };
    ScriptBasicFunctions.RenderableAnchorSet = function RenderableAnchorSetFn(ThisScript, Object) {
        var Anchor = null;
        if (Object.Anchor === "TopLeft") {
            Anchor = EA.TopLeft
        } else if (Object.Anchor === "TopMiddle") {
            Anchor = EA.TopMiddle
        } else if (Object.Anchor === "TopRight") {
            Anchor = EA.TopRight
        } else if (Object.Anchor === "MiddleLeft") {
            Anchor = EA.MiddleLeft
        } else if (Object.Anchor === "MiddleMiddle") {
            Anchor = EA.MiddleMiddle
        } else if (Object.Anchor === "Middle") {
            Anchor = EA.Middle
        } else if (Object.Anchor === "Default") {
            Anchor = EA.Default
        } else if (Object.Anchor === "MiddleRight") {
            Anchor = EA.MiddleRight
        } else if (Object.Anchor === "BottomLeft") {
            Anchor = EA.BottomLeft
        } else if (Object.Anchor === "BottomMiddle") {
            Anchor = EA.BottomMiddle
        } else if (Object.Anchor === "BottomRight") {
            Anchor = EA.BottomRight
        }
        if (Anchor) {
            var NewObject = ThisScript.LocalVariables[Object.Name];
            var ThisRenderable = NewObject.Renderable;
            ThisRenderable.SetAnchor(Anchor)
        } else {
            ThisScript.Error = "Unrecognised anchor " + Object.Anchor
        }
        return true
    };
    ScriptBasicFunctions.RenderableBlinkStart = function RenderableBlinkStartFn(ThisScript, Object) {
        var NewObject = ThisScript.LocalVariables[Object.Name];
        NewObject.BlinkDuration = Math.floor(Object.Duration * 60);
        NewObject.BlinkOnDelay = Math.floor(Object.OnDelay * 60);
        NewObject.BlinkOffDelay = Math.floor(Object.OffDelay * 60);
        return true
    };
    ScriptBasicFunctions.SoundPlay = function SoundPlayFn(ThisScript, Object) {
        Helpers.PlaySound(Object.Name);
        return true
    };
    ScriptBasicFunctions.SoundStop = function SoundStopFn(ThisScript, Object) {
        Helpers.StopSound(Object.Name);
        return true
    };
    ScriptBasicFunctions.SoundSetVolume = function SoundSetVolumeFn(ThisScript, Object) {
        Helpers.SetSoundVolume(Object.Name, Object.Volume);
        return true
    };
    ScriptBasicFunctions.Init = function ScriptBasicFunctionsInitFn() {
        var BasicFunctions = [{
            Name: "Log",
            Function: ScriptBasicFunctions.Log
        }, {
            Name: "Wait",
            Function: ScriptBasicFunctions.Wait
        }, {
            Name: "StartScript",
            Function: ScriptBasicFunctions.StartScript
        }, {
            Name: "WaitScript",
            Function: ScriptBasicFunctions.WaitScript
        }, {
            Name: "SetLabel",
            Function: ScriptBasicFunctions.SetLabel
        }, {
            Name: "SetVariableImmediate",
            Function: ScriptBasicFunctions.SetVariableImmediate
        }, {
            Name: "SetVariableVariable",
            Function: ScriptBasicFunctions.SetVariableVariable
        }, {
            Name: "AddVariableImmediate",
            Function: ScriptBasicFunctions.AddVariableImmediate
        }, {
            Name: "AddVariableVariable",
            Function: ScriptBasicFunctions.AddVariableVariable
        }, {
            Name: "CmpVariable",
            Function: ScriptBasicFunctions.CmpVariable
        }, {
            Name: "SpriteCreate",
            Function: ScriptBasicFunctions.SpriteCreate
        }, {
            Name: "SpriteDestroy",
            Function: ScriptBasicFunctions.SpriteDestroy
        }, {
            Name: "TextCreate",
            Function: ScriptBasicFunctions.TextCreate
        }, {
            Name: "TextDestroy",
            Function: ScriptBasicFunctions.TextDestroy
        }, {
            Name: "RenderablePositionSet",
            Function: ScriptBasicFunctions.RenderablePositionSet
        }, {
            Name: "RenderablePositionTo",
            Function: ScriptBasicFunctions.RenderablePositionTo
        }, {
            Name: "RenderableScaleSet",
            Function: ScriptBasicFunctions.RenderableScaleSet
        }, {
            Name: "RenderableScaleTo",
            Function: ScriptBasicFunctions.RenderableScaleTo
        }, {
            Name: "RenderableRotationSet",
            Function: ScriptBasicFunctions.RenderableRotationSet
        }, {
            Name: "RenderableRotationTo",
            Function: ScriptBasicFunctions.RenderableRotationTo
        }, {
            Name: "RenderableColourSet",
            Function: ScriptBasicFunctions.RenderableColourSet
        }, {
            Name: "RenderableAnchorSet",
            Function: ScriptBasicFunctions.RenderableAnchorSet
        }, {
            Name: "RenderableBlinkStart",
            Function: ScriptBasicFunctions.RenderableBlinkStart
        }, {
            Name: "SoundPlay",
            Function: ScriptBasicFunctions.SoundPlay
        }, {
            Name: "SoundStop",
            Function: ScriptBasicFunctions.SoundStop
        }, {
            Name: "SoundSetVolume",
            Function: ScriptBasicFunctions.SetVolume
        }];
        JamSystem.ScriptManager.AddFunctions(BasicFunctions)
    };

    function TextManager() {}
    TextManager.prototype = {};
    TextManager.Create = function TextManagerCreateFn(mathDevice, NumSources) {
        var TextDictionarys = [];

        function ClearFn() {
            TextDictionarys = []
        }

        function GetTextFn(TextIdentifier, TextSubstitutionFifo) {
            var i;
            for (i = 0; i < TextDictionarys.length; i += 1) {
                var Dictionary = TextDictionarys[i];
                var Text = Dictionary[TextIdentifier];
                if (Text !== undefined) {
                    return this.FormatText(Text, TextSubstitutionFifo)
                }
            }
            Debug.Log("******** warning : couldn't find text - " + TextIdentifier);
            return "#" + TextIdentifier
        }

        function FormatTextFn(TextIn, TextSubstitutionFifo) {
            var TextOut = "";
            var i;
            for (i = 0; i < TextIn.length; i += 1) {
                var Char = TextIn.substring(i, i + 1);
                if (Char === "%" && TextIn.substring(i + 1, i + 2) === "s") {
                    if (!TextSubstitutionFifo || TextSubstitutionFifo.length === 0) {
                        Debug.Assert(false, "*********************** Fatal error : " + TextIn + " has no substitution text")
                    }
                    Char = TextSubstitutionFifo[0];
                    TextSubstitutionFifo.splice(0, 1);
                    i += 1
                }
                TextOut += Char
            }
            return TextOut
        }

        function AddTextFn(Text) {
            TextDictionarys[TextDictionarys.length] = Text
        }

        function initFn() {}

        function DestroyFn() {}
        initFn();
        var NewTextManager = new TextManager;
        NewTextManager.Clear = ClearFn;
        NewTextManager.GetText = GetTextFn;
        NewTextManager.FormatText = FormatTextFn;
        NewTextManager.AddText = AddTextFn;
        NewTextManager.Destroy = DestroyFn;
        return NewTextManager
    };

    function Tweener() {}
    Tweener.prototype = {
        Set: function SetFn(TimeTarget, VariableXStart, VariableXEnd, VariableYStart, VariableYEnd) {
            this.Time = 0;
            this.TimeTarget = TimeTarget;
            this.VariableXStart = VariableXStart;
            this.VariableXDelta = VariableXEnd - VariableXStart;
            this.VariableXEnd = VariableXEnd;
            this.VariableX = VariableXStart;
            this.VariableYStart = VariableYStart;
            this.VariableYDelta = VariableYEnd - VariableYStart;
            this.VariableYEnd = VariableYEnd;
            this.VariableY = VariableXStart
        },
        Reset: function ResetFn() {
            this.Time = 0;
            this.TimeTarget = 0
        },
        Update: function UpdateFn(TimeDelta) {
            if (this.Time < this.TimeTarget) {
                this.Time += TimeDelta;
                if (this.Time >= this.TimeTarget) {
                    this.Time = this.TimeTarget;
                    this.TimePercent = 1;
                    this.VariableX = this.VariableXEnd;
                    this.VariableY = this.VariableYEnd
                } else {
                    this.TimePercent = this.Time / this.TimeTarget;
                    var Percent = -(Math.cos(this.TimePercent * Math.PI) / 2) + .5;
                    this.VariableX = this.VariableXStart + Percent * this.VariableXDelta;
                    this.VariableY = this.VariableYStart + Percent * this.VariableYDelta
                }
                return true
            }
            return false
        },
        Destroy: function DestroyFn() {}
    };
    Tweener.Create = function TweenerCreate() {
        var NewObject = new Tweener;
        NewObject.Time = 0;
        NewObject.TimeTarget = 0;
        NewObject.VariableXStart = 0;
        NewObject.VariableXDelta = 0;
        NewObject.VariableX = 0;
        NewObject.VariableYStart = 0;
        NewObject.VariableYEnd = 0;
        NewObject.VariableY = 0;
        NewObject.TimePercent = 0;
        return NewObject
    };

    function NetworkSession() {}
    NetworkSession.TypeCreate = 0;
    NetworkSession.TypeJoinAny = 1;
    NetworkSession.TypeJoinSpecific = 2;
    NetworkSession.TypeJoinCreate = 3;
    NetworkSession.prototype = {
        SendToOne: function SendToOneFn(messageType, messageData, playerID) {
            messageData[NetworkManager.mU_Players] = JamSystem.NetworkManager.PlayerInfo.length;
            messageData = JSON.stringify(messageData);
            this.TurbulenzNetworkSession.sendTo(playerID, messageType, messageData)
        },
        SendToMany: function SendToManyFn(messageType, messageData, playerIDs) {
            messageData[NetworkManager.mU_Players] = JamSystem.NetworkManager.PlayerInfo.length;
            messageData = JSON.stringify(messageData);
            this.TurbulenzNetworkSession.sendToGroup(playerIDs, messageType, messageData)
        },
        SendToAll: function SendToAllFn(messageType, messageData) {
            messageData[NetworkManager.mU_Players] = JamSystem.NetworkManager.PlayerInfo.length;
            messageData = JSON.stringify(messageData);
            Debug.Log("SENDING -> Message " + messageData + " TYPE " + messageType);
            this.TurbulenzNetworkSession.sendToAll(messageType, messageData)
        },
        ErrorCallback: function ErrorCallbackFn(errorMsg, httpStatus, calledByFn, calledByParams) {
            Debug.Log("***** NetworkSession Error : " + errorMsg);
            Debug.Log("httpStatus : " + httpStatus);
            Debug.Log("calledByFn : " + calledByFn);
            Debug.Log("calledByParams : " + calledByParams)
        },
        CreatedCallback: function CreatedCallbackFn(Session) {
            Debug.Log("Network Session Created");
            JamSystem.NetworkManager.Session.TurbulenzNetworkSession = Session;
            JamSystem.NetworkManager.Session.IsReady = true;
            JamSystem.NetworkManager.State = NetworkManager.StateInitiallyCreated;
            JamSystem.NetworkManager.Session.TurbulenzNetworkSession.onmessage = NetworkSession.OnMessage;
            JamSystem.NetworkManager.Session.TurbulenzNetworkSession.onclose = NetworkSession.OnClose
        },
        SessionJoinedCallback: function SessionJoinedCallbackFn(Session) {
            Debug.Log("Network Session Created, Joined another user");
            JamSystem.NetworkManager.Session.TurbulenzNetworkSession = Session;
            JamSystem.NetworkManager.Session.IsReady = true;
            JamSystem.NetworkManager.State = NetworkManager.StateInitiallyJoined;
            JamSystem.NetworkManager.Session.TurbulenzNetworkSession.onmessage = NetworkSession.OnMessage;
            JamSystem.NetworkManager.Session.TurbulenzNetworkSession.onclose = NetworkSession.OnClose
        },
        SessionJoinedFailedCallback: function SessionJoinedFailedCallbackFn(Session) {
            Debug.Log("Network Session Failed, No user to join");
            JamSystem.NetworkManager.Session.TurbulenzNetworkSession = Session;
            JamSystem.NetworkManager.Session.IsReady = false;
            JamSystem.NetworkManager.State = NetworkManager.StateJoinFailed
        },
        Destroy: function Destroy() {
            Debug.Log("DESTROY SESSION");
            if (this.TurbulenzNetworkSession) {
                Debug.Log("SENDING DEATH");
                this.SendToAll(NetworkManager.MsgDisconnect, [])
            }
            if (this.TurbulenzNetworkSession) {
                this.TurbulenzNetworkSession.destroy()
            }
            this.TurbulenzNetworkSession = null
        }
    };
    NetworkSession.OnMessage = function OnMessageFn(senderId, messageType, messageData) {
        var ths = JamSystem.NetworkManager.Session;
        if (messageData) {
            var updateData = JSON.parse(messageData);
            Debug.Log("DATA RCVD -> " + updateData + " FROM " + senderId + " TYPE " + messageType);
            var i = 0,
                PlayerIndex = -1;
            var PlayerInfo = JamSystem.NetworkManager.PlayerInfo;
            for (i = 0; i < PlayerInfo.length; i += 1) {
                if (PlayerInfo[i].ID === senderId) {
                    PlayerIndex = i;
                    break
                }
            }
            if (messageType === NetworkManager.MsgDisconnect) {
                Debug.Log("Player " + senderId + " left the game");
                if (PlayerIndex !== -1) {
                    PlayerInfo.splice(PlayerIndex)
                }
                return
            } else if (messageType === NetworkManager.MsgUpdate) {
                if (PlayerIndex === -1) {
                    PlayerIndex = PlayerInfo.length;
                    Debug.Log("Adding " + senderId + " to the players list as index: " + PlayerIndex);
                    PlayerInfo[PlayerIndex] = {};
                    PlayerInfo[PlayerIndex].ID = senderId;
                    PlayerInfo[PlayerIndex].Timeout = 0;
                    PlayerInfo[PlayerIndex].x = 0;
                    PlayerInfo[PlayerIndex].y = 0;
                    PlayerInfo[PlayerIndex].direction = 0
                } else {
                    PlayerInfo[PlayerIndex].Timeout = 0
                }
                updateData[0] = PlayerIndex;
                ths.MessageQueue.push(updateData)
            }
        }
    };
    NetworkSession.OnClose = function OnCloseFn() {
        var ths = JamSystem.NetworkManager.Session;
        Debug.Log("Connection lost!")
    };
    NetworkSession.Create = function Create(Manager, MaxPlayers, SessionID, Type) {
        var NewObject = new NetworkSession;
        Debug.Log("Creating a session");
        switch (Type) {
            case NetworkSession.TypeCreate:
                Debug.Log("TYPE " + Type);
                NewObject.TurbulenzNetworkSession = Manager.createSession(MaxPlayers, NewObject.CreatedCallback, NewObject.ErrorCallback);
                break;
            case NetworkSession.TypeJoinAny:
                Debug.Log("TYPE " + Type);
                NewObject.TurbulenzNetworkSession = Manager.joinAnySession(NewObject.SessionJoinedCallback, NewObject.SessionJoinedFailedCallback, NewObject.ErrorCallback);
                break;
            case NetworkSession.TypeJoinSpecific:
                Debug.Log("TYPE " + Type);
                NewObject.TurbulenzNetworkSession = Manager.joinSession(SessionID, NewObject.SessionJoinedCallback, NewObject.ErrorCallback);
                break;
            case NetworkSession.TypeJoinCreate:
                Debug.Log("TYPE " + Type);
                NewObject.TurbulenzNetworkSession = Manager.joinOrCreateSession(MaxPlayers, NewObject.CreatedCallback, NewObject.ErrorCallback);
                break
        }
        NewObject.IsReady = false;
        NewObject.MessageQueue = [];
        return NewObject
    };

    function NetworkManager() {}
    NetworkManager.MaxPlayers = 4;
    NetworkManager.StateOff = 0;
    NetworkManager.StateCreating = 1;
    NetworkManager.StateJoining = 2;
    NetworkManager.StateInitiallyCreated = 3;
    NetworkManager.StateInitiallyJoined = 4;
    NetworkManager.StateCreated = 5;
    NetworkManager.StateJoined = 6;
    NetworkManager.StateJoinFailed = 7;
    NetworkManager.MsgUpdate = 0;
    NetworkManager.MsgDisconnect = 1;
    NetworkManager.mU_Players = 0;
    NetworkManager.mU_PosX = 1;
    NetworkManager.mU_PosY = 2;
    NetworkManager.mU_Direction = 3;
    NetworkManager.prototype = {
        createSession: function CreateSessionFn() {
            if (this.Session && this.Session.TurbulenzNetworkSession) {
                Debug.Log("Session Exists");
                return
            }
            this.State = NetworkManager.StateCreating;
            this.Session = NetworkSession.Create(this.TurbulenzNetworkManager, NetworkManager.MaxPlayers, null, NetworkSession.TypeCreate)
        },
        joinAnySession: function joinAnySessionFn() {
            if (this.Session && this.Session.TurbulenzNetworkSession) {
                Debug.Log("Session Exists");
                return
            }
            this.State = NetworkManager.StateJoining;
            this.Session = NetworkSession.Create(this.TurbulenzNetworkManager, null, null, NetworkSession.TypeJoinAny)
        },
        joinSession: function joinSessionFn(SessionID) {
            if (this.Session && this.Session.TurbulenzNetworkSession) {
                Debug.Log("Session Exists");
                return
            }
            if (!SessionID) {
                Debug.Log("FAIL - Didn't pass a SessionID");
                return
            }
            this.State = NetworkManager.StateJoining;
            this.Session = NetworkSession.Create(this.TurbulenzNetworkManager, null, SessionID, NetworkSession.TypeJoinSpecific)
        },
        joinOrCreateSession: function joinOrCreateSessionFn() {
            if (this.Session && this.Session.TurbulenzNetworkSession) {
                Debug.Log("Session Exists");
                return
            }
            this.State = NetworkManager.StateJoining;
            this.Session = NetworkSession.Create(this.TurbulenzNetworkManager, null, null, NetworkSession.TypeJoinAny);
            this.CreateOnFail = true
        },
        queryFriendsSessions: function queryFriendsSessionsFn() {
            if (this.Session && this.Session.TurbulenzNetworkSession) {
                Debug.Log("Session Exists");
                return
            }
            this.TurbulenzNetworkManager.queryFriendsSessions(this.QuerySuccessCallback, this.ErrorCallback)
        },
        getFriendSessionInfo: function getFriendSessionInfo() {
            if (this.Session && this.Session.TurbulenzNetworkSession) {
                Debug.Log("Session Exists");
                return
            }
            this.TurbulenzNetworkManager.queryFriendsSessions(this.QueryFriendSuccessCallback, this.ErrorCallback)
        },
        getSessionID: function getSessionIDFn() {
            if (!this.Session.TurbulenzNetworkSession) {
                Debug.Log("Session Doesn't Exist");
                return -1
            }
            return this.Session.TurbulenzNetworkSession.sessionId
        },
        getPlayerID: function getPlayerIDFn() {
            if (!this.Session.TurbulenzNetworkSession) {
                Debug.Log("Session Doesn't Exist");
                return -1
            }
            return this.Session.TurbulenzNetworkSession.playerId
        },
        getConnected: function getConnectedFn() {
            if (!this.Session.TurbulenzNetworkSession) {
                return
            }
            return this.Session.TurbulenzNetworkSession.connected()
        },
        makePublic: function makePublicFn() {
            if (!this.Session.TurbulenzNetworkSession) {
                Debug.Log("Session Doesn't Exist");
                return
            }
            return this.Session.TurbulenzNetworkSession.makePublic(this.PublicCallback())
        },
        Update: function UpdateFn(TimeDelta) {
            var i = 0;
            if (this.State === NetworkManager.StateCreated || this.State === NetworkManager.StateJoined) {
                if (this.Session.TurbulenzNetworkSession.connected()) {
                    for (i = 0; i < this.Session.MessageQueue.length; i += 1) {
                        var Data = this.Session.MessageQueue[i];
                        var Player = Data[0];
                        this.PlayerInfo[Player].x = Data[1];
                        this.PlayerInfo[Player].y = Data[2];
                        this.PlayerInfo[Player].direction = Data[3]
                    }
                    this.Session.MessageQueue = [];
                    for (i = 0; i < this.PlayerInfo.length; i += 1) {
                        this.PlayerInfo[i].Timeout += TimeDelta;
                        if (this.PlayerInfo[i].Timeout > 30) {
                            Debug.Log("Player " + this.PlayerInfo[i].ID + " is removed from game [30 sec kick]");
                            this.PlayerInfo.splice(i)
                        }
                    }
                    if (this.PlayerText) {
                        var i = 0,
                            TempPlayers = this.Session.TurbulenzNetworkSession.playerId + ", ";
                        for (i = 0; i < this.PlayerInfo.length; i += 1) {
                            TempPlayers += this.PlayerInfo[i].ID + ", "
                        }
                        this.PlayerText.SetText("Players: " + TempPlayers)
                    }
                    if (this.DebugText) {
                        this.DebugText.SetText((this.getConnected() ? "Connected, " : "") + "SessionID " + this.Session.TurbulenzNetworkSession.sessionId + " PlayerID " + this.Session.TurbulenzNetworkSession.playerId)
                    }
                }
            } else if (this.State === NetworkManager.StateInitiallyCreated) {
                this.State = NetworkManager.StateCreated
            } else if (this.State === NetworkManager.StateInitiallyJoined) {
                this.State = NetworkManager.StateJoined
            } else if (this.State === NetworkManager.StateCreating || this.State === NetworkManager.StateJoining) {
                if (this.DebugText) {
                    this.DebugText.SetText(this.State === NetworkManager.StateCreating ? "Creating Game" : "Joining Game")
                }
            } else if (this.State === NetworkManager.StateJoinFailed) {
                this.State = NetworkManager.StateOff;
                if (this.CreateOnFail) {
                    this.createSession();
                    this.CreateOnFail = false
                }
            } else if (this.State === NetworkManager.StateOff) {
                if (this.DebugText) {
                    this.DebugText.SetText("Disconnected")
                }
            } else {
                this.queue = this.TurbulenzNetworkManager.getJoinRequestQueue();
                this.pendingJoinRequest = this.queue.shift();
                this.queue.onEvent(this.JoinCallback);
                if (this.pendingJoinRequest) {
                    Debug.Log("PENDING REQUEST - JOIN SESSION");
                    this.joinSession(this.pendingJoinRequest)
                }
            }
        },
        StartDebugOutput: function StartDebugOutputFn(RootTree) {
            this.DebugText = Helpers.CreateBitmapText("Network Text", JamSystem.RenderManager.GetScreenWidth() / 2, JamSystem.RenderManager.GetScreenHeight() - 60, EA.Default, "Font", RootTree);
            this.PlayerText = Helpers.CreateBitmapText("Players:", JamSystem.RenderManager.GetScreenWidth() / 2, JamSystem.RenderManager.GetScreenHeight() - 20, EA.Default, "Font", RootTree)
        },
        Disconnect: function DisconnectFn() {
            if (this.Session) {
                this.Session.Destroy()
            }
            this.State = NetworkManager.StateOff
        },
        JoinCallback: function JoinCallbackFn(joinMultiplayerSessionId) {
            Debug.Log("EVENT CALLBACK - JOIN SESSION");
            this.queue.pause();
            this.joinSession(joinMultiplayerSessionId, this.MultiplayerSessionSuccess, this.ErrorCallback)
        },
        MultiplayerSessionSuccess: function MultiplayerSessionSuccessFn() {
            this.queue.clear();
            this.queue.resume()
        },
        ErrorCallback: function ErrorCallbackFn(errorMsg, httpStatus, calledByFn, calledByParams) {
            Debug.Log("***** NetworkManager Error : " + errorMsg);
            Debug.Log("httpStatus : " + httpStatus);
            Debug.Log("calledByFn : " + calledByFn);
            Debug.Log("calledByParams : " + calledByParams)
        },
        QueryFriendSuccessCallback: function QueryFriendSuccessCallbackFn(sessionList) {
            JamSystem.NetworkManager.FriendSessionList = sessionList
        },
        PublicCallback: function PublicCallbackFn() {},
        Destroy: function Destroy() {
            if (this.DebugText) {
                Helpers.DestroyBitmapText(this.DebugText)
            }
            if (this.PlayerText) {
                Helpers.DestroyBitmapText(this.PlayerText)
            }
            if (this.Session) {
                this.Session.Destroy()
            }
            this.TurbulenzNetworkManager.destroy();
            this.TurbulenzNetworkManager = null;
            this.State = NetworkManager.StateOff
        }
    };
    NetworkManager.Create = function Create(requestHandler, GameSession) {
        var NewObject = new NetworkManager;
        NewObject.TurbulenzNetworkManager = TurbulenzServices.createMultiplayerSessionManager(requestHandler, GameSession);
        NewObject.State = NetworkManager.StateOff;
        NewObject.FriendSessionList = null;
        NewObject.CreateOnFail = false;
        NewObject.queue = null;
        NewObject.DebugText = null;
        NewObject.PlayerText = null;
        NewObject.PlayerInfo = [];
        return NewObject
    };

    function Jake() {}
    Jake.prototype = {};
    Jake.Init = function InitFn(Gravity, Distribution) {
        var CharToImageTable = [];
        var i;
        for (i = 0; i < 91; i += 1) {
            CharToImageTable[32 + i] = i
        }
        JamSystem.AssetManager.LoadTexture("../Jake/assets/working/EditorSprites.json");
        JamSystem.AssetManager.CreateBitmapFont("EditorFont", "../Jake/assets/working/EditorFont.json", CharToImageTable, 1, 0, "#", 1);
        JamSystem.AssetManager.LoadTexture("../Jake/assets/working/DefaultGfx.json", !Distribution, !Distribution);
        Physics.Init(Gravity);
        WorldFileManager.Init();
        EntityTypeManager.Init()
    };

    function EntityTypeManager() {}
    EntityTypeManager.prototype = {};
    EntityTypeManager.Init = function EntityTypeManagerInitFn(ObjectPaletteFileName) {
        EntityTypeManager.PlayerEntityTypeID = -1;
        EntityTypeManager.TypesRegistered = [];
        EntityTypeManager.TypesUpdateAllReady = [];
        EntityTypeManager.Register(EntityNone);
        EntityTypeManager.Register(EntityStatic);
        EntityTypeManager.Register(EntityDynamic);
        EntityTypeManager.Register(EntityGroup);
        EntityTypeManager.Register(EntityJoint);
        EntityTypeManager.Register(EntityPin);
        EntityTypeManager.Register(EntityRod);
        EntityTypeManager.Register(EntitySpring);
        EntityTypeManager.Register(EntityWeld);
        EntityTypeManager.Register(EntityMarker);
        EntityTypeManager.Register(EntityAnimating)
    };
    EntityTypeManager.Register = function EntityTypeManagerRegisterFn(EntityClass, PlayerEntity) {
        EntityClass.TypeID = EntityTypeManager.TypesRegistered.length;
        EntityTypeManager.TypesRegistered[EntityTypeManager.TypesRegistered.length] = EntityClass;
        if (PlayerEntity === true) {
            EntityTypeManager.PlayerEntityTypeID = EntityClass.TypeID
        }
        if (EntityClass.UpdateAllReady) {
            EntityTypeManager.TypesUpdateAllReady[EntityTypeManager.TypesUpdateAllReady.length] = EntityClass
        }
    };
    EntityTypeManager.RegisterCollision = function EntityTypeManagerRegisterCollisionFn() {
        var i;
        for (i = 0; i < EntityTypeManager.TypesRegistered.length; i += 1) {
            if (EntityTypeManager.TypesRegistered[i].RegisterCollision) {
                EntityTypeManager.TypesRegistered[i].RegisterCollision()
            }
        }
    };
    EntityTypeManager.GetPlayerTypeID = function GetPlayerTypeID() {
        return EntityTypeManager.PlayerEntityTypeID
    };
    EntityTypeManager.GetClassFromName = function EntityTypeManagerGetIDFromNameFn(EntityTypeName) {
        var i;
        for (i = 0; i < EntityTypeManager.TypesRegistered.length; i += 1) {
            if (EntityTypeManager.TypesRegistered[i].Name === EntityTypeName) {
                return EntityTypeManager.TypesRegistered[i]
            }
        }
        return null
    };
    EntityTypeManager.GetNameFromID = function EntityTypeManagerGetNameFromIDFn(EntityTypeID) {
        if (EntityTypeID < EntityTypeManager.TypesRegistered.length) {
            return EntityTypeManager.TypesRegistered[EntityTypeID].Name
        }
        return null
    };
    EntityTypeManager.GetClassFromID = function EntityTypeManagerGetClassFromIDFn(EntityTypeID) {
        return EntityTypeManager.TypesRegistered[EntityTypeID]
    };
    EntityTypeManager.GetNumRegisteredTypes = function GetNumRegisteredTypesFn() {
        return EntityTypeManager.TypesRegistered.length
    };
    EntityTypeManager.GetIDFromName = function GetIDFromNameFn(TypeName) {
        var z = 0;
        for (z = 0; z < EntityTypeManager.TypesRegistered.length; z += 1) {
            if (EntityTypeManager.TypesRegistered[z].Name === TypeName) {
                return z
            }
        }
        return -1
    };
    EntityTypeManager.Update = function UpdateFn(TimeDelta) {
        var i;
        for (i = 0; i < EntityTypeManager.TypesUpdateAllReady.length; i += 1) {
            EntityTypeManager.TypesUpdateAllReady[i].UpdateAllReady(TimeDelta)
        }
    };

    function ObjectPalette() {}
    ObjectPalette.prototype = {};

    function ObjectCategory() {}
    ObjectCategory.prototype = {};

    function ObjectPaletteManager() {}
    ObjectPaletteManager.prototype = {};
    ObjectPaletteManager.Init = function ObjectPaletteManagerInitFn(ObjectPaletteFileName, AbsolutePath) {
        ObjectPaletteManager.ObjectPalette = [];
        ObjectPaletteManager.ObjectCategory = [];
        ObjectPaletteManager.ObjectPaletteFile = File.Load(ObjectPaletteFileName, ObjectPaletteManager.ParseObjectPaletteFile, null, AbsolutePath)
    };
    ObjectPaletteManager.GetPaletteIndexFromName = function GetPaletteIndexFromNameFn(ObjectPaletteName) {
        var i;
        for (i = 0; i < ObjectPaletteManager.ObjectPalette.length; i += 1) {
            if (ObjectPaletteName === ObjectPaletteManager.ObjectPalette[i].Name) {
                return i
            }
        }
        return -1
    };
    ObjectPaletteManager.GetPaletteEditableVariable = function GetPaletteEditableVariableFn(ObjectPaletteIndex, VariableIndex) {
        if (ObjectPaletteIndex !== -1) {
            var Variable = ObjectPaletteManager.ObjectPalette[ObjectPaletteIndex].Editables[VariableIndex];
            if (Variable) {
                return Variable.Value
            }
        }
        return undefined
    };
    ObjectPaletteManager.CheckNameExclusive = function CheckNameExclusiveFn(ObjectPaletteIndex) {
        if (ObjectPaletteIndex !== -1) {
            var i = 0;
            var OriginalName = ObjectPaletteManager.ObjectPalette[ObjectPaletteIndex].Name;
            var Increment = 0;
            for (i = 0; i < ObjectPaletteManager.ObjectPalette.length; i += 1) {
                if (ObjectPaletteManager.ObjectPalette[i].Name === ObjectPaletteManager.ObjectPalette[ObjectPaletteIndex].Name && i !== ObjectPaletteIndex) {
                    while (1) {
                        Increment += 1;
                        if (OriginalName + Increment !== ObjectPaletteManager.ObjectPalette[i].Name) {
                            break
                        }
                    }
                    ObjectPaletteManager.ObjectPalette[ObjectPaletteIndex].Name = OriginalName + Increment
                }
            }
        }
        return undefined
    };
    ObjectPaletteManager.AlterComboBoxesValue = function AlterComboBoxesValueFn(Inserted, Added) {
        var i, j;
        for (i = 0; i < ObjectPaletteManager.ObjectPalette.length; i += 1) {
            if (ObjectPaletteManager.ObjectPalette[i].Editables) {
                if (ObjectPaletteManager.ObjectPalette[i].Editables.length > 0) {
                    for (j = 0; j < ObjectPaletteManager.ObjectPalette[i].Editables.length; j += 1) {
                        if (ObjectPaletteManager.ObjectPalette[i].Editables[j]) {
                            var EntityTypeID = EntityTypeManager.GetIDFromName(ObjectPaletteManager.ObjectPalette[i].Type);
                            var EntityType = EntityTypeManager.TypesRegistered[EntityTypeID];
                            if (EntityType.EditableVariables[j].Type === "ObjectCombo") {
                                var Index = ObjectPaletteManager.ObjectPalette[i].Editables[j].Value;
                                if (Index >= Inserted) {
                                    ObjectPaletteManager.ObjectPalette[i].Editables[j].Value += Added ? 1 : -1
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    ObjectPaletteManager.SavePalette = function ObjectPaletteManagerSavePaletteFn(ObjectPaletteFileName) {
        var i, j, k;
        var myJSONTextWhiteSpace = "{\n    ";
        myJSONTextWhiteSpace += '"objects":\n';
        myJSONTextWhiteSpace += "    [\n";
        for (i = 0; i < ObjectPaletteManager.ObjectPalette.length; i += 1) {
            myJSONTextWhiteSpace += "        {";
            myJSONTextWhiteSpace += '"name":"' + ObjectPaletteManager.ObjectPalette[i].Name + '",';
            if (ObjectPaletteManager.ObjectPalette[i].Alias) {
                myJSONTextWhiteSpace += '"alias":"' + ObjectPaletteManager.ObjectPalette[i].Alias + '",'
            }
            myJSONTextWhiteSpace += '"image":"' + ObjectPaletteManager.ObjectPalette[i].Image + '",';
            if (ObjectPaletteManager.ObjectPalette[i].Image2) {
                myJSONTextWhiteSpace += '"image2":"' + ObjectPaletteManager.ObjectPalette[i].Image2 + '",'
            }
            myJSONTextWhiteSpace += '"type":"' + ObjectPaletteManager.ObjectPalette[i].Type + '"';
            if (ObjectPaletteManager.ObjectPalette[i].Editables) {
                if (ObjectPaletteManager.ObjectPalette[i].Editables.length > 0) {
                    myJSONTextWhiteSpace += ",";
                    myJSONTextWhiteSpace += '"defaults":[';
                    var FirstEditable = true;
                    for (j = 0; j < ObjectPaletteManager.ObjectPalette[i].Editables.length; j += 1) {
                        if (ObjectPaletteManager.ObjectPalette[i].Editables[j]) {
                            if (FirstEditable) {
                                FirstEditable = false
                            } else {
                                myJSONTextWhiteSpace += ","
                            }
                            myJSONTextWhiteSpace += '{"name":"' + ObjectPaletteManager.ObjectPalette[i].Editables[j].Name + '",';
                            var EntityTypeID = EntityTypeManager.GetIDFromName(ObjectPaletteManager.ObjectPalette[i].Type);
                            var EntityType = EntityTypeManager.TypesRegistered[EntityTypeID];
                            if (EntityType.EditableVariables[j].Type === "ObjectCombo") {
                                var Index = ObjectPaletteManager.ObjectPalette[i].Editables[j].Value;
                                if (Index === undefined) {
                                    Index = i
                                }
                                var StringValue = ObjectPaletteManager.ObjectPalette[Index].Name;
                                myJSONTextWhiteSpace += '"value":"' + StringValue + '"}'
                            } else {
                                myJSONTextWhiteSpace += '"value":' + ObjectPaletteManager.ObjectPalette[i].Editables[j].Value + "}"
                            }
                        }
                    }
                    myJSONTextWhiteSpace += "]"
                }
            }
            if (ObjectPaletteManager.ObjectPalette[i].Scale) {
                if (ObjectPaletteManager.ObjectPalette[i].Scale.x !== 1 || ObjectPaletteManager.ObjectPalette[i].Scale.y !== 1) {
                    myJSONTextWhiteSpace += ",";
                    myJSONTextWhiteSpace += '"scale":{';
                    myJSONTextWhiteSpace += '"x":' + ObjectPaletteManager.ObjectPalette[i].Scale.x + ",";
                    myJSONTextWhiteSpace += '"y":' + ObjectPaletteManager.ObjectPalette[i].Scale.y + "}"
                }
            }
            if (ObjectPaletteManager.ObjectPalette[i].Mass) {
                if (ObjectPaletteManager.ObjectPalette[i].Mass !== 1) {
                    myJSONTextWhiteSpace += ",";
                    myJSONTextWhiteSpace += '"mass":' + ObjectPaletteManager.ObjectPalette[i].Mass
                }
            }
            if (ObjectPaletteManager.ObjectPalette[i].Rotation) {
                if (ObjectPaletteManager.ObjectPalette[i].Rotation !== 0) {
                    myJSONTextWhiteSpace += ",";
                    myJSONTextWhiteSpace += '"rotation":' + ObjectPaletteManager.ObjectPalette[i].Rotation
                }
            }
            if (ObjectPaletteManager.ObjectPalette[i].Colour) {
                if (ObjectPaletteManager.ObjectPalette[i].Colour) {
                    if (ObjectPaletteManager.ObjectPalette[i].Colour[0] + ObjectPaletteManager.ObjectPalette[i].Colour[1] + ObjectPaletteManager.ObjectPalette[i].Colour[2] + ObjectPaletteManager.ObjectPalette[i].Colour[3] !== 4) {
                        myJSONTextWhiteSpace += ",";
                        myJSONTextWhiteSpace += '"colour":[' + ObjectPaletteManager.ObjectPalette[i].Colour + "]"
                    }
                }
            }
            var Collision = ObjectPaletteManager.ObjectPalette[i].Collision;
            if (Collision.Loaded) {
                myJSONTextWhiteSpace += ",";
                myJSONTextWhiteSpace += '"collision":{';
                myJSONTextWhiteSpace += '"circle":' + Collision.Circle + ",";
                myJSONTextWhiteSpace += '"circleRadius":' + Collision.CircleRadius + ",";
                myJSONTextWhiteSpace += '"density":' + Collision.Density + ",";
                myJSONTextWhiteSpace += '"friction":' + Collision.Friction + ",";
                myJSONTextWhiteSpace += '"restitution":' + Collision.Restitution + ",";
                myJSONTextWhiteSpace += '"collisionPoints":[';
                var CollisionPoints = Collision.CollisionPoints;
                if (CollisionPoints) {
                    for (j = 0; j < CollisionPoints.length; j += 1) {
                        myJSONTextWhiteSpace += '{"x":' + CollisionPoints[j].x + ",";
                        myJSONTextWhiteSpace += '"y":' + CollisionPoints[j].y + "}";
                        if (j !== CollisionPoints.length - 1) {
                            myJSONTextWhiteSpace += ", "
                        } else {
                            myJSONTextWhiteSpace += "]}"
                        }
                    }
                } else {
                    myJSONTextWhiteSpace += "]}"
                }
            }
            if (i !== ObjectPaletteManager.ObjectPalette.length - 1) {
                myJSONTextWhiteSpace += "},\n"
            } else {
                myJSONTextWhiteSpace += "}\n"
            }
        }
        myJSONTextWhiteSpace += "    ],\n\n";
        myJSONTextWhiteSpace += '    "categories":\n';
        myJSONTextWhiteSpace += "    [\n";
        for (i = 0; i < ObjectPaletteManager.ObjectCategory.length; i += 1) {
            myJSONTextWhiteSpace += "        {";
            myJSONTextWhiteSpace += '\n            "name":"' + ObjectPaletteManager.ObjectCategory[i].Name + '"';
            if (ObjectPaletteManager.ObjectCategory[i].Items.length > 0) {
                myJSONTextWhiteSpace += ',\n            "items":\n            [\n';
                for (j = 0; j < ObjectPaletteManager.ObjectCategory[i].Items.length; j += 1) {
                    myJSONTextWhiteSpace += '                "' + ObjectPaletteManager.ObjectCategory[i].Items[j] + '"';
                    if (j !== ObjectPaletteManager.ObjectCategory[i].Items.length - 1) {
                        myJSONTextWhiteSpace += ","
                    }
                    myJSONTextWhiteSpace += "\n"
                }
                myJSONTextWhiteSpace += "            ]\n"
            }
            if (i !== ObjectPaletteManager.ObjectCategory.length - 1) {
                myJSONTextWhiteSpace += "        },\n"
            } else {
                myJSONTextWhiteSpace += "        }\n"
            }
        }
        myJSONTextWhiteSpace += "    ]\n}\n";
        ObjectPaletteManager.ObjectPaletteFile = File.Save(ObjectPaletteFileName, myJSONTextWhiteSpace, true)
    };
    ObjectPaletteManager.GetIsReady = function ObjectPaletteManagerGetIsReadyFn() {
        if (!ObjectPaletteManager.ObjectPaletteFile.bFinished) {
            return false
        }
        return true
    };
    ObjectPaletteManager.ParseObjectPaletteFile = function ObjectPaletteManagerParseObjectPaletteFileFn(psData, iDataSize, psUserData) {
        var i, j, k;
        if (psData === null) {
            return
        }
        var JSONObject = JSON.parse(psData);
        if (JSONObject.categories) {
            for (i = 0; i < JSONObject.categories.length; i += 1) {
                var Category = JSONObject.categories[i];
                ObjectPaletteManager.ObjectCategory[i] = new ObjectCategory;
                ObjectPaletteManager.ObjectCategory[i].Name = Category.name;
                ObjectPaletteManager.ObjectCategory[i].Items = [];
                if (Category.items) {
                    for (j = 0; j < Category.items.length; j += 1) {
                        ObjectPaletteManager.ObjectCategory[i].Items[j] = Category.items[j]
                    }
                }
            }
        }
        if (JSONObject.objects) {
            for (i = 0; i < JSONObject.objects.length; i += 1) {
                var Object = JSONObject.objects[i];
                ObjectPaletteManager.ObjectPalette[i] = new ObjectPalette;
                ObjectPaletteManager.ObjectPalette[i].Name = Object.name;
                ObjectPaletteManager.ObjectPalette[i].Alias = null;
                if (Object.alias) {
                    ObjectPaletteManager.ObjectPalette[i].Alias = Object.alias
                }
                ObjectPaletteManager.ObjectPalette[i].Image = Object.image;
                if (Object.image2) {
                    ObjectPaletteManager.ObjectPalette[i].Image2 = Object.image2
                }
                ObjectPaletteManager.ObjectPalette[i].Type = Object.type;
                ObjectPaletteManager.ObjectPalette[i].Unknown = false;
                ObjectPaletteManager.ObjectPalette[i].Editables = [];
                ObjectPaletteManager.ObjectPalette[i].Scale = new Vector2(1, 1);
                ObjectPaletteManager.ObjectPalette[i].Mass = 1;
                ObjectPaletteManager.ObjectPalette[i].Rotation = 0;
                ObjectPaletteManager.ObjectPalette[i].Colour = [1, 1, 1, 1];
                var Texture = JamSystem.AssetManager.GetTextureInfoFromImageName(Object.image);
                if (Texture === null) {
                    ObjectPaletteManager.ObjectPalette[i].Image = "InvalidImage"
                }
                if (Object.scale) {
                    ObjectPaletteManager.ObjectPalette[i].Scale.x = Object.scale.x;
                    ObjectPaletteManager.ObjectPalette[i].Scale.y = Object.scale.y
                }
                if (Object.rotation) {
                    ObjectPaletteManager.ObjectPalette[i].Rotation = Object.rotation
                }
                if (Object.mass) {
                    ObjectPaletteManager.ObjectPalette[i].Mass = Object.mass
                }
                if (Object.colour) {
                    ObjectPaletteManager.ObjectPalette[i].Colour = Object.colour
                }
                var OldCollision = Object.collision;
                var ObjectCollision = new EntityCollisionData;
                if (OldCollision) {
                    ObjectCollision.Loaded = true;
                    ObjectCollision.Circle = OldCollision.circle;
                    ObjectCollision.CircleRadius = OldCollision.circleRadius;
                    ObjectCollision.Density = OldCollision.density;
                    ObjectCollision.Friction = OldCollision.friction;
                    ObjectCollision.Restitution = OldCollision.restitution;
                    ObjectCollision.CollisionPoints = [];
                    var CollisionPoints = OldCollision.collisionPoints;
                    if (CollisionPoints) {
                        for (j = 0; j < CollisionPoints.length; j += 1) {
                            var x = CollisionPoints[j].x;
                            var y = CollisionPoints[j].y;
                            ObjectCollision.CollisionPoints[j] = new Vector2(x, y)
                        }
                    }
                } else {
                    ObjectCollision.Loaded = false;
                    var TextureInfo = Helpers.GetTextureInfoFromImageName(ObjectPaletteManager.ObjectPalette[i].Image);
                    var Frame = TextureInfo.Texture.GetFrame(TextureInfo.Frame);
                    var HalfWidth = Frame.Width / 2;
                    var HalfHeight = Frame.Height / 2;
                    ObjectCollision.Circle = false;
                    if (HalfWidth > HalfHeight) {
                        ObjectCollision.CircleRadius = HalfWidth
                    } else {
                        ObjectCollision.CircleRadius = HalfHeight
                    }
                    ObjectCollision.Density = 1;
                    ObjectCollision.Friction = .5;
                    ObjectCollision.Restitution = .2;
                    ObjectCollision.CollisionPoints = [];
                    ObjectCollision.CollisionPoints[0] = new Vector2(-HalfWidth, -HalfHeight);
                    ObjectCollision.CollisionPoints[1] = new Vector2(HalfWidth, -HalfHeight);
                    ObjectCollision.CollisionPoints[2] = new Vector2(HalfWidth, HalfHeight);
                    ObjectCollision.CollisionPoints[3] = new Vector2(-HalfWidth, HalfHeight)
                }
                ObjectPaletteManager.ObjectPalette[i].Collision = ObjectCollision;
                ObjectPaletteManager.ObjectPalette[i].ObjectType = EntityTypeManager.GetClassFromName(Object.type);
                if (ObjectPaletteManager.ObjectPalette[i].ObjectType === null) {
                    ObjectPaletteManager.ObjectPalette[i].Image = "InvalidEntity";
                    ObjectPaletteManager.ObjectPalette[i].Unknown = true
                }
            }
            for (i = 0; i < JSONObject.objects.length; i += 1) {
                var Object = JSONObject.objects[i];
                if (Object.defaults) {
                    var EntityTypeID = EntityTypeManager.GetIDFromName(Object.type);
                    var EntityType = EntityTypeManager.TypesRegistered[EntityTypeID];
                    if (EntityType === undefined) {
                        Debug.Log("UNKNOWN ENTITY TYPE " + Object.type);
                        continue
                    }
                    if (EntityType.EditableVariables) {
                        for (k = 0; k < EntityType.EditableVariables.length; k += 1) {
                            if (!EntityType.EditableVariables[k].Hidden) {
                                var Found = false;
                                for (j = 0; j < Object.defaults.length; j += 1) {
                                    if (EntityType.EditableVariables[k].Name === Object.defaults[j].name) {
                                        ObjectPaletteManager.ObjectPalette[i].Editables[k] = {
                                            Name: Object.defaults[j].name,
                                            Value: Object.defaults[j].value
                                        };
                                        if (EntityType.EditableVariables[k].Type === "ObjectCombo") {
                                            var Name = ObjectPaletteManager.ObjectPalette[i].Editables[k].Value,
                                                z = 0;
                                            for (z = 0; z < ObjectPaletteManager.ObjectPalette.length; z += 1) {
                                                if (ObjectPaletteManager.ObjectPalette[z].Name === Name) {
                                                    ObjectPaletteManager.ObjectPalette[i].Editables[k].Value = z
                                                }
                                            }
                                        }
                                        Found = true
                                    }
                                }
                                if (!Found) {
                                    ObjectPaletteManager.ObjectPalette[i].Editables[k] = {
                                        Name: EntityType.EditableVariables[k].Name,
                                        Value: EntityType.EditableVariables[k].Default
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    };

    function BrushPalette() {}
    BrushPalette.prototype = {};

    function EntityInfo() {}
    EntityInfo.prototype = {};

    function BrushPaletteManager() {}
    BrushPaletteManager.prototype = {};
    BrushPaletteManager.Init = function BrushPaletteManagerInitFn(BrushPaletteFileName, AbsolutePath) {
        BrushPaletteManager.EntityInfo = [];
        BrushPaletteManager.BrushPalette = [];
        BrushPaletteManager.BrushPaletteFile = File.Load(BrushPaletteFileName, BrushPaletteManager.ParseBrushPalette, null, AbsolutePath)
    };
    BrushPaletteManager.GetIsReady = function BrushPaletteManagerGetIsReadyFn() {
        if (BrushPaletteManager.BrushPaletteFile && !BrushPaletteManager.BrushPaletteFile.bFinished) {
            return false
        }
        BrushPaletteManager.BrushPaletteFile = null;
        return true
    };
    BrushPaletteManager.CreateEntity = function CreateEntityFn(X, Y, Rotation, ScaleX, ScaleY, Name, ObjectPaletteIndex, JSONObject) {
        var Image;
        var Collision;
        var ObjectType;
        if (ObjectPaletteIndex === -1) {
            Image = "InvalidObject";
            Collision = {};
            ObjectType = EntityTypeManager.GetClassFromName("None")
        } else {
            var ObjectPalette = ObjectPaletteManager.ObjectPalette[ObjectPaletteIndex];
            if (!ObjectPalette.Unknown) {
                Image = ObjectPalette.Image;
                Collision = ObjectPalette.Collision;
                ObjectType = ObjectPalette.ObjectType
            } else {
                Image = "InvalidEntity";
                Collision = {};
                ObjectType = EntityTypeManager.GetClassFromName("None")
            }
        }
        var NewEntity = ObjectType.Create(X, Y, Rotation, ScaleX, ScaleY, Name, Image, Collision);
        NewEntity.ObjectPaletteIndex = ObjectPaletteIndex;
        return NewEntity
    };
    BrushPaletteManager.Save = function BrushPaletteManagerSaveFn(BrushObjects, FileName) {
        var i, j, k;
        var myJSONTextWhiteSpace = "{\n    ";
        myJSONTextWhiteSpace += '"brushes":\n    [\n';
        for (i = 0; i < BrushObjects.length; i += 1) {
            myJSONTextWhiteSpace += "       {";
            myJSONTextWhiteSpace += '"entities":\n       [\n';
            var Entities = BrushObjects[i].Entities;
            Entities.sort(BrushPaletteManager.ActiveSort);
            for (j = 0; j < Entities.length; j += 1) {
                var Entity = Entities[j];
                var Index = Entity.ObjectPaletteIndex;
                myJSONTextWhiteSpace += "           {";
                var Name = null;
                if (ObjectPaletteManager.ObjectPalette[Index]) {
                    Name = ObjectPaletteManager.ObjectPalette[Index].Name
                }
                myJSONTextWhiteSpace += '"type":"' + Name + '",';
                myJSONTextWhiteSpace += '"x":' + Entity.StartX.toFixed(3) + ",";
                myJSONTextWhiteSpace += '"y":' + Entity.StartY.toFixed(3) + ",";
                myJSONTextWhiteSpace += '"r":' + Entity.StartRotation.toFixed(3) + ",";
                myJSONTextWhiteSpace += '"sx":' + Entity.StartScaleX.toFixed(3) + ",";
                myJSONTextWhiteSpace += '"sy":' + Entity.StartScaleY.toFixed(3);
                if (Entity.Name) {
                    myJSONTextWhiteSpace += ',"Name":"' + Entity.Name + '"'
                }
                var EntityType = EntityTypeManager.TypesRegistered[Entity.TypeID];
                if (EntityType.EditableVariables) {
                    for (k = 0; k < EntityType.EditableVariables.length; k += 1) {
                        var Variable = Entity.EditableVariables[k];
                        if (!EntityType.EditableVariables[k].Shared) {
                            if (EntityType.EditableVariables[k].Type === "Combo") {
                                myJSONTextWhiteSpace += ',"' + EntityType.EditableVariables[k].Name + '":"' + EntityType.EditableVariables[k].Combo[Variable] + '"'
                            } else {
                                if (Variable !== undefined && Variable !== "undefined") {
                                    if (typeof Variable === "string") {
                                        myJSONTextWhiteSpace += ',"' + EntityType.EditableVariables[k].Name + '":"' + Variable + '"'
                                    } else {
                                        myJSONTextWhiteSpace += ',"' + EntityType.EditableVariables[k].Name + '":' + Variable
                                    }
                                }
                            }
                        }
                    }
                }
                if (Entity.Children && Entity.Children.length) {
                    myJSONTextWhiteSpace += ',"children":[';
                    for (k = 0; k < Entity.Children.length; k += 1) {
                        if (k !== Entity.Children.length - 1) {
                            myJSONTextWhiteSpace += '"' + Entity.Children[k].Name + '",'
                        } else {
                            myJSONTextWhiteSpace += '"' + Entity.Children[k].Name + '"'
                        }
                    }
                    myJSONTextWhiteSpace += "]"
                }
                myJSONTextWhiteSpace += "}";
                if (j !== Entities.length - 1) {
                    myJSONTextWhiteSpace += ",\n"
                }
            }
            myJSONTextWhiteSpace += "\n";
            if (i === BrushObjects.length - 1) {
                myJSONTextWhiteSpace += "       ]}\n"
            } else {
                myJSONTextWhiteSpace += "       ]},\n"
            }
        }
        myJSONTextWhiteSpace += "    ]\n}\n";
        BrushPaletteManager.BrushPaletteFile = File.Save(FileName, myJSONTextWhiteSpace, true)
    };
    BrushPaletteManager.ParseBrushPalette = function BrushPaletteManagerParseBrushPaletteFn(psData, iDataSize, psUserData) {
        var i, j, k, l;
        if (psData === null) {
            return
        }
        var JSONObject = JSON.parse(psData);
        for (i = 0; i < JSONObject.brushes.length; i += 1) {
            var JSONBrush = JSONObject.brushes[i];
            BrushPaletteManager.EntityInfo[i] = new EntityInfo;
            BrushPaletteManager.EntityInfo[i].Entities = [];
            for (j = 0; j < JSONBrush.entities.length; j += 1) {
                var JSONEntity = JSONBrush.entities[j];
                BrushPaletteManager.EntityInfo[i].Entities[j] = new EntityInfo;
                var ObjectPaletteName = JSONEntity.type;
                var ObjectPaletteIndex = -1;
                for (ObjectPaletteIndex = 0; ObjectPaletteIndex < ObjectPaletteManager.ObjectPalette.length; ObjectPaletteIndex += 1) {
                    if (ObjectPaletteManager.ObjectPalette[ObjectPaletteIndex].Name === ObjectPaletteName) {
                        break
                    }
                }
                if (ObjectPaletteIndex === ObjectPaletteManager.ObjectPalette.length) {
                    ObjectPaletteIndex = -1
                }
                BrushPaletteManager.EntityInfo[i].Entities[j].ObjectPaletteIndex = ObjectPaletteIndex;
                BrushPaletteManager.EntityInfo[i].Entities[j].X = JSONEntity.x;
                BrushPaletteManager.EntityInfo[i].Entities[j].Y = JSONEntity.y;
                BrushPaletteManager.EntityInfo[i].Entities[j].Rotation = JSONEntity.r;
                BrushPaletteManager.EntityInfo[i].Entities[j].ScaleX = JSONEntity.sx;
                BrushPaletteManager.EntityInfo[i].Entities[j].ScaleY = JSONEntity.sy;
                BrushPaletteManager.EntityInfo[i].Entities[j].Name = null;
                if (JSONEntity.Name) {
                    BrushPaletteManager.EntityInfo[i].Entities[j].Name = JSONEntity.Name
                }
                BrushPaletteManager.EntityInfo[i].Entities[j].JSONEntityData = JSONEntity
            }
        }
    };
    BrushPaletteManager.GenerateAllBrushes = function GenerateAllBrushesFn() {
        var i = 0;
        for (i = 0; i < BrushPaletteManager.EntityInfo.length; i += 1) {
            BrushPaletteManager.BrushPalette[i] = new BrushPalette;
            BrushPaletteManager.BrushPalette[i].Entities = [];
            for (j = 0; j < BrushPaletteManager.EntityInfo[i].Entities.length; j += 1) {
                var NewEntity = BrushPaletteManager.CreateEntity(BrushPaletteManager.EntityInfo[i].Entities[j].X, BrushPaletteManager.EntityInfo[i].Entities[j].Y, BrushPaletteManager.EntityInfo[i].Entities[j].Rotation, BrushPaletteManager.EntityInfo[i].Entities[j].ScaleX, BrushPaletteManager.EntityInfo[i].Entities[j].ScaleY, BrushPaletteManager.EntityInfo[i].Entities[j].Name, BrushPaletteManager.EntityInfo[i].Entities[j].ObjectPaletteIndex, BrushPaletteManager.EntityInfo[i].Entities[j].JSONEntityData);
                if (NewEntity) {
                    var EntityType = EntityTypeManager.TypesRegistered[NewEntity.TypeID];
                    if (EntityType.EditableVariables) {
                        for (k = 0; k < EntityType.EditableVariables.length; k += 1) {
                            var Variable = BrushPaletteManager.EntityInfo[i].Entities[j].JSONEntityData[EntityType.EditableVariables[k].Name];
                            if (Variable) {
                                if (EntityType.EditableVariables[k].Type === "Combo") {
                                    var Combo = EntityType.EditableVariables[k].Combo;
                                    for (l = 0; l < Combo.length; l += 1) {
                                        if (Combo[l] === Variable) {
                                            NewEntity.SetEditableVariable(k, l);
                                            break
                                        }
                                    }
                                } else {
                                    NewEntity.SetEditableVariable(k, Variable)
                                }
                            }
                        }
                    }
                    if (BrushPaletteManager.EntityInfo[i].Entities[j].JSONEntityData.children) {
                        NewEntity.Children = BrushPaletteManager.EntityInfo[i].Entities[j].JSONEntityData.children
                    }
                    if (NewEntity.Box2DBody) {
                        Physics.SetBodyActive(NewEntity.Box2DBody, false)
                    }
                    BrushPaletteManager.BrushPalette[i].Entities[j] = NewEntity
                }
            }
        }
        for (i = 0; i < BrushPaletteManager.BrushPalette.length; i += 1) {
            for (j = 0; j < BrushPaletteManager.BrushPalette[i].Entities.length; j += 1) {
                var thisEntity = BrushPaletteManager.BrushPalette[i].Entities[j];
                var ChildrenNames = thisEntity.Children;
                if (ChildrenNames) {
                    thisEntity.Children = null;
                    for (k = 0; k < ChildrenNames.length; k += 1) {
                        for (l = 0; l < BrushPaletteManager.BrushPalette[i].Entities.length; l += 1) {
                            var PossibleChild = BrushPaletteManager.BrushPalette[i].Entities[l];
                            if (PossibleChild.Name === ChildrenNames[k]) {
                                thisEntity.AddChild(PossibleChild)
                            }
                        }
                    }
                }
            }
        }
        BrushPaletteManager.EntityInfo = 0
    };
    BrushPaletteManager.ActiveSort = function ActiveSortFn(EntityA, EntityB) {
        return EntityA.Depth - EntityB.Depth
    };

    function SettingsFileManager() {}
    SettingsFileManager.prototype = {};
    SettingsFileManager.Init = function SettingsFileManagerInitFn() {
        SettingsFileManager.ActiveFile = null;
        SettingsFileManager.FileToLoad = null
    };
    SettingsFileManager.GetIsReady = function SettingsFileManagerGetIsReadyFn() {
        if (SettingsFileManager.ActiveFile && !SettingsFileManager.ActiveFile.bFinished) {
            return false
        }
        return true
    };
    SettingsFileManager.HasLoadingFailed = function HasLoadingFailedFn() {
        if (SettingsFileManager.ActiveFile && !SettingsFileManager.ActiveFile.bSuccess) {
            return true
        }
        return false
    };
    SettingsFileManager.Load = function SettingsFileManagerLoadFn(FileName, AbsolutePath) {
        SettingsFileManager.ActiveFile = File.Load(FileName, SettingsFileManager.ParseWorldFile, null, AbsolutePath)
    };
    SettingsFileManager.Save = function SettingsFileManagerSaveFn(FileToSave, FileName) {
        var i, j, k;
        var myJSONTextWhiteSpace = "{\n";
        myJSONTextWhiteSpace += '    "level":"' + FileToSave + '",\n';
        if (!SettingsFileManager.ObjectPaletteFile) {
            SettingsFileManager.ObjectPaletteFile = "assets/Levels/ObjectPalette.json"
        }
        if (!SettingsFileManager.BrushPaletteFile) {
            SettingsFileManager.BrushPaletteFile = "assets/Levels/BrushPalette.json"
        }
        myJSONTextWhiteSpace += '    "palette":"' + SettingsFileManager.ObjectPaletteFile + '",\n';
        myJSONTextWhiteSpace += '    "brushes":"' + SettingsFileManager.BrushPaletteFile + '"\n';
        myJSONTextWhiteSpace += "};\n";
        SettingsFileManager.ActiveFile = File.Save(FileName, myJSONTextWhiteSpace, true)
    };
    SettingsFileManager.ParseWorldFile = function SettingsFileManagerParseWorldFileFn(psData, iDataSize, EditorFile) {
        var i, j, k, l;
        if (psData === null) {
            return
        }
        var JSONObject = JSON.parse(psData);
        SettingsFileManager.FileToLoad = JSONObject.level ? JSONObject.level : Application.LevelFile;
        SettingsFileManager.ObjectPaletteFile = JSONObject.palette ? JSONObject.palette : Application.ObjectPaletteFile;
        SettingsFileManager.BrushPaletteFile = JSONObject.brushes ? JSONObject.brushes : Application.ObjectPaletteFile
    };

    function World() {}
    World.prototype = {
        AddLayer: function AddLayerFn(MovementScale, BucketWidth, BucketHeight, StaticLayer, Name) {
            var Width = this.DimensionWidth * MovementScale.x;
            var Height = this.DimensionHeight * MovementScale.y;
            if (Name === undefined) {
                Name = "Layer " + (this.Layers.length + 1)
            }
            this.Layers[this.Layers.length] = Layer.Create(this, this.RootTreeScale, Width, Height, MovementScale, BucketWidth, BucketHeight, StaticLayer, Name, this.Layers.length)
        },
        CopyLayer: function CopyLayerFn(TheLayer, ToSlot) {
            this.Layers.splice(ToSlot, 0, this.Layers[TheLayer])
        },
        GetLayer: function GetLayerFn(Layer) {
            return this.Layers[Layer]
        },
        GetLayerByName: function GetLayerByNameFn(Name) {
            var i;
            for (i = 0; i < this.Layers.length; i += 1) {
                if (this.Layers[i].Name === Name) {
                    return this.Layers[i]
                }
            }
            return null
        },
        RemoveLayer: function RemoveLayerFn(Layer) {
            this.Layers.splice(Layer, 1)
        },
        ShowLayer: function ShowLayerFn(Layer, Show) {
            this.Layers[Layer].IsVisible = Show
        },
        IsLayerActive: function IsLayerActiveFn(Layer) {
            return this.Layers[Layer].IsVisible
        },
        Optimise: function OptimiseFn() {
            var i;
            for (i = 0; i < this.Layers.length; i += 1) {
                this.Layers[i].Optimise()
            }
        },
        AutoSortActive: function AutoSortActiveFn() {
            var i;
            for (i = 0; i < this.Layers.length; i += 1) {
                this.Layers[i].AutoSortActive()
            }
        },
        SetDimensions: function SetDimensionsFn(Width, Height) {
            this.DimensionWidth = Width;
            this.DimensionHeight = Height
        },
        GetWidth: function GetWidthFn() {
            return this.DimensionWidth
        },
        GetHeight: function GetHeightFn() {
            return this.DimensionHeight
        },
        SetViewPosition: function SetViewPositionFn(x, y) {
            var i;
            for (i = 0; i < this.Layers.length; i += 1) {
                this.Layers[i].SetViewPosition(x, y)
            }
        },
        SetViewScale: function SetViewScaleFn(Scale) {
            this.RootTreeScale.SetScale(Scale, Scale)
        },
        SetViewRotation: function SetViewRotationFn(Rotation) {
            this.RootTreeRotate.SetRotation(Rotation)
        },
        FinaliseView: function FinaliseViewFn() {
            var i;
            for (i = 0; i < this.Layers.length; i += 1) {
                this.Layers[i].FinaliseView()
            }
        },
        ShowEditMode: function ShowEditModeFn(EditActive) {
            var i;
            for (i = 0; i < this.Layers.length; i += 1) {
                this.Layers[i].ShowEditMode(EditActive)
            }
        },
        ClearLayer: function ClearLayerFn(Layer) {
            this.Layers[Layer].Clear()
        },
        GetLayerAmount: function GetLayerAmountFn() {
            return this.Layers.length
        },
        GetEntityAt: function GetEntityAtFn(Layer, x, y, ReturnAll) {
            if (!ReturnAll) {
                ReturnAll = false
            }
            var PickedEntities = this.Layers[Layer].GetEntityAt(x, y, ReturnAll);
            if (PickedEntities) {
                if (ReturnAll) {
                    return PickedEntities
                }
                if (!ReturnAll && PickedEntities[0]) {
                    return PickedEntities[0]
                }
            }
            return null
        },
        UpdateEntityCollision: function UpdateEntityCollisionFn(ObjectPaletteIndex, CollisionData) {
            var i;
            for (i = 0; i < this.Layers.length; i += 1) {
                this.Layers[i].UpdateEntityCollision(ObjectPaletteIndex, CollisionData)
            }
        },
        GetAllEntitiesOfType: function GetAllEntitiesOfTypeFn(EntityTypeID, AllowDisabled) {
            var EntityList = [];
            if (!AllowDisabled) {
                AllowDisabled = false
            }
            var i;
            for (i = 0; i < this.Layers.length; i += 1) {
                this.Layers[i].GetAllEntitiesOfType(EntityTypeID, EntityList, AllowDisabled)
            }
            return EntityList
        },
        GetAllEntitiesOfObjectIndex: function GetAllEntitiesOfObjectIndexFn(ObjectPaletteIndex, AllowDisabled) {
            var EntityList = [];
            if (!AllowDisabled) {
                AllowDisabled = false
            }
            var i;
            for (i = 0; i < this.Layers.length; i += 1) {
                this.Layers[i].GetAllEntitiesOfObjectIndex(ObjectPaletteIndex, EntityList, AllowDisabled)
            }
            return EntityList
        },
        FindEntityByName: function FindEntityByNameFn(Name) {
            var EntityList = [];
            var i;
            for (i = 0; i < this.Layers.length; i += 1) {
                this.Layers[i].FindEntityByName(Name, EntityList)
            }
            return EntityList
        },
        FindEntityParents: function FindEntityParentsFn(ThisEntity) {
            var ParentList = [];
            var i;
            for (i = 0; i < this.Layers.length; i += 1) {
                this.Layers[i].FindEntityParents(ThisEntity, ParentList)
            }
            return ParentList
        },
        FindSingleEntityByName: function FindSingleEntityByNameFn(Name) {
            var EntityList = this.FindEntityByName(Name);
            if (EntityList.length === 0) {
                Debug.Log("************** Couldn't find entity called " + Name);
                return null
            }
            if (EntityList.length !== 1) {
                Debug.Log("************** More than 1 entity called " + Name + " Found")
            }
            return EntityList[0]
        },
        GetLayerEntityBelongsTo: function GetLayerEntityBelongsToFn(Entity) {
            var i;
            for (i = 0; i < this.Layers.length; i += 1) {
                for (var j = 0; j < this.Layers[i].Buckets.length; j += 1) {
                    for (var k = 0; k < this.Layers[i].Buckets[j].Entities.length; k += 1) {
                        if (Entity === this.Layers[i].Buckets[j].Entities[k]) {
                            return i
                        }
                    }
                }
            }
        },
        AlterPaletteIndices: function AlterPaletteIndicesFn(FromIndex, Addition) {
            var i;
            for (i = 0; i < this.Layers.length; i += 1) {
                for (var j = 0; j < this.Layers[i].Buckets.length; j += 1) {
                    for (var k = 0; k < this.Layers[i].Buckets[j].Entities.length; k += 1) {
                        if (this.Layers[i].Buckets[j].Entities[k].ObjectPaletteIndex >= FromIndex) {
                            this.Layers[i].Buckets[j].Entities[k].ObjectPaletteIndex += Addition
                        }
                    }
                }
            }
        },
        SwapPaletteIndex: function SwapPaletteIndexFn(OldIndex, NewIndex) {
            var i;
            for (i = 0; i < this.Layers.length; i += 1) {
                for (var j = 0; j < this.Layers[i].Buckets.length; j += 1) {
                    for (var k = 0; k < this.Layers[i].Buckets[j].Entities.length; k += 1) {
                        if (this.Layers[i].Buckets[j].Entities[k].ObjectPaletteIndex === OldIndex) {
                            this.Layers[i].Buckets[j].Entities[k].ObjectPaletteIndex = NewIndex
                        } else if (this.Layers[i].Buckets[j].Entities[k].ObjectPaletteIndex === NewIndex) {
                            this.Layers[i].Buckets[j].Entities[k].ObjectPaletteIndex = OldIndex
                        }
                    }
                }
            }
        },
        GetDisabledEntityLayer: function GetDisabledEntityLayerFn(ThisEntity) {
            var i;
            for (i = 0; i < this.Layers.length; i += 1) {
                if (this.Layers[i].GetIsEntityDisabled(ThisEntity)) {
                    return this.Layers[i]
                }
            }
            return null
        },
        GetPlayLayer: function GetPlayLayerFn() {
            return this.PlayLayer
        },
        CheckNameUniqueness: function CheckNameUniquenessFn(ThisEntity) {
            if (ThisEntity.Name === null || ThisEntity.Name === false) {
                return
            }
            var OriginalName = ThisEntity.Name;
            var Addition = parseFloat(0);
            var i = 0,
                j = 0,
                k = 0;
            for (i = 0; i < this.Layers.length; i += 1) {
                var ThisLayer = this.Layers[i];
                for (j = 0; j < ThisLayer.Buckets.length; j += 1) {
                    var ThisBucket = ThisLayer.Buckets[j];
                    for (k = 0; k < ThisBucket.Entities.length; k += 1) {
                        var TestEntity = ThisBucket.Entities[k];
                        if (TestEntity !== ThisEntity && TestEntity.Name === ThisEntity.Name) {
                            if (ThisEntity.Name !== OriginalName) {
                                ThisEntity.Name = OriginalName
                            }
                            while (1) {
                                Addition += parseFloat(1);
                                if (ThisEntity.Name + Addition !== TestEntity.Name) {
                                    break
                                }
                            }
                            ThisEntity.Name += Addition
                        }
                    }
                }
            }
        },
        NameEntityUniquely: function NameEntityUniquelyFn(ThisEntity) {
            var BaseName = "Object";
            var AlreadyUnique = true;
            if (ThisEntity.Name === null || ThisEntity.Name === false) {
                AlreadyUnique = false
            }
            var BiggestNumber = 0;
            var i;
            for (i = 0; i < this.Layers.length; i += 1) {
                var ThisLayer = this.Layers[i];
                var j;
                for (j = 0; j < ThisLayer.Buckets.length; j += 1) {
                    var ThisBucket = ThisLayer.Buckets[j];
                    var k;
                    for (k = 0; k < ThisBucket.Entities.length; k += 1) {
                        var TestEntity = ThisBucket.Entities[k];
                        if (TestEntity !== ThisEntity && TestEntity.Name && TestEntity.Name.substring(0, 6) === BaseName) {
                            if (AlreadyUnique && TestEntity.Name === ThisEntity.Name) {
                                AlreadyUnique = false
                            }
                            var TestNumber = parseInt(TestEntity.Name.substring(6, 11), 10);
                            if (BiggestNumber < TestNumber) {
                                BiggestNumber = TestNumber
                            }
                        }
                    }
                }
                this.Layers[i].UpdatePhysics()
            }
            if (AlreadyUnique) {
                return
            }
            var NewName = BaseName;
            var Number = BiggestNumber + 1;
            for (i = 0; i < 5; i += 1) {
                var Digit = Number % 10;
                Number = Math.floor(Number / 10);
                NewName = NewName.slice(0, BaseName.length) + Digit + NewName.slice(BaseName.length)
            }
            ThisEntity.Name = NewName
        },
        GetEntitiesInBox: function GetEntitiesInBoxFn(StartPos, EndPos, EntityArrayObject) {
            var i = 0;
            for (i = 0; i < this.Layers.length; i += 1) {
                var ThisLayer = this.Layers[i];
                if (ThisLayer.IsVisible) {
                    ThisLayer.GetEntitiesInBox(StartPos, EndPos, EntityArrayObject, i)
                }
            }
        },
        GetEntityLayer: function GetEntityLayer(Entity) {
            var i = 0,
                j = 0,
                k = 0;
            for (i = 0; i < this.Layers.length; i += 1) {
                var ThisLayer = this.Layers[i];
                for (j = 0; j < ThisLayer.Buckets.length; j += 1) {
                    var ThisBucket = ThisLayer.Buckets[j];
                    for (k = 0; k < ThisBucket.Entities.length; k += 1) {
                        var TestEntity = ThisBucket.Entities[k];
                        if (TestEntity === Entity) {
                            return i
                        }
                    }
                }
            }
            return 0
        },
        UpdateNewChanges: function UpdateNewChangesFn() {
            var i;
            for (i = 0; i < this.Layers.length; i += 1) {
                this.Layers[i].UpdateNewChanges()
            }
        },
        Update: function UpdateFn(TimeDelta) {
            EntityTypeManager.Update(TimeDelta);
            World.DebugTotalUpdateEntities = 0;
            for (i = 0; i < EntityTypeManager.GetNumRegisteredTypes(); i += 1) {
                World.DebugTotalUpdateEntitiesByType[i] = 0
            }
            Physics.Update(TimeDelta);
            var i;
            for (i = 0; i < this.Layers.length; i += 1) {
                this.Layers[i].UpdatePhysics()
            }
            for (i = 0; i < this.Layers.length; i += 1) {
                this.Layers[i].Update(TimeDelta)
            }
        },
        ViewportChanged: function ViewportChangedFn() {
            var x = JamSystem.RenderManager.GetScreenWidth() / 2;
            var y = JamSystem.RenderManager.GetScreenHeight() / 2;
            this.RootTreeTranslate.SetPosition(x, y)
        },
        Reset: function ResetFn() {
            var i;
            for (i = 0; i < this.Layers.length; i += 1) {
                this.Layers[i].Reset()
            }
            Physics.Reset();
            var Entities = this.GetAllEntitiesOfType(EntityTypeManager.GetPlayerTypeID());
            if (Entities.length) {
                this.PlayLayer = Entities[0].Layer.Index
            } else {
                this.PlayLayer = 0
            }
        },
        RenderReady: function RenderReadyFn() {
            World.DebugPhysicsEntities = 0;
            World.DebugVisibleBuckets = 0;
            World.DebugVisibleActiveEntities = 0;
            World.DebugVisibleStaticEntities = 0;
            World.DebugVisibleStaticLists = 0;
            World.DebugActiveParticles = 0;
            this.RootTreeTranslate.UpdateMatrix();
            this.RootTreeScale.UpdateMatrix();
            this.RootTreeRotate.UpdateMatrix()
        },
        Render: function RenderFn() {
            var i;
            this.RenderReady();
            if (JamSystem.InputManager.GetKeyPressed(4)) {
                Layer.DebugRendering = true
            }
            for (i = 0; i < this.Layers.length; i += 1) {
                if (this.Layers[i].IsVisible) {
                    this.Layers[i].Render();
                    World.DebugPhysicsEntities += this.Layers[i].PhysicalEntities.length
                }
            }
            Layer.DebugRendering = false
        },
        ToggleCollisionDisplay: function ToggleCollisionDisplayFn() {
            this.DebugShowCollision = !this.DebugShowCollision
        },
        SetLayerDebug: function SetLayerDebugFn(Active) {
            this.DebugShowLayers = Active
        },
        RenderDebug: function RenderDebugFn() {
            var i = 0;
            if (this.DebugShowCollision) {
                Physics.RenderDebugCollision(this.Layers[this.PlayLayer].RootTree.Matrix);
                for (i = 0; i < this.Layers.length; i += 1) {
                    if (this.Layers[i].IsVisible) {
                        this.Layers[i].RenderDebugEntitySurrounds()
                    }
                }
            }
            if (this.DebugShowLayers) {
                for (i = 0; i < this.Layers.length; i += 1) {
                    if (this.Layers[i].IsVisible) {
                        this.Layers[i].RenderDebug()
                    }
                }
            }
        },
        Init: function InitFn() {
            this.Layers = [];
            this.RootTreeTranslate = Helpers.CreateTree(0, 0, null);
            var x = JamSystem.RenderManager.GetScreenWidth() / 2;
            var y = JamSystem.RenderManager.GetScreenHeight() / 2;
            this.RootTreeTranslate.SetPosition(x, y);
            this.RootTreeScale = Helpers.CreateTree(0, 0, this.RootTreeTranslate);
            this.RootTreeRotate = Helpers.CreateTree(0, 0, this.RootTreeScale)
        },
        Clear: function ClearFn() {
            var i;
            for (i = 0; i < this.Layers.length; i += 1) {
                this.Layers[i].Clear();
                this.Layers[i].Destroy()
            }
            this.Layers = []
        },
        CreateDebugStats: function CreateDebugStatsFn() {
            this.DisplayStats = false;
            this.DebugFPSText = Helpers.CreateBitmapText("", 0, 0, EA.TopLeft, "EditorFont", JamSystem.RenderManager.GetRoot());
            this.DebugPhysicsEntitiesText = Helpers.CreateBitmapText("", 0, 20, EA.TopLeft, "EditorFont", JamSystem.RenderManager.GetRoot());
            this.DebugPhysicsActiveEntitiesText = Helpers.CreateBitmapText("", 0, 40, EA.TopLeft, "EditorFont", JamSystem.RenderManager.GetRoot());
            this.DebugVisibleBucketsText = Helpers.CreateBitmapText("", 0, 60, EA.TopLeft, "EditorFont", JamSystem.RenderManager.GetRoot());
            this.DebugTotalUpdateEntitiesText = Helpers.CreateBitmapText("", 0, 80, EA.TopLeft, "EditorFont", JamSystem.RenderManager.GetRoot());
            this.DebugVisibleActiveEntitiesText = Helpers.CreateBitmapText("", 0, 100, EA.TopLeft, "EditorFont", JamSystem.RenderManager.GetRoot());
            this.DebugVisibleStaticEntitiesText = Helpers.CreateBitmapText("", 0, 120, EA.TopLeft, "EditorFont", JamSystem.RenderManager.GetRoot());
            this.DebugVisibleStaticListsText = Helpers.CreateBitmapText("", 0, 140, EA.TopLeft, "EditorFont", JamSystem.RenderManager.GetRoot());
            this.DebugActiveParticlesText = Helpers.CreateBitmapText("", 0, 160, EA.TopLeft, "EditorFont", JamSystem.RenderManager.GetRoot());
            this.DebugRenderCallsText = Helpers.CreateBitmapText("", 0, 180, EA.TopLeft, "EditorFont", JamSystem.RenderManager.GetRoot());
            this.DebugFPSText.SetIsVisible(false);
            this.DebugPhysicsEntitiesText.SetIsVisible(false);
            this.DebugPhysicsActiveEntitiesText.SetIsVisible(false);
            this.DebugVisibleBucketsText.SetIsVisible(false);
            this.DebugTotalUpdateEntitiesText.SetIsVisible(false);
            this.DebugVisibleActiveEntitiesText.SetIsVisible(false);
            this.DebugVisibleStaticEntitiesText.SetIsVisible(false);
            this.DebugVisibleStaticListsText.SetIsVisible(false);
            this.DebugActiveParticlesText.SetIsVisible(false);
            this.DebugRenderCallsText.SetIsVisible(false)
        },
        ToggleDebugStats: function ToggleDebugStatsFn() {
            this.DisplayStats = !this.DisplayStats;
            this.DebugFPSText.SetIsVisible(this.DisplayStats);
            this.DebugPhysicsEntitiesText.SetIsVisible(this.DisplayStats);
            this.DebugPhysicsActiveEntitiesText.SetIsVisible(this.DisplayStats);
            this.DebugVisibleBucketsText.SetIsVisible(this.DisplayStats);
            this.DebugTotalUpdateEntitiesText.SetIsVisible(this.DisplayStats);
            this.DebugVisibleActiveEntitiesText.SetIsVisible(this.DisplayStats);
            this.DebugVisibleStaticEntitiesText.SetIsVisible(this.DisplayStats);
            this.DebugVisibleStaticListsText.SetIsVisible(this.DisplayStats);
            this.DebugActiveParticlesText.SetIsVisible(this.DisplayStats);
            this.DebugRenderCallsText.SetIsVisible(this.DisplayStats)
        },
        UpdateDebugStats: function UpdateDebugStatsFn() {
            if (this.DisplayStats) {
                this.DebugFPSText.SetText("FPS : " + JamSystem.GetFPS());
                this.DebugPhysicsEntitiesText.SetText("All Physicals : " + Physics.GetBodies());
                this.DebugPhysicsActiveEntitiesText.SetText("Active Physicals : " + Physics.GetActiveBodies());
                this.DebugVisibleBucketsText.SetText("Visible Buckets : " + World.DebugVisibleBuckets);
                this.DebugTotalUpdateEntitiesText.SetText("Total Active : " + World.DebugTotalUpdateEntities);
                this.DebugVisibleActiveEntitiesText.SetText("Visible Active : " + World.DebugVisibleActiveEntities);
                this.DebugVisibleStaticEntitiesText.SetText("Visible Static : " + World.DebugVisibleStaticEntities);
                this.DebugVisibleStaticListsText.SetText("Visible Static Lists : " + World.DebugVisibleStaticLists + " Ratio : " + World.DebugVisibleStaticEntities / World.DebugVisibleStaticLists);
                this.DebugActiveParticlesText.SetText("Active Particles: " + World.DebugActiveParticles);
                this.DebugRenderCallsText.SetText("Render Calls: Sprites " + Sprite.DebugRenderCount + " - Lists " + SpriteList.DebugRenderCount + " - Text " + BitmapText.DebugRenderCount)
            }
        },
        Destroy: function DestroyFn() {
            Helpers.DestroyTree(this.RootTreeRotate);
            this.RootTreeRotate = null;
            Helpers.DestroyTree(this.RootTreeScale);
            this.RootTreeScale = null;
            Helpers.DestroyTree(this.RootTreeTranslate);
            this.RootTreeTranslate = null
        }
    };
    World.DebugPhysicsEntities = 0;
    World.DebugPhysicsActiveEntities = 0;
    World.DebugPhysicsActiveLists = 0;
    World.DebugVisibleBuckets = 0;
    World.DebugTotalUpdateEntities = 0;
    World.DebugVisibleActiveEntities = 0;
    World.DebugVisibleStaticEntities = 0;
    World.DebugActiveParticles = 0;
    World.DebugTotalUpdateEntitiesByType = [];
    World.Create = function WorldCreateFn() {
        var NewObject = new World;
        NewObject.DimensionWidth = 0;
        NewObject.DimensionHeight = 0;
        NewObject.Layers = [];
        NewObject.RootTreeTranslate = 0;
        NewObject.RootTreeScale = 0;
        NewObject.RootTreeRotate = 0;
        NewObject.PlayerEntity = 0;
        NewObject.PlayLayer = 0;
        NewObject.OptimiseRunTime = false;
        NewObject.DebugShowCollision = false;
        NewObject.DebugShowLayers = false;
        NewObject.DisplayStats = null;
        NewObject.DebugFPSText = null;
        NewObject.DebugPhysicsEntitiesText = null;
        NewObject.DebugPhysicsActiveEntitiesText = null;
        NewObject.DebugVisibleBucketsText = null;
        NewObject.DebugTotalUpdateEntitiesText = null;
        NewObject.DebugVisibleActiveEntitiesText = null;
        NewObject.DebugVisibleStaticEntitiesText = null;
        NewObject.DebugVisibleStaticListsText = null;
        NewObject.DebugActiveParticlesText = null;
        NewObject.DebugRenderCallsText = null;
        NewObject.Init();
        return NewObject
    };

    function WorldFileManager() {}
    WorldFileManager.prototype = {};
    WorldFileManager.Init = function WorldFileManagerInitFn() {
        WorldFileManager.ActiveFile = null;
        WorldFileManager.Success = null
    };
    WorldFileManager.GetIsReady = function WorldFileManagerGetIsReadyFn() {
        if (WorldFileManager.ActiveFile && !WorldFileManager.ActiveFile.bFinished) {
            return false
        }
        if (WorldFileManager.ActiveFile) {
            WorldFileManager.Success = WorldFileManager.ActiveFile.bSuccess
        }
        WorldFileManager.ActiveFile = null;
        return true
    };
    WorldFileManager.AssignDefaultVariables = function AssignDefaultVariablesFn(NewEntity, ObjectPaletteIndex) {
        var ObjectInfo = ObjectPaletteManager.ObjectPalette[ObjectPaletteIndex];
        var EntityType = EntityTypeManager.GetClassFromName(ObjectInfo.Type);
        var EditableDefaults = [];
        if (EntityType) {
            if (EntityType.EditableVariables) {
                var i = 0,
                    j = 0;
                for (i = 0; i < EntityType.EditableVariables.length; i += 1) {
                    EditableDefaults[i] = EntityType.EditableVariables[i].Default;
                    if (ObjectInfo.Editables[i]) {
                        EditableDefaults[i] = ObjectInfo.Editables[i].Value
                    }
                    NewEntity.EditableVariables[i] = EditableDefaults[i]
                }
            }
        }
    };
    WorldFileManager.CreateEntity = function CreateEntityFn(X, Y, Rotation, ScaleX, ScaleY, Name, ObjectPaletteIndex, JSONObject) {
        var Image, Image2;
        var Collision;
        var ObjectType;
        if (ObjectPaletteIndex === -1) {
            Image = "InvalidObject";
            Collision = {};
            ObjectType = EntityTypeManager.GetClassFromName("None")
        } else {
            var ObjectPalette = ObjectPaletteManager.ObjectPalette[ObjectPaletteIndex];
            if (!ObjectPalette.Unknown) {
                Image = ObjectPalette.Image;
                Image2 = ObjectPalette.Image2;
                Collision = ObjectPalette.Collision;
                ObjectType = ObjectPalette.ObjectType
            } else {
                Image = "InvalidEntity";
                Collision = {};
                ObjectType = EntityTypeManager.GetClassFromName("None")
            }
        }
        var NewEntity = ObjectType.Create(X, Y, Rotation, ScaleX, ScaleY, Name, Image, Collision);
        if (Image2) {
            NewEntity.SetSecondImage(Image2)
        }
        if (NewEntity) {
            NewEntity.ObjectPaletteIndex = ObjectPaletteIndex
        }
        if (ObjectPaletteIndex !== -1) {
            WorldFileManager.AssignDefaultVariables(NewEntity, ObjectPaletteIndex)
        }
        var ObjectInfo = ObjectPaletteManager.ObjectPalette[ObjectPaletteIndex];
        if (ObjectInfo && !JSONObject) {
            var ScaleXAlter = ObjectInfo.Scale ? ObjectInfo.Scale.x : ScaleX;
            var ScaleYAlter = ObjectInfo.Scale ? ObjectInfo.Scale.y : ScaleY;
            NewEntity.StartScaleX = ScaleXAlter;
            NewEntity.StartScaleY = ScaleYAlter;
            if (NewEntity.Box2DBody) {
                var Mass = ObjectInfo.Mass ? ObjectInfo.Mass : 1;
                Physics.SetBodyMass(NewEntity.Box2DBody, Mass)
            }
            var RotationAlter = ObjectInfo.Rotation ? ObjectInfo.Rotation : Rotation;
            NewEntity.StartRotation = RotationAlter
        }
        return NewEntity
    };
    WorldFileManager.Load = function WorldFileManagerLoadFn(NewWorld, FileName, AbsolutePath) {
        NewWorld.Clear();
        var ext = FileName.substring(FileName.length - 3, FileName.length);
        if (ext === "xml" || ext === "XML") {
            WorldFileManager.ActiveFile = File.Load(FileName, WorldFileManager.ParseWorldFileXML, NewWorld, AbsolutePath)
        } else {
            WorldFileManager.ActiveFile = File.Load(FileName, WorldFileManager.ParseWorldFile, NewWorld, AbsolutePath)
        }
    };
    WorldFileManager.Save = function WorldFileManagerSaveFn(NewWorld, FileName) {
        var i, j, k;
        var myJSONTextWhiteSpace = "{\n    ";
        myJSONTextWhiteSpace += '"width":' + NewWorld.GetWidth() + ",";
        myJSONTextWhiteSpace += '"height":' + NewWorld.GetHeight() + ",";
        myJSONTextWhiteSpace += '"layers":\n    [\n';
        var NextLayerStaticEntities = [];
        var NextLayerDynamicEntities = [];
        var LastEntry = false;
        for (i = 0; i < NewWorld.GetLayerAmount(); i += 1) {
            var Layer = NewWorld.GetLayer(i);
            myJSONTextWhiteSpace += "       {";
            myJSONTextWhiteSpace += '"speedX":' + Layer.MovementScale.x + ",";
            myJSONTextWhiteSpace += '"speedY":' + Layer.MovementScale.y + ",";
            myJSONTextWhiteSpace += '"bucketWidth":' + Layer.BucketWidth + ",";
            myJSONTextWhiteSpace += '"bucketHeight":' + Layer.BucketHeight + ",";
            myJSONTextWhiteSpace += '"staticLayer":' + Layer.StaticLayer + ",";
            myJSONTextWhiteSpace += '"name": "' + Layer.Name + '",';
            myJSONTextWhiteSpace += '"entities":\n       [\n';
            var Entities = [];
            for (j = 0; j < Layer.Buckets.length; j += 1) {
                var Bucket = Layer.Buckets[j];
                for (k = 0; k < Bucket.Entities.length; k += 1) {
                    var TempEntity = Bucket.Entities[k];
                    Entities[Entities.length] = TempEntity
                }
            }
            LastEntry = false;
            if (i === NewWorld.GetLayerAmount() - 1 && NextLayerStaticEntities.length === 0 && NextLayerDynamicEntities.length === 0) {
                LastEntry = true
            }
            myJSONTextWhiteSpace = this.SaveEntitiesFromLayer(Entities, myJSONTextWhiteSpace, LastEntry)
        }
        myJSONTextWhiteSpace += "    ]\n}\n";
        WorldFileManager.ActiveFile = File.Save(FileName, myJSONTextWhiteSpace, true)
    };
    WorldFileManager.SaveEntitiesFromLayer = function SaveFromLayerFn(Entities, myJSONTextWhiteSpace, LastEntry) {
        Entities.sort(WorldFileManager.ActiveSort);
        var First = true,
            Index = 0,
            j = 0,
            k = 0;
        for (j = 0; j < Entities.length; j += 1) {
            var Entity = Entities[j];
            Index = Entity.ObjectPaletteIndex;
            if (Index !== -1) {
                if (!First) {
                    myJSONTextWhiteSpace += ",\n"
                }
                First = false;
                myJSONTextWhiteSpace += "           {";
                myJSONTextWhiteSpace += '"type":"' + ObjectPaletteManager.ObjectPalette[Index].Name + '",';
                myJSONTextWhiteSpace += '"x":' + Entity.StartX.toFixed(3) + ",";
                myJSONTextWhiteSpace += '"y":' + Entity.StartY.toFixed(3) + ",";
                myJSONTextWhiteSpace += '"r":' + Entity.StartRotation.toFixed(3) + ",";
                myJSONTextWhiteSpace += '"sx":' + Entity.StartScaleX.toFixed(3) + ",";
                myJSONTextWhiteSpace += '"sy":' + Entity.StartScaleY.toFixed(3);
                if (Entity.TrueColour[0] !== 1 && Entity.TrueColour[0] !== undefined) {
                    myJSONTextWhiteSpace += ',"ColR":' + Entity.TrueColour[0].toFixed(2)
                }
                if (Entity.TrueColour[1] !== 1 && Entity.TrueColour[1] !== undefined) {
                    myJSONTextWhiteSpace += ',"ColG":' + Entity.TrueColour[1].toFixed(2)
                }
                if (Entity.TrueColour[2] !== 1 && Entity.TrueColour[2] !== undefined) {
                    myJSONTextWhiteSpace += ',"ColB":' + Entity.TrueColour[2].toFixed(2)
                }
                if (Entity.TrueColour[3] !== 1 && Entity.TrueColour[3] !== undefined) {
                    myJSONTextWhiteSpace += ',"ColA":' + Entity.TrueColour[3].toFixed(2)
                }
                if (Entity.Name) {
                    myJSONTextWhiteSpace += ',"Name":"' + Entity.Name + '"'
                }
                if (Entity.Box2DBody && !Physics.GetIsStatic(Entity.Box2DBody) && Entity.Box2DBody.Mass) {
                    myJSONTextWhiteSpace += ',"Mass":' + Entity.Box2DBody.Mass + ""
                }
                if (Entity.Selected) {
                    myJSONTextWhiteSpace += ',"Selected":"' + Entity.Selected + '"'
                }
                var EntityType = EntityTypeManager.TypesRegistered[Entity.TypeID];
                if (EntityType.EditableVariables) {
                    for (k = 0; k < EntityType.EditableVariables.length; k += 1) {
                        if (!EntityType.EditableVariables[k].Hidden && !EntityType.EditableVariables[k].Shared) {
                            var Variable = Entity.EditableVariables[k];
                            if (EntityType.EditableVariables[k].Type === "Combo") {
                                myJSONTextWhiteSpace += ',"' + EntityType.EditableVariables[k].Name + '":"' + EntityType.EditableVariables[k].Combo[Variable] + '"'
                            } else {
                                if (typeof Variable === "string" || Variable === undefined) {
                                    myJSONTextWhiteSpace += ',"' + EntityType.EditableVariables[k].Name + '":"' + Variable + '"'
                                } else {
                                    myJSONTextWhiteSpace += ',"' + EntityType.EditableVariables[k].Name + '":' + Variable
                                }
                            }
                        }
                    }
                }
                if (Entity.Children && Entity.Children.length) {
                    myJSONTextWhiteSpace += ',"children":[';
                    for (k = 0; k < Entity.Children.length; k += 1) {
                        if (Entity.Children[k].Loaded) {
                            if (k !== Entity.Children.length - 1) {
                                myJSONTextWhiteSpace += '"' + Entity.Children[k].Name + '",'
                            } else {
                                myJSONTextWhiteSpace += '"' + Entity.Children[k].Name + '"'
                            }
                        }
                    }
                    myJSONTextWhiteSpace += "]"
                }
                myJSONTextWhiteSpace += "}"
            } else {
                j = j
            }
        }
        myJSONTextWhiteSpace += "\n";
        if (LastEntry) {
            myJSONTextWhiteSpace += "       ]}\n"
        } else {
            myJSONTextWhiteSpace += "       ]},\n"
        }
        return myJSONTextWhiteSpace
    };
    WorldFileManager.ParseWorldFile = function WorldFileManagerParseWorldFileFn(psData, iDataSize, NewWorld) {
        var i, j, k, l;
        if (psData === null) {
            return
        }
        var JSONObject = JSON.parse(psData);
        NewWorld.SetDimensions(JSONObject.width, JSONObject.height);
        var JSONLayer;
        for (i = 0; i < JSONObject.layers.length; i += 1) {
            JSONLayer = JSONObject.layers[i];
            var Speed = 0;
            if (JSONLayer.speed) {
                Speed = new Vector2(JSONLayer.speed, JSONLayer.speed)
            } else {
                Speed = new Vector2(JSONLayer.speedX, JSONLayer.speedY)
            }
            NewWorld.AddLayer(Speed, JSONLayer.bucketWidth, JSONLayer.bucketHeight, JSONLayer.staticLayer, JSONLayer.name)
        }
        for (i = 0; i < JSONObject.layers.length; i += 1) {
            JSONLayer = JSONObject.layers[i];
            var NewLayer = NewWorld.GetLayer(i);
            for (j = 0; j < JSONLayer.entities.length; j += 1) {
                var JSONEntity = JSONLayer.entities[j];
                var ObjectPaletteName = JSONEntity.type;
                var ObjectPaletteIndex = -1;
                for (ObjectPaletteIndex = 0; ObjectPaletteIndex < ObjectPaletteManager.ObjectPalette.length; ObjectPaletteIndex += 1) {
                    if (ObjectPaletteManager.ObjectPalette[ObjectPaletteIndex].Name === ObjectPaletteName) {
                        break
                    }
                }
                if (ObjectPaletteIndex === ObjectPaletteManager.ObjectPalette.length) {
                    ObjectPaletteIndex = -1
                }
                var X = JSONEntity.x;
                var Y = JSONEntity.y;
                var Rotation = JSONEntity.r;
                var ScaleX = JSONEntity.sx;
                var ScaleY = JSONEntity.sy;
                var Name = null;
                if (JSONEntity.Name) {
                    Name = JSONEntity.Name
                }
                var NewEntity = WorldFileManager.CreateEntity(X, Y, Rotation, ScaleX, ScaleY, Name, ObjectPaletteIndex, JSONEntity);
                if (NewEntity) {
                    var Colour = [1, 1, 1, 1];
                    if (JSONEntity.ColR !== undefined) {
                        Colour[0] = JSONEntity.ColR
                    }
                    if (JSONEntity.ColG !== undefined) {
                        Colour[1] = JSONEntity.ColG
                    }
                    if (JSONEntity.ColB !== undefined) {
                        Colour[2] = JSONEntity.ColB
                    }
                    if (JSONEntity.ColA !== undefined) {
                        Colour[3] = JSONEntity.ColA
                    }
                    NewEntity.SetColour(Colour);
                    if (JSONEntity.Mass) {
                        Physics.SetBodyMass(NewEntity.Box2DBody, JSONEntity.Mass)
                    }
                    var EntityType = EntityTypeManager.TypesRegistered[NewEntity.TypeID];
                    if (EntityType.EditableVariables) {
                        for (k = 0; k < EntityType.EditableVariables.length; k += 1) {
                            var Variable = JSONEntity[EntityType.EditableVariables[k].Name];
                            if (Variable !== undefined) {
                                if (EntityType.EditableVariables[k].Type === "Combo") {
                                    var Combo = EntityType.EditableVariables[k].Combo;
                                    for (l = 0; l < Combo.length; l += 1) {
                                        if (Combo[l] === Variable) {
                                            NewEntity.SetEditableVariable(k, l);
                                            break
                                        }
                                    }
                                } else {
                                    NewEntity.SetEditableVariable(k, Variable)
                                }
                            }
                        }
                    }
                    if (JSONEntity.children) {
                        NewEntity.Children = JSONEntity.children
                    }
                    NewLayer.AddEntity(NewEntity, false)
                }
            }
        }
        for (i = 0; i < NewWorld.GetLayerAmount(); i += 1) {
            var thisLayer = NewWorld.GetLayer(i);
            for (j = 0; j < thisLayer.Buckets.length; j += 1) {
                var thisBucket = thisLayer.Buckets[j];
                for (k = 0; k < thisBucket.Entities.length; k += 1) {
                    var thisEntity = thisBucket.Entities[k];
                    var ChildrenNames = thisEntity.Children;
                    if (ChildrenNames) {
                        thisEntity.Children = null;
                        for (l = 0; l < ChildrenNames.length; l += 1) {
                            var EntityList = NewWorld.FindEntityByName(ChildrenNames[l]);
                            if (EntityList.length === 1) {
                                thisEntity.AddChild(EntityList[0])
                            } else {
                                if (EntityList.length === 0) {
                                    Debug.Log("************* Child not found : " + ChildrenNames[l])
                                } else {
                                    Debug.Log("************* Multiple children of the same name found : " + ChildrenNames[l])
                                }
                            }
                        }
                    }
                }
            }
        }
        NewWorld.Optimise();
        for (i = 0; i < NewWorld.GetLayerAmount(); i += 1) {
            var thisLayer = NewWorld.GetLayer(i);
            for (j = 0; j < thisLayer.Buckets.length; j += 1) {
                var thisBucket = thisLayer.Buckets[j];
                for (k = 0; k < thisBucket.Entities.length; k += 1) {
                    var thisEntity = thisBucket.Entities[k];
                    thisEntity.SetColour(thisEntity.TrueColour)
                }
            }
        }
        JamSystem.Flush()
    };
    WorldFileManager.ParseWorldFileXML = function WorldFileManagerParseWorldFileXMLFn(psData, iDataSize, NewWorld) {
        if (psData === null) {
            return
        }
        var xmlDoc = psData;
        var Layers = xmlDoc.getElementsByTagName("Layer");
        var i, j, k, l;
        for (i = 0; i < Layers.length; i += 1) {
            var Width = parseFloat(Layers[i].getAttribute("Width"));
            var Height = parseFloat(Layers[i].getAttribute("Height"));
            var SpeedX = parseFloat(Layers[i].getAttribute("SpeedX"));
            var SpeedY = parseFloat(Layers[i].getAttribute("SpeedY"));
            if (SpeedX === 1) {
                NewWorld.SetDimensions(Width, Height)
            }
            NewWorld.AddLayer(SpeedX, 1280, 960);
            var NewLayer = NewWorld.GetLayer(i);
            var Objects = Layers[i].getElementsByTagName("Object");
            for (j = 0; j < Objects.length; j += 1) {
                var ObjectPaletteName = Objects[j].getAttribute("Type");
                var ObjectPaletteIndex = -1;
                for (ObjectPaletteIndex = 0; ObjectPaletteIndex < ObjectPaletteManager.ObjectPalette.length; ObjectPaletteIndex += 1) {
                    if (ObjectPaletteManager.ObjectPalette[ObjectPaletteIndex].Name === ObjectPaletteName) {
                        break
                    }
                }
                if (ObjectPaletteIndex === ObjectPaletteManager.ObjectPalette.length) {
                    ObjectPaletteIndex = -1
                }
                var X = parseFloat(Objects[j].getAttribute("X"));
                var Y = parseFloat(Objects[j].getAttribute("Y"));
                var Rotation = parseFloat(Objects[j].getAttribute("Rotation"));
                var ScaleX = parseFloat(Objects[j].getAttribute("ScaleX"));
                var ScaleY = parseFloat(Objects[j].getAttribute("ScaleY"));
                var Name = null;
                if (Objects[j].getAttribute("Name")) {
                    Name = Objects[j].getAttribute("Name")
                }
                var NewEntity = WorldFileManager.CreateEntity(X, Y, Rotation, ScaleX, ScaleY, Name, ObjectPaletteIndex, null);
                if (NewEntity) {
                    if (Objects[j].getAttribute("Mass")) {
                        var Mass = Objects[j].getAttribute("Mass");
                        Physics.SetBodyMass(NewEntity.Box2DBody, Mass)
                    }
                    var EntityType = EntityTypeManager.TypesRegistered[NewEntity.TypeID];
                    if (EntityType.EditableVariables) {
                        for (k = 0; k < EntityType.EditableVariables.length; k += 1) {
                            Name = EntityType.EditableVariables[k].Name;
                            var Variable = Objects[j].getAttribute(Name);
                            if (Variable) {
                                var EditableType = EntityType.EditableVariables[k].Type;
                                if (EditableType === "Integer") {
                                    var Integer = parseInt(Variable, 10);
                                    NewEntity.SetEditableVariable(k, Integer)
                                } else if (EditableType === "Number") {
                                    var Float = parseFloat(Variable);
                                    NewEntity.SetEditableVariable(k, Float)
                                } else if (EditableType === "String") {
                                    NewEntity.SetEditableVariable(k, Variable)
                                } else if (EditableType === "Boolean") {
                                    if (Variable === "True") {
                                        NewEntity.SetEditableVariable(k, true)
                                    } else {
                                        NewEntity.SetEditableVariable(k, false)
                                    }
                                } else if (EditableType === "Combo") {
                                    var Combo = EntityType.EditableVariables[k].Combo;
                                    for (l = 0; l < Combo.length; l += 1) {
                                        if (Combo[l] === Variable) {
                                            NewEntity.SetEditableVariable(k, l);
                                            break
                                        }
                                    }
                                }
                            }
                        }
                    }
                    NewLayer.AddEntity(NewEntity, false)
                }
            }
        }
        NewWorld.Optimise()
    };
    WorldFileManager.ActiveSort = function ActiveSortFn(EntityA, EntityB) {
        return EntityA.Depth - EntityB.Depth
    };
    Camera.ZoomAdjuster = .75;

    function Camera() {}
    Camera.prototype = {
        SetPosition: function SetPositionFn(x, y) {
            this.X = x;
            this.Y = y;
            this.PosTweener.Reset()
        },
        GetPosition: function GetPositionFn() {
            return new Vector2(this.X, this.Y)
        },
        MovePosition: function MovePositionFn(x, y, Time) {
            this.PosTweener.Set(Time, this.X, x, this.Y, y)
        },
        SetZoom: function SetZoomFn(NewZoom) {
            this.Zoom = NewZoom * Camera.ZoomAdjuster;
            this.ZoomTweener.Reset()
        },
        GetZoom: function GetZoomFn() {
            return this.Zoom / Camera.ZoomAdjuster
        },
        GetAdjustedZoom: function GetAdjustedZoomFn() {
            return this.Zoom
        },
        MoveZoom: function MoveZoomFn(Zoom, Time) {
            this.ZoomTweener.Set(Time, this.Zoom, Zoom * Camera.ZoomAdjuster, 0, 0)
        },
        SetRotation: function SetRotationFn(NewRotation) {
            this.Rotation = NewRotation;
            this.RotationTweener.Reset()
        },
        GetRotation: function GetRotationFn() {
            return this.Rotation
        },
        MoveRotation: function MoveRotationFn(Rotation, Time) {
            this.RotationTweener.Set(Time, this.Rotation, Rotation, 0, 0)
        },
        AccumulateZoom: function AccumulateZoomFn(NewZoom) {
            var i;
            for (i = this.ZoomHistory.length - 2; i >= 0; i -= 1) {
                this.ZoomHistory[i + 1] = this.ZoomHistory[i]
            }
            this.ZoomHistory[0] = NewZoom * Camera.ZoomAdjuster;
            this.Zoom = 0;
            for (i = 0; i < this.ZoomHistory.length; i += 1) {
                this.Zoom += this.ZoomHistory[i]
            }
            this.Zoom /= this.ZoomHistory.length
        },
        AccumulateLookAhead: function AccumulateLookAheadFn(x, y) {
            var i = 0;
            for (i = this.LookAheadHistoryX.length - 2; i >= 0; i -= 1) {
                this.LookAheadHistoryX[i + 1] = this.LookAheadHistoryX[i];
                this.LookAheadHistoryY[i + 1] = this.LookAheadHistoryY[i]
            }
            this.LookAheadHistoryX[0] = x;
            this.LookAheadHistoryY[0] = y;
            this.LookAheadX = 0;
            this.LookAheadY = 0;
            for (i = 0; i < this.LookAheadHistoryX.length; i += 1) {
                this.LookAheadX += this.LookAheadHistoryX[i];
                this.LookAheadY += this.LookAheadHistoryY[i]
            }
            this.LookAheadX /= this.LookAheadHistoryX.length;
            this.LookAheadY /= this.LookAheadHistoryX.length
        },
        GetLookAheadX: function GetLookAheadXFn() {
            return this.LookAheadX
        },
        GetLookAheadY: function GetLookAheadYFn() {
            return this.LookAheadY
        },
        Update: function UpdateFn(TimeDelta) {
            if (this.PosTweener.Update(TimeDelta)) {
                this.X = this.PosTweener.VariableX;
                this.Y = this.PosTweener.VariableY
            }
            if (this.ZoomTweener.Update(TimeDelta)) {
                this.Zoom = this.ZoomTweener.VariableX
            }
            if (this.RotationTweener.Update(TimeDelta)) {
                this.Rotation = this.RotationTweener.VariableX
            }
        },
        Reset: function ResetFn() {
            var i;
            for (i = 0; i < this.LookAheadHistoryX.length; i += 1) {
                this.ZoomHistory[i] = this.Zoom;
                this.LookAheadHistoryX[i] = 0;
                this.LookAheadHistoryY[i] = 0
            }
            this.PosTweener.Reset();
            this.ZoomTweener.Reset();
            this.RotationTweener.Reset()
        },
        Destroy: function DestroyFn() {}
    };
    Camera.Create = function CreateFn() {
        var NewObject = new Camera;
        NewObject.X = 0;
        NewObject.Y = 0;
        NewObject.Zoom = 1 * Camera.ZoomAdjuster;
        NewObject.Rotation = 0;
        NewObject.ZoomHistory = [];
        NewObject.LookAheadX = 0;
        NewObject.LookAheadY = 0;
        NewObject.LookAheadHistoryX = [];
        NewObject.LookAheadHistoryY = [];
        NewObject.PosTweener = new Tweener;
        NewObject.ZoomTweener = new Tweener;
        NewObject.RotationTweener = new Tweener;
        var i;
        for (i = 0; i < 120; i += 1) {
            NewObject.ZoomHistory[i] = NewObject.Zoom;
            NewObject.LookAheadHistoryX[i] = 0;
            NewObject.LookAheadHistoryY[i] = 0
        }
        return NewObject
    };
    var DynamicSplits = 0;
    var AssetSplits = 0;
    var BucketSplits = 0;

    function Bucket() {}
    Bucket.prototype = {
        AddEntity: function AddEntityFn(NewEntity) {
            this.Entities[this.Entities.length] = NewEntity;
            NewEntity.Bucket = this;
            if (NewEntity.IsActive) {
                this.ActiveEntities[this.ActiveEntities.length] = NewEntity;
                if (EntityTypeManager.GetClassFromID(NewEntity.TypeID).UpdateAll) {
                    if (NewEntity.GetIsActiveVisible()) {
                        var i;
                        var Array;
                        for (i = 0; i < this.UpdateAllEntities.length; i += 1) {
                            var TempArray = this.UpdateAllEntities[i];
                            if (TempArray[0].TypeID === NewEntity.TypeID) {
                                Array = TempArray;
                                break
                            }
                        }
                        if (!Array) {
                            this.UpdateAllEntities[this.UpdateAllEntities.length] = [];
                            Array = this.UpdateAllEntities[this.UpdateAllEntities.length - 1]
                        }
                        Array[Array.length] = NewEntity;
                        this.Actives = true
                    }
                } else {
                    if (NewEntity.GetIsActiveVisible()) {
                        this.UpdateEntitiesVisible[this.UpdateEntitiesVisible.length] = NewEntity
                    } else {
                        this.UpdateEntities[this.UpdateEntities.length] = NewEntity
                    }
                    this.Actives = true
                }
                this.Layer.UpdateBuckets = true
            } else {
                if (this.EditActive) {
                    this.Unoptimise()
                }
            }
            if (NewEntity.GetIsCollidable()) {
                this.CollidableEntities[NewEntity.TypeID][this.CollidableEntities[NewEntity.TypeID].length] = NewEntity
            }
            NewEntity.CalcBoundingBox();
            if (this.Left > NewEntity.AABB_Left) {
                this.Left = NewEntity.AABB_Left
            }
            if (this.Right < NewEntity.AABB_Right) {
                this.Right = NewEntity.AABB_Right
            }
            if (this.Top > NewEntity.AABB_Top) {
                this.Top = NewEntity.AABB_Top
            }
            if (this.Bottom < NewEntity.AABB_Bottom) {
                this.Bottom = NewEntity.AABB_Bottom
            }
        },
        RemoveEntity: function RemoveEntityFn(NewEntity) {
            if (NewEntity.IsActive) {
                var Index;
                Index = this.ActiveEntities.indexOf(NewEntity);
                if (Index !== -1) {
                    this.ActiveEntities.splice(Index, 1)
                }
                if (EntityTypeManager.GetClassFromID(NewEntity.TypeID).UpdateAll) {
                    if (NewEntity.GetIsActiveVisible()) {
                        var i;
                        for (i = 0; i < this.UpdateAllEntities.length; i += 1) {
                            var Array = this.UpdateAllEntities[i];
                            if (Array[0].TypeID === NewEntity.TypeID) {
                                Index = Array.indexOf(NewEntity);
                                if (Index !== -1) {
                                    Array.splice(Index, 1);
                                    if (!Array.length) {
                                        Index = this.UpdateAllEntities.indexOf(Array);
                                        this.UpdateAllEntities.splice(Index, 1);
                                        i -= 1
                                    }
                                }
                                break
                            }
                        }
                    }
                } else {
                    if (NewEntity.GetIsActiveVisible()) {
                        Index = this.UpdateEntitiesVisible.indexOf(NewEntity);
                        if (Index !== -1) {
                            this.UpdateEntitiesVisible.splice(Index, 1)
                        }
                    } else {
                        Index = this.UpdateEntities.indexOf(NewEntity);
                        if (Index !== -1) {
                            this.UpdateEntities.splice(Index, 1)
                        }
                    }
                }
            }
            var Index;
            if (NewEntity.GetIsCollidable()) {
                Index = this.CollidableEntities[NewEntity.TypeID].indexOf(NewEntity);
                if (Index !== -1) {
                    this.CollidableEntities[NewEntity.TypeID].splice(Index, 1)
                }
            }
            if (NewEntity.SpriteList) {
                if (this.EditActive) {
                    this.Unoptimise()
                }
            }
            Index = this.Entities.indexOf(NewEntity);
            if (Index !== -1) {
                this.Entities.splice(Index, 1)
            }
            NewEntity.Bucket = null
        },
        MakeEntityActive: function MakeEntityActiveFn(NewEntity) {
            if (!NewEntity.IsActive) {
                NewEntity.IsActive = true;
                this.ActiveEntities[this.ActiveEntities.length] = NewEntity;
                if (NewEntity.GetIsActiveVisible()) {
                    this.UpdateEntitiesVisible[this.UpdateEntitiesVisible.length] = NewEntity
                } else {
                    this.UpdateEntities[this.UpdateEntities.length] = NewEntity
                }
            }
        },
        MakeEntityInactive: function MakeEntityInactiveFn(NewEntity) {
            var Index;
            if (NewEntity.IsActive) {
                NewEntity.IsActive = false;
                if (NewEntity.GetIsActiveVisible()) {
                    Index = this.UpdateEntitiesVisible.indexOf(NewEntity);
                    if (Index !== -1) {
                        this.UpdateEntitiesVisible.splice(Index, 1)
                    }
                } else {
                    Index = this.UpdateEntities.indexOf(NewEntity);
                    if (Index !== -1) {
                        this.UpdateEntities.splice(Index, 1)
                    }
                }
                Index = this.ActiveEntities.indexOf(NewEntity);
                if (Index !== -1) {
                    this.ActiveEntities.splice(Index, 1)
                }
            }
        },
        Clear: function ClearFn() {
            var NewEntity = 0;
            var OriginalLength = this.Entities.length;
            var i;
            for (i = OriginalLength - 1; i > -1; i -= 1) {
                NewEntity = this.Entities[i];
                NewEntity.Destroy()
            }
            for (i = 0; i < this.StaticSpriteLists.length; i += 1) {
                Helpers.DestroySpriteList(this.StaticSpriteLists[i])
            }
            this.StaticSpriteLists = []
        },
        GetEntityAt: function GetEntityAtFn(x, y, ReturnAll) {
            var i, j;
            var BestEntity = null;
            var AllEntities = [];
            for (i = this.Entities.length - 1; i >= 0; i -= 1) {
                if (this.Entities[i].GetIsAt(x, y)) {
                    AllEntities[AllEntities.length] = this.Entities[i];
                    if (BestEntity === null || BestEntity.Depth < this.Entities[i].Depth) {
                        BestEntity = this.Entities[i]
                    }
                }
            }
            for (i = this.StaticSpriteLists.length - 1; i >= 0; i -= 1) {
                var Index = this.StaticSpriteLists[i].GetIsAnyAt(x, y);
                if (Index !== -1) {
                    for (j = this.Entities.length - 1; j >= 0; j -= 1) {
                        if (Index === this.Entities[j].SpriteListIndex && this.Entities[j].SpriteList === this.StaticSpriteLists[i]) {
                            AllEntities[AllEntities.length] = this.Entities[j];
                            if (BestEntity === null || BestEntity.Depth < this.Entities[j].Depth) {
                                BestEntity = this.Entities[j]
                            }
                        }
                    }
                }
            }
            if (AllEntities.length > 1 && ReturnAll) {
                return AllEntities
            }
            if (BestEntity) {
                AllEntities = [];
                AllEntities[0] = BestEntity;
                return AllEntities
            }
            return null
        },
        GetIsVisible: function GetIsVisible(x1, y1, x2, y2) {
            if (this.Right <= x1 || this.Left > x2 || this.Bottom <= y1 || this.Top > y2) {
                return false
            }
            return true
        },
        GetNextDepthEntity: function GetNextDepthEntityFn(ThisEntity, Closer, ToEnd) {
            var BestEntity = null;
            var i;
            for (i = 0; i < this.Entities.length; i += 1) {
                var TestEntity = null;
                if (Closer) {
                    if (ThisEntity.Depth < this.Entities[i].Depth) {
                        if (BestEntity === null) {
                            TestEntity = this.Entities[i]
                        } else {
                            if (ToEnd) {
                                if (BestEntity.Depth < this.Entities[i].Depth) {
                                    TestEntity = this.Entities[i]
                                }
                            } else {
                                if (BestEntity.Depth > this.Entities[i].Depth) {
                                    TestEntity = this.Entities[i]
                                }
                            }
                        }
                    }
                } else {
                    if (ThisEntity.Depth > this.Entities[i].Depth) {
                        if (BestEntity === null) {
                            TestEntity = this.Entities[i]
                        } else {
                            if (ToEnd) {
                                if (BestEntity.Depth > this.Entities[i].Depth) {
                                    TestEntity = this.Entities[i]
                                }
                            } else {
                                if (BestEntity.Depth < this.Entities[i].Depth) {
                                    TestEntity = this.Entities[i]
                                }
                            }
                        }
                    }
                }
                if (TestEntity) {
                    if (ThisEntity.GetDoesOverlap(TestEntity)) {
                        BestEntity = TestEntity
                    }
                }
            }
            return BestEntity
        },
        OptimiseStatics: function OptimiseStaticsFn(RootTree, TouchingEntitiesList) {
            var i, j;
            this.Unoptimise();
            var SpriteLists = [];
            var OtherSpriteList = [];
            var CurrentSpriteList = null;
            var CurrentTexture = null;
            var CurrentTexture2 = null;
            var CurrentImage = null;
            var CurrentImage2 = undefined;
            var CurrentShader = null;
            var LastSprite = false;
            var NumStaticsLeft = 0;
            for (i = 0; i < this.Entities.length; i += 1) {
                var ThisEntity = this.Entities[i];
                if (!ThisEntity.IsActive && !ThisEntity.IsActiveVisible) {
                    ThisEntity.Optimised = false;
                    NumStaticsLeft += 1
                }
            }
            while (NumStaticsLeft) {
                CurrentSpriteList = null;
                for (i = 0; i < this.Entities.length; i += 1) {
                    var ThisEntity = this.Entities[i];
                    if (!ThisEntity.Optimised) {
                        if (!ThisEntity.IsActive && !ThisEntity.IsActiveVisible) {
                            var ThisSprite = ThisEntity.Sprite;
                            var psTexture = ThisSprite.psTexture;
                            var psTexture2 = ThisSprite.psTexture2;
                            var Image = psTexture.Frames[ThisSprite.Frame].PageIndex;
                            var Image2 = undefined;
                            if (psTexture2) {
                                Image2 = psTexture2.Frames[ThisSprite.Frame2].PageIndex
                            }
                            var Skip = false;
                            if (!CurrentSpriteList) {
                                OtherSpriteList = [];
                                SpriteLists[SpriteLists.length] = [];
                                CurrentSpriteList = SpriteLists[SpriteLists.length - 1];
                                CurrentTexture = ThisSprite.psTexture;
                                CurrentTexture2 = ThisSprite.psTexture2;
                                CurrentImage = Image;
                                CurrentImage2 = Image2;
                                CurrentShader = ThisSprite.Shader
                            } else {
                                var BreakOut, j;
                                if (psTexture !== CurrentTexture || Image !== CurrentImage || ThisSprite.Shader !== CurrentShader || psTexture2 !== CurrentTexture2 || psTexture2 && Image2 !== CurrentImage2) {
                                    BreakOut = false;
                                    for (j = 0; j < CurrentSpriteList.length; j += 1) {
                                        if (ThisEntity.GetDoesOverlap(CurrentSpriteList[j])) {
                                            BreakOut = true;
                                            break
                                        }
                                    }
                                    if (BreakOut) {
                                        AssetSplits += 1;
                                        break
                                    }
                                    OtherSpriteList[OtherSpriteList.length] = ThisEntity;
                                    Skip = true
                                }
                                if (!Skip) {
                                    if (Bucket.prototype.DoesEntityUnderlapEntities(ThisEntity, TouchingEntitiesList, CurrentSpriteList[0].Depth)) {
                                        BucketSplits += 1;
                                        break
                                    }
                                    BreakOut = false;
                                    for (j = 0; j < OtherSpriteList.length; j += 1) {
                                        if (ThisEntity.GetDoesOverlap(OtherSpriteList[j])) {
                                            BreakOut = true;
                                            break
                                        }
                                    }
                                    if (BreakOut) {
                                        AssetSplits += 1;
                                        break
                                    }
                                }
                            }
                            if (!Skip) {
                                CurrentSpriteList[CurrentSpriteList.length] = this.Entities[i];
                                this.Entities[i].Optimised = true;
                                NumStaticsLeft -= 1
                            }
                        } else {
                            if (CurrentSpriteList) {
                                DynamicSplits += 1;
                                break
                            }
                        }
                    }
                }
            }
            for (i = 0; i < SpriteLists.length; i += 1) {
                CurrentSpriteList = SpriteLists[i];
                this.StaticSpriteLists[i] = JamSystem.RenderManager.CreateSpriteList(CurrentSpriteList.length, CurrentSpriteList[0].Sprite.psTexture, CurrentSpriteList[0].Sprite.psTexture2);
                var psTexture = CurrentSpriteList[0].Sprite.psTexture;
                var Image = psTexture.Frames[CurrentSpriteList[0].Sprite.Frame].PageIndex;
                this.StaticSpriteLists[i].SetTexture(psTexture, Image);
                var psTexture2 = CurrentSpriteList[0].Sprite.psTexture2;
                if (psTexture2) {
                    var Image2 = psTexture2.Frames[CurrentSpriteList[0].Sprite.Frame2].PageIndex;
                    this.StaticSpriteLists[i].SetTexture2(psTexture2, Image2)
                }
                RootTree.AddChild(this.StaticSpriteLists[i]);
                var DepthSet = false;
                for (j = 0; j < CurrentSpriteList.length; j += 1) {
                    if (!DepthSet) {
                        DepthSet = true;
                        this.StaticSpriteLists[i].Depth = CurrentSpriteList[j].Sprite.Depth
                    }
                    CurrentSpriteList[j].SetSpriteList(this.StaticSpriteLists[i], j)
                }
                this.StaticSpriteLists[i].UpdateVertices()
            }
            this.Left = this.x * this.DefaultWidth;
            this.Right = (this.x + 1) * this.DefaultWidth;
            this.Top = this.y * this.DefaultHeight;
            this.Bottom = (this.y + 1) * this.DefaultHeight;
            for (i = 0; i < this.Entities.length; i += 1) {
                if (this.Entities[i].SpriteList) {
                    this.Entities[i].CalcBoundingBox()
                }
                if (this.Left > this.Entities[i].AABB_Left) {
                    this.Left = this.Entities[i].AABB_Left
                }
                if (this.Right < this.Entities[i].AABB_Right) {
                    this.Right = this.Entities[i].AABB_Right
                }
                if (this.Top > this.Entities[i].AABB_Top) {
                    this.Top = this.Entities[i].AABB_Top
                }
                if (this.Bottom < this.Entities[i].AABB_Bottom) {
                    this.Bottom = this.Entities[i].AABB_Bottom
                }
            }
            this.Optimised = true
        },
        UpdateEntityCollision: function UpdateEntityCollisionFn(ObjectPaletteIndex, CollisionData) {
            var i;
            for (i = 0; i < this.Entities.length; i += 1) {
                var Entity = this.Entities[i];
                if (Entity.ObjectPaletteIndex === ObjectPaletteIndex && Entity.Box2DBody) {
                    Entity.CalcBoundingBox();
                    Physics.UpdateFixture(Entity.Box2DBody, CollisionData, Entity.StartScaleX, Entity.StartScaleY, Entity)
                }
            }
        },
        Update: function UpdateFn(TimeDelta) {
            World.DebugTotalUpdateEntities += this.UpdateEntities.length;
            var i;
            for (i = 0; i < this.UpdateEntities.length; i += 1) {
                this.UpdateEntities[i].Update(TimeDelta)
            }
            if (this.IsVisible) {
                World.DebugTotalUpdateEntities += this.UpdateEntitiesVisible.length;
                for (i = 0; i < this.UpdateEntitiesVisible.length; i += 1) {
                    this.UpdateEntitiesVisible[i].Update(TimeDelta)
                }
                for (i = 0; i < this.UpdateAllEntities.length; i += 1) {
                    var Class = EntityTypeManager.GetClassFromID(this.UpdateAllEntities[i][0].TypeID);
                    Class.UpdateAll(this.UpdateAllEntities[i], TimeDelta)
                }
            }
        },
        Reset: function ResetFn() {},
        ShowEditMode: function ShowEditModeFn(EditActive) {
            this.EditActive = EditActive;
            var i;
            for (i = 0; i < this.Entities.length; i += 1) {
                this.Entities[i].ShowEditMode(EditActive)
            }
        },
        RenderStatic: function RenderStaticFn(FinalListArray, FinalSpriteArray) {
            if (this.Layer.ParentWorld.OptimiseRunTime && !this.Optimised) {
                this.Layer.OptimiseBucket(this)
            }
            var i = 0;
            World.DebugVisibleBuckets += 1;
            for (i = 0; i < this.StaticSpriteLists.length; i += 1) {
                World.DebugVisibleStaticEntities += this.StaticSpriteLists[i].NumSprites
            }
            World.DebugVisibleStaticLists += this.StaticSpriteLists.length;
            for (i = 0; i < this.StaticSpriteLists.length; i += 1) {
                FinalListArray[FinalListArray.length] = this.StaticSpriteLists[i]
            }
            if (!this.Optimised) {
                for (i = 0; i < this.Entities.length; i += 1) {
                    if (!this.Entities[i].IsActive && !this.Entities[i].IsActiveVisible && this.Entities[i].Sprite && this.Entities[i].Sprite.bVisible) {
                        FinalSpriteArray[FinalSpriteArray.length] = this.Entities[i].Sprite;
                        World.DebugVisibleStaticEntities += 1
                    }
                }
            }
        },
        RenderActive: function RenderActiveFn(FinalSpriteArray) {
            var i = 0;
            World.DebugVisibleActiveEntities += this.ActiveEntities.length;
            for (i = 0; i < this.ActiveEntities.length; i += 1) {
                if (this.ActiveEntities[i].Sprite && this.ActiveEntities[i].Sprite.bVisible) {
                    FinalSpriteArray[FinalSpriteArray.length] = this.ActiveEntities[i].Sprite
                }
            }
        },
        RenderDebug: function RenderDebugFn(ShowChildrenLines, ShowBucketLines, Matrix) {
            var Colour;
            if (ShowChildrenLines) {
                var i;
                for (i = 0; i < this.Entities.length; i += 1) {
                    var thisEntity = this.Entities[i];
                    if (thisEntity === GlobalMain.Editor.SelectedFunctions.HoverEntity && thisEntity.Children) {
                        var j;
                        for (j = 0; j < thisEntity.Children.length; j += 1) {
                            var ChildEntity = thisEntity.Children[j];
                            Colour = [1, 1, 1, 1];
                            var x1, y1;
                            var x2, y2;
                            if (thisEntity.TypeID === EntityRod.TypeID || thisEntity.TypeID === EntitySpring.TypeID) {
                                var WorldCoord;
                                var Frame = thisEntity.Sprite.psTexture.GetFrame(thisEntity.Sprite.GetFrame());
                                var Height = Frame.Height / 2;
                                if (j === 0) {
                                    WorldCoord = Entity.TransformLocalToWorld(thisEntity, new Vector2(0, -Height))
                                } else {
                                    WorldCoord = Entity.TransformLocalToWorld(thisEntity, new Vector2(0, Height))
                                }
                                x1 = WorldCoord.x;
                                y1 = WorldCoord.y;
                                x2 = ChildEntity.StartX;
                                y2 = ChildEntity.StartY
                            } else {
                                x1 = thisEntity.StartX;
                                y1 = thisEntity.StartY;
                                x2 = ChildEntity.StartX;
                                y2 = ChildEntity.StartY
                            }
                            JamSystem.RenderManager.DrawDebugLine(x1, y1, x2, y2, Colour, Matrix);
                            Colour = [1, 1, 1, 1];
                            var Text = "" + (j + 1);
                            var DiffX = x2 - x1;
                            var DiffY = y2 - y1;
                            var x = x1 + DiffX * .75;
                            var y = y1 + DiffY * .75;
                            JamSystem.RenderManager.DrawDebugText(x, y, 1, 1, 0, Text, "EditorFont", Colour, Matrix)
                        }
                    }
                }
            }
            if (ShowBucketLines) {
                if (this.Optimised) {
                    Colour = [0, 0, 1, 1]
                } else {
                    Colour = [1, 0, 1, 1]
                }
                JamSystem.RenderManager.DrawDebugLine(this.Left, this.Top, this.Right, this.Top, Colour, Matrix);
                JamSystem.RenderManager.DrawDebugLine(this.Right, this.Top, this.Right, this.Bottom, Colour, Matrix);
                JamSystem.RenderManager.DrawDebugLine(this.Right, this.Bottom, this.Left, this.Bottom, Colour, Matrix);
                JamSystem.RenderManager.DrawDebugLine(this.Left, this.Bottom, this.Left, this.Top, Colour, Matrix)
            }
        },
        Unoptimise: function UnoptimiseFn() {
            if (this.Optimised) {
                this.Optimised = false;
                var i;
                for (i = 0; i < this.Entities.length; i += 1) {
                    if (this.Entities[i].SpriteList) {
                        this.Entities[i].ClearSpriteList()
                    }
                }
                for (i = 0; i < this.StaticSpriteLists.length; i += 1) {
                    Helpers.DestroySpriteList(this.StaticSpriteLists[i])
                }
                this.StaticSpriteLists = [];
                if (!this.EditActive) {
                    Debug.Log("********* Warning : Bucket was unoptimised")
                }
            }
        },
        OptimiseBoundingBox: function OptimiseBoundingBoxFn() {
            var SmallNumber = 1e-5;
            this.Left = this.x * this.DefaultWidth;
            this.Right = (this.x + 1) * this.DefaultWidth - SmallNumber;
            this.Top = this.y * this.DefaultHeight;
            this.Bottom = (this.y + 1) * this.DefaultHeight - SmallNumber;
            var i;
            for (i = 0; i < this.Entities.length; i += 1) {
                {
                    if (this.Left > this.Entities[i].AABB_Left) {
                        this.Left = this.Entities[i].AABB_Left
                    }
                    if (this.Right < this.Entities[i].AABB_Right) {
                        this.Right = this.Entities[i].AABB_Right
                    }
                    if (this.Top > this.Entities[i].AABB_Top) {
                        this.Top = this.Entities[i].AABB_Top
                    }
                    if (this.Bottom < this.Entities[i].AABB_Bottom) {
                        this.Bottom = this.Entities[i].AABB_Bottom
                    }
                }
            }
        },
        DoesEntityUnderlapEntities: function DoesEntityUnderlapEntitiesFn(TestEntity, TouchingEntitiesList, FirstDepth) {
            var i, j;
            for (i = 0; i < TouchingEntitiesList.length; i += 1) {
                var TouchingEntities = TouchingEntitiesList[i];
                for (j = 0; j < TouchingEntities.length; j += 1) {
                    if (TouchingEntities[j].Depth > FirstDepth && TouchingEntities[j].Depth < TestEntity.Depth) {
                        if (TestEntity.GetDoesOverlap(TouchingEntities[j])) {
                            return true
                        }
                    }
                }
            }
            return false
        },
        ActiveSort: function ActiveSortFn(EntityA, EntityB) {
            return EntityA.Depth - EntityB.Depth
        }
    };
    Bucket.Create = function BucketCreateFn(x, y, DefaultWidth, DefaultHeight, RootTree, Layer) {
        var NewObject = new Bucket;
        NewObject.x = x;
        NewObject.y = y;
        NewObject.DefaultWidth = DefaultWidth;
        NewObject.DefaultHeight = DefaultHeight;
        NewObject.IsVisible = false;
        NewObject.EditActive = false;
        NewObject.Actives = false;
        NewObject.Layer = Layer;
        NewObject.Left = x * DefaultWidth;
        NewObject.Right = (x + 1) * DefaultWidth;
        NewObject.Top = y * DefaultHeight;
        NewObject.Bottom = (y + 1) * DefaultHeight;
        NewObject.Entities = [];
        NewObject.UpdateEntities = [];
        NewObject.UpdateEntitiesVisible = [];
        NewObject.UpdateAllEntities = [];
        NewObject.ActiveEntities = [];
        NewObject.CollidableEntities = [];
        var i;
        for (i = 0; i < EntityTypeManager.GetNumRegisteredTypes(); i += 1) {
            NewObject.CollidableEntities[i] = []
        }
        NewObject.StaticSpriteLists = [];
        NewObject.Optimised = false;
        NewObject.TouchingBuckets = [];
        return NewObject
    };

    function BucketVisibility() {}
    BucketVisibility.prototype = {
        Build: function Build(Buckets) {
            var i;
            if (this.Children.length) {
                for (i = 0; i < this.Children.length; i += 1) {
                    this.Children[i].Build(Buckets)
                }
            } else {
                this.Buckets.length = 0;
                for (i = 0; i < Buckets.length; i += 1) {
                    if (Buckets[i].Right <= this.AABB_Left || Buckets[i].Left > this.AABB_Right || Buckets[i].Bottom <= this.AABB_Top || Buckets[i].Top > this.AABB_Bottom) {
                        continue
                    }
                    this.Buckets[this.Buckets.length] = Buckets[i]
                }
            }
        },
        GetVisibilityList: function GetVisibilityList(ViewTop, ViewLeft, ViewBottom, ViewRight, VisibleBucketList) {
            var i;
            if (ViewRight <= this.AABB_Left || ViewLeft > this.AABB_Right || ViewBottom <= this.AABB_Top || ViewTop > this.AABB_Bottom) {
                return
            }
            if (this.Children.length) {
                for (i = 0; i < this.Children.length; i += 1) {
                    this.Children[i].GetVisibilityList(ViewTop, ViewLeft, ViewBottom, ViewRight, VisibleBucketList)
                }
            } else {
                for (i = 0; i < this.Buckets.length; i += 1) {
                    if (this.Buckets[i].IsVisible) {
                        continue
                    }
                    if (ViewRight <= this.Buckets[i].Left || ViewLeft > this.Buckets[i].Right || ViewBottom <= this.Buckets[i].Top || ViewTop > this.Buckets[i].Bottom) {
                        continue
                    }
                    this.Buckets[i].IsVisible = true;
                    VisibleBucketList[VisibleBucketList.length] = this.Buckets[i]
                }
            }
        }
    };
    BucketVisibility.Create = function BucketVisibilityCreateFn(x, y, Width, Height, MinWidth, MinHeight) {
        var NewObject = new BucketVisibility;
        NewObject.AABB_Left = x;
        NewObject.AABB_Top = y;
        NewObject.AABB_Right = x + Width;
        NewObject.AABB_Bottom = y + Height;
        NewObject.Children = [];
        NewObject.Buckets = [];
        if (Width > MinWidth || Height > MinHeight) {
            var HalfWidth = Width / 2;
            var HalfHeight = Height / 2;
            NewObject.Children[NewObject.Children.length] = BucketVisibility.Create(x, y, HalfWidth, HalfHeight, MinWidth, MinHeight);
            NewObject.Children[NewObject.Children.length] = BucketVisibility.Create(x + HalfWidth, y, HalfWidth, HalfHeight, MinWidth, MinHeight);
            NewObject.Children[NewObject.Children.length] = BucketVisibility.Create(x, y + HalfHeight, HalfWidth, HalfHeight, MinWidth, MinHeight);
            NewObject.Children[NewObject.Children.length] = BucketVisibility.Create(x + HalfWidth, y + HalfHeight, HalfWidth, HalfHeight, MinWidth, MinHeight)
        }
        return NewObject
    };

    function Layer() {}
    Layer.DebugRendering = false;
    Layer.prototype = {
        CalcBucketCoords: function CalcBucketCoordsFn(xs, ys) {
            var xd = Math.floor(xs / this.BucketWidth);
            var yd = Math.floor(ys / this.BucketHeight);
            if (xd < 0) {
                xd = 0
            }
            if (yd < 0) {
                yd = 0
            }
            if (xd >= this.BucketsWide) {
                xd = this.BucketsWide - 1
            }
            if (yd >= this.BucketsHigh) {
                yd = this.BucketsHigh - 1
            }
            return new Vector2(xd, yd)
        },
        AddEntity: function AddEntityFn(NewEntity, Reset) {
            if (NewEntity.Box2DBody && (this.MovementScale.x !== 1 || this.MovementScale.y !== 1)) {
                Debug.Log("******** Warning : Entity " + NewEntity.Name + " at " + NewEntity.x + "," + NewEntity.y + " has collision on a non-1:1 scrolling layer:" + this.Name)
            }
            NewEntity.Layer = this;
            if (Reset === undefined || Reset === true) {
                Entity.ResetToStart(NewEntity);
                NewEntity.Reset()
            }
            if (NewEntity.Box2DBody) {
                this.AddEntityPhysics(NewEntity)
            }
            if (NewEntity.Depth === -1) {
                if (NewEntity.Sprite) {
                    NewEntity.Sprite.Depth = this.NextEntityDepth
                }
                NewEntity.Depth = this.NextEntityDepth;
                this.NextEntityDepth += 1
            }
            var BucketCoords = this.CalcBucketCoords(NewEntity.StartX, NewEntity.StartY);
            var Bucket = this.Buckets[BucketCoords.y * this.BucketsWide + BucketCoords.x];
            Bucket.AddEntity(NewEntity);
            NewEntity.SetParent(this.RootTree);
            if (EntityTypeManager.GetClassFromID(NewEntity.TypeID).UpdateAll) {
                if (!NewEntity.GetIsActiveVisible()) {
                    var i;
                    var Array;
                    for (i = 0; i < this.UpdateAllEntities.length; i += 1) {
                        var TempArray = this.UpdateAllEntities[i];
                        if (TempArray[0].TypeID === NewEntity.TypeID) {
                            Array = TempArray;
                            break
                        }
                    }
                    if (!Array) {
                        this.UpdateAllEntities[this.UpdateAllEntities.length] = [];
                        Array = this.UpdateAllEntities[this.UpdateAllEntities.length - 1]
                    }
                    Array[Array.length] = NewEntity
                }
            }
        },
        RemoveEntity: function RemoveEntityFn(NewEntity, RemoveFromParents) {
            if (NewEntity === undefined || NewEntity === 0) {
                Debug.Log("Trying to remove NULL Entity");
                return
            }
            var Index = this.NewEnabledEntities.indexOf(NewEntity);
            if (Index !== -1) {
                this.NewEnabledEntities.splice(Index, 1)
            }
            Index = this.NewDisabledEntities.indexOf(NewEntity);
            if (Index !== -1) {
                this.NewDisabledEntities.splice(Index, 1)
            }
            Index = this.DisabledEntities.indexOf(NewEntity);
            if (Index !== -1) {
                this.DisabledEntities.splice(Index, 1)
            }
            if (NewEntity.Box2DBody) {
                this.RemoveEntityPhysics(NewEntity)
            }
            if (NewEntity.Bucket) {
                NewEntity.Bucket.RemoveEntity(NewEntity)
            }
            if (EntityTypeManager.GetClassFromID(NewEntity.TypeID).UpdateAll) {
                if (!NewEntity.GetIsActiveVisible()) {
                    var i;
                    for (i = 0; i < this.UpdateAllEntities.length; i += 1) {
                        var Array = this.UpdateAllEntities[i];
                        if (Array[0].TypeID === NewEntity.TypeID) {
                            Index = Array.indexOf(NewEntity);
                            if (Index !== -1) {
                                Array.splice(Index, 1);
                                if (!Array.length) {
                                    Index = this.UpdateAllEntities.indexOf(Array);
                                    this.UpdateAllEntities.splice(Index, 1);
                                    i -= 1
                                }
                            }
                            break
                        }
                    }
                }
            }
            if (RemoveFromParents !== false) {
                var Parents = this.ParentWorld.FindEntityParents(NewEntity);
                var i;
                for (i = 0; i < Parents.length; i += 1) {
                    if (Parents[i].EnableChild) {
                        Parents[i].EnableChild(NewEntity, false)
                    }
                }
            }
            NewEntity.Layer = null;
            NewEntity.ChangeDisabled()
        },
        AddEntityPhysics: function AddEntityPhysicsFn(NewEntity) {
            if (NewEntity.GetIsActive() && NewEntity.Box2DBody) {
                this.PhysicalEntities[this.PhysicalEntities.length] = NewEntity
            }
            if (NewEntity.Box2DBody) {
                Physics.SetBodyActive(NewEntity.Box2DBody, true)
            }
        },
        RemoveEntityPhysics: function RemoveEntityPhysicsFn(NewEntity) {
            if (NewEntity.Box2DBody) {
                Physics.SetBodyActive(NewEntity.Box2DBody, false)
            }
            var Index = this.PhysicalEntities.indexOf(NewEntity);
            if (Index !== -1) {
                this.PhysicalEntities.splice(Index, 1)
            }
        },
        UpdateEntity: function(NewEntity) {
            if (NewEntity.Bucket) {
                NewEntity.Bucket.RemoveEntity(NewEntity)
            }
            var xd = Math.floor(NewEntity.StartX / this.BucketWidth);
            var yd = Math.floor(NewEntity.StartY / this.BucketHeight);
            if (xd < 0) {
                xd = 0
            }
            if (yd < 0) {
                yd = 0
            }
            if (xd >= this.BucketsWide) {
                xd = this.BucketsWide - 1
            }
            if (yd >= this.BucketsHigh) {
                yd = this.BucketsHigh - 1
            }
            var Bucket = this.Buckets[yd * this.BucketsWide + xd];
            Bucket.AddEntity(NewEntity);
            Entity.ResetToStart(NewEntity);
            NewEntity.Reset();
            Entity.UpdateCollision(NewEntity)
        },
        UpdateEntityBucket: function(NewEntity) {
            var xd = Math.floor(NewEntity.x / this.BucketWidth);
            var yd = Math.floor(NewEntity.y / this.BucketHeight);
            if (xd < 0) {
                xd = 0
            }
            if (yd < 0) {
                yd = 0
            }
            if (xd >= this.BucketsWide) {
                xd = this.BucketsWide - 1
            }
            if (yd >= this.BucketsHigh) {
                yd = this.BucketsHigh - 1
            }
            if (xd !== NewEntity.Bucket.x || yd !== NewEntity.Bucket.y) {
                NewEntity.Bucket.RemoveEntity(NewEntity);
                var Bucket = this.Buckets[yd * this.BucketsWide + xd];
                Bucket.AddEntity(NewEntity)
            }
        },
        DisableEntity: function DisableEntity(NewEntity, Remove) {
            var Index = this.NewEnabledEntities.indexOf(NewEntity);
            if (Index !== -1) {
                this.NewEnabledEntities.splice(Index, 1);
                this.DisabledEntities[this.DisabledEntities.length] = NewEntity;
                return
            }
            var Exists = false;
            var i;
            for (i = 0; i < this.Buckets.length; i += 1) {
                for (var j = 0; j < this.Buckets[i].Entities.length; j += 1) {
                    if (this.Buckets[i].Entities[j] === NewEntity) {
                        Exists = true;
                        break
                    }
                }
                if (Exists) {
                    break
                }
            }
            if (Exists) {
                if (this.NewDisabledEntities.indexOf(NewEntity) === -1) {
                    if (this.DisabledEntities.indexOf(NewEntity) !== -1) {
                        NewEntity = NewEntity
                    }
                    Debug.Assert(this.DisabledEntities.indexOf(NewEntity) === -1, "Oh no. This entity exists in the layer AND in the disabled list");
                    NewEntity.Disabled = true;
                    NewEntity.RemoveOnDisable = Remove;
                    this.NewDisabledEntities[this.NewDisabledEntities.length] = NewEntity;
                    NewEntity.ChangeDisabled()
                } else {}
            } else {
                if (this.DisabledEntities.indexOf(NewEntity) !== -1) {} else {
                    Debug.Assert(false, "Entity does not exist in this layer")
                }
            }
        },
        EnableEntity: function EnableEntity(NewEntity, Add) {
            var Index = this.NewDisabledEntities.indexOf(NewEntity);
            if (Index !== -1) {
                this.NewDisabledEntities.splice(Index, 1);
                return
            }
            var Exists;
            Index = this.DisabledEntities.indexOf(NewEntity);
            if (Index !== -1) {
                this.DisabledEntities.splice(Index, 1);
                Exists = true
            }
            if (Exists || !Add) {
                if (this.NewEnabledEntities.indexOf(NewEntity) === -1) {
                    NewEntity.Disabled = false;
                    NewEntity.RemoveOnDisable = Add;
                    this.NewEnabledEntities[this.NewEnabledEntities.length] = NewEntity;
                    NewEntity.ChangeDisabled()
                } else {}
            }
        },
        GetIsEntityDisabled: function GetIsEntityDisabled(NewEntity) {
            var Index = this.DisabledEntities.indexOf(NewEntity);
            if (Index !== -1) {
                return true
            }
            return false
        },
        GetAllEntitiesOfType: function GetAllEntitiesOfTypeFn(EntityTypeID, EntityList, AllowDisabled) {
            var i = 0;
            for (i = 0; i < this.Buckets.length; i += 1) {
                for (var j = 0; j < this.Buckets[i].Entities.length; j += 1) {
                    var Entity = this.Buckets[i].Entities[j];
                    if (Entity.TypeID === EntityTypeID) {
                        EntityList[EntityList.length] = Entity
                    }
                }
            }
            if (AllowDisabled) {
                for (i = 0; i < this.DisabledEntities.length; i += 1) {
                    if (this.DisabledEntities[i].TypeID === EntityTypeID) {
                        EntityList[EntityList.length] = this.DisabledEntities[i]
                    }
                }
            }
        },
        GetAllEntitiesOfObjectIndex: function GetAllEntitiesOfObjectIndexFn(ObjectPaletteIndex, EntityList, AllowDisabled) {
            var i = 0;
            for (i = 0; i < this.Buckets.length; i += 1) {
                for (var j = 0; j < this.Buckets[i].Entities.length; j += 1) {
                    var Entity = this.Buckets[i].Entities[j];
                    if (Entity.ObjectPaletteIndex === ObjectPaletteIndex) {
                        EntityList[EntityList.length] = Entity
                    }
                }
            }
            if (AllowDisabled) {
                for (i = 0; i < this.DisabledEntities.length; i += 1) {
                    if (this.DisabledEntities[i].ObjectPaletteIndex === ObjectPaletteIndex) {
                        EntityList[EntityList.length] = this.DisabledEntities[i]
                    }
                }
            }
        },
        GetAllEntities: function GetAllEntitiesFn(EntityList) {
            for (var i = 0; i < this.Buckets.length; i += 1) {
                for (var j = 0; j < this.Buckets[i].Entities.length; j += 1) {
                    var Entity = this.Buckets[i].Entities[j];
                    EntityList[EntityList.length] = Entity
                }
            }
        },
        FindEntityByName: function FindEntityByNameFn(Name, EntityList) {
            for (var i = 0; i < this.Buckets.length; i += 1) {
                for (var j = 0; j < this.Buckets[i].Entities.length; j += 1) {
                    var Entity = this.Buckets[i].Entities[j];
                    if (Entity.Name === Name) {
                        EntityList[EntityList.length] = Entity
                    }
                }
            }
            for (var i = 0; i < this.DisabledEntities.length; i += 1) {
                var Entity = this.DisabledEntities[i];
                if (Entity.Name === Name) {
                    EntityList[EntityList.length] = Entity
                }
            }
            for (var i = 0; i < this.NewDisabledEntities.length; i += 1) {
                var Entity = this.NewDisabledEntities[i];
                if (Entity.Name === Name) {
                    EntityList[EntityList.length] = Entity
                }
            }
            for (var i = 0; i < this.NewEnabledEntities.length; i += 1) {
                var Entity = this.NewEnabledEntities[i];
                if (Entity.Name === Name) {
                    EntityList[EntityList.length] = Entity
                }
            }
        },
        FindEntityParents: function FindEntityParentsFn(Child, ParentList) {
            var i;
            for (i = 0; i < this.Buckets.length; i += 1) {
                var Bucket = this.Buckets[i];
                var j;
                for (j = 0; j < Bucket.Entities.length; j += 1) {
                    var Entity = Bucket.Entities[j];
                    if (Entity.Children && Entity.Children.indexOf(Child) !== -1) {
                        ParentList[ParentList.length] = Entity
                    }
                }
            }
        },
        OptimiseBucket: function OptimiseBucketFn(ThisBucket) {
            var i, j;
            ThisBucket.TouchingBuckets = [];
            ThisBucket.TouchingBuckets[ThisBucket.TouchingBuckets.length] = ThisBucket;
            var TouchingEntitiesList = [];
            for (j = 0; j < this.Buckets.length; j += 1) {
                if (this.Buckets[j] !== ThisBucket) {
                    if (ThisBucket.GetIsVisible(this.Buckets[j].Left, this.Buckets[j].Top, this.Buckets[j].Right, this.Buckets[j].Bottom)) {
                        ThisBucket.TouchingBuckets[ThisBucket.TouchingBuckets.length] = this.Buckets[j];
                        TouchingEntitiesList[TouchingEntitiesList.length] = this.Buckets[j].Entities
                    }
                }
            }
            ThisBucket.OptimiseStatics(this.RootTree, TouchingEntitiesList)
        },
        Optimise: function OptimiseFn() {
            var i, j;
            for (i = 0; i < this.Buckets.length; i += 1) {
                this.Buckets[i].OptimiseBoundingBox()
            }
            for (i = 0; i < this.Buckets.length; i += 1) {
                this.Buckets[i].Entities.sort(Layer.prototype.ActiveSort)
            }
            if (!this.ParentWorld.OptimiseRunTime) {
                for (i = 0; i < this.Buckets.length; i += 1) {
                    this.OptimiseBucket(this.Buckets[i])
                }
            }
            this.BucketVisibility.Build(this.Buckets)
        },
        AutoSortActive: function AutoSortActiveFn() {
            return;
            var i, j;
            var ActiveEntities = [];
            var NearestDepth = 0;
            for (i = 0; i < this.Buckets.length; i += 1) {
                for (j = 0; j < this.Buckets[i].Entities.length; j += 1) {
                    var ThisEntity = this.Buckets[i].Entities[j];
                    if (ThisEntity.IsActive || ThisEntity.IsActiveVisible) {
                        if (ThisEntity.TypeID !== EntityScroller.TypeID && ThisEntity.TypeID !== EntityGate.TypeID && ThisEntity.TypeID !== EntityGenerator.TypeID && ThisEntity.TypeID !== EntityPad.TypeID && ThisEntity.TypeID !== EntityWaterBody.TypeID && ThisEntity.TypeID !== EntityChopper.TypeID) {
                            ActiveEntities[ActiveEntities.length] = ThisEntity
                        }
                    }
                    if (ThisEntity.TypeID !== EntityTypeManager.GetPlayerTypeID() && ThisEntity.Depth > NearestDepth) {
                        NearestDepth = ThisEntity.Depth
                    }
                }
            }
            ActiveEntities.sort(Layer.prototype.ActiveSort);
            ActiveEntities.sort(Layer.prototype.TypeSort);
            for (i = 0; i < ActiveEntities.length; i += 1) {
                ActiveEntities[i].Depth = NearestDepth;
                ActiveEntities[i].Sprite.Depth = NearestDepth;
                NearestDepth += 1
            }
        },
        ChangeEntityDepth: function ChangeEntityDepthFn(ThisEntity, Closer, ToEnd) {
            var i, j;
            var BestEntity = null;
            for (i = 0; i < this.Buckets.length; i += 1) {
                if (ThisEntity.Bucket.GetIsVisible(this.Buckets[i].Left, this.Buckets[i].Top, this.Buckets[i].Right, this.Buckets[i].Bottom)) {
                    var NewEntity = this.Buckets[i].GetNextDepthEntity(ThisEntity, Closer, ToEnd);
                    if (NewEntity) {
                        if (BestEntity === null) {
                            BestEntity = NewEntity
                        } else {
                            if (ToEnd) {
                                if (Closer && NewEntity.Depth > BestEntity.Depth || !Closer && NewEntity.Depth < BestEntity.Depth) {
                                    BestEntity = NewEntity
                                }
                            } else {
                                if (Closer && NewEntity.Depth < BestEntity.Depth || !Closer && NewEntity.Depth > BestEntity.Depth) {
                                    BestEntity = NewEntity
                                }
                            }
                        }
                    }
                }
            }
            if (BestEntity) {
                var Depth = BestEntity.Depth;
                if (Closer) {
                    Depth += 1
                }
                for (i = 0; i < this.Buckets.length; i += 1) {
                    var thisBucket = this.Buckets[i];
                    for (j = 0; j < thisBucket.Entities.length; j += 1) {
                        if (thisBucket.Entities[j].Depth >= Depth) {
                            var NewDepth = thisBucket.Entities[j].Depth + 1;
                            if (thisBucket.Entities[j].Sprite) {
                                thisBucket.Entities[j].Sprite.Depth = NewDepth
                            } else {
                                if (thisBucket.Entities[j].SpriteList.Depth === thisBucket.Entities[j].Depth) {
                                    thisBucket.Entities[j].SpriteList.Depth = NewDepth
                                }
                            }
                            thisBucket.Entities[j].Depth = NewDepth
                        }
                    }
                }
                ThisEntity.Depth = Depth;
                this.UpdateEntity(ThisEntity);
                ThisEntity.Sprite.Depth = ThisEntity.Depth;
                if (Depth > this.NextEntityDepth) {
                    this.NextEntityDepth = Depth
                }
                var ThisBucket = ThisEntity.Bucket;
                var TouchingBuckets = [];
                for (j = 0; j < this.Buckets.length; j += 1) {
                    if (ThisBucket.GetIsVisible(this.Buckets[j].Left, this.Buckets[j].Top, this.Buckets[j].Right, this.Buckets[j].Bottom)) {
                        TouchingBuckets[TouchingBuckets.length] = this.Buckets[j]
                    }
                }
                for (j = 0; j < TouchingBuckets.length; j += 1) {
                    TouchingBuckets[j].Entities.sort(Layer.prototype.ActiveSort);
                    this.OptimiseBucket(TouchingBuckets[j])
                }
            }
        },
        UpdateEntityCollision: function UpdateEntityCollisionFn(ObjectPaletteIndex, CollisionData) {
            var i;
            for (i = 0; i < this.Buckets.length; i += 1) {
                this.Buckets[i].UpdateEntityCollision(ObjectPaletteIndex, CollisionData)
            }
        },
        GetEntityAt: function GetEntityAtFn(x, y, ReturnAll) {
            var i, j;
            var Local = this.TransformScreenToLocal(x, y);
            var PotentialEntities = [];
            for (i = 0; i < this.BucketsVisible.length; i += 1) {
                var Entities = this.BucketsVisible[i].GetEntityAt(Local.x, Local.y, ReturnAll);
                if (Entities) {
                    for (j = 0; j < Entities.length; j += 1) {
                        if (Entities[j]) {
                            PotentialEntities[PotentialEntities.length] = Entities[j]
                        }
                    }
                }
            }
            if (ReturnAll) {
                return PotentialEntities
            }
            var BestEntity = null;
            for (i = 0; i < PotentialEntities.length; i += 1) {
                if (BestEntity === null || BestEntity.Depth < PotentialEntities[i].Depth) {
                    BestEntity = PotentialEntities[i]
                }
            }
            return BestEntity
        },
        GetEntityAtAllBuckets: function GetEntityAtAllBucketsFn(x, y, ReturnAll) {
            var i, j;
            var PotentialEntities = [];
            for (i = 0; i < this.Buckets.length; i += 1) {
                for (j = 0; j < this.Buckets[i].Entities.length; j += 1) {
                    var ThisEntity = this.Buckets[i].Entities[j];
                    if (x >= ThisEntity.AABB_Left && x <= ThisEntity.AABB_Right && y >= ThisEntity.AABB_Top && y <= ThisEntity.AABB_Bottom) {
                        PotentialEntities[PotentialEntities.length] = ThisEntity
                    }
                }
            }
            if (ReturnAll) {
                return PotentialEntities
            }
            var BestEntity = null;
            for (i = 0; i < PotentialEntities.length; i += 1) {
                if (BestEntity === null || BestEntity.Depth < PotentialEntities[i].Depth) {
                    BestEntity = PotentialEntities[i]
                }
            }
            return BestEntity
        },
        GetEntitiesInBox: function GetEntityInBoxFn(StartPos, EndPos, EntityArrayObject, IndexLayer) {
            for (var i = 0; i < this.Buckets.length; i += 1) {
                for (var j = 0; j < this.Buckets[i].Entities.length; j += 1) {
                    var Entity = this.Buckets[i].Entities[j];
                    if (Entity.AABB_Right >= StartPos.x && Entity.AABB_Left <= EndPos.x && Entity.AABB_Bottom >= StartPos.y && Entity.AABB_Top <= EndPos.y) {
                        var Len = EntityArrayObject.Entities.length;
                        EntityArrayObject.Entities[Len] = Entity;
                        EntityArrayObject.Layers[Len] = IndexLayer
                    }
                }
            }
        },
        SetViewPosition: function SetViewPositionFn(x, y) {
            this.RootTree.SetPosition(x * this.MovementScale.x, y * this.MovementScale.y)
        },
        TransformScreenToLocal: function TransformScreenToLocalFn(xs, ys) {
            var xd = (xs - JamSystem.RenderManager.GetScreenWidth() / 2) / this.Scale - this.RootTree.x;
            var yd = (ys - JamSystem.RenderManager.GetScreenHeight() / 2) / this.Scale - this.RootTree.y;
            return new Vector2(xd, yd)
        },
        TransformLocalToScreen: function TransformLocalToScreenFn(xs, ys) {
            var xd = (xs + this.RootTree.x) * this.Scale + JamSystem.RenderManager.GetScreenWidth() / 2;
            var yd = (ys + this.RootTree.y) * this.Scale + JamSystem.RenderManager.GetScreenHeight() / 2;
            return new Vector2(xd, yd)
        },
        FinaliseView: function FinaliseViewFn() {
            var y, x;
            this.Scale = this.RootTree.Parent.ScaleX;
            this.TopLeft = this.TransformScreenToLocal(0, 0);
            this.BottomRight = this.TransformScreenToLocal(JamSystem.RenderManager.GetScreenWidth(), JamSystem.RenderManager.GetScreenHeight());
            var i;
            for (i = 0; i < this.BucketsVisible.length; i += 1) {
                this.BucketsVisible[i].IsVisible = false
            }
            this.BucketsVisible.length = 0;
            this.BucketVisibility.GetVisibilityList(this.TopLeft.y, this.TopLeft.x, this.BottomRight.y, this.BottomRight.x, this.BucketsVisible)
        },
        UpdateNewChanges: function UpdateNewChangesFn() {
            var i;
            var thisEntity;
            for (i = 0; i < this.NewDisabledEntities.length; i += 1) {
                thisEntity = this.NewDisabledEntities[i];
                if (thisEntity.RemoveOnDisable) {
                    var Box2DBody = thisEntity.Box2DBody;
                    if (Box2DBody) {
                        Physics.WakeTouchingBodies(Box2DBody)
                    }
                    if (thisEntity.Sprite) {
                        this.RemoveEntity(thisEntity, false);
                        i -= 1
                    } else {
                        thisEntity.SpriteList.SetScale(thisEntity.SpriteListIndex, 0, 0);
                        if (thisEntity.Box2DBody) {
                            Physics.SetBodyActive(thisEntity.Box2DBody, false)
                        }
                        if (thisEntity.Bucket) {
                            thisEntity.Bucket.RemoveEntity(thisEntity)
                        }
                    }
                    if (thisEntity.Loaded) {
                        this.DisabledEntities[this.DisabledEntities.length] = thisEntity
                    } else {
                        thisEntity.Destroy()
                    }
                } else {
                    thisEntity.Bucket.MakeEntityInactive(thisEntity)
                }
            }
            this.NewDisabledEntities = [];
            for (i = 0; i < this.NewEnabledEntities.length; i += 1) {
                thisEntity = this.NewEnabledEntities[i];
                if (thisEntity.RemoveOnDisable) {
                    if (thisEntity.Sprite) {
                        this.AddEntity(thisEntity, false)
                    } else {
                        thisEntity.SpriteList.SetScale(thisEntity.SpriteListIndex, thisEntity.StartScaleX, thisEntity.StartScaleY);
                        if (thisEntity.Box2DBody) {
                            Physics.SetBodyActive(thisEntity.Box2DBody, true)
                        }
                        var BucketCoords = this.CalcBucketCoords(thisEntity.StartX, thisEntity.StartY);
                        var Bucket = this.Buckets[BucketCoords.y * this.BucketsWide + BucketCoords.x];
                        Bucket.AddEntity(thisEntity)
                    }
                } else {
                    thisEntity.Bucket.MakeEntityActive(thisEntity)
                }
            }
            this.NewEnabledEntities = []
        },
        Update: function UpdateFn(TimeDelta) {
            if (this.UpdateBuckets) {
                var i;
                var thisEntity;
                for (i = 0; i < this.Buckets.length; i += 1) {
                    if (this.Buckets[i].Actives) {
                        this.Buckets[i].Update(TimeDelta)
                    }
                }
                var i;
                for (i = 0; i < this.UpdateAllEntities.length; i += 1) {
                    var Class = EntityTypeManager.GetClassFromID(this.UpdateAllEntities[i][0].TypeID);
                    Class.UpdateAll(this.UpdateAllEntities[i], TimeDelta)
                }
                this.UpdateNewChanges()
            }
        },
        UpdatePhysics: function UpdatePhysicsFn() {
            var i;
            for (i = 0; i < this.PhysicalEntities.length; i += 1) {
                var NewEntity = this.PhysicalEntities[i];
                if (NewEntity.Box2DBody.IsAwake()) {
                    Physics.UpdateEntityToBody(NewEntity);
                    var xd = Math.floor(NewEntity.x / this.BucketWidth);
                    var yd = Math.floor(NewEntity.y / this.BucketHeight);
                    if (xd < 0) {
                        xd = 0
                    }
                    if (yd < 0) {
                        yd = 0
                    }
                    if (xd >= this.BucketsWide) {
                        xd = this.BucketsWide - 1
                    }
                    if (yd >= this.BucketsHigh) {
                        yd = this.BucketsHigh - 1
                    }
                    if (xd !== NewEntity.Bucket.x || yd !== NewEntity.Bucket.y) {
                        NewEntity.Bucket.RemoveEntity(NewEntity);
                        var Bucket = this.Buckets[yd * this.BucketsWide + xd];
                        Bucket.AddEntity(NewEntity)
                    }
                }
            }
        },
        Reset: function ResetFn() {
            var i, j;
            var ThisBucket;
            var thisEntity;
            Debug.Assert(this.NewDisabledEntities.length === 0, "Shouldn't have new disabled entities");
            Debug.Assert(this.NewEnabledEntities.length === 0, "Shouldn't have new enabled entities");
            for (i = 0; i < this.DisabledEntities.length; i += 1) {
                thisEntity = this.DisabledEntities[i];
                thisEntity.Disabled = false;
                if (thisEntity.RemoveOnDisable) {
                    if (thisEntity.Sprite) {
                        this.AddEntity(thisEntity)
                    } else {
                        thisEntity.SpriteList.SetScale(thisEntity.SpriteListIndex, thisEntity.StartScaleX, thisEntity.StartScaleY);
                        if (thisEntity.Box2DBody) {
                            Physics.SetBodyActive(thisEntity.Box2DBody, true)
                        }
                        var BucketCoords = this.CalcBucketCoords(thisEntity.StartX, thisEntity.StartY);
                        var Bucket = this.Buckets[BucketCoords.y * this.BucketsWide + BucketCoords.x];
                        Bucket.AddEntity(thisEntity)
                    }
                } else {
                    thisEntity.Bucket.MakeEntityActive(thisEntity)
                }
            }
            this.NewDisabledEntities = [];
            this.DisabledEntities = [];
            this.NewEnabledEntities = [];
            for (i = 0; i < this.Buckets.length; i += 1) {
                ThisBucket = this.Buckets[i];
                for (j = ThisBucket.Entities.length - 1; j >= 0; j -= 1) {
                    thisEntity = ThisBucket.Entities[j];
                    if (!thisEntity.Loaded) {
                        this.RemoveEntity(thisEntity, true);
                        thisEntity.Destroy()
                    } else {
                        if (thisEntity.Sprite) {
                            Entity.ResetToStart(thisEntity)
                        }
                    }
                }
            }
            var AllEntities = [];
            for (i = 0; i < this.Buckets.length; i += 1) {
                ThisBucket = this.Buckets[i];
                for (j = 0; j < ThisBucket.Entities.length; j += 1) {
                    AllEntities[AllEntities.length] = ThisBucket.Entities[j]
                }
            }
            for (i = 0; i < AllEntities.length; i += 1) {
                var NewEntity = AllEntities[i];
                if (!NewEntity.IsActive || NewEntity.SpriteList) {
                    NewEntity.Reset()
                } else {
                    this.UpdateEntity(NewEntity)
                }
            }
            this.UpdatePhysics();
            for (i = 0; i < this.PhysicalEntities.length; i += 1) {
                var NewEntity = this.PhysicalEntities[i];
                if (NewEntity.Sprite.Anchor !== EA.Default) {
                    NewEntity.SetEditableVariable(-100, 0)
                }
            }
        },
        ShowEditMode: function ShowEditModeFn(EditActive) {
            var i;
            for (i = 0; i < this.Buckets.length; i += 1) {
                this.Buckets[i].ShowEditMode(EditActive)
            }
        },
        ToggleBucketLines: function ToggleBucketLineFn() {
            this.ShowBucketLines = !this.ShowBucketLines
        },
        ShiftLayerContents: function ShiftLayerFn(Shift) {
            var i = 0,
                j = 0,
                NewEntity = 0;
            for (i = 0; i < this.Buckets.length; i += 1) {
                for (j = 0; j < this.Buckets[i].Entities.length; j += 1) {
                    NewEntity = this.Buckets[i].Entities[j];
                    NewEntity.StartX += Shift.x;
                    NewEntity.StartY += Shift.y;
                    Entity.ResetToStart(NewEntity);
                    NewEntity.Reset()
                }
            }
            for (i = 0; i < this.Buckets.length; i += 1) {
                for (j = 0; j < this.Buckets[i].Entities.length; j += 1) {
                    NewEntity = this.Buckets[i].Entities[j];
                    this.UpdateEntity(NewEntity)
                }
            }
        },
        StaticSort: function ActiveSortFn(SpriteListA, SpriteListB) {
            return SpriteListA.Depth - SpriteListB.Depth
        },
        ActiveSort: function ActiveSortFn(EntityA, EntityB) {
            return EntityA.Depth - EntityB.Depth
        },
        TextureSort: function TextureSortFn(EntityA, EntityB) {
            if (EntityA.Sprite.psTexture.Index < EntityB.Sprite.psTexture.Index) {
                return -1
            }
            if (EntityA.Sprite.psTexture.Index > EntityB.Sprite.psTexture.Index) {
                return 1
            }
            var ImageA = EntityA.Sprite.psTexture.Frames[EntityA.Sprite.Frame].PageIndex;
            var ImageB = EntityB.Sprite.psTexture.Frames[EntityB.Sprite.Frame].PageIndex;
            if (ImageA < ImageB) {
                return -1
            }
            if (ImageA > ImageB) {
                return 1
            }
            return 0
        },
        TypeSort: function TypeSortFn(EntityA, EntityB) {
            return EntityA.TypeID - EntityB.TypeID
        },
        Render: function RenderFn() {
            this.RootTree.UpdateMatrix();
            var i;
            var FinalListArray = [];
            var FinalSpriteArray = [];
            for (i = 0; i < this.BucketsVisible.length; i += 1) {
                this.BucketsVisible[i].RenderStatic(FinalSpriteArray, FinalSpriteArray)
            }
            for (i = 0; i < this.BucketsVisible.length; i += 1) {
                this.BucketsVisible[i].RenderActive(FinalSpriteArray)
            }
            FinalSpriteArray.sort(Layer.prototype.ActiveSort);
            if (Layer.DebugRendering) {
                Debug.Log("Layer : " + this.Name)
            }
            var NumSprites = 0;
            var CurrentTexture = null;
            var CurrentTexture2 = null;
            var CurrentShader = null;
            var CurrentImage = null;
            var CurrentImage2 = undefined;
            var SpriteList = this.ActiveSpriteList;
            SpriteList.Lock();
            var FirstSprite = false;
            for (i = 0; i < FinalSpriteArray.length; i += 1) {
                var Renderable = FinalSpriteArray[i];
                if (!Renderable.Sprite) {
                    if (NumSprites) {
                        if (Layer.DebugRendering) {
                            Debug.Log("Sprites : " + CurrentTexture.FileName + " Count:" + NumSprites)
                        }
                        SpriteList.NumSprites = NumSprites;
                        SpriteList.UnLock();
                        SpriteList.Render();
                        SpriteList.Lock();
                        NumSprites = 0
                    }
                    if (Layer.DebugRendering) {
                        if (Renderable.pszText !== undefined) {
                            Debug.Log("Text : " + Renderable.pszText)
                        } else {
                            Debug.Log("Renderable : " + Renderable.Texture.FileName + " Count:" + Renderable.NumSprites)
                        }
                    }
                    Renderable.Render()
                } else {
                    if (!FirstSprite) {
                        FirstSprite = true
                    }
                    var RequiredTexture = Renderable.psTexture;
                    var RequiredTexture2 = Renderable.psTexture2;
                    var Frame = Renderable.Frame;
                    if (Frame < 0) {
                        Renderable.Frame = 5;
                        Frame = 5
                    }
                    var RequiredImage = RequiredTexture.Frames[Frame].PageIndex;
                    var RequiredImage2 = undefined;
                    if (RequiredTexture2) {
                        RequiredImage2 = RequiredTexture2.Frames[Renderable.Frame2].PageIndex
                    }
                    var RequiredShader = this.DefaultShader;
                    if (Renderable.Shader !== JamSystem.RenderManager.DefaultSpriteShader) {
                        RequiredShader = Renderable.Shader
                    }
                    if (CurrentTexture !== RequiredTexture || CurrentTexture2 !== RequiredTexture2 || CurrentImage !== RequiredImage || CurrentTexture2 && CurrentImage2 !== RequiredImage2 || CurrentShader !== RequiredShader) {
                        if (NumSprites) {
                            if (Layer.DebugRendering) {
                                Debug.Log("Sprites : " + CurrentTexture.FileName + " Count:" + NumSprites)
                            }
                            SpriteList.NumSprites = NumSprites;
                            SpriteList.UnLock();
                            SpriteList.Render();
                            SpriteList.Lock();
                            NumSprites = 0
                        }
                        CurrentShader = RequiredShader;
                        CurrentTexture = RequiredTexture;
                        CurrentTexture2 = RequiredTexture2;
                        CurrentImage = RequiredImage;
                        CurrentImage2 = RequiredImage2;
                        SpriteList.SetTexture(CurrentTexture, CurrentImage);
                        SpriteList.SetTexture2(CurrentTexture2, CurrentImage2);
                        SpriteList.SetShader(CurrentShader)
                    }
                    SpriteList.OutputSprite(Renderable);
                    if (!Renderable.ColourNormal) {
                        SpriteList.SetColour(NumSprites, Renderable.ColourArray)
                    } else {
                        if (!SpriteList.ColourNormal[NumSprites]) {
                            SpriteList.SetColour(NumSprites, [1, 1, 1, 1])
                        }
                    }
                    NumSprites += 1
                }
            }
            if (NumSprites) {
                if (Layer.DebugRendering) {
                    Debug.Log("Sprites : " + CurrentTexture.FileName + " Count:" + NumSprites)
                }
            }
            SpriteList.NumSprites = NumSprites;
            SpriteList.UnLock();
            SpriteList.Render();
            if (!FirstSprite) {} else {}
            World.DebugActiveParticles += this.ParticleSpriteList.NumSprites;
            this.ParticleSpriteList.Render()
        },
        RenderDebugEntitySurrounds: function RenderDebugEntitySurroundsFn() {
            for (var i = 0; i < this.Buckets.length; i += 1) {
                for (var j = 0; j < this.Buckets[i].Entities.length; j += 1) {
                    var Entity = this.Buckets[i].Entities[j];
                    if (Entity.TypeID === EntityNone.TypeID) {
                        var TopLeft = new Vector2(Entity.StartX - Entity.GetWidth() * Entity.StartScaleX / 2, Entity.StartY - Entity.GetHeight() * Entity.StartScaleY / 2);
                        var BottomRight = new Vector2(Entity.StartX + Entity.GetWidth() * Entity.StartScaleX / 2, Entity.StartY + Entity.GetHeight() * Entity.StartScaleY / 2);
                        var TopRight = new Vector2(BottomRight.x, TopLeft.y);
                        var BottomLeft = new Vector2(TopLeft.x, BottomRight.y);
                        if (Entity.StartRotation !== 0) {
                            var CosAlpha = Math.cos(Entity.StartRotation);
                            var SinAlpha = Math.sin(Entity.StartRotation);
                            var LocalX = TopLeft.x - Entity.StartX;
                            var LocalY = TopLeft.y - Entity.StartY;
                            TopLeft.x = LocalX * CosAlpha - LocalY * SinAlpha + Entity.StartX;
                            TopLeft.y = LocalX * SinAlpha + LocalY * CosAlpha + Entity.StartY;
                            LocalX = TopRight.x - Entity.StartX;
                            LocalY = TopRight.y - Entity.StartY;
                            TopRight.x = LocalX * CosAlpha - LocalY * SinAlpha + Entity.StartX;
                            TopRight.y = LocalX * SinAlpha + LocalY * CosAlpha + Entity.StartY;
                            LocalX = BottomRight.x - Entity.StartX;
                            LocalY = BottomRight.y - Entity.StartY;
                            BottomRight.x = LocalX * CosAlpha - LocalY * SinAlpha + Entity.StartX;
                            BottomRight.y = LocalX * SinAlpha + LocalY * CosAlpha + Entity.StartY;
                            LocalX = BottomLeft.x - Entity.StartX;
                            LocalY = BottomLeft.y - Entity.StartY;
                            BottomLeft.x = LocalX * CosAlpha - LocalY * SinAlpha + Entity.StartX;
                            BottomLeft.y = LocalX * SinAlpha + LocalY * CosAlpha + Entity.StartY
                        }
                        JamSystem.RenderManager.DrawDebugLine(TopLeft.x, TopLeft.y, TopRight.x, TopRight.y, [1, 1, 0, 1], this.RootTree.Matrix);
                        JamSystem.RenderManager.DrawDebugLine(BottomLeft.x, BottomLeft.y, BottomRight.x, BottomRight.y, [1, 1, 0, 1], this.RootTree.Matrix);
                        JamSystem.RenderManager.DrawDebugLine(TopLeft.x, TopLeft.y, BottomLeft.x, BottomLeft.y, [1, 1, 0, 1], this.RootTree.Matrix);
                        JamSystem.RenderManager.DrawDebugLine(TopRight.x, TopRight.y, BottomRight.x, BottomRight.y, [1, 1, 0, 1], this.RootTree.Matrix)
                    }
                }
            }
        },
        RenderDebug: function RenderDebugFn() {
            var i, j, Colour;
            if (this.ShowChildrenLines || this.ShowBucketLines) {
                for (i = 0; i < this.BucketsVisible.length; i += 1) {
                    this.BucketsVisible[i].RenderDebug(this.ShowChildrenLines, this.ShowBucketLines, this.RootTree.Matrix)
                }
            }
            if (this.ShowGridLines && this.Zoom > .4) {
                var XAmount = this.Width / this.GridSpace + 1;
                var YAmount = this.Height / this.GridSpace + 1;
                var Addition = Math.floor(this.CameraMove.x / YAmount);
                for (i = Addition - YAmount; i < YAmount + Addition; i += 1) {
                    JamSystem.RenderManager.DrawDebugLine(-JamSystem.RenderManager.GetScreenWidth() * 1.5 + this.CameraMove.x, this.GridSpace * i, JamSystem.RenderManager.GetScreenWidth() * 1.5 + this.CameraMove.x, this.GridSpace * i, [1, 1, 1, 1], this.RootTree.Matrix)
                }
                for (i = Addition - XAmount; i < Addition + XAmount; i += 1) {
                    JamSystem.RenderManager.DrawDebugLine(this.GridSpace * i, -JamSystem.RenderManager.GetScreenHeight() * 1.5 + this.CameraMove.y, this.GridSpace * i, JamSystem.RenderManager.GetScreenHeight() * 1.5 + this.CameraMove.y, [1, 1, 1, 1], this.RootTree.Matrix)
                }
            }
            if (this.ShowLimitLines) {
                Colour = [1, 0, 0, 1];
                JamSystem.RenderManager.DrawDebugLine(0, 0, this.Width, 0, Colour, this.RootTree.Matrix);
                JamSystem.RenderManager.DrawDebugLine(this.Width, 0, this.Width, this.Height, Colour, this.RootTree.Matrix);
                JamSystem.RenderManager.DrawDebugLine(this.Width, this.Height, 0, this.Height, Colour, this.RootTree.Matrix);
                JamSystem.RenderManager.DrawDebugLine(0, this.Height, 0, 0, Colour, this.RootTree.Matrix)
            }
        },
        Clear: function Clear() {
            var i;
            for (i = 0; i < this.Buckets.length; i += 1) {
                this.Buckets[i].Clear()
            }
            for (i = 0; i < this.DisabledEntities.length; i += 1) {
                this.DisabledEntities[i].Destroy()
            }
            this.BucketsVisible = [];
            this.PhysicalEntities = []
        },
        Destroy: function DestroyFn() {
            Helpers.DestroySpriteList(this.ActiveSpriteList);
            this.ActiveSpriteList = null;
            Helpers.DestroySpriteList(this.ParticleSpriteList);
            this.ParticleSpriteList = null;
            Helpers.DestroyTree(this.RootTree);
            this.RootTree = null
        }
    };
    Layer.Create = function LayerCreateFn(ParentWorld, ParentTree, Width, Height, NewMovementScale, BucketWidth, BucketHeight, StaticLayer, Name, Index) {
        var NewObject = new Layer;
        NewObject.ParentWorld = ParentWorld;
        NewObject.Name = Name;
        NewObject.IsVisible = true;
        NewObject.Width = Width;
        NewObject.Height = Height;
        NewObject.Index = Index;
        NewObject.MovementScale = new Vector2(NewMovementScale.x, NewMovementScale.y);
        NewObject.Scale = 1;
        NewObject.RootTree = Helpers.CreateTree(0, 0, ParentTree);
        NewObject.PhysicalEntities = [];
        NewObject.ShowGridLines = false;
        NewObject.ShowLimitLines = false;
        NewObject.ShowBucketLines = false;
        NewObject.ShowChildrenLines = true;
        NewObject.Zoom = 1;
        NewObject.CameraMove = new Vector2;
        NewObject.GridSpace = 64;
        if (StaticLayer === undefined) {
            StaticLayer = true
        }
        NewObject.StaticLayer = StaticLayer;
        NewObject.UpdateBuckets = false;
        NewObject.NextEntityDepth = 1e3;
        NewObject.Buckets = [];
        if (BucketWidth === undefined) {
            BucketWidth = 1e3
        }
        if (BucketHeight === undefined) {
            BucketHeight = 640
        }
        NewObject.BucketWidth = BucketWidth;
        NewObject.BucketHeight = BucketHeight;
        NewObject.BucketsWide = Math.floor(Width / NewObject.BucketWidth) + 1;
        NewObject.BucketsHigh = Math.floor(Height / NewObject.BucketHeight) + 1;
        var y, x;
        for (y = 0; y < NewObject.BucketsHigh; y += 1) {
            for (x = 0; x < NewObject.BucketsWide; x += 1) {
                var k = y * NewObject.BucketsWide + x;
                NewObject.Buckets[k] = Bucket.Create(x, y, NewObject.BucketWidth, NewObject.BucketHeight, NewObject.RootTree, NewObject)
            }
        }
        NewObject.BucketsVisible = [];
        NewObject.BucketVisibility = BucketVisibility.Create(0, 0, Width, Height, NewObject.BucketWidth, NewObject.BucketHeight);
        NewObject.DisabledEntities = [];
        NewObject.NewDisabledEntities = [];
        NewObject.NewEnabledEntities = [];
        NewObject.UpdateAllEntities = [];
        NewObject.ActiveSpriteList = Helpers.CreateSpriteList(2e3, null, NewObject.RootTree);
        if (Application.BuildTestNewSmoke) {
            NewObject.ParticleSpriteList = JamSystem.RenderManager.CreateSpriteList(1e3, null, null);
            NewObject.RootTree.AddChild(NewObject.ParticleSpriteList)
        } else {
            NewObject.ParticleSpriteList = Helpers.CreateSpriteList(2e3, null, NewObject.RootTree)
        }
        NewObject.ParticleSpriteList.NumSprites = 0;
        NewObject.DefaultShader = JamSystem.RenderManager.DefaultSpriteShader;
        return NewObject
    };

    function EntityCollisionData() {}
    EntityCollisionData.prototype = {
        Circle: false,
        CircleRadius: 0,
        Density: 1,
        Friction: .5,
        Restitution: .2,
        CollisionPoints: []
    };

    function Entity() {}
    Entity.prototype = {
        GetIsAt: function GetIsAtFn(x, y) {
            return this.Sprite.GetIsAt(x, y)
        },
        GetIsOnEdge: function GetIsOnEdgeFn(x, y) {
            return this.Sprite.GetIsOnEdge(x, y)
        },
        SetParent: function SetParentFn(Parent) {
            Debug.Assert(this.Sprite);
            Parent.AddChild(this.Sprite)
        },
        GetIsActive: function GetIsActiveFn() {
            return this.IsActive
        },
        GetIsActiveVisible: function GetIsActiveVisibleFn() {
            return this.IsActiveVisible
        },
        SetIsVisible: function SetIsVisibleFn(Visible) {
            this.Sprite.SetIsVisible(Visible)
        },
        GetIsCollidable: function GetIsCollidableFn() {
            return this.IsCollidable
        },
        SetColour: function SetColourFn(Colour) {
            this.TrueColour = Colour;
            if (Colour !== 0) {
                this.Sprite.SetColour(Colour)
            }
        },
        SetEditorColour: function SetEditorColourFn(Colour) {
            this.Sprite.SetColour(Colour)
        },
        ResetEditorColour: function ResetEditorColourFn() {
            if (this.TrueColour === 0) {
                this.TrueColour = [1, 1, 1, 1]
            }
            this.Sprite.SetColour(this.TrueColour)
        },
        GetColour: function GetColourFn() {
            if (this.TrueColour) {
                return this.TrueColour
            }
            if (this.Sprite) {
                return this.Sprite.GetColour()
            }
            return 0
        },
        SetSecondImage: function SetSecondImageFn(Image) {
            this.SecondTexture = true;
            var Info = Helpers.GetTextureInfoFromImageName(Image);
            this.Sprite.SetTexture2(Info.Texture, Info.Frame);
            this.Sprite.SetShader(JamSystem.RenderManager.DefaultSpriteShader2)
        },
        CalcBoundingBox: function CalcBoundingBoxFn() {
            Entity.CalcBoundingBox(this)
        },
        GetDoesOverlap: function GetDoesOverlapFn(TestEntity) {
            if (this.AABB_Right <= TestEntity.AABB_Left || this.AABB_Left > TestEntity.AABB_Right || this.AABB_Bottom <= TestEntity.AABB_Top || this.AABB_Top > TestEntity.AABB_Bottom) {
                return false
            }
            return true
        },
        Reset: function ResetFn() {
            Entity.ResetToStart(this)
        },
        Update: function UpdateFn(TimeDelta) {},
        ShowEditMode: function ShowEditModeFn(EditActive) {},
        GetWidth: function GetWidthFn() {
            return this.Sprite.GetWidth()
        },
        GetHeight: function GetHeightFn() {
            return this.Sprite.GetHeight()
        },
        Copy: function CopyFn(OldEntity) {
            Entity.Copy(this, OldEntity)
        },
        ChangeDisabled: function ChangeDisabledFn() {},
        AddChild: function AddChildFn(Child) {
            Entity.AddChild(this, Child)
        },
        RemoveChild: function RemoveChildFn(Child) {
            Entity.RemoveChild(this, Child)
        },
        SetEditableVariable: function SetEditableVariableFn(VariableIndex, Value) {
            if (VariableIndex >= 0) {
                this.EditableVariables[VariableIndex] = Value
            }
            if (this.UpdateEditableVariable) {
                this.UpdateEditableVariable(VariableIndex)
            }
        },
        Delete: function Delete() {},
        UnDelete: function UnDelete() {},
        Destroy: function Destroy() {
            Entity.Destroy(this)
        }
    };
    Entity.ResetToStart = function ResetToStartFn(thisEntity) {
        if (thisEntity.Sprite) {
            thisEntity.x = thisEntity.StartX;
            thisEntity.y = thisEntity.StartY;
            if (thisEntity.Box2DBody) {
                Physics.SetBody(thisEntity.Box2DBody, thisEntity.StartX, thisEntity.StartY, thisEntity.StartRotation)
            }
            if (thisEntity.Sprite.SetPosition) {
                thisEntity.Sprite.SetPosition(thisEntity.StartX, thisEntity.StartY);
                thisEntity.Sprite.SetRotation(thisEntity.StartRotation);
                thisEntity.Sprite.SetScale(thisEntity.StartScaleX, thisEntity.StartScaleY)
            }
        }
    };
    Entity.Clone = function CloneFn(thisEntity) {
        var NewEntity = WorldFileManager.CreateEntity(thisEntity.StartX, thisEntity.StartY, thisEntity.StartRotation, thisEntity.StartScaleX, thisEntity.StartScaleY, null, thisEntity.ObjectPaletteIndex, 0);
        NewEntity.Copy(NewEntity, thisEntity);
        return NewEntity
    };
    Entity.Copy = function CopyFn(thisEntity, OldEntity) {
        var i;
        for (i = 0; i < OldEntity.EditableVariables.length; i += 1) {
            thisEntity.SetEditableVariable(i, OldEntity.EditableVariables[i])
        }
    };
    Entity.CalcBoundingBox = function CalcBoundingBoxFn(thisEntity) {
        var Width, Height;
        if (thisEntity.Sprite.psTexture && thisEntity.Sprite.Frame !== -1) {
            var Frame = thisEntity.Sprite.psTexture.GetFrame(thisEntity.Sprite.Frame);
            Width = Frame.Width / 2 * thisEntity.Sprite.ScaleX;
            Height = Frame.Height / 2 * thisEntity.Sprite.ScaleY
        } else {
            Width = 10;
            Height = 10
        }
        if (Width < 0) {
            Width = -Width
        }
        if (Height < 0) {
            Height = -Height
        }
        thisEntity.AABB_Left = thisEntity.Sprite.x - Width;
        thisEntity.AABB_Right = thisEntity.Sprite.x + Width;
        thisEntity.AABB_Top = thisEntity.Sprite.y - Height;
        thisEntity.AABB_Bottom = thisEntity.Sprite.y + Height
    };
    Entity.UpdateCollision = function UpdateCollisionFn(thisEntity, CollisionData) {
        thisEntity.CalcBoundingBox();
        if (thisEntity.Box2DBody) {
            if (CollisionData === undefined) {
                CollisionData = ObjectPaletteManager.ObjectPalette[thisEntity.ObjectPaletteIndex].Collision
            }
            if (thisEntity.Sprite) {
                Physics.UpdateFixture(thisEntity.Box2DBody, CollisionData, thisEntity.StartScaleX, thisEntity.StartScaleY, thisEntity)
            } else {
                var Index = thisEntity.SpriteListIndex;
                Physics.UpdateFixture(thisEntity.Box2DBody, CollisionData, thisEntity.StartScaleX, thisEntity.StartScaleY, thisEntity)
            }
        }
    };
    Entity.TestCollision = function TestCollisionFn(thisEntity, WithPhysics, WithCollidables) {
        thisEntity.CalcBoundingBox();
        if (WithPhysics) {
            Physics.TestBoundingBoxCollision(thisEntity)
        }
        if (WithCollidables) {
            var TableA = Physics.CollisionTable[thisEntity.TypeID];
            if (!TableA) {
                return
            }
            var i, j, k;
            for (k = 0; k < EntityTypeManager.GetNumRegisteredTypes(); k += 1) {
                if (TableA[k] !== false && TableA[k] !== undefined) {
                    for (i = 0; i < thisEntity.Bucket.TouchingBuckets.length; i += 1) {
                        var Entities = thisEntity.Bucket.TouchingBuckets[i].CollidableEntities;
                        var EntityList = Entities[k];
                        for (j = 0; j < EntityList.length; j += 1) {
                            var TestEntity = EntityList[j];
                            if (TestEntity.IsActive) {
                                if (thisEntity.GetDoesOverlap(TestEntity)) {
                                    TableA[k](thisEntity, TestEntity, null)
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    Entity.AddChild = function AddChildFn(thisEntity, childEntity) {
        if (thisEntity.Children === null) {
            thisEntity.Children = []
        }
        thisEntity.Children[thisEntity.Children.length] = childEntity
    };
    Entity.RemoveChild = function RemoveChildFn(thisEntity, childEntity) {
        Debug.Assert(thisEntity.Children !== null);
        var Index = thisEntity.Children.indexOf(childEntity);
        if (Index !== -1) {
            thisEntity.Children.splice(Index, 1)
        }
    };
    Entity.TransformLocalToWorld = function TransformLocalToWorldFn(thisEntity, Local) {
        var Scaled = new Vector2;
        Scaled.x = Local.x * thisEntity.Sprite.ScaleX;
        Scaled.y = Local.y * thisEntity.Sprite.ScaleY;
        var World = new Vector2;
        var CosAngle = Math.cos(thisEntity.Sprite.Rotation);
        var SinAngle = Math.sin(thisEntity.Sprite.Rotation);
        World.x = Scaled.x * CosAngle - Scaled.y * SinAngle;
        World.y = Scaled.x * SinAngle + Scaled.y * CosAngle;
        World.x += thisEntity.Sprite.x;
        World.y += thisEntity.Sprite.y;
        return World
    };
    Entity.TransformWorldToLocal = function TransformWorldToLocalFn(thisEntity, World) {
        var Local = new Vector2;
        Local.x = World.x;
        Local.y = World.y;
        Local.x -= thisEntity.Sprite.x;
        Local.y -= thisEntity.Sprite.y;
        var CosAngle = Math.cos(-thisEntity.Sprite.Rotation);
        var SinAngle = Math.sin(-thisEntity.Sprite.Rotation);
        var Rotated = new Vector2;
        Rotated.x = Local.x * CosAngle - Local.y * SinAngle;
        Rotated.y = Local.x * SinAngle + Local.y * CosAngle;
        var Scaled = new Vector2;
        Scaled.x = Rotated.x / thisEntity.Sprite.ScaleX;
        Scaled.y = Rotated.y / thisEntity.Sprite.ScaleY;
        return Scaled
    };
    Entity.TransformPositionToScreen = function TransformPositionToScreenFn(x, y) {
        var Screen = new Vector2;
        Screen.x = x;
        Screen.y = y;
        Screen.x -= GlobalMain.CameraManager.Camera.GetPosition().x;
        Screen.y -= GlobalMain.CameraManager.Camera.GetPosition().y;
        Screen.x *= GlobalMain.CameraManager.Camera.GetAdjustedZoom();
        Screen.y *= GlobalMain.CameraManager.Camera.GetAdjustedZoom();
        Screen.x += JamSystem.RenderManager.GetScreenWidth() / 2;
        Screen.y += JamSystem.RenderManager.GetScreenHeight() / 2;
        return Screen
    };
    Entity.GetIsInView = function GetIsInViewFn(thisEntity) {
        if (!thisEntity.Bucket) {
            return false
        }
        if (!thisEntity.Bucket.IsVisible) {
            return false
        }
        if (thisEntity.AABB_Bottom > thisEntity.Layer.TopLeft.y && thisEntity.AABB_Top < thisEntity.Layer.BottomRight.y && thisEntity.AABB_Right > thisEntity.Layer.TopLeft.x && thisEntity.AABB_Left < thisEntity.Layer.BottomRight.x) {
            return true
        }
        return false
    };
    Entity.GetDistance = function GetDistanceFn(thisEntity, x, y) {
        var xd = x - thisEntity.x;
        var yd = y - thisEntity.y;
        var d = Math.sqrt(xd * xd + yd * yd);
        return d
    };
    Entity.SetPosition = function SetPositionFn(thisEntity, x, y) {
        thisEntity.x = x;
        thisEntity.y = y;
        thisEntity.Sprite.SetPosition(x, y);
        if (thisEntity.Layer) {
            thisEntity.Layer.UpdateEntityBucket(thisEntity)
        }
    };
    Entity.Destroy = function DestroyFn(thisEntity) {
        Helpers.DestroySprite(thisEntity.Sprite)
    };
    Entity.Create = function EntityCreateFn(x, y, Rotation, ScaleX, ScaleY, Name, DefaultImage, Active) {
        var NewObject = new Entity;
        NewObject.TypeID = 0;
        NewObject.x = x;
        NewObject.y = y;
        NewObject.StartX = x;
        NewObject.StartY = y;
        NewObject.StartScaleX = ScaleX;
        NewObject.StartScaleY = ScaleY;
        NewObject.StartRotation = Rotation;
        NewObject.IsActive = Active;
        NewObject.IsActiveVisible = false;
        NewObject.IsCollidable = false;
        NewObject.Depth = -1;
        NewObject.Name = Name;
        NewObject.Layer = null;
        NewObject.Disabled = false;
        NewObject.Selected = false;
        NewObject.Loaded = true;
        NewObject.ObjectPaletteIndex = -1;
        NewObject.Bucket = null;
        NewObject.AABB_Left = x;
        NewObject.AABB_Right = x;
        NewObject.AABB_Top = y;
        NewObject.AABB_Bottom = y;
        NewObject.Sprite = Helpers.CreateSprite(x, y, EA.Default, DefaultImage, 0);
        NewObject.Sprite.SetRotation(Rotation);
        NewObject.Sprite.SetScale(ScaleX, ScaleY);
        NewObject.Box2DBody = 0;
        NewObject.EditableVariables = [];
        NewObject.Children = null;
        NewObject.TrueColour = 0;
        return NewObject
    };

    function EntityAnimating() {}
    EntityAnimating.Name = "Animating";
    EntityAnimating.AnimationID = 0;
    EntityAnimating.RandomStartID = 1;
    EntityAnimating.EditableVariables = [{
        Name: "Type",
        Type: "Combo",
        Combo: ["Default"],
        Default: 0,
        Info: "What animation to play."
    }, {
        Name: "Random Start",
        Type: "Boolean",
        Default: true,
        Info: "Start the animation in a random place."
    }];
    EntityAnimating.prototype = {
        Reset: function ResetFn() {
            if (this.EditableVariables[EntityAnimating.RandomStartID]) {
                this.SpriteAnimation.CurrentFrame = Math.floor(Math.random() * this.SpriteAnimation.AnimationData.Frames.length);
                this.SpriteAnimation.FrameTime = Math.random() * this.SpriteAnimation.AnimationData.Frames[this.SpriteAnimation.CurrentFrame].Delay
            } else {
                this.SpriteAnimation.CurrentFrame = 0;
                this.SpriteAnimation.FrameTime = 0
            }
        },
        Update: function UpdateFn(TimeDelta) {
            if (this.Bucket.IsVisible) {
                this.SpriteAnimation.Update(TimeDelta)
            }
        },
        UpdateEditableVariable: function UpdateEditableVariableFn(VariableIndex) {
            if (VariableIndex === EntityAnimating.AnimationID) {
                var Animation = this.EditableVariables[EntityAnimating.AnimationID];
                this.SpriteAnimation.SetData(EntityAnimating.Animations[Animation])
            }
        },
        Destroy: function DestroyFn() {
            JamSystem.RenderManager.DestroySpriteAnimation(this.SpriteAnimation);
            Entity.Destroy(this)
        }
    };
    EntityAnimating.RegisterAnimations = function RegisterAnimations(Animations) {
        EntityAnimating.Animations = Animations;
        var Combo = EntityAnimating.EditableVariables[EntityAnimating.AnimationID].Combo;
        Combo.length = 0;
        var i;
        for (i = 0; i < Animations.length; i += 1) {
            Combo[i] = Animations[i].Name
        }
    };
    EntityAnimating.Create = function EntityAnimatingFn(x, y, Rotation, ScaleX, ScaleY, Name, Image, Collision) {
        var NewObject = Entity.Create(x, y, Rotation, ScaleX, ScaleY, Name, Image, true);
        NewObject.Reset = EntityAnimating.prototype.Reset;
        NewObject.Update = EntityAnimating.prototype.Update;
        NewObject.UpdateEditableVariable = EntityAnimating.prototype.UpdateEditableVariable;
        NewObject.Destroy = EntityAnimating.prototype.Destroy;
        NewObject.TypeID = EntityAnimating.TypeID;
        NewObject.SpriteAnimation = JamSystem.RenderManager.CreateSpriteAnimation(NewObject.Sprite);
        NewObject.SpriteAnimation.SetData(EntityAnimating.Animations[0]);
        return NewObject
    };

    function EntityNone() {}
    EntityNone.Name = "None";
    EntityNone.prototype = {
        SetIsVisible: function SetIsVisibleFn(Visible) {
            if (this.Sprite) {
                this.Sprite.SetIsVisible(Visible)
            } else {
                if (Visible) {
                    this.SpriteList.SetScale(this.SpriteListIndex, this.StartScaleX, this.StartScaleY)
                } else {
                    this.SpriteList.SetScale(this.SpriteListIndex, 0, 0)
                }
            }
        },
        GetIsAt: function GetIsAtFn(x, y) {
            if (this.Sprite) {
                return this.Sprite.GetIsAt(x, y)
            } else {
                return false
            }
        },
        GetIsOnEdge: function GetIsOnEdgeFn(x, y) {
            if (this.Sprite) {
                return this.Sprite.GetIsOnEdge(x, y)
            } else {
                return this.SpriteList.GetIsOnEdge(this.SpriteListIndex, x, y)
            }
        },
        SetColour: function SetColourFn(Colour) {
            this.TrueColour = Colour;
            if (this.Sprite) {
                this.Sprite.SetColour(Colour)
            } else {
                this.SpriteList.SetColour(this.SpriteListIndex, Colour)
            }
        },
        GetColour: function GetColourFn() {
            if (this.TrueColour) {
                return this.TrueColour
            }
            if (this.Sprite) {
                return this.Sprite.GetColour()
            } else {
                return this.SpriteList.GetColour(this.SpriteListIndex)
            }
            return 0
        },
        SetEditorColour: function SetEditorColourFn(Colour) {
            if (this.Sprite) {
                this.Sprite.SetColour(Colour)
            } else {
                this.SpriteList.SetColour(this.SpriteListIndex, Colour)
            }
        },
        ResetEditorColour: function ResetEditorColourFn() {
            if (this.TrueColour === 0) {
                this.TrueColour = [1, 1, 1, 1]
            }
            if (this.Sprite) {
                this.Sprite.SetColour(this.TrueColour)
            } else {
                this.SpriteList.SetColour(this.SpriteListIndex, this.TrueColour)
            }
        },
        SetSecondImage: function SetSecondImageFn(Image) {
            this.SecondTexture = true;
            var Info = Helpers.GetTextureInfoFromImageName(Image);
            if (this.Sprite) {
                this.Sprite.SetTexture2(Info.Texture, Info.Frame);
                this.Sprite.SetShader(JamSystem.RenderManager.DefaultSpriteShader2)
            } else {
                this.SpriteList.SetTexture2(Info.Texture, Info.Texture.Frames[Info.Frame].PageIndex);
                this.SpriteList.SetFrame2(this.SpriteListIndex, Info.Frame);
                this.SpriteList.SetShader(JamSystem.RenderManager.DefaultSpriteShader2)
            }
        },
        CalcBoundingBox: function CalcBoundingBoxFn() {
            if (this.SpriteList) {
                var Index = this.SpriteListIndex;
                this.AABB_Left = this.SpriteList.AABB_Left[Index];
                this.AABB_Right = this.SpriteList.AABB_Right[Index];
                this.AABB_Top = this.SpriteList.AABB_Top[Index];
                this.AABB_Bottom = this.SpriteList.AABB_Bottom[Index]
            } else {
                var Width, Height;
                if (this.Sprite.Frame !== -1) {
                    var Frame = this.Sprite.psTexture.GetFrame(this.Sprite.Frame);
                    Width = Frame.Width / 2;
                    Height = Frame.Height / 2
                } else {
                    Width = 10;
                    Height = 10
                }
                var Vertices = [];
                Vertices[0] = Entity.TransformLocalToWorld(this, new Vector2(-Width, -Height));
                Vertices[1] = Entity.TransformLocalToWorld(this, new Vector2(Width, -Height));
                Vertices[2] = Entity.TransformLocalToWorld(this, new Vector2(Width, Height));
                Vertices[3] = Entity.TransformLocalToWorld(this, new Vector2(-Width, Height));
                this.AABB_Top = Vertices[0].y;
                this.AABB_Bottom = Vertices[0].y;
                this.AABB_Left = Vertices[0].x;
                this.AABB_Right = Vertices[0].x;
                var j;
                for (j = 1; j < 4; j += 1) {
                    if (this.AABB_Top > Vertices[j].y) {
                        this.AABB_Top = Vertices[j].y
                    }
                    if (this.AABB_Bottom < Vertices[j].y) {
                        this.AABB_Bottom = Vertices[j].y
                    }
                    if (this.AABB_Left > Vertices[j].x) {
                        this.AABB_Left = Vertices[j].x
                    }
                    if (this.AABB_Right < Vertices[j].x) {
                        this.AABB_Right = Vertices[j].x
                    }
                }
            }
        },
        SetSpriteList: function SetSpriteListFn(NewSpriteList, SpriteIndex) {
            if (this.Sprite) {
                this.SpriteList = NewSpriteList;
                this.SpriteListIndex = SpriteIndex;
                this.SpriteList.SetPosition(SpriteIndex, this.Sprite.x, this.Sprite.y);
                this.SpriteList.SetScale(SpriteIndex, this.Sprite.ScaleX, this.Sprite.ScaleY);
                this.SpriteList.SetRotation(SpriteIndex, this.Sprite.Rotation);
                this.SpriteList.SetAnchor(SpriteIndex, this.Sprite.Anchor);
                this.SpriteList.SetFrame(SpriteIndex, this.Sprite.Frame);
                this.SpriteList.SetShader(this.Sprite.Shader);
                var MainColour = this.Sprite.GetColour();
                this.SpriteList.SetColour(SpriteIndex, MainColour);
                if (this.Sprite.psTexture2) {
                    this.SpriteList.SetTexture2(this.Sprite.psTexture2, this.Sprite.psTexture2.Frames[this.Sprite.Frame2].PageIndex);
                    this.SpriteList.SetFrame2(SpriteIndex, this.Sprite.Frame2)
                }
                Helpers.DestroySprite(this.Sprite);
                this.Sprite = null
            }
        },
        ClearSpriteList: function ClearSpriteListFn() {
            if (this.SpriteList) {
                var Index = this.SpriteListIndex;
                this.Sprite = Helpers.CreateSpriteWithInfo(this.SpriteList.x[Index], this.SpriteList.y[Index], EA.Default, this.SpriteList.Texture, this.SpriteList.Frame[Index], this.SpriteList.Parent);
                if (this.SpriteList.Texture2) {
                    this.Sprite.SetTexture2(this.SpriteList.Texture2, this.SpriteList.Frame2[Index])
                }
                this.Sprite.SetShader(this.SpriteList.Shader);
                this.Sprite.SetRotation(this.SpriteList.Rotation[Index]);
                this.Sprite.SetScale(this.SpriteList.ScaleX[Index], this.SpriteList.ScaleY[Index]);
                var MainColour = this.SpriteList.GetColour(Index);
                this.Sprite.SetColour(MainColour);
                this.Sprite.Depth = this.Depth;
                this.SpriteList.SetScale(Index, 0, 0);
                this.SpriteList = null;
                this.SpriteListIndex = -1
            }
        },
        GetWidth: function GetWidthFn() {
            if (this.Sprite) {
                return this.Sprite.GetWidth()
            } else {
                var Index = this.SpriteListIndex;
                return this.SpriteList.GetWidth(Index)
            }
        },
        GetHeight: function GetHeightFn() {
            if (this.Sprite) {
                return this.Sprite.GetHeight()
            } else {
                var Index = this.SpriteListIndex;
                return this.SpriteList.GetHeight(Index)
            }
        },
        Destroy: function Destroy() {
            EntityNone.Destroy(this)
        }
    };
    EntityNone.Destroy = function DestroyFn(thisEntity) {
        if (thisEntity.Sprite) {
            Helpers.DestroySprite(thisEntity.Sprite)
        } else {
            thisEntity.SpriteList.SetScale(thisEntity.SpriteListIndex, 0, 0);
            thisEntity.SpriteList = null;
            thisEntity.SpriteListIndex = -1
        }
    };
    EntityNone.Create = function EntityNoneFn(x, y, Rotation, ScaleX, ScaleY, Name, Image, Collision) {
        var NewObject = Entity.Create(x, y, Rotation, ScaleX, ScaleY, Name, Image, false);
        NewObject.SetSpriteList = EntityNone.prototype.SetSpriteList;
        NewObject.ClearSpriteList = EntityNone.prototype.ClearSpriteList;
        NewObject.SetIsVisible = EntityNone.prototype.SetIsVisible;
        NewObject.GetIsAt = EntityNone.prototype.GetIsAt;
        NewObject.GetIsOnEdge = EntityNone.prototype.GetIsOnEdge;
        NewObject.SetColour = EntityNone.prototype.SetColour;
        NewObject.CalcBoundingBox = EntityNone.prototype.CalcBoundingBox;
        NewObject.GetWidth = EntityNone.prototype.GetWidth;
        NewObject.GetHeight = EntityNone.prototype.GetHeight;
        NewObject.Destroy = EntityNone.prototype.Destroy;
        NewObject.GetColour = EntityNone.prototype.GetColour;
        NewObject.SetEditorColour = EntityNone.prototype.SetEditorColour;
        NewObject.ResetEditorColour = EntityNone.prototype.ResetEditorColour;
        NewObject.SpriteList = 0;
        NewObject.SpriteListIndex = -1;
        NewObject.TypeID = EntityNone.TypeID;
        return NewObject
    };

    function EntityStatic() {}
    EntityStatic.Name = "Static";
    EntityStatic.prototype = {
        Destroy: function Destroy() {
            EntityStatic.Destroy(this)
        }
    };
    EntityStatic.Destroy = function DestroyFn(thisEntity) {
        Physics.DestroyBody(thisEntity.Box2DBody);
        EntityNone.Destroy(thisEntity)
    };
    EntityStatic.Create = function EntityStaticFn(x, y, Rotation, ScaleX, ScaleY, Name, Image, Collision) {
        var NewObject = EntityNone.Create(x, y, Rotation, ScaleX, ScaleY, Name, Image);
        NewObject.TypeID = EntityStatic.TypeID;
        NewObject.Destroy = EntityStatic.prototype.Destroy;
        NewObject.Box2DBody = Physics.CreateBody(x, y, Rotation, ScaleX, ScaleY, false, Collision, NewObject);
        Physics.SetCollisionFilter(NewObject.Box2DBody, EntityStatic.TypeID);
        return NewObject
    };

    function EntityDynamic() {}
    EntityDynamic.Name = "Dynamic";
    EntityDynamic.prototype = {
        Destroy: function Destroy() {
            EntityDynamic.Destroy(this)
        }
    };
    EntityDynamic.Destroy = function DestroyFn(thisEntity) {
        Physics.DestroyBody(thisEntity.Box2DBody);
        Entity.Destroy(thisEntity)
    };
    EntityDynamic.Create = function EntityDynamicFn(x, y, Rotation, ScaleX, ScaleY, Name, Image, Collision) {
        var NewObject = Entity.Create(x, y, Rotation, ScaleX, ScaleY, Name, Image, true);
        NewObject.TypeID = EntityDynamic.TypeID;
        NewObject.Destroy = EntityDynamic.prototype.Destroy;
        NewObject.Box2DBody = Physics.CreateBody(x, y, Rotation, ScaleX, ScaleY, true, Collision, NewObject);
        Physics.SetCollisionFilter(NewObject.Box2DBody, EntityDynamic.TypeID);
        return NewObject
    };

    function EntityGroup() {}
    EntityGroup.Name = "Group";
    EntityGroup.prototype = {
        EnableChild: function EnableChildFn(thisEntity, Enabled) {
            if (!thisEntity.Loaded) {
                return
            }
            if (!Enabled && (thisEntity.Layer || !thisEntity.Disabled)) {
                thisEntity.Layer.DisableEntity(thisEntity, true)
            } else if (Enabled && (thisEntity.Layer === null || thisEntity.Disabled)) {
                if (thisEntity.Layer === null) {
                    var EntityLayer = this.Layer.ParentWorld.GetDisabledEntityLayer(thisEntity);
                    EntityLayer.EnableEntity(thisEntity, true)
                } else {
                    thisEntity.Layer.EnableEntity(thisEntity, true)
                }
            }
            if (thisEntity.Children) {
                var i;
                for (i = 0; i < thisEntity.Children.length; i += 1) {
                    var thisChild = thisEntity.Children[i];
                    this.EnableChild(thisChild, Enabled)
                }
            }
        },
        EnableChildren: function EnableChildrenFn(Enabled) {
            var i;
            for (i = 0; i < this.Children.length; i += 1) {
                var thisEntity = this.Children[i];
                this.EnableChild(thisEntity, Enabled)
            }
        },
        ShowEditMode: function ShowEditModeFn(EditActive) {
            this.SetIsVisible(EditActive)
        }
    };
    EntityGroup.Create = function EntityGroupFn(x, y, Rotation, ScaleX, ScaleY, Name, Image, Collision) {
        var NewObject = EntityNone.Create(x, y, Rotation, ScaleX, ScaleY, Name, Image, Collision);
        NewObject.EnableChild = EntityGroup.prototype.EnableChild;
        NewObject.EnableChildren = EntityGroup.prototype.EnableChildren;
        NewObject.ShowEditMode = EntityGroup.prototype.ShowEditMode;
        NewObject.TypeID = EntityGroup.TypeID;
        return NewObject
    };

    function EntityJoint() {}
    EntityJoint.Name = "Joint";
    EntityJoint.VisibleID = 0;
    EntityJoint.EditableVariables = [{
        Name: "Visible",
        Type: "Boolean",
        Default: false
    }];
    EntityJoint.prototype = {
        ShowEditMode: function ShowEditModeFn(EditActive) {
            if (!this.EditableVariables[EntityJoint.VisibleID]) {
                this.SetIsVisible(EditActive)
            }
        },
        AddChild: function AddChildFn(Child) {
            if (!Child.Box2DBody) {
                return
            }
            if (this.Children && this.Children.length >= 2) {
                return
            }
            Entity.AddChild(this, Child)
        },
        RemoveChild: function RemoveChildFn(Child) {
            EntityJoint.DestroyJoint(this);
            Entity.RemoveChild(this, Child)
        },
        EnableChild: function EnableChildFn(Child, Enabled) {
            EntityJoint.DestroyJoint(this)
        },
        Destroy: function Destroy() {
            EntityJoint.DestroyJoint(this);
            Entity.Destroy(this)
        }
    };
    EntityJoint.DestroyJoint = function DestroyJointFn(thisEntity) {
        if (thisEntity.Joint) {
            Physics.DestroyJoint(thisEntity.Joint);
            thisEntity.Joint = null
        }
    };
    EntityJoint.Create = function EntityJointFn(x, y, Rotation, ScaleX, ScaleY, Name, Image) {
        var NewObject = Entity.Create(x, y, Rotation, ScaleX, ScaleY, Name, Image, true);
        NewObject.EnableChildren = EntityJoint.prototype.EnableChildren;
        NewObject.ShowEditMode = EntityJoint.prototype.ShowEditMode;
        NewObject.AddChild = EntityJoint.prototype.AddChild;
        NewObject.RemoveChild = EntityJoint.prototype.RemoveChild;
        NewObject.EnableChild = EntityJoint.prototype.EnableChild;
        NewObject.Destroy = EntityJoint.prototype.Destroy;
        NewObject.TypeID = EntityJoint.TypeID;
        NewObject.Joint = null;
        return NewObject
    };

    function EntityPin() {}
    EntityPin.Name = "Pin";
    EntityJoint.VisibleID = 0;
    EntityPin.CollideID = 1;
    EntityPin.EditableVariables = [EntityJoint.EditableVariables[0], {
        Name: "Collide",
        Type: "Boolean",
        Default: true,
        Info: "The attached objects will\ncollide with each other."
    }];
    EntityPin.prototype = {
        Reset: function ResetFn() {
            EntityJoint.DestroyJoint(this);
            if (this.Children && this.Children.length === 2 && this.Children[0].Box2DBody && this.Children[1].Box2DBody) {
                this.Joint = Physics.CreatePinJoint(this.Children[0].Box2DBody, this.Children[1].Box2DBody, this.StartX, this.StartY, this.EditableVariables[EntityPin.CollideID])
            }
        }
    };
    EntityPin.Create = function EntityPinFn(x, y, Rotation, ScaleX, ScaleY, Name, Image, Collision) {
        var NewObject = EntityJoint.Create(x, y, Rotation, ScaleX, ScaleY, Name, Image);
        NewObject.Reset = EntityPin.prototype.Reset;
        NewObject.TypeID = EntityPin.TypeID;
        return NewObject
    };

    function EntityRod() {}
    EntityRod.Name = "Rod";
    EntityRod.EditableVariables = [EntityJoint.EditableVariables[0]];
    EntityRod.prototype = {
        Reset: function ResetFn() {
            EntityJoint.DestroyJoint(this);
            if (this.Children && this.Children.length === 2 && this.Children[0].Box2DBody && this.Children[1].Box2DBody) {
                var Frame = this.Sprite.psTexture.GetFrame(this.Sprite.Frame);
                var Height = Frame.Height / 2;
                var Point1 = Entity.TransformLocalToWorld(this, new Vector2(0, -Height));
                var Point2 = Entity.TransformLocalToWorld(this, new Vector2(0, Height));
                this.Joint = Physics.CreateDistanceJoint(this.Children[0].Box2DBody, this.Children[1].Box2DBody, Point1.x, Point1.y, Point2.x, Point2.y, 0, 0)
            }
        }
    };
    EntityRod.Create = function EntityRodFn(x, y, Rotation, ScaleX, ScaleY, Name, Image, Collision) {
        var NewObject = EntityJoint.Create(x, y, Rotation, ScaleX, ScaleY, Name, Image);
        NewObject.Reset = EntityRod.prototype.Reset;
        NewObject.TypeID = EntityRod.TypeID;
        return NewObject
    };

    function EntitySpring() {}
    EntitySpring.Name = "Spring";
    EntitySpring.FrequencyID = EntityJoint.VisibleID + 1;
    EntitySpring.DampingID = EntityJoint.VisibleID + 2;
    EntitySpring.EditableVariables = [EntityJoint.EditableVariables[0], {
        Name: "Frequency",
        Type: "Number",
        Default: 0
    }, {
        Name: "Damping",
        Type: "Number",
        Default: 0
    }];
    EntitySpring.prototype = {
        Reset: function ResetFn() {
            EntityJoint.DestroyJoint(this);
            if (this.Children && this.Children.length === 2 && this.Children[0].Box2DBody && this.Children[1].Box2DBody) {
                var Frame = this.Sprite.psTexture.GetFrame(this.Sprite.Frame);
                var Height = Frame.Height / 2;
                var Point1 = Entity.TransformLocalToWorld(this, new Vector2(0, -Height));
                var Point2 = Entity.TransformLocalToWorld(this, new Vector2(0, Height));
                var Frequency = this.EditableVariables[EntitySpring.FrequencyID];
                var Damping = this.EditableVariables[EntitySpring.DampingID];
                this.Joint = Physics.CreateDistanceJoint(this.Children[0].Box2DBody, this.Children[1].Box2DBody, Point1.x, Point1.y, Point2.x, Point2.y, Frequency, Damping)
            }
        }
    };
    EntitySpring.Create = function EntitySpringFn(x, y, Rotation, ScaleX, ScaleY, Name, Image, Collision) {
        var NewObject = EntityJoint.Create(x, y, Rotation, ScaleX, ScaleY, Name, Image);
        NewObject.Reset = EntitySpring.prototype.Reset;
        NewObject.TypeID = EntitySpring.TypeID;
        NewObject.EditableVariables[EntitySpring.FrequencyID] = 0;
        NewObject.EditableVariables[EntitySpring.DampingID] = 0;
        return NewObject
    };

    function EntityWeld() {}
    EntityWeld.Name = "Weld";
    EntityWeld.prototype = {
        Reset: function ResetFn() {
            if (this.Children === null) {
                return
            }
            Physics.DestroyFixture(this.Box2DBody);
            var i;
            for (i = 0; i < this.Children.length; i += 1) {
                var Child = this.Children[i];
                var ObjectPalette = ObjectPaletteManager.ObjectPalette[Child.ObjectPaletteIndex];
                var Collision = ObjectPalette.Collision;
                if (this.ChildrenTransform[i] === undefined) {
                    this.ChildrenTransform[i] = {}
                }
                var NewPoint = Entity.TransformWorldToLocal(this, new Vector2(Child.StartX, Child.StartY));
                this.ChildrenTransform[i].x = NewPoint.x;
                this.ChildrenTransform[i].y = NewPoint.y;
                this.ChildrenTransform[i].Rotation = Child.StartRotation - this.StartRotation;
                if (Child.Box2DBody) {
                    if (Collision.Circle) {
                        Physics.CreateFixtureAsCircle(this.Box2DBody, NewPoint.x, NewPoint.y, this.StartScaleX, Collision.CircleRadius * Child.StartScaleX, Collision.Density, Collision.Friction, Collision.Restitution, this)
                    } else {
                        var OldPoints = Collision.CollisionPoints;
                        var NewPoints = [];
                        var j;
                        for (j = 0; j < OldPoints.length; j += 1) {
                            var TempPoint = Entity.TransformLocalToWorld(Child, new Vector2(OldPoints[j].x, OldPoints[j].y));
                            NewPoints[j] = Entity.TransformWorldToLocal(this, new Vector2(TempPoint.x, TempPoint.y))
                        }
                        Physics.CreateFixture(this.Box2DBody, NewPoints, this.StartScaleX, this.StartScaleY, Collision.Density, Collision.Friction, Collision.Restitution, this)
                    }
                }
            }
        },
        Update: function UpdateFn(TimeDelta) {
            if (this.Children === null) {
                return
            }
            var i;
            for (i = 0; i < this.Children.length; i += 1) {
                var Child = this.Children[i];
                var thisSprite = Child.Sprite;
                var Transform = this.ChildrenTransform[i];
                var WorldCoord = Entity.TransformLocalToWorld(this, new Vector2(Transform.x, Transform.y));
                thisSprite.SetPosition(WorldCoord.x, WorldCoord.y);
                var Rotation = this.Sprite.Rotation + Transform.Rotation;
                thisSprite.SetRotation(Rotation)
            }
        },
        ShowEditMode: function ShowEditModeFn(EditActive) {
            this.SetIsVisible(EditActive)
        },
        AddChild: function AddChildFn(Child) {
            if (!Child.IsActive) {
                return
            }
            Entity.AddChild(this, Child);
            Child.Layer.RemoveEntityPhysics(Child)
        },
        RemoveChild: function RemoveChildFn(Child) {
            Entity.RemoveChild(this, Child);
            this.Layer.AddEntityPhysics(Child);
            Entity.ResetToStart(Child);
            Child.Reset()
        }
    };
    EntityWeld.Create = function EntityWeldFn(x, y, Rotation, ScaleX, ScaleY, Name, Image, Collision) {
        var NewObject = EntityDynamic.Create(x, y, Rotation, ScaleX, ScaleY, Name, Image, Collision);
        Physics.SetCollisionFilter(NewObject.Box2DBody, EntityWeld.TypeID);
        NewObject.Reset = EntityWeld.prototype.Reset;
        NewObject.Update = EntityWeld.prototype.Update;
        NewObject.Render = EntityWeld.prototype.Render;
        NewObject.ShowEditMode = EntityWeld.prototype.ShowEditMode;
        NewObject.AddChild = EntityWeld.prototype.AddChild;
        NewObject.RemoveChild = EntityWeld.prototype.RemoveChild;
        NewObject.TypeID = EntityWeld.TypeID;
        NewObject.ChildrenTransform = [];
        return NewObject
    };

    function EntityMarker() {}
    EntityMarker.Name = "Marker";
    EntityMarker.prototype = {
        ShowEditMode: function ShowEditModeFn(EditActive) {
            this.SetIsVisible(EditActive)
        }
    };
    EntityMarker.Create = function EntityMarkerFn(x, y, Rotation, ScaleX, ScaleY, Name, Image, Collision) {
        var NewObject = EntityNone.Create(x, y, Rotation, ScaleX, ScaleY, Name, Image, Collision);
        NewObject.ShowEditMode = EntityMarker.prototype.ShowEditMode;
        NewObject.TypeID = EntityMarker.TypeID;
        return NewObject
    };

    function Physics() {}
    Physics.prototype = {};
    Physics.CreateFixture = function CreateFixtureFn(Box2DBody, CollisionVertices, ScaleX, ScaleY, Density, Friction, Restitution, UserData) {
        var i, j, x, y;
        var vertices = [];
        for (i = 0; i < CollisionVertices.length; i += 1) {
            x = CollisionVertices[i].x / Physics.Box2DScale * ScaleX;
            y = CollisionVertices[i].y / Physics.Box2DScale * ScaleY;
            if ((ScaleX < 0 || ScaleY < 0) && !(ScaleX < 0 && ScaleY < 0)) {
                vertices[i] = new Point(x, y)
            } else {
                vertices[CollisionVertices.length - 1 - i] = new Point(x, y)
            }
        }
        var triangles = triangulatePolygon(vertices);
        var polys = polygonizeTriangles(triangles);
        for (i = 0; i < polys.length; i += 1) {
            var Poly = polys[i];
            var fixDef = new Physics.B2FixtureDef;
            fixDef.density = Density;
            fixDef.friction = Friction;
            fixDef.restitution = Restitution;
            fixDef.shape = new Physics.B2PolygonShape;
            fixDef.userData = UserData;
            var FinalVertices = [];
            for (j = 0; j < Poly.nVertices; j += 1) {
                x = Poly.x[j];
                y = Poly.y[j];
                FinalVertices[j] = new Physics.B2Vec2(x, y)
            }
            fixDef.shape.SetAsArray(FinalVertices, FinalVertices.length);
            Box2DBody.CreateFixture(fixDef)
        }
        if (Box2DBody.Mass) {
            Physics.SetBodyMass(Box2DBody, Box2DBody.Mass)
        }
    };
    Physics.CreateFixtureAsCircle = function CreateFixtureFn(Box2DBody, x, y, Scale, Radius, Density, Friction, Restitution, UserData) {
        var fixDef = new Physics.B2FixtureDef;
        fixDef.density = Density;
        fixDef.friction = Friction;
        fixDef.restitution = Restitution;
        fixDef.shape = new Physics.B2CircleShape(Radius / Physics.Box2DScale * Scale);
        fixDef.shape.SetLocalPosition(new Physics.B2Vec2(x / Physics.Box2DScale * Scale, y / Physics.Box2DScale * Scale));
        fixDef.userData = UserData;
        Box2DBody.CreateFixture(fixDef)
    };
    Physics.DestroyFixture = function DestroyFixtureFn(Box2DBody) {
        var Fixtures = Box2DBody.GetFixtureList();
        while (Fixtures) {
            var CurrentFixture = Fixtures;
            Box2DBody.DestroyFixture(CurrentFixture);
            Fixtures = Box2DBody.GetFixtureList()
        }
    };
    Physics.UpdateFixture = function UpdateFixtureFn(Box2DBody, CollisionData, ScaleX, ScaleY, UserData) {
        Physics.DestroyFixture(Box2DBody);
        if (CollisionData.Circle) {
            Physics.CreateFixtureAsCircle(Box2DBody, 0, 0, ScaleX, CollisionData.CircleRadius, CollisionData.Density, CollisionData.Friction, CollisionData.Restitution, UserData)
        } else {
            Physics.CreateFixture(Box2DBody, CollisionData.CollisionPoints, ScaleX, ScaleY, CollisionData.Density, CollisionData.Friction, CollisionData.Restitution, UserData)
        }
    };
    Physics.CreateBody = function CreateBodyFn(x, y, Angle, ScaleX, ScaleY, CollisionIsActive, CollisionData, UserData) {
        var Box2DBodyDef = new Physics.B2BodyDef;
        if (!CollisionIsActive) {
            Box2DBodyDef.type = Physics.B2Body.b2_staticBody
        } else {
            Box2DBodyDef.type = Physics.B2Body.b2_dynamicBody
        }
        Box2DBodyDef.position.x = x / Physics.Box2DScale;
        Box2DBodyDef.position.y = y / Physics.Box2DScale;
        Box2DBodyDef.angle = Angle;
        var Box2DBody = Physics.Box2DWorld.CreateBody(Box2DBodyDef);
        if (CollisionData.Circle) {
            Physics.CreateFixtureAsCircle(Box2DBody, 0, 0, ScaleX, CollisionData.CircleRadius, CollisionData.Density, CollisionData.Friction, CollisionData.Restitution, UserData)
        } else {
            Physics.CreateFixture(Box2DBody, CollisionData.CollisionPoints, ScaleX, ScaleY, CollisionData.Density, CollisionData.Friction, CollisionData.Restitution, UserData)
        }
        return Box2DBody
    };
    Physics.DestroyBody = function DestroyBodyFn(Box2DBody) {
        Physics.DestroyFixture(Box2DBody);
        Physics.Box2DWorld.DestroyBody(Box2DBody)
    };
    Physics.SetBodyActive = function SetBodyActiveFn(Body, Active) {
        Body.SetActive(Active);
        Body.SetAwake(Active)
    };
    Physics.SetBodyFixedRotation = function SetBodyFixedRotationFn(Body, Fixed) {
        Body.SetFixedRotation(Fixed)
    };
    Physics.SetDefaultBodyMass = function SetDefaultBodyMassFn(Body) {
        Body.ResetMassData();
        Body.Mass = undefined
    };
    Physics.GetBodyMass = function GetBodyMassFn(Body) {
        if (Body.Mass) {
            return Body.Mass
        }
        return Body.GetMass()
    };
    Physics.SetBodyMass = function SetBodyMassFn(Body, Mass) {
        if (Body === 0) {
            return
        }
        var MassData = new Physics.B2MassData;
        Body.GetMassData(MassData);
        MassData.mass = Mass;
        Body.SetMassData(MassData);
        Body.Mass = Mass
    };
    Physics.GetBodyArea = function GetBodyAreaFn(Body) {
        return Body.area
    };
    Physics.UpdateEntityToBody = function UpdateEntityToBodyFn(Entity) {
        var position = Entity.Box2DBody.GetPosition();
        var angle = Entity.Box2DBody.GetAngle();
        Entity.x = position.x * Physics.Box2DScale;
        Entity.y = position.y * Physics.Box2DScale;
        Entity.Rotation = angle;
        Entity.Sprite.SetPosition(Entity.x, Entity.y);
        Entity.Sprite.SetRotation(angle)
    };
    Physics.SetBody = function SetBodyFn(Box2DBody, StartX, StartY, StartRotation) {
        Box2DBody.SetPositionAndAngle(new Physics.B2Vec2(StartX / Physics.Box2DScale, StartY / Physics.Box2DScale), StartRotation);
        if (Box2DBody.GetType() !== Physics.B2Body.b2_staticBody) {
            Box2DBody.SetLinearVelocity(new Physics.B2Vec2(0, 0));
            Box2DBody.SetAngularVelocity(0);
            Box2DBody.SetAwake(true);
            Box2DBody.m_force.SetZero();
            Box2DBody.m_torque = 0
        }
    };
    Physics.SetBodyRotation = function SetBodyFn(Box2DBody, StartRotation) {
        Box2DBody.SetAngle(StartRotation);
        if (Box2DBody.GetType() !== Physics.B2Body.b2_staticBody) {
            Box2DBody.SetAngularVelocity(0);
            Box2DBody.SetAwake(true)
        }
    };
    Physics.SetPosition = function SetPositionFn(Box2DBody, StartX, StartY) {
        Box2DBody.SetPosition(new Physics.B2Vec2(StartX / Physics.Box2DScale, StartY / Physics.Box2DScale))
    };
    Physics.GetPosition = function GetPositionFn(Box2DBody) {
        var Position = Box2DBody.GetPosition();
        return new Vector2(Position.x * Physics.Box2DScale, Position.y * Physics.Box2DScale)
    };
    Physics.GetRotation = function GetRotationFn(Box2DBody) {
        return Box2DBody.GetAngle()
    };
    Physics.CreateDistanceJoint = function CreateDistanceJointFn(BodyA, BodyB, x1, y1, x2, y2, Frequency, Damping) {
        var jointDef = new Physics.B2DistanceJointDef;
        jointDef.Initialize(BodyA, BodyB, new Physics.B2Vec2(x1 / Physics.Box2DScale, y1 / Physics.Box2DScale), new Physics.B2Vec2(x2 / Physics.Box2DScale, y2 / Physics.Box2DScale));
        jointDef.frequencyHz = Frequency;
        jointDef.dampingRatio = Damping;
        jointDef.collideConnected = true;
        var joint = Physics.Box2DWorld.CreateJoint(jointDef);
        return joint
    };
    Physics.SetDistanceJointLength = function SetDistanceJointLength(Joint, Length) {
        Joint.SetLength(Length / Physics.Box2DScale)
    };
    Physics.SetPinJointLimits = function SetPinJointLimits(Joint, LimitA, LimitB) {
        if (LimitA === 0 && LimitB === 0) {
            Joint.enableLimit = false
        } else {
            Joint.enableLimit = true;
            Joint.SetLimits(LimitA, LimitB)
        }
    };
    Physics.SetPinAnchor = function SetPinAnchor(Joint, AnchorA, AnchorB) {
        Joint.m_localAnchor1.y = AnchorA / Physics.Box2DScale;
        Joint.m_localAnchor2.y = AnchorB / Physics.Box2DScale
    };
    Physics.CreatePrismaticJoint = function CreatePrismaticJoint(BodyA, BodyB, x, y, xd, yd, MinDist, MaxDist) {
        var jointDef = new Physics.B2PrismaticJointDef;
        jointDef.Initialize(BodyA, BodyB, new Physics.B2Vec2(x / Physics.Box2DScale, y / Physics.Box2DScale), new Physics.B2Vec2(xd, yd));
        jointDef.enableLimit = true;
        jointDef.lowerTranslation = MinDist / Physics.Box2DScale;
        jointDef.upperTranslation = MaxDist / Physics.Box2DScale;
        var joint = Physics.Box2DWorld.CreateJoint(jointDef);
        return joint
    };
    Physics.CreatePinJoint = function CreatePinJointFn(BodyA, BodyB, x, y, collideConnected) {
        var jointDef = new Physics.B2RevoluteJointDef;
        jointDef.Initialize(BodyA, BodyB, new Physics.B2Vec2(x / Physics.Box2DScale, y / Physics.Box2DScale));
        jointDef.collideConnected = collideConnected;
        var joint = Physics.Box2DWorld.CreateJoint(jointDef);
        return joint
    };
    Physics.CreateRopeJoint = function CreateRopeJointFn(BodyA, BodyB, x1, y1, x2, y2) {
        var jointDef = new b2RopeJointDef;
        jointDef.Initialize(BodyA, BodyB, new Physics.B2Vec2(x1 / Physics.Box2DScale, y1 / Physics.Box2DScale), new Physics.B2Vec2(x2 / Physics.Box2DScale, y2 / Physics.Box2DScale));
        var joint = Physics.Box2DWorld.CreateJoint(jointDef);
        return joint
    };
    Physics.DestroyJoint = function DestroyJointFn(Joint) {
        Physics.Box2DWorld.DestroyJoint(Joint)
    };
    Physics.ApplyForce = function ApplyForceFn(Box2DBody, Force, Position) {
        if (Force.x < 1e-5 && Force.x > -1e-5 && (Force.y < 1e-5 && Force.y > -1e-5)) {
            return
        }
        var x = Box2DBody.GetPosition().x + Position.x / Physics.Box2DScale;
        var y = Box2DBody.GetPosition().y + Position.y / Physics.Box2DScale;
        Box2DBody.ApplyForce(new Physics.B2Vec2(Force.x / Physics.Box2DScale, Force.y / Physics.Box2DScale), new Physics.B2Vec2(x, y))
    };
    Physics.GetForce = function GetForceFn(Box2DBody) {
        var Force = new Vector2(0, 0);
        Force.x = Box2DBody.m_force.x * Physics.Box2DScale;
        Force.y = Box2DBody.m_force.y * Physics.Box2DScale;
        return Force
    };
    Physics.ClearForce = function ClearForceFn(Box2DBody) {
        Box2DBody.m_force.SetZero();
        Box2DBody.m_torque = 0
    };
    Physics.GetLinearVelocity = function GetLinearVelocityFn(Box2DBody) {
        var Velocity = Box2DBody.GetLinearVelocity();
        var FinalVelocity = new Vector2(Velocity.x * Physics.Box2DScale, Velocity.y * Physics.Box2DScale);
        return FinalVelocity
    };
    Physics.ApplyTorque = function ApplyTorqueFn(Box2DBody, Torque) {
        Box2DBody.ApplyTorque(Torque)
    };
    Physics.GetAngularVelocity = function GetAngularVelocityFn(Box2DBody) {
        return Box2DBody.GetAngularVelocity()
    };
    Physics.SetAngularVelocity = function SetAngularVelocityFn(Box2DBody, Velocity) {
        Box2DBody.SetAngularVelocity(Velocity)
    };
    Physics.SetAngularDamping = function SetAngularDampingFn(Box2DBody, Dampening) {
        return Box2DBody.SetAngularDamping(Dampening)
    };
    Physics.ApplyImpulse = function ApplyImpulseFn(Box2DBody, Force, Position) {
        var x = Box2DBody.GetPosition().x + Position.x / Physics.Box2DScale;
        var y = Box2DBody.GetPosition().y + Position.y / Physics.Box2DScale;
        Box2DBody.ApplyImpulse(new Physics.B2Vec2(Force.x / Physics.Box2DScale, Force.y / Physics.Box2DScale), new Physics.B2Vec2(x, y))
    };
    Physics.BodySleep = function ApplyImpulseFn(Box2DBody, Sleep) {
        Box2DBody.SetAwake(!Sleep)
    };
    Physics.GetBodySleep = function GetBodySleepFn(Box2DBody) {
        if (Box2DBody.m_flags & b2Body.e_awakeFlag) {
            return false
        }
        return true
    };
    Physics.WakeTouchingBodies = function WakeTouchingBodiesFn(Box2DBody) {
        var ContactList = Box2DBody.m_contactList;
        while (ContactList) {
            var Body = ContactList.contact.m_fixtureA.m_body;
            if (Body.type !== Physics.B2Body.b2_staticBody) {
                Body.SetAwake(true)
            }
            Body = ContactList.contact.m_fixtureB.m_body;
            if (Body.type !== Physics.B2Body.b2_staticBody) {
                Body.SetAwake(true)
            }
            ContactList = ContactList.next
        }
    };
    Physics.GetSpeed = function GetSpeedFn(Box2DBody) {
        var Velocity = Box2DBody.GetLinearVelocity();
        var Size = Math.sqrt(Velocity.x * Velocity.x + Velocity.y * Velocity.y) * Physics.Box2DScale;
        return Size
    };
    Physics.GetVelocity = function GetVelocityFn(Box2DBody) {
        var Velocity = Box2DBody.GetLinearVelocity();
        return new Vector2(Velocity.x * Physics.Box2DScale, Velocity.y * Physics.Box2DScale)
    };
    Physics.GetVelocityAtPoint = function GetVelocityAtPointFn(Box2DBody, x, y) {
        var Velocity = Box2DBody.GetLinearVelocityFromWorldPoint(new Physics.B2Vec2(x / Physics.Box2DScale, y / Physics.Box2DScale));
        return new Vector2(Velocity.x * Physics.Box2DScale, Velocity.y * Physics.Box2DScale)
    };
    Physics.SetVelocity = function SetVelocityFn(Box2DBody, x, y) {
        var Velocity = Box2DBody.SetLinearVelocity(new Physics.B2Vec2(x / Physics.Box2DScale, y / Physics.Box2DScale))
    };
    Physics.GetIsStatic = function GetIsStaticFn(Box2DBody) {
        if (Box2DBody.GetType() === Physics.B2Body.b2_staticBody) {
            return true
        }
        return false
    };
    Physics.RenderDebugCollision = function RenderDebugCollisionFn(Matrix) {
        var i = 0;
        var b;
        var f;
        var Colour;
        for (b = Physics.Box2DWorld.m_bodyList; b; b = b.m_next) {
            if (b.IsActive()) {
                if (b.IsActive() === false) {
                    Colour = [.5, .5, .3, 1]
                } else if (b.GetType() === Physics.B2Body.b2_staticBody) {
                    Colour = [.5, .9, .5, 1]
                } else if (b.GetType() === Physics.B2Body.b2_kinematicBody) {
                    Colour = [.5, .5, .9, 1]
                } else if (b.IsAwake() === false) {
                    Colour = [0, 0, 0, 1]
                } else {
                    Colour = [.9, 0, 0, 1]
                }
                var xf = b.m_xf;
                for (f = b.GetFixtureList(); f; f = f.m_next) {
                    if (f.GetUserData()) {
                        var Entity = f.GetUserData();
                        if (Entity.Bucket && !Entity.Bucket.IsVisible) {
                            continue
                        }
                    }
                    var shape = f.GetShape();
                    switch (shape.m_type) {
                        case Physics.B2Shape.e_circleShape:
                            var circle = shape instanceof Physics.B2CircleShape ? shape : null;
                            var center = Physics.B2Math.MulX(xf, circle.m_p);
                            var radius = circle.m_radius;
                            var axis = xf.R.col1;
                            var TextureInfo = Helpers.GetTextureInfoFromImageName("Circle");
                            var Frame = TextureInfo.Texture.GetFrame(TextureInfo.Frame);
                            var Scale = radius * Physics.Box2DScale * 2 / Frame.Width;
                            JamSystem.RenderManager.DrawDebugSprite(center.x * Physics.Box2DScale, center.y * Physics.Box2DScale, Scale, Scale, 0, "Circle", Colour, Matrix);
                            break;
                        case Physics.B2Shape.e_polygonShape:
                            i = 0;
                            var poly = shape instanceof Physics.B2PolygonShape ? shape : null;
                            var vertexCount = Math.floor(poly.GetVertexCount());
                            var localVertices = poly.GetVertices();
                            var vertices = new Vector2(vertexCount);
                            for (i = 0; i < vertexCount; i += 1) {
                                vertices[i] = Physics.B2Math.MulX(xf, localVertices[i]);
                                vertices[i].Multiply(Physics.Box2DScale)
                            }
                            for (i = 0; i < vertexCount - 1; i += 1) {
                                JamSystem.RenderManager.DrawDebugLine(vertices[i].x, vertices[i].y, vertices[i + 1].x, vertices[i + 1].y, Colour, Matrix)
                            }
                            JamSystem.RenderManager.DrawDebugLine(vertices[i].x, vertices[i].y, vertices[0].x, vertices[0].y, Colour, Matrix);
                            break
                    }
                }
            }
        }
        var j;
        for (j = Physics.Box2DWorld.m_jointList; j; j = j.m_next) {
            var joint = j;
            var b1 = joint.GetBodyA();
            var b2 = joint.GetBodyB();
            var xf1 = b1.m_xf;
            var xf2 = b2.m_xf;
            var x1 = xf1.position;
            var x2 = xf2.position;
            var p1 = joint.GetAnchorA();
            p1.Multiply(Physics.Box2DScale);
            var p2 = joint.GetAnchorB();
            p2.Multiply(Physics.Box2DScale);
            Colour = [1, .5, 0, 1];
            if (joint.m_type === Physics.B2Joint.e_distanceJoint || joint.m_type === Physics.B2Joint.e_ropeJoint) {
                if (b1.IsActive() && b2.IsActive()) {
                    JamSystem.RenderManager.DrawDebugLine(p1.x, p1.y, p2.x, p2.y, Colour, Matrix)
                }
            }
        }
        for (i = 0; i < Physics.RenderDebugBox.length; i += 1) {
            var Box = Physics.RenderDebugBox[i].Coords;
            if (Physics.RenderDebugBox[i].Hit) {
                Colour = [1, 0, 0, 1]
            } else {
                Colour = [0, 1, 0, 1]
            }
            JamSystem.RenderManager.DrawDebugLine(Box[0], Box[1], Box[2], Box[1], Colour, Matrix);
            JamSystem.RenderManager.DrawDebugLine(Box[2], Box[1], Box[2], Box[3], Colour, Matrix);
            JamSystem.RenderManager.DrawDebugLine(Box[2], Box[3], Box[0], Box[3], Colour, Matrix);
            JamSystem.RenderManager.DrawDebugLine(Box[0], Box[3], Box[0], Box[1], Colour, Matrix)
        }
        Physics.RenderDebugBox = []
    };
    Physics.GetBodies = function GetBodiesFn() {
        var Num = 0;
        var b;
        for (b = Physics.Box2DWorld.m_bodyListActive; b; b = b.m_nextActive) {
            if (b.IsActive()) {
                Num += 1
            }
        }
        return Num
    };
    Physics.GetActiveBodies = function GetActiveBodiesFn() {
        var NumActive = 0;
        var b;
        for (b = Physics.Box2DWorld.m_bodyListActive; b; b = b.m_nextActive) {
            if (b.IsActive() && b.IsAwake()) {
                NumActive += 1
            }
        }
        return NumActive
    };
    Physics.Update = function UpdateFn(TimeDelta) {
        Physics.RenderDebug = false;
        Physics.Box2DWorld.Step(TimeDelta, 8, 3);
        var MaxSpeed = 1e3 / Physics.Box2DScale;
        var b;
        for (b = Physics.Box2DWorld.m_bodyListActive; b; b = b.m_nextActive) {
            if (b.IsActive() && b.IsAwake()) {
                if (b.m_linearVelocity.x > MaxSpeed) {
                    b.m_linearVelocity.x = MaxSpeed
                }
                if (b.m_linearVelocity.x < -MaxSpeed) {
                    b.m_linearVelocity.x = -MaxSpeed
                }
                if (b.m_linearVelocity.y > MaxSpeed) {
                    b.m_linearVelocity.y = MaxSpeed
                }
                if (b.m_linearVelocity.y < -MaxSpeed) {
                    b.m_linearVelocity.y = -MaxSpeed
                }
            }
        }
        Physics.Box2DWorld.ClearForces()
    };
    Physics.CalcApproachVelocity = function CalcApproachVelocity(EntityA, EntityB, contact) {
        var WorldManifold = new Physics.B2WorldManifold;
        contact.GetWorldManifold(WorldManifold);
        var VelocityA = EntityA.Box2DBody.GetLinearVelocityFromLocalPoint(new Physics.B2Vec2(0, 0));
        var VelocityB = EntityB.Box2DBody.GetLinearVelocityFromLocalPoint(new Physics.B2Vec2(0, 0));
        var xD = VelocityB.x - VelocityA.x;
        var yD = VelocityB.y - VelocityA.y;
        var ApproachVelocity = xD * WorldManifold.m_normal.x + yD * WorldManifold.m_normal.y;
        if (ApproachVelocity < 0) {
            ApproachVelocity = -ApproachVelocity
        }
        return ApproachVelocity
    };
    Physics.CalcApproachForce = function CalcApproachForce(EntityA, EntityB, contact) {
        var WorldManifold = new Physics.B2WorldManifold;
        contact.GetWorldManifold(WorldManifold);
        var VelocityA = EntityA.Box2DBody.GetLinearVelocityFromLocalPoint(new Physics.B2Vec2(0, 0));
        var MassData = new Physics.B2MassData;
        EntityA.Box2DBody.GetMassData(MassData);
        VelocityA.x += EntityA.Box2DBody.m_force.x * MassData.mass;
        VelocityA.y += EntityA.Box2DBody.m_force.y * MassData.mass;
        var VelocityB = EntityB.Box2DBody.GetLinearVelocityFromLocalPoint(new Physics.B2Vec2(0, 0));
        EntityB.Box2DBody.GetMassData(MassData);
        VelocityB.x += EntityB.Box2DBody.m_force.x * MassData.mass;
        VelocityB.y += EntityB.Box2DBody.m_force.y * MassData.mass;
        var xD = VelocityB.x - VelocityA.x;
        var yD = VelocityB.y - VelocityA.y;
        var ApproachVelocity = xD * WorldManifold.m_normal.x + yD * WorldManifold.m_normal.y;
        if (ApproachVelocity < 0) {
            ApproachVelocity = -ApproachVelocity
        }
        return ApproachVelocity
    };
    Physics.GetCollisionPoint = function GetCollisionPoint(contact) {
        var Manifold = new b2WorldManifold;
        contact.GetWorldManifold(Manifold);
        var OldPoint = Manifold.m_points[0];
        var NewPoint = new Vector2(OldPoint.x * Physics.Box2DScale, OldPoint.y * Physics.Box2DScale);
        return NewPoint
    };
    Physics.GetCollisionVector = function GetCollisionVector(contact) {
        var Manifold = new b2WorldManifold;
        contact.GetWorldManifold(Manifold);
        var NewPoint = new Vector2(Manifold.m_normal.x, Manifold.m_normal.y);
        return NewPoint
    };
    Physics.ListenerBeginContact = function ListenerBeginContact(contact) {};
    Physics.ListenerEndContact = function ListenerEndContact(contact) {};
    Physics.ListenerPreSolve = function ListenerPreSolve(contact, oldManifold) {
        if (contact.m_manifold.m_pointCount || contact.IsTouching()) {
            var EntityA = contact.GetFixtureA().GetUserData();
            var EntityB = contact.GetFixtureB().GetUserData();
            var DoCollision = true;
            if (Physics.CollisionTable[EntityA.TypeID] && Physics.CollisionTable[EntityA.TypeID][EntityB.TypeID] !== undefined) {
                if (Physics.CollisionTable[EntityA.TypeID][EntityB.TypeID] === false) {
                    DoCollision = false
                } else {
                    DoCollision = Physics.CollisionTable[EntityA.TypeID][EntityB.TypeID](EntityA, EntityB, contact)
                }
            } else if (Physics.CollisionTable[EntityB.TypeID] && Physics.CollisionTable[EntityB.TypeID][EntityA.TypeID] !== undefined) {
                if (Physics.CollisionTable[EntityB.TypeID][EntityA.TypeID] === false) {
                    DoCollision = false
                } else {
                    DoCollision = Physics.CollisionTable[EntityB.TypeID][EntityA.TypeID](EntityB, EntityA, contact)
                }
            }
            contact.SetEnabled(DoCollision)
        }
    };
    Physics.ListenerPostSolve = function ListenerPostSolve(contact, impulse) {};
    Physics.RegisterCollision = function RegisterCollision(EntityID, CollisionTable) {
        Physics.CollisionTable[EntityID] = CollisionTable
    };
    Physics.SetCollisionTable = function SetCollisionTable(EntityID, EntityTargetID, Value) {
        Physics.CollisionTable[EntityID][EntityTargetID] = Value
    };
    Physics.CreateCollision = function CreateCollision(ImageName, Circle, Density, Friction, Restitution) {
        var NewCollision = new EntityCollisionData;
        NewCollision.Circle = Circle;
        NewCollision.Density = Density;
        NewCollision.Friction = Friction;
        NewCollision.Restitution = Restitution;
        var TextureInfo = Helpers.GetTextureInfoFromImageName(ImageName);
        var Frame = TextureInfo.Texture.GetFrame(TextureInfo.Frame);
        var HalfWidth = Frame.Width / 2;
        var HalfHeight = Frame.Height / 2;
        if (Circle) {
            NewCollision.CircleRadius = HalfWidth
        } else {
            NewCollision.CollisionPoints = [];
            NewCollision.CollisionPoints[0] = new Vector2(-HalfWidth, -HalfHeight);
            NewCollision.CollisionPoints[1] = new Vector2(HalfWidth, -HalfHeight);
            NewCollision.CollisionPoints[2] = new Vector2(HalfWidth, HalfHeight);
            NewCollision.CollisionPoints[3] = new Vector2(-HalfWidth, HalfHeight)
        }
        return NewCollision
    };
    Physics.SetCollisionFilter = function SetCollisionFilter(Box2DBody, TypeID, GroupIndex) {
        var Filter = new Physics.B2FilterData;
        Filter.categoryBits = 1 << TypeID;
        Filter.maskBits = 0;
        if (GroupIndex !== undefined) {
            Filter.groupIndex = GroupIndex
        }
        var i;
        for (i = 0; i < EntityTypeManager.TypesRegistered.length; i += 1) {
            if (Physics.CollisionTable[TypeID] === undefined && Physics.CollisionTable[i] === undefined) {
                Filter.maskBits |= 1 << i
            } else if (Physics.CollisionTable[TypeID] !== undefined) {
                if (Physics.CollisionTable[TypeID][i] !== false) {
                    Filter.maskBits |= 1 << i
                }
            } else {
                if (Physics.CollisionTable[i][TypeID] !== false) {
                    Filter.maskBits |= 1 << i
                }
            }
        }
        var Fixtures = Box2DBody.GetFixtureList();
        while (Fixtures) {
            var CurrentFixture = Fixtures;
            CurrentFixture.SetFilterData(Filter);
            Fixtures = Fixtures.m_next
        }
    };
    Physics.ChangeCollisionFilter = function ChangeCollisionFilter(Box2DBody, TypeID, Active) {
        var Fixtures = Box2DBody.GetFixtureList();
        while (Fixtures) {
            var CurrentFixture = Fixtures;
            var Data = CurrentFixture.GetFilterData();
            if (Active) {
                Data.maskBits |= 1 << TypeID
            } else {
                Data.maskBits &= 4294967295 - (1 << TypeID)
            }
            CurrentFixture.SetFilterData(Data);
            Fixtures = Fixtures.m_next
        }
    };
    Physics.CreateCollisionVertices = function CreateCollisionVertices(ThisEntity, CollisionVertices, ScaleX, ScaleY) {
        ThisEntity.CollisionVertices = [];
        var i;
        for (i = 0; i < CollisionVertices.length; i += 1) {
            var x = CollisionVertices[i].x / Physics.Box2DScale * ScaleX;
            var y = CollisionVertices[i].y / Physics.Box2DScale * ScaleY;
            if ((ScaleX < 0 || ScaleY < 0) && !(ScaleX < 0 && ScaleY < 0)) {
                ThisEntity.CollisionVertices[CollisionVertices.length - 1 - i] = new Physics.B2Vec2(x, y)
            } else {
                ThisEntity.CollisionVertices[i] = new Physics.B2Vec2(x, y)
            }
        }
    };
    Physics.TestBoundingBoxCollisionCallback = function TestBoundingBoxCollisionCallback(Fixture) {
        var TestEntity = Fixture.GetUserData();
        var MainEntity = 0;
        var SecondEntity = 0;
        if (Physics.CollisionTable[Physics.TestEntity.TypeID] && Physics.CollisionTable[Physics.TestEntity.TypeID][TestEntity.TypeID] !== undefined) {
            if (Physics.CollisionTable[Physics.TestEntity.TypeID][TestEntity.TypeID] !== false) {
                MainEntity = Physics.TestEntity;
                SecondEntity = TestEntity
            }
        } else if (Physics.CollisionTable[TestEntity.TypeID] && Physics.CollisionTable[TestEntity.TypeID][Physics.TestEntity.TypeID] !== undefined) {
            if (Physics.CollisionTable[TestEntity.TypeID][Physics.TestEntity.TypeID] !== false) {
                MainEntity = TestEntity;
                SecondEntity = Physics.TestEntity
            }
        }
        if (MainEntity) {
            var RotA = Physics.TestEntity.Sprite.Rotation;
            var xA = Physics.TestEntity.x / Physics.Box2DScale;
            var yA = Physics.TestEntity.y / Physics.Box2DScale;
            var RotB;
            if (TestEntity.Sprite) {
                RotB = TestEntity.Sprite.Rotation
            } else {
                RotB = TestEntity.SpriteList.Rotation[TestEntity.SpriteListIndex]
            }
            var xB = TestEntity.x / Physics.Box2DScale;
            var yB = TestEntity.y / Physics.Box2DScale;
            var CollisionPoint = {};
            if (Fixture.GetShape().m_type !== 0) {
                if (Collision.DoShapesOverlap(Physics.TestEntity.CollisionVertices, RotA, xA, yA, Fixture.GetShape().GetVertices(), Fixture.GetShape().GetNormals(), RotB, xB, yB, CollisionPoint)) {
                    CollisionPoint.x *= Physics.Box2DScale;
                    CollisionPoint.y *= Physics.Box2DScale;
                    Physics.CollisionTable[MainEntity.TypeID][SecondEntity.TypeID](MainEntity, SecondEntity, CollisionPoint)
                }
            } else {
                if (Collision.DoesCircleOverlap(Physics.TestEntity.CollisionVertices, RotA, xA, yA, Fixture.GetShape().GetRadius(), xB, yB, CollisionPoint)) {
                    CollisionPoint.x *= Physics.Box2DScale;
                    CollisionPoint.y *= Physics.Box2DScale;
                    Physics.CollisionTable[MainEntity.TypeID][SecondEntity.TypeID](MainEntity, SecondEntity, CollisionPoint)
                }
            }
        }
        return true
    };
    Physics.TestBoundingBoxCollision = function TestBoundingBoxCollision(TestEntity) {
        Physics.TestEntity = TestEntity;
        var aabb = new Physics.B2AABB;
        aabb.lowerBound.Set(TestEntity.AABB_Left / Physics.Box2DScale, TestEntity.AABB_Top / Physics.Box2DScale);
        aabb.upperBound.Set(TestEntity.AABB_Right / Physics.Box2DScale, TestEntity.AABB_Bottom / Physics.Box2DScale);
        Physics.Box2DWorld.QueryAABB(Physics.TestBoundingBoxCollisionCallback, aabb)
    };
    Physics.TestPointCollisionCallback = function TestPointCollisionCallback(Fixture) {
        var TestEntity = Fixture.GetUserData();
        if (Physics.CollisionTable[Physics.TestEntity.TypeID] && Physics.CollisionTable[Physics.TestEntity.TypeID][TestEntity.TypeID] !== undefined) {
            if (Physics.CollisionTable[Physics.TestEntity.TypeID][TestEntity.TypeID] !== false) {
                Physics.UserPointCallback(TestEntity)
            }
        } else if (Physics.CollisionTable[TestEntity.TypeID] && Physics.CollisionTable[TestEntity.TypeID][Physics.TestEntity.TypeID] !== undefined) {
            if (Physics.CollisionTable[TestEntity.TypeID][Physics.TestEntity.TypeID] !== false) {
                Physics.UserPointCallback(TestEntity)
            }
        } else {
            Physics.UserPointCallback(TestEntity)
        }
        return true
    };
    Physics.TestPointCollision = function TestPointCollision(TestEntity, x, y, Callback) {
        Physics.TestEntity = TestEntity;
        Physics.UserPointCallback = Callback;
        Physics.Box2DWorld.QueryPoint(Physics.TestPointCollisionCallback, new b2Vec2(x / Physics.Box2DScale, y / Physics.Box2DScale))
    };
    Physics.TestRectangleCollisionCallback = function TestRectangleCollisionCallback(Fixture) {
        var TestEntity = Fixture.GetUserData();
        var Hit = false;
        if (Physics.CollisionTable[Physics.TestEntity.TypeID] && Physics.CollisionTable[Physics.TestEntity.TypeID][TestEntity.TypeID] !== undefined) {
            if (Physics.CollisionTable[Physics.TestEntity.TypeID][TestEntity.TypeID] !== false) {
                Hit = true
            }
        } else if (Physics.CollisionTable[TestEntity.TypeID] && Physics.CollisionTable[TestEntity.TypeID][Physics.TestEntity.TypeID] !== undefined) {
            if (Physics.CollisionTable[TestEntity.TypeID][Physics.TestEntity.TypeID] !== false) {
                Hit = true
            }
        } else {
            Hit = true
        }
        if (Hit) {
            var RotB;
            if (TestEntity.Sprite) {
                RotB = TestEntity.Sprite.Rotation
            } else {
                RotB = TestEntity.SpriteList.Rotation[TestEntity.SpriteListIndex]
            }
            var xB = TestEntity.x / Physics.Box2DScale;
            var yB = TestEntity.y / Physics.Box2DScale;
            var CollisionPoint = {};
            if (Fixture.GetShape().m_type !== 0) {
                if (Collision.DoShapesOverlap(Physics.RectangleVertices, 0, 0, 0, Fixture.GetShape().GetVertices(), Fixture.GetShape().GetNormals(), RotB, xB, yB, CollisionPoint)) {
                    if (GlobalMain.World.DebugShowCollision) {
                        Physics.RenderDebugBox[Physics.RenderDebugBox.length - 1].Hit = true
                    }
                    if (Physics.UserPointCallback) {
                        CollisionPoint.x *= Physics.Box2DScale;
                        CollisionPoint.y *= Physics.Box2DScale;
                        Physics.UserPointCallback(TestEntity, CollisionPoint)
                    }
                }
            } else {
                if (Collision.DoesCircleOverlap(Physics.RectangleVertices, 0, 0, 0, Fixture.GetShape().GetRadius(), xB, yB, CollisionPoint)) {
                    if (GlobalMain.World.DebugShowCollision) {
                        Physics.RenderDebugBox[Physics.RenderDebugBox.length - 1].Hit = true
                    }
                    if (Physics.UserPointCallback) {
                        CollisionPoint.x *= Physics.Box2DScale;
                        CollisionPoint.y *= Physics.Box2DScale;
                        Physics.UserPointCallback(TestEntity, CollisionPoint)
                    }
                }
            }
        }
        return true
    };
    Physics.TestRectangleCollision = function TestRectangleCollision(TestEntity, Left, Top, Right, Bottom, Callback) {
        Physics.TestEntity = TestEntity;
        Physics.UserPointCallback = Callback;
        if (GlobalMain.World.DebugShowCollision) {
            Physics.RenderDebugBox[Physics.RenderDebugBox.length] = {
                Coords: [Left, Top, Right, Bottom],
                Hit: false
            }
        }
        var aabb = new Physics.B2AABB;
        Left /= Physics.Box2DScale;
        Top /= Physics.Box2DScale;
        Right /= Physics.Box2DScale;
        Bottom /= Physics.Box2DScale;
        aabb.lowerBound.Set(Left, Top);
        aabb.upperBound.Set(Right, Bottom);
        Physics.RectangleVertices = [{
            x: Left,
            y: Top
        }, {
            x: Right,
            y: Top
        }, {
            x: Right,
            y: Bottom
        }, {
            x: Left,
            y: Bottom
        }];
        Physics.Box2DWorld.QueryAABB(Physics.TestRectangleCollisionCallback, aabb)
    };
    Physics.CreateBuoyancyController = function CreateBuoyancyController(Offset) {
        var Controller = new Physics.B2BuoyancyController;
        Controller.normal.Set(0, 1);
        Controller.offset = Offset / Physics.Box2DScale;
        Controller.density = 1;
        Controller.linearDrag = 5;
        Controller.angularDrag = 1;
        Controller.useWorldGravity = false;
        Controller.gravity = new b2Vec2(0, 17);
        return Controller
    };
    Physics.DestroyBuoyancyController = function DestroyBuoyancyController(Controller) {};
    Physics.SetBuoyancyControllerOffset = function SetBuoyancyControllerOffset(Controller, Offset) {
        Controller.offset = Offset / Physics.Box2DScale
    };
    Physics.UpdateBuoyancyController = function UpdateBuoyancyController(Controller, TimeDelta) {
        Controller.Step(TimeDelta)
    };
    Physics.ResetBuoyancyController = function ResetBuoyancyController(Controller) {
        Controller.Clear()
    };
    Physics.AddToBuoyancyController = function AddToBuoyancyController(Controller, Box2DBody) {
        Controller.AddBody(Box2DBody)
    };
    Physics.RemoveFromBuoyancyController = function RemoveFromBuoyancyController(Controller, Box2DBody) {
        Controller.RemoveBody(Box2DBody)
    };
    Physics.Reset = function ResetFn() {
        Physics.CurrentTime = 0;
        Physics.DesiredTime = 0;
        Physics.Box2DWorld.ClearForces()
    };
    Physics.Init = function InitFn(Gravity) {
        Physics.Box2DScale = 50;
        Physics.B2Vec2 = b2Vec2;
        Physics.B2Dot = b2Math.Dot;
        Physics.B2Math = b2Math;
        Physics.B2BodyDef = b2BodyDef;
        Physics.B2Body = b2Body;
        Physics.B2FixtureDef = b2FixtureDef;
        Physics.B2Fixture = b2Fixture;
        Physics.B2Joint = b2Joint;
        Physics.B2RevoluteJoint = b2RevoluteJoint;
        Physics.B2RevoluteJointDef = b2RevoluteJointDef;
        Physics.B2DistanceJoint = b2DistanceJoint;
        Physics.B2DistanceJointDef = b2DistanceJointDef;
        Physics.B2PrismaticJointDef = b2PrismaticJointDef;
        Physics.B2Shape = b2Shape;
        Physics.B2PolygonShape = b2PolygonShape;
        Physics.B2CircleShape = b2CircleShape;
        Physics.B2WorldManifold = b2WorldManifold;
        Physics.B2FilterData = b2FilterData;
        Physics.B2AABB = b2AABB;
        Physics.B2Settings = b2Settings;
        Physics.Bb2PrismaticJointDef = b2PrismaticJointDef;
        Physics.B2MassData = b2MassData;
        Physics.B2Mat22 = b2Mat22;
        Physics.B2Transform = b2Transform;
        Physics.B2BuoyancyController = b2BuoyancyController;
        Physics.Box2DWorld = new b2World(new Physics.B2Vec2(0, Gravity / Physics.Box2DScale), true);
        b2Settings.b2_linearSleepTolerance = b2Settings.b2_linearSleepTolerance * 10;
        b2Settings.b2_angularSleepTolerance = b2Settings.b2_angularSleepTolerance * 10;
        b2World.m_continuousPhysics = false;
        var Listener = new b2ContactListener;
        Listener.BeginContact = Physics.ListenerBeginContact;
        Listener.EndContact = Physics.ListenerEndContact;
        Listener.PreSolve = Physics.ListenerPreSolve;
        Listener.PostSolve = Physics.ListenerPostSolve;
        Physics.Box2DWorld.SetContactListener(Listener);
        Physics.CollisionTable = [];
        Physics.RenderDebugBox = [];
        Physics.CurrentTime = 0;
        Physics.DesiredTime = 0
    };

    function Collision() {}
    Collision.DoesCircleOverlap = function DoesCircleOverlap(VertListA, RotA, xA, yA, RadiusB, xB, yB, CollisionPoint) {
        var aVertList = [];
        var CosAngle = Math.cos(RotA);
        var SinAngle = Math.sin(RotA);
        var i;
        for (i = 0; i < VertListA.length; i += 1) {
            aVertList[i] = {};
            aVertList[i].x = VertListA[i].x * CosAngle - VertListA[i].y * SinAngle + xA;
            aVertList[i].y = VertListA[i].x * SinAngle + VertListA[i].y * CosAngle + yA
        }
        var j;
        var Result = {};
        var p2;
        for (i = 0; i < aVertList.length; i += 1) {
            p2 = i + 1;
            if (p2 === aVertList.length) {
                p2 = 0
            }
            var x1 = aVertList[i].x;
            var y1 = aVertList[i].y;
            var x2 = aVertList[p2].x;
            var y2 = aVertList[p2].y;
            var dx = x2 - x1;
            var dy = y2 - y1;
            var a = dx * dx + dy * dy;
            var b = 2 * (dx * (x1 - xB) + dy * (y1 - yB));
            var c = xB * xB + yB * yB;
            c += x1 * x1 + y1 * y1;
            c -= 2 * (xB * x1 + yB * y1);
            c -= RadiusB * RadiusB;
            var bb4ac = b * b - 4 * a * c;
            if (bb4ac < 0) {} else {
                return true
            }
        }
        return false
    };
    Collision.DoShapesOverlap = function DoShapesOverlap(VertListA, RotA, xA, yA, VertListB, NormListB, RotB, xB, yB, CollisionPoint) {
        var aVertList = [];
        var CosAngle = Math.cos(RotA);
        var SinAngle = Math.sin(RotA);
        var i;
        for (i = 0; i < VertListA.length; i += 1) {
            aVertList[i] = {};
            aVertList[i].x = VertListA[i].x * CosAngle - VertListA[i].y * SinAngle + xA;
            aVertList[i].y = VertListA[i].x * SinAngle + VertListA[i].y * CosAngle + yA
        }
        var bVertList = [];
        CosAngle = Math.cos(RotB);
        SinAngle = Math.sin(RotB);
        for (i = 0; i < VertListB.length; i += 1) {
            bVertList[i] = {};
            bVertList[i].x = VertListB[i].x * CosAngle - VertListB[i].y * SinAngle + xB;
            bVertList[i].y = VertListB[i].x * SinAngle + VertListB[i].y * CosAngle + yB
        }
        var j;
        var Result = {};
        var p2;
        for (i = 0; i < aVertList.length; i += 1) {
            p2 = i + 1;
            if (p2 === aVertList.length) {
                p2 = 0
            }
            for (j = 0; j < bVertList.length; j += 1) {
                var p4 = j + 1;
                if (p4 === bVertList.length) {
                    p4 = 0
                }
                Collision.GetLineIntersection(aVertList[i], aVertList[p2], bVertList[j], bVertList[p4], Result);
                if (Result.Hit) {
                    CollisionPoint.x = Result.HitX;
                    CollisionPoint.y = Result.HitY;
                    CollisionPoint.vx = NormListB[j].x;
                    CollisionPoint.vy = NormListB[j].y;
                    return true
                }
            }
        }
        var AllInside = true;
        var dx1, dy1, dx2, dy2;
        var Side;
        for (i = 0; i < aVertList.length; i += 1) {
            p2 = i + 1;
            if (p2 === aVertList.length) {
                p2 = 0
            }
            for (j = 0; j < bVertList.length; j += 1) {
                dx1 = aVertList[p2].x - aVertList[i].x;
                dy1 = aVertList[p2].y - aVertList[i].y;
                dx2 = bVertList[j].x - aVertList[p2].x;
                dy2 = bVertList[j].y - aVertList[p2].y;
                Side = dx1 * dy2 - dy1 * dx2;
                if (Side < 0) {
                    AllInside = false
                }
            }
        }
        if (AllInside) {
            CollisionPoint.x = aVertList[0].x;
            CollisionPoint.y = aVertList[0].y;
            CollisionPoint.vx = 0;
            CollisionPoint.vy = 1;
            return true
        }
        AllInside = true;
        for (i = 0; i < bVertList.length; i += 1) {
            p2 = i + 1;
            if (p2 === bVertList.length) {
                p2 = 0
            }
            for (j = 0; j < aVertList.length; j += 1) {
                dx1 = bVertList[p2].x - bVertList[i].x;
                dy1 = bVertList[p2].y - bVertList[i].y;
                dx2 = aVertList[j].x - bVertList[p2].x;
                dy2 = aVertList[j].y - bVertList[p2].y;
                Side = dx1 * dy2 - dy1 * dx2;
                if (Side < 0) {
                    AllInside = false
                }
            }
        }
        if (AllInside) {
            CollisionPoint.x = aVertList[0].x;
            CollisionPoint.y = aVertList[0].y;
            CollisionPoint.vx = 0;
            CollisionPoint.vy = 1;
            return true
        }
        return false
    };
    Collision.GetLineIntersection = function GetLineIntersection(p0, p1, p2, p3, Result) {
        var s1_x, s1_y, s2_x, s2_y;
        s1_x = p1.x - p0.x;
        s1_y = p1.y - p0.y;
        s2_x = p3.x - p2.x;
        s2_y = p3.y - p2.y;
        var Cross = -s2_x * s1_y + s1_x * s2_y;
        var xd = p0.x - p2.x;
        var yd = p0.y - p2.y;
        var s = (-s1_y * xd + s1_x * yd) / Cross;
        var t = (s2_x * yd - s2_y * xd) / Cross;
        if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {
            Result.HitX = p0.x + t * s1_x;
            Result.HitY = p0.y + t * s1_y;
            Result.Hit = true;
            return
        }
        Result.Hit = false
    };
    Collision.convexPolygonOverlap = function findSeparatingAxis(aVertList, bVertList) {
        if (Collision.findSeparatingAxis(aVertList, bVertList)) {
            return false
        }
        if (Collision.findSeparatingAxis(bVertList, aVertList)) {
            return false
        }
        return true
    };
    Collision.findSeparatingAxis = function findSeparatingAxis(aVertList, bVertList) {
        var prev = aVertList.length - 1;
        var cur;
        for (cur = 0; cur < aVertList.length; cur += 1) {
            var edge = {};
            edge.x = aVertList[cur].x - aVertList[prev].x;
            edge.y = aVertList[cur].y - aVertList[prev].y;
            var v = {};
            v.x = edge.y;
            v.y = -edge.x;
            var aMinMax, bMinMax;
            aMinMax = Collision.gatherPolygonProjectionExtents(aVertList, v);
            bMinMax = Collision.gatherPolygonProjectionExtents(bVertList, v);
            if (aMinMax.outMax < bMinMax.outMin) {
                return true
            }
            if (bMinMax.outMax < aMinMax.outMin) {
                return true
            }
            prev = cur
        }
        return false
    };
    Collision.gatherPolygonProjectionExtents = function gatherPolygonProjectionExtents(vertList, v, outMin, outMax) {
        var Output = {};
        Output.outMin = v.x * vertList[0].x + v.y * vertList[0].y;
        Output.outMax = Output.outMin;
        var i;
        for (i = 1; i < vertList.length; i += 1) {
            var d = v.x * vertList[i].x + v.y * vertList[i].y;
            if (d < Output.outMin) {
                Output.outMin = d
            } else {
                if (d > Output.outMax) {
                    Output.outMax = d
                }
            }
        }
        return Output
    };

    function Polygon(_x, _y) {
        this.x = [];
        this.y = [];
        this.nVertices = _x.length;
        for (var i = 0; i < this.nVertices; ++i) {
            this.x[i] = _x[i];
            this.y[i] = _y[i]
        }
    }
    Polygon.prototype.set = function(p) {
        this.nVertices = p.nVertices;
        this.x = [];
        this.y = [];
        for (var i = 0; i < this.nVertices; ++i) {
            this.x[i] = p.x[i];
            this.y[i] = p.y[i]
        }
    };
    Polygon.prototype.isConvex = function() {
        var isPositive = false;
        for (var i = 0; i < this.nVertices; ++i) {
            var lower;
            if (i == 0) lower = this.nVertices - 1;
            else lower = i - 1;
            var middle = i;
            var upper;
            if (i == this.nVertices - 1) upper = 0;
            else upper = i + 1;
            var dx0 = this.x[middle] - this.x[lower];
            var dy0 = this.y[middle] - this.y[lower];
            var dx1 = this.x[upper] - this.x[middle];
            var dy1 = this.y[upper] - this.y[middle];
            var cross = dx0 * dy1 - dx1 * dy0;
            var newIsP;
            if (cross > 0) newIsP = true;
            else newIsP = false;
            if (i == 0) {
                isPositive = newIsP
            } else if (isPositive != newIsP) {
                return false
            }
        }
        return true
    };
    Polygon.prototype.add = function(t) {
        var firstP = -1;
        var firstT = -1;
        var secondP = -1;
        var secondT = -1;
        var i = 0;
        for (i = 0; i < this.nVertices; i++) {
            if (t.x[0] == this.x[i] && t.y[0] == this.y[i]) {
                if (firstP == -1) {
                    firstP = i;
                    firstT = 0
                } else {
                    secondP = i;
                    secondT = 0
                }
            } else if (t.x[1] == this.x[i] && t.y[1] == this.y[i]) {
                if (firstP == -1) {
                    firstP = i;
                    firstT = 1
                } else {
                    secondP = i;
                    secondT = 1
                }
            } else if (t.x[2] == this.x[i] && t.y[2] == this.y[i]) {
                if (firstP == -1) {
                    firstP = i;
                    firstT = 2
                } else {
                    secondP = i;
                    secondT = 2
                }
            } else {}
        }
        if (firstP == 0 && secondP == this.nVertices - 1) {
            firstP = this.nVertices - 1;
            secondP = 0
        }
        if (secondP == -1) return null;
        var tipT = 0;
        if (tipT == firstT || tipT == secondT) tipT = 1;
        if (tipT == firstT || tipT == secondT) tipT = 2;
        var newx = [];
        var newy = [];
        var currOut = 0;
        for (i = 0; i < this.nVertices; i++) {
            newx[currOut] = this.x[i];
            newy[currOut] = this.y[i];
            if (i == firstP) {
                ++currOut;
                newx[currOut] = t.x[tipT];
                newy[currOut] = t.y[tipT]
            }++currOut
        }
        return new Polygon(newx, newy)
    };

    function Point(_x, _y) {
        this.x = _x;
        this.y = _y
    }

    function Triangle(x1, y1, x2, y2, x3, y3) {
        this.x = [];
        this.y = [];
        var dx1 = x2 - x1;
        var dx2 = x3 - x1;
        var dy1 = y2 - y1;
        var dy2 = y3 - y1;
        var cross = dx1 * dy2 - dx2 * dy1;
        var ccw = cross > 0;
        if (ccw) {
            this.x[0] = x1;
            this.x[1] = x2;
            this.x[2] = x3;
            this.y[0] = y1;
            this.y[1] = y2;
            this.y[2] = y3
        } else {
            this.x[0] = x1;
            this.x[1] = x3;
            this.x[2] = x2;
            this.y[0] = y1;
            this.y[1] = y3;
            this.y[2] = y2
        }
    }
    Triangle.prototype.isInside = function(_x, _y) {
        var vx2 = _x - this.x[0];
        var vy2 = _y - this.y[0];
        var vx1 = this.x[1] - this.x[0];
        var vy1 = this.y[1] - this.y[0];
        var vx0 = this.x[2] - this.x[0];
        var vy0 = this.y[2] - this.y[0];
        var dot00 = vx0 * vx0 + vy0 * vy0;
        var dot01 = vx0 * vx1 + vy0 * vy1;
        var dot02 = vx0 * vx2 + vy0 * vy2;
        var dot11 = vx1 * vx1 + vy1 * vy1;
        var dot12 = vx1 * vx2 + vy1 * vy2;
        var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
        var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
        return u > 0 && v > 0 && u + v < 1
    };
    var MAX_VERTICES = 8;

    function triangulatePolygon(v) {
        var xA = [];
        var yA = [];
        for (var i = 0; i < v.length; i++) {
            xA.push(v[i].x);
            yA.push(v[i].y)
        }
        return triangulatePolygonFromFlatArray(xA, yA)
    }

    function triangulatePolygonFromFlatArray(xv, yv) {
        if (xv.length < 3 || yv.length < 3 || yv.length != xv.length) {
            console.log("Please make sure both arrays or of the same length and have at least 3 vertices in them!");
            return null
        }
        var i = 0;
        var vNum = xv.length;
        var buffer = [];
        var bufferSize = 0;
        var xrem = [];
        var yrem = [];
        for (i = 0; i < vNum; ++i) {
            xrem[i] = xv[i];
            yrem[i] = yv[i]
        }
        while (vNum > 3) {
            var earIndex = -1;
            for (i = 0; i < vNum; ++i) {
                if (isEar(i, xrem, yrem)) {
                    earIndex = i;
                    break
                }
            }
            if (earIndex == -1) {
                console.log("no ear found");
                return null
            }--vNum;
            var newx = [];
            var newy = [];
            var currDest = 0;
            for (i = 0; i < vNum; ++i) {
                if (currDest == earIndex) ++currDest;
                newx[i] = xrem[currDest];
                newy[i] = yrem[currDest];
                ++currDest
            }
            var under;
            if (earIndex == 0) under = xrem.length - 1;
            else under = earIndex - 1;
            var over;
            if (earIndex == xrem.length - 1) over = 0;
            else over = earIndex + 1;
            var toAdd = new Triangle(xrem[earIndex], yrem[earIndex], xrem[over], yrem[over], xrem[under], yrem[under]);
            buffer[bufferSize] = toAdd;
            ++bufferSize;
            xrem = newx;
            yrem = newy
        }
        var toAddMore = new Triangle(xrem[1], yrem[1], xrem[2], yrem[2], xrem[0], yrem[0]);
        buffer[bufferSize] = toAddMore;
        ++bufferSize;
        var res = [];
        for (i = 0; i < bufferSize; i++) {
            res[i] = buffer[i]
        }
        return res
    }

    function polygonizeTriangles(triangulated) {
        var polys;
        var polyIndex = 0;
        var i = 0;
        if (triangulated == null) {
            return null
        } else {
            polys = [];
            var covered = [];
            for (i = 0; i < triangulated.length; i++) {
                covered[i] = false
            }
            var notDone = true;
            while (notDone) {
                var currTri = -1;
                for (i = 0; i < triangulated.length; i++) {
                    if (covered[i]) continue;
                    currTri = i;
                    break
                }
                if (currTri == -1) {
                    notDone = false
                } else {
                    var poly = new Polygon(triangulated[currTri].x, triangulated[currTri].y);
                    covered[currTri] = true;
                    for (i = 0; i < triangulated.length; i++) {
                        if (covered[i]) continue;
                        var newP = poly.add(triangulated[i]);
                        if (newP == null) continue;
                        if (newP.isConvex()) {
                            poly = newP;
                            covered[i] = true
                        }
                        if (poly.nVertices >= MAX_VERTICES) break
                    }
                    polys[polyIndex] = poly;
                    polyIndex++
                }
            }
        }
        var ret = [];
        for (i = 0; i < polyIndex; i++) {
            ret[i] = polys[i]
        }
        return ret
    }

    function isEar(i, xv, yv) {
        var dx0, dy0, dx1, dy1;
        dx0 = dy0 = dx1 = dy1 = 0;
        if (i >= xv.length || i < 0 || xv.length < 3) {
            return false
        }
        var upper = i + 1;
        var lower = i - 1;
        if (i == 0) {
            dx0 = xv[0] - xv[xv.length - 1];
            dy0 = yv[0] - yv[yv.length - 1];
            dx1 = xv[1] - xv[0];
            dy1 = yv[1] - yv[0];
            lower = xv.length - 1
        } else if (i == xv.length - 1) {
            dx0 = xv[i] - xv[i - 1];
            dy0 = yv[i] - yv[i - 1];
            dx1 = xv[0] - xv[i];
            dy1 = yv[0] - yv[i];
            upper = 0
        } else {
            dx0 = xv[i] - xv[i - 1];
            dy0 = yv[i] - yv[i - 1];
            dx1 = xv[i + 1] - xv[i];
            dy1 = yv[i + 1] - yv[i]
        }
        var cross = dx0 * dy1 - dx1 * dy0;
        if (cross > 0) return false;
        var myTri = new Triangle(xv[i], yv[i], xv[upper], yv[upper], xv[lower], yv[lower]);
        for (var j = 0; j < xv.length; ++j) {
            if (!(j == i || j == lower || j == upper)) {
                if (myTri.isInside(xv[j], yv[j])) return false
            }
        }
        return true
    }
    if (typeof exports !== "undefined") {
        exports.b2BoundValues = b2BoundValues;
        exports.b2Math = b2Math;
        exports.b2DistanceOutput = b2DistanceOutput;
        exports.b2Mat33 = b2Mat33;
        exports.b2ContactPoint = b2ContactPoint;
        exports.b2PairManager = b2PairManager;
        exports.b2PositionSolverManifold = b2PositionSolverManifold;
        exports.b2OBB = b2OBB;
        exports.b2CircleContact = b2CircleContact;
        exports.b2PulleyJoint = b2PulleyJoint;
        exports.b2Pair = b2Pair;
        exports.b2TimeStep = b2TimeStep;
        exports.b2FixtureDef = b2FixtureDef;
        exports.b2World = b2World;
        exports.b2PrismaticJoint = b2PrismaticJoint;
        exports.b2Controller = b2Controller;
        exports.b2ContactID = b2ContactID;
        exports.b2RevoluteJoint = b2RevoluteJoint;
        exports.b2JointDef = b2JointDef;
        exports.b2Transform = b2Transform;
        exports.b2GravityController = b2GravityController;
        exports.b2EdgeAndCircleContact = b2EdgeAndCircleContact;
        exports.b2EdgeShape = b2EdgeShape;
        exports.b2BuoyancyController = b2BuoyancyController;
        exports.b2LineJointDef = b2LineJointDef;
        exports.b2Contact = b2Contact;
        exports.b2DistanceJoint = b2DistanceJoint;
        exports.b2RopeJoint = b2RopeJoint;
        exports.b2Body = b2Body;
        exports.b2DestructionListener = b2DestructionListener;
        exports.b2PulleyJointDef = b2PulleyJointDef;
        exports.b2ContactEdge = b2ContactEdge;
        exports.b2ContactConstraint = b2ContactConstraint;
        exports.b2ContactImpulse = b2ContactImpulse;
        exports.b2DistanceJointDef = b2DistanceJointDef;
        exports.b2RopeJointDef = b2RopeJointDef;
        exports.b2ContactResult = b2ContactResult;
        exports.b2EdgeChainDef = b2EdgeChainDef;
        exports.b2Vec2 = b2Vec2;
        exports.b2Vec3 = b2Vec3;
        exports.b2DistanceProxy = b2DistanceProxy;
        exports.b2FrictionJointDef = b2FrictionJointDef;
        exports.b2PolygonContact = b2PolygonContact;
        exports.b2TensorDampingController = b2TensorDampingController;
        exports.b2ContactFactory = b2ContactFactory;
        exports.b2WeldJointDef = b2WeldJointDef;
        exports.b2ConstantAccelController = b2ConstantAccelController;
        exports.b2GearJointDef = b2GearJointDef;
        exports.ClipVertex = ClipVertex;
        exports.b2SeparationFunction = b2SeparationFunction;
        exports.b2ManifoldPoint = b2ManifoldPoint;
        exports.b2Color = b2Color;
        exports.b2PolygonShape = b2PolygonShape;
        exports.b2DynamicTreePair = b2DynamicTreePair;
        exports.b2ContactConstraintPoint = b2ContactConstraintPoint;
        exports.b2FrictionJoint = b2FrictionJoint;
        exports.b2ContactFilter = b2ContactFilter;
        exports.b2ControllerEdge = b2ControllerEdge;
        exports.b2Distance = b2Distance;
        exports.b2Fixture = b2Fixture;
        exports.b2DynamicTreeNode = b2DynamicTreeNode;
        exports.b2MouseJoint = b2MouseJoint;
        exports.b2DistanceInput = b2DistanceInput;
        exports.b2BodyDef = b2BodyDef;
        exports.b2DynamicTreeBroadPhase = b2DynamicTreeBroadPhase;
        exports.b2Settings = b2Settings;
        exports.b2Proxy = b2Proxy;
        exports.b2Point = b2Point;
        exports.b2BroadPhase = b2BroadPhase;
        exports.b2Manifold = b2Manifold;
        exports.b2WorldManifold = b2WorldManifold;
        exports.b2PrismaticJointDef = b2PrismaticJointDef;
        exports.b2RayCastOutput = b2RayCastOutput;
        exports.b2ConstantForceController = b2ConstantForceController;
        exports.b2TimeOfImpact = b2TimeOfImpact;
        exports.b2CircleShape = b2CircleShape;
        exports.b2MassData = b2MassData;
        exports.b2Joint = b2Joint;
        exports.b2GearJoint = b2GearJoint;
        exports.b2DynamicTree = b2DynamicTree;
        exports.b2JointEdge = b2JointEdge;
        exports.b2LineJoint = b2LineJoint;
        exports.b2NullContact = b2NullContact;
        exports.b2ContactListener = b2ContactListener;
        exports.b2RayCastInput = b2RayCastInput;
        exports.b2TOIInput = b2TOIInput;
        exports.Features = Features;
        exports.b2FilterData = b2FilterData;
        exports.b2Island = b2Island;
        exports.b2ContactManager = b2ContactManager;
        exports.b2ContactSolver = b2ContactSolver;
        exports.b2Simplex = b2Simplex;
        exports.b2AABB = b2AABB;
        exports.b2Jacobian = b2Jacobian;
        exports.b2Bound = b2Bound;
        exports.b2RevoluteJointDef = b2RevoluteJointDef;
        exports.b2PolyAndEdgeContact = b2PolyAndEdgeContact;
        exports.b2SimplexVertex = b2SimplexVertex;
        exports.b2WeldJoint = b2WeldJoint;
        exports.b2Collision = b2Collision;
        exports.b2Mat22 = b2Mat22;
        exports.b2SimplexCache = b2SimplexCache;
        exports.b2PolyAndCircleContact = b2PolyAndCircleContact;
        exports.b2MouseJointDef = b2MouseJointDef;
        exports.b2Shape = b2Shape;
        exports.b2Segment = b2Segment;
        exports.b2ContactRegister = b2ContactRegister;
        exports.b2DebugDraw = b2DebugDraw;
        exports.b2Sweep = b2Sweep
    }

    function extend(a, b) {
        for (var c in b) {
            a[c] = b[c]
        }
    }

    function isInstanceOf(obj, _constructor) {
        while (typeof obj === "object") {
            if (obj.constructor === _constructor) return true;
            obj = obj._super
        }
        return false
    }
    var b2BoundValues = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2BoundValues.prototype.__constructor = function() {
        this.lowerValues = new Array;
        this.lowerValues[0] = 0;
        this.lowerValues[1] = 0;
        this.upperValues = new Array;
        this.upperValues[0] = 0;
        this.upperValues[1] = 0
    };
    b2BoundValues.prototype.__varz = function() {};
    b2BoundValues.prototype.lowerValues = null;
    b2BoundValues.prototype.upperValues = null;
    var b2PairManager = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2PairManager.prototype.__constructor = function() {
        this.m_pairs = new Array;
        this.m_pairBuffer = new Array;
        this.m_pairCount = 0;
        this.m_pairBufferCount = 0;
        this.m_freePair = null
    };
    b2PairManager.prototype.__varz = function() {};
    b2PairManager.prototype.AddPair = function(proxy1, proxy2) {
        var pair = proxy1.pairs[proxy2];
        if (pair != null) return pair;
        if (this.m_freePair == null) {
            this.m_freePair = new b2Pair;
            this.m_pairs.push(this.m_freePair)
        }
        pair = this.m_freePair;
        this.m_freePair = pair.next;
        pair.proxy1 = proxy1;
        pair.proxy2 = proxy2;
        pair.status = 0;
        pair.userData = null;
        pair.next = null;
        proxy1.pairs[proxy2] = pair;
        proxy2.pairs[proxy1] = pair;
        ++this.m_pairCount;
        return pair
    };
    b2PairManager.prototype.RemovePair = function(proxy1, proxy2) {
        var pair = proxy1.pairs[proxy2];
        if (pair == null) {
            return null
        }
        var userData = pair.userData;
        delete proxy1.pairs[proxy2];
        delete proxy2.pairs[proxy1];
        pair.next = this.m_freePair;
        pair.proxy1 = null;
        pair.proxy2 = null;
        pair.userData = null;
        pair.status = 0;
        this.m_freePair = pair;
        --this.m_pairCount;
        return userData
    };
    b2PairManager.prototype.Find = function(proxy1, proxy2) {
        return proxy1.pairs[proxy2]
    };
    b2PairManager.prototype.ValidateBuffer = function() {};
    b2PairManager.prototype.ValidateTable = function() {};
    b2PairManager.prototype.Initialize = function(broadPhase) {
        this.m_broadPhase = broadPhase
    };
    b2PairManager.prototype.AddBufferedPair = function(proxy1, proxy2) {
        var pair = this.AddPair(proxy1, proxy2);
        if (pair.IsBuffered() == false) {
            pair.SetBuffered();
            this.m_pairBuffer[this.m_pairBufferCount] = pair;
            ++this.m_pairBufferCount
        }
        pair.ClearRemoved();
        if (b2BroadPhase.s_validate) {
            this.ValidateBuffer()
        }
    };
    b2PairManager.prototype.RemoveBufferedPair = function(proxy1, proxy2) {
        var pair = this.Find(proxy1, proxy2);
        if (pair == null) {
            return
        }
        if (pair.IsBuffered() == false) {
            pair.SetBuffered();
            this.m_pairBuffer[this.m_pairBufferCount] = pair;
            ++this.m_pairBufferCount
        }
        pair.SetRemoved();
        if (b2BroadPhase.s_validate) {
            this.ValidateBuffer()
        }
    };
    b2PairManager.prototype.Commit = function(callback) {
        var i = 0;
        var removeCount = 0;
        for (i = 0; i < this.m_pairBufferCount; ++i) {
            var pair = this.m_pairBuffer[i];
            pair.ClearBuffered();
            var proxy1 = pair.proxy1;
            var proxy2 = pair.proxy2;
            if (pair.IsRemoved()) {} else {
                if (pair.IsFinal() == false) {
                    callback(proxy1.userData, proxy2.userData)
                }
            }
        }
        this.m_pairBufferCount = 0;
        if (b2BroadPhase.s_validate) {
            this.ValidateTable()
        }
    };
    b2PairManager.prototype.m_broadPhase = null;
    b2PairManager.prototype.m_pairs = null;
    b2PairManager.prototype.m_freePair = null;
    b2PairManager.prototype.m_pairCount = 0;
    b2PairManager.prototype.m_pairBuffer = null;
    b2PairManager.prototype.m_pairBufferCount = 0;
    var b2TimeStep = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2TimeStep.prototype.__constructor = function() {};
    b2TimeStep.prototype.__varz = function() {};
    b2TimeStep.prototype.Set = function(step) {
        this.dt = step.dt;
        this.inv_dt = step.inv_dt;
        this.positionIterations = step.positionIterations;
        this.velocityIterations = step.velocityIterations;
        this.warmStarting = step.warmStarting
    };
    b2TimeStep.prototype.dt = null;
    b2TimeStep.prototype.inv_dt = null;
    b2TimeStep.prototype.dtRatio = null;
    b2TimeStep.prototype.velocityIterations = 0;
    b2TimeStep.prototype.positionIterations = 0;
    b2TimeStep.prototype.warmStarting = null;
    var b2Controller = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2Controller.prototype.__constructor = function() {};
    b2Controller.prototype.__varz = function() {};
    b2Controller.prototype.Step = function(step) {};
    b2Controller.prototype.Draw = function(debugDraw) {};
    b2Controller.prototype.AddBody = function(body) {
        var edge = new b2ControllerEdge;
        edge.controller = this;
        edge.body = body;
        edge.nextBody = this.m_bodyList;
        edge.prevBody = null;
        this.m_bodyList = edge;
        if (edge.nextBody) edge.nextBody.prevBody = edge;
        this.m_bodyCount++;
        edge.nextController = body.m_controllerList;
        edge.prevController = null;
        body.m_controllerList = edge;
        if (edge.nextController) edge.nextController.prevController = edge;
        body.m_controllerCount++
    };
    b2Controller.prototype.RemoveBody = function(body) {
        var edge = body.m_controllerList;
        while (edge && edge.controller != this) edge = edge.nextController;
        if (edge.prevBody) edge.prevBody.nextBody = edge.nextBody;
        if (edge.nextBody) edge.nextBody.prevBody = edge.prevBody;
        if (edge.nextController) edge.nextController.prevController = edge.prevController;
        if (edge.prevController) edge.prevController.nextController = edge.nextController;
        if (this.m_bodyList == edge) this.m_bodyList = edge.nextBody;
        if (body.m_controllerList == edge) body.m_controllerList = edge.nextController;
        body.m_controllerCount--;
        this.m_bodyCount--
    };
    b2Controller.prototype.Clear = function() {
        while (this.m_bodyList) this.RemoveBody(this.m_bodyList.body)
    };
    b2Controller.prototype.GetNext = function() {
        return this.m_next
    };
    b2Controller.prototype.GetWorld = function() {
        return this.m_world
    };
    b2Controller.prototype.GetBodyList = function() {
        return this.m_bodyList
    };
    b2Controller.prototype.m_bodyList = null;
    b2Controller.prototype.m_bodyCount = 0;
    b2Controller.prototype.m_next = null;
    b2Controller.prototype.m_prev = null;
    b2Controller.prototype.m_world = null;
    var b2GravityController = function() {
        b2Controller.prototype.__varz.call(this);
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    extend(b2GravityController.prototype, b2Controller.prototype);
    b2GravityController.prototype._super = b2Controller.prototype;
    b2GravityController.prototype.__constructor = function() {
        this._super.__constructor.apply(this, arguments)
    };
    b2GravityController.prototype.__varz = function() {};
    b2GravityController.prototype.Step = function(step) {
        var i = null;
        var body1 = null;
        var p1 = null;
        var mass1 = 0;
        var j = null;
        var body2 = null;
        var p2 = null;
        var dx = 0;
        var dy = 0;
        var r2 = 0;
        var f = null;
        if (this.invSqr) {
            for (i = m_bodyList; i; i = i.nextBody) {
                body1 = i.body;
                p1 = body1.GetWorldCenter();
                mass1 = body1.GetMass();
                for (j = m_bodyList; j != i; j = j.nextBody) {
                    body2 = j.body;
                    p2 = body2.GetWorldCenter();
                    dx = p2.x - p1.x;
                    dy = p2.y - p1.y;
                    r2 = dx * dx + dy * dy;
                    if (r2 < Number.MIN_VALUE) continue;
                    f = new b2Vec2(dx, dy);
                    f.Multiply(this.G / r2 / Math.sqrt(r2) * mass1 * body2.GetMass());
                    if (body1.IsAwake()) body1.ApplyForce(f, p1);
                    f.Multiply(-1);
                    if (body2.IsAwake()) body2.ApplyForce(f, p2)
                }
            }
        } else {
            for (i = m_bodyList; i; i = i.nextBody) {
                body1 = i.body;
                p1 = body1.GetWorldCenter();
                mass1 = body1.GetMass();
                for (j = m_bodyList; j != i; j = j.nextBody) {
                    body2 = j.body;
                    p2 = body2.GetWorldCenter();
                    dx = p2.x - p1.x;
                    dy = p2.y - p1.y;
                    r2 = dx * dx + dy * dy;
                    if (r2 < Number.MIN_VALUE) continue;
                    f = new b2Vec2(dx, dy);
                    f.Multiply(this.G / r2 * mass1 * body2.GetMass());
                    if (body1.IsAwake()) body1.ApplyForce(f, p1);
                    f.Multiply(-1);
                    if (body2.IsAwake()) body2.ApplyForce(f, p2)
                }
            }
        }
    };
    b2GravityController.prototype.G = 1;
    b2GravityController.prototype.invSqr = true;
    var b2DestructionListener = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2DestructionListener.prototype.__constructor = function() {};
    b2DestructionListener.prototype.__varz = function() {};
    b2DestructionListener.prototype.SayGoodbyeJoint = function(joint) {};
    b2DestructionListener.prototype.SayGoodbyeFixture = function(fixture) {};
    var b2ContactEdge = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2ContactEdge.prototype.__constructor = function() {};
    b2ContactEdge.prototype.__varz = function() {};
    b2ContactEdge.prototype.other = null;
    b2ContactEdge.prototype.contact = null;
    b2ContactEdge.prototype.prev = null;
    b2ContactEdge.prototype.next = null;
    var b2EdgeChainDef = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2EdgeChainDef.prototype.__constructor = function() {
        this.vertexCount = 0;
        this.isALoop = true;
        this.vertices = []
    };
    b2EdgeChainDef.prototype.__varz = function() {};
    b2EdgeChainDef.prototype.vertices = null;
    b2EdgeChainDef.prototype.vertexCount = null;
    b2EdgeChainDef.prototype.isALoop = null;
    var b2Vec2 = function(x_, y_) {
        if (arguments.length == 2) {
            this.x = x_;
            this.y = y_
        }
    };
    b2Vec2.Make = function(x_, y_) {
        return new b2Vec2(x_, y_)
    };
    b2Vec2.prototype.SetZero = function() {
        this.x = 0;
        this.y = 0
    };
    b2Vec2.prototype.Set = function(x_, y_) {
        this.x = x_;
        this.y = y_
    };
    b2Vec2.prototype.SetV = function(v) {
        this.x = v.x;
        this.y = v.y
    };
    b2Vec2.prototype.GetNegative = function() {
        return new b2Vec2(-this.x, -this.y)
    };
    b2Vec2.prototype.NegativeSelf = function() {
        this.x = -this.x;
        this.y = -this.y
    };
    b2Vec2.prototype.Copy = function() {
        return new b2Vec2(this.x, this.y)
    };
    b2Vec2.prototype.Add = function(v) {
        this.x += v.x;
        this.y += v.y
    };
    b2Vec2.prototype.Subtract = function(v) {
        this.x -= v.x;
        this.y -= v.y
    };
    b2Vec2.prototype.Multiply = function(a) {
        this.x *= a;
        this.y *= a
    };
    b2Vec2.prototype.MulM = function(A) {
        var tX = this.x;
        this.x = A.col1.x * tX + A.col2.x * this.y;
        this.y = A.col1.y * tX + A.col2.y * this.y
    };
    b2Vec2.prototype.MulTM = function(A) {
        var tX = b2Math.Dot(this, A.col1);
        this.y = b2Math.Dot(this, A.col2);
        this.x = tX
    };
    b2Vec2.prototype.CrossVF = function(s) {
        var tX = this.x;
        this.x = s * this.y;
        this.y = -s * tX
    };
    b2Vec2.prototype.CrossFV = function(s) {
        var tX = this.x;
        this.x = -s * this.y;
        this.y = s * tX
    };
    b2Vec2.prototype.MinV = function(b) {
        this.x = this.x < b.x ? this.x : b.x;
        this.y = this.y < b.y ? this.y : b.y
    };
    b2Vec2.prototype.MaxV = function(b) {
        this.x = this.x > b.x ? this.x : b.x;
        this.y = this.y > b.y ? this.y : b.y
    };
    b2Vec2.prototype.Abs = function() {
        if (this.x < 0) this.x = -this.x;
        if (this.y < 0) this.y = -this.y
    };
    b2Vec2.prototype.Length = function() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    };
    b2Vec2.prototype.LengthSquared = function() {
        return this.x * this.x + this.y * this.y
    };
    b2Vec2.prototype.Normalize = function() {
        var length = Math.sqrt(this.x * this.x + this.y * this.y);
        if (length < Number.MIN_VALUE) {
            return 0
        }
        var invLength = 1 / length;
        this.x *= invLength;
        this.y *= invLength;
        return length
    };
    b2Vec2.prototype.IsValid = function() {
        return b2Math.IsValid(this.x) && b2Math.IsValid(this.y)
    };
    b2Vec2.prototype.x = 0;
    b2Vec2.prototype.y = 0;
    var b2Vec3 = function(x, y, z) {
        if (arguments.length == 3) {
            this.x = x;
            this.y = y;
            this.z = z
        }
    };
    b2Vec3.prototype.SetZero = function() {
        this.x = this.y = this.z = 0
    };
    b2Vec3.prototype.Set = function(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z
    };
    b2Vec3.prototype.SetV = function(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z
    };
    b2Vec3.prototype.GetNegative = function() {
        return new b2Vec3(-this.x, -this.y, -this.z)
    };
    b2Vec3.prototype.NegativeSelf = function() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z
    };
    b2Vec3.prototype.Copy = function() {
        return new b2Vec3(this.x, this.y, this.z)
    };
    b2Vec3.prototype.Add = function(v) {
        this.x += v.x;
        this.y += v.y;
        this.z += v.z
    };
    b2Vec3.prototype.Subtract = function(v) {
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z
    };
    b2Vec3.prototype.Multiply = function(a) {
        this.x *= a;
        this.y *= a;
        this.z *= a
    };
    b2Vec3.prototype.x = 0;
    b2Vec3.prototype.y = 0;
    b2Vec3.prototype.z = 0;
    var b2DistanceProxy = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2DistanceProxy.prototype.__constructor = function() {};
    b2DistanceProxy.prototype.__varz = function() {};
    b2DistanceProxy.prototype.Set = function(shape) {
        switch (shape.GetType()) {
            case b2Shape.e_circleShape:
                {
                    var circle = shape;this.m_vertices = new Array(1);this.m_vertices[0] = circle.m_p;this.m_count = 1;this.m_radius = circle.m_radius
                }
                break;
            case b2Shape.e_polygonShape:
                {
                    var polygon = shape;this.m_vertices = polygon.m_vertices;this.m_count = polygon.m_vertexCount;this.m_radius = polygon.m_radius
                }
                break;
            default:
                b2Settings.b2Assert(false)
        }
    };
    b2DistanceProxy.prototype.GetSupport = function(d) {
        var bestIndex = 0;
        var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
        for (var i = 1; i < this.m_count; ++i) {
            var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
            if (value > bestValue) {
                bestIndex = i;
                bestValue = value
            }
        }
        return bestIndex
    };
    b2DistanceProxy.prototype.GetSupportVertex = function(d) {
        var bestIndex = 0;
        var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
        for (var i = 1; i < this.m_count; ++i) {
            var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
            if (value > bestValue) {
                bestIndex = i;
                bestValue = value
            }
        }
        return this.m_vertices[bestIndex]
    };
    b2DistanceProxy.prototype.GetVertexCount = function() {
        return this.m_count
    };
    b2DistanceProxy.prototype.GetVertex = function(index) {
        b2Settings.b2Assert(0 <= index && index < this.m_count);
        return this.m_vertices[index]
    };
    b2DistanceProxy.prototype.m_vertices = null;
    b2DistanceProxy.prototype.m_count = 0;
    b2DistanceProxy.prototype.m_radius = null;
    var b2ContactFactory = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2ContactFactory.prototype.__constructor = function(allocator) {
        this.m_allocator = allocator;
        this.InitializeRegisters()
    };
    b2ContactFactory.prototype.__varz = function() {};
    b2ContactFactory.prototype.AddType = function(createFcn, destroyFcn, type1, type2) {
        this.m_registers[type1][type2].createFcn = createFcn;
        this.m_registers[type1][type2].destroyFcn = destroyFcn;
        this.m_registers[type1][type2].primary = true;
        if (type1 != type2) {
            this.m_registers[type2][type1].createFcn = createFcn;
            this.m_registers[type2][type1].destroyFcn = destroyFcn;
            this.m_registers[type2][type1].primary = false
        }
    };
    b2ContactFactory.prototype.InitializeRegisters = function() {
        this.m_registers = new Array(b2Shape.e_shapeTypeCount);
        for (var i = 0; i < b2Shape.e_shapeTypeCount; i++) {
            this.m_registers[i] = new Array(b2Shape.e_shapeTypeCount);
            for (var j = 0; j < b2Shape.e_shapeTypeCount; j++) {
                this.m_registers[i][j] = new b2ContactRegister
            }
        }
        this.AddType(b2CircleContact.Create, b2CircleContact.Destroy, b2Shape.e_circleShape, b2Shape.e_circleShape);
        this.AddType(b2PolyAndCircleContact.Create, b2PolyAndCircleContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_circleShape);
        this.AddType(b2PolygonContact.Create, b2PolygonContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_polygonShape);
        this.AddType(b2EdgeAndCircleContact.Create, b2EdgeAndCircleContact.Destroy, b2Shape.e_edgeShape, b2Shape.e_circleShape);
        this.AddType(b2PolyAndEdgeContact.Create, b2PolyAndEdgeContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_edgeShape)
    };
    b2ContactFactory.prototype.Create = function(fixtureA, fixtureB) {
        var type1 = fixtureA.GetType();
        var type2 = fixtureB.GetType();
        var reg = this.m_registers[type1][type2];
        var c;
        if (reg.pool) {
            c = reg.pool;
            reg.pool = c.m_next;
            reg.poolCount--;
            c.Reset(fixtureA, fixtureB);
            return c
        }
        var createFcn = reg.createFcn;
        if (createFcn != null) {
            if (reg.primary) {
                c = createFcn(this.m_allocator);
                c.Reset(fixtureA, fixtureB);
                return c
            } else {
                c = createFcn(this.m_allocator);
                c.Reset(fixtureB, fixtureA);
                return c
            }
        } else {
            return null
        }
    };
    b2ContactFactory.prototype.Destroy = function(contact) {
        if (contact.m_manifold.m_pointCount > 0) {
            contact.m_fixtureA.m_body.SetAwake(true);
            contact.m_fixtureB.m_body.SetAwake(true)
        }
        var type1 = contact.m_fixtureA.GetType();
        var type2 = contact.m_fixtureB.GetType();
        var reg = this.m_registers[type1][type2];
        if (true) {
            reg.poolCount++;
            contact.m_next = reg.pool;
            reg.pool = contact
        }
        var destroyFcn = reg.destroyFcn;
        destroyFcn(contact, this.m_allocator)
    };
    b2ContactFactory.prototype.m_registers = null;
    b2ContactFactory.prototype.m_allocator = null;
    var b2ConstantAccelController = function() {
        b2Controller.prototype.__varz.call(this);
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    extend(b2ConstantAccelController.prototype, b2Controller.prototype);
    b2ConstantAccelController.prototype._super = b2Controller.prototype;
    b2ConstantAccelController.prototype.__constructor = function() {
        this._super.__constructor.apply(this, arguments)
    };
    b2ConstantAccelController.prototype.__varz = function() {
        this.A = new b2Vec2(0, 0)
    };
    b2ConstantAccelController.prototype.Step = function(step) {
        var smallA = new b2Vec2(this.A.x * step.dt, this.A.y * step.dt);
        for (var i = m_bodyList; i; i = i.nextBody) {
            var body = i.body;
            if (!body.IsAwake()) continue;
            body.SetLinearVelocity(new b2Vec2(body.GetLinearVelocity().x + smallA.x, body.GetLinearVelocity().y + smallA.y))
        }
    };
    b2ConstantAccelController.prototype.A = new b2Vec2(0, 0);
    var b2SeparationFunction = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2SeparationFunction.prototype.__constructor = function() {};
    b2SeparationFunction.prototype.__varz = function() {
        this.m_localPoint = new b2Vec2;
        this.m_axis = new b2Vec2
    };
    b2SeparationFunction.e_points = 1;
    b2SeparationFunction.e_faceA = 2;
    b2SeparationFunction.e_faceB = 4;
    b2SeparationFunction.prototype.Initialize = function(cache, proxyA, transformA, proxyB, transformB) {
        this.m_proxyA = proxyA;
        this.m_proxyB = proxyB;
        var count = cache.count;
        b2Settings.b2Assert(0 < count && count < 3);
        var localPointA;
        var localPointA1;
        var localPointA2;
        var localPointB;
        var localPointB1;
        var localPointB2;
        var pointAX;
        var pointAY;
        var pointBX;
        var pointBY;
        var normalX;
        var normalY;
        var tMat;
        var tVec;
        var s;
        var sgn;
        if (count == 1) {
            this.m_type = b2SeparationFunction.e_points;
            localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
            localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
            tVec = localPointA;
            tMat = transformA.R;
            pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tVec = localPointB;
            tMat = transformB.R;
            pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            this.m_axis.x = pointBX - pointAX;
            this.m_axis.y = pointBY - pointAY;
            this.m_axis.Normalize()
        } else if (cache.indexB[0] == cache.indexB[1]) {
            this.m_type = b2SeparationFunction.e_faceA;
            localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
            localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
            localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
            this.m_localPoint.x = .5 * (localPointA1.x + localPointA2.x);
            this.m_localPoint.y = .5 * (localPointA1.y + localPointA2.y);
            this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointA2, localPointA1), 1);
            this.m_axis.Normalize();
            tVec = this.m_axis;
            tMat = transformA.R;
            normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tVec = this.m_localPoint;
            tMat = transformA.R;
            pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tVec = localPointB;
            tMat = transformB.R;
            pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            s = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;
            if (s < 0) {
                this.m_axis.NegativeSelf()
            }
        } else if (cache.indexA[0] == cache.indexA[0]) {
            this.m_type = b2SeparationFunction.e_faceB;
            localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
            localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
            localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
            this.m_localPoint.x = .5 * (localPointB1.x + localPointB2.x);
            this.m_localPoint.y = .5 * (localPointB1.y + localPointB2.y);
            this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointB2, localPointB1), 1);
            this.m_axis.Normalize();
            tVec = this.m_axis;
            tMat = transformB.R;
            normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tVec = this.m_localPoint;
            tMat = transformB.R;
            pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tVec = localPointA;
            tMat = transformA.R;
            pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            s = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;
            if (s < 0) {
                this.m_axis.NegativeSelf()
            }
        } else {
            localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
            localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
            localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
            localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
            var pA = b2Math.MulX(transformA, localPointA);
            var dA = b2Math.MulMV(transformA.R, b2Math.SubtractVV(localPointA2, localPointA1));
            var pB = b2Math.MulX(transformB, localPointB);
            var dB = b2Math.MulMV(transformB.R, b2Math.SubtractVV(localPointB2, localPointB1));
            var a = dA.x * dA.x + dA.y * dA.y;
            var e = dB.x * dB.x + dB.y * dB.y;
            var r = b2Math.SubtractVV(dB, dA);
            var c = dA.x * r.x + dA.y * r.y;
            var f = dB.x * r.x + dB.y * r.y;
            var b = dA.x * dB.x + dA.y * dB.y;
            var denom = a * e - b * b;
            s = 0;
            if (denom != 0) {
                s = b2Math.Clamp((b * f - c * e) / denom, 0, 1)
            }
            var t = (b * s + f) / e;
            if (t < 0) {
                t = 0;
                s = b2Math.Clamp((b - c) / a, 0, 1)
            }
            localPointA = new b2Vec2;
            localPointA.x = localPointA1.x + s * (localPointA2.x - localPointA1.x);
            localPointA.y = localPointA1.y + s * (localPointA2.y - localPointA1.y);
            localPointB = new b2Vec2;
            localPointB.x = localPointB1.x + s * (localPointB2.x - localPointB1.x);
            localPointB.y = localPointB1.y + s * (localPointB2.y - localPointB1.y);
            if (s == 0 || s == 1) {
                this.m_type = b2SeparationFunction.e_faceB;
                this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointB2, localPointB1), 1);
                this.m_axis.Normalize();
                this.m_localPoint = localPointB;
                tVec = this.m_axis;
                tMat = transformB.R;
                normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                tVec = this.m_localPoint;
                tMat = transformB.R;
                pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
                pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
                tVec = localPointA;
                tMat = transformA.R;
                pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
                pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
                sgn = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;
                if (s < 0) {
                    this.m_axis.NegativeSelf()
                }
            } else {
                this.m_type = b2SeparationFunction.e_faceA;
                this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointA2, localPointA1), 1);
                this.m_localPoint = localPointA;
                tVec = this.m_axis;
                tMat = transformA.R;
                normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                tVec = this.m_localPoint;
                tMat = transformA.R;
                pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
                pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
                tVec = localPointB;
                tMat = transformB.R;
                pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
                pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
                sgn = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;
                if (s < 0) {
                    this.m_axis.NegativeSelf()
                }
            }
        }
    };
    b2SeparationFunction.prototype.Evaluate = function(transformA, transformB) {
        var axisA;
        var axisB;
        var localPointA;
        var localPointB;
        var pointA;
        var pointB;
        var seperation;
        var normal;
        switch (this.m_type) {
            case b2SeparationFunction.e_points:
                {
                    axisA = b2Math.MulTMV(transformA.R, this.m_axis);axisB = b2Math.MulTMV(transformB.R, this.m_axis.GetNegative());localPointA = this.m_proxyA.GetSupportVertex(axisA);localPointB = this.m_proxyB.GetSupportVertex(axisB);pointA = b2Math.MulX(transformA, localPointA);pointB = b2Math.MulX(transformB, localPointB);seperation = (pointB.x - pointA.x) * this.m_axis.x + (pointB.y - pointA.y) * this.m_axis.y;
                    return seperation
                }
            case b2SeparationFunction.e_faceA:
                {
                    normal = b2Math.MulMV(transformA.R, this.m_axis);pointA = b2Math.MulX(transformA, this.m_localPoint);axisB = b2Math.MulTMV(transformB.R, normal.GetNegative());localPointB = this.m_proxyB.GetSupportVertex(axisB);pointB = b2Math.MulX(transformB, localPointB);seperation = (pointB.x - pointA.x) * normal.x + (pointB.y - pointA.y) * normal.y;
                    return seperation
                }
            case b2SeparationFunction.e_faceB:
                {
                    normal = b2Math.MulMV(transformB.R, this.m_axis);pointB = b2Math.MulX(transformB, this.m_localPoint);axisA = b2Math.MulTMV(transformA.R, normal.GetNegative());localPointA = this.m_proxyA.GetSupportVertex(axisA);pointA = b2Math.MulX(transformA, localPointA);seperation = (pointA.x - pointB.x) * normal.x + (pointA.y - pointB.y) * normal.y;
                    return seperation
                }
            default:
                b2Settings.b2Assert(false);
                return 0
        }
    };
    b2SeparationFunction.prototype.m_proxyA = null;
    b2SeparationFunction.prototype.m_proxyB = null;
    b2SeparationFunction.prototype.m_type = 0;
    b2SeparationFunction.prototype.m_localPoint = new b2Vec2;
    b2SeparationFunction.prototype.m_axis = new b2Vec2;
    var b2DynamicTreePair = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2DynamicTreePair.prototype.__constructor = function() {};
    b2DynamicTreePair.prototype.__varz = function() {};
    b2DynamicTreePair.prototype.proxyA = null;
    b2DynamicTreePair.prototype.proxyB = null;
    var b2ContactConstraintPoint = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2ContactConstraintPoint.prototype.__constructor = function() {};
    b2ContactConstraintPoint.prototype.__varz = function() {
        this.localPoint = new b2Vec2;
        this.rA = new b2Vec2;
        this.rB = new b2Vec2
    };
    b2ContactConstraintPoint.prototype.localPoint = new b2Vec2;
    b2ContactConstraintPoint.prototype.rA = new b2Vec2;
    b2ContactConstraintPoint.prototype.rB = new b2Vec2;
    b2ContactConstraintPoint.prototype.normalImpulse = null;
    b2ContactConstraintPoint.prototype.tangentImpulse = null;
    b2ContactConstraintPoint.prototype.normalMass = null;
    b2ContactConstraintPoint.prototype.tangentMass = null;
    b2ContactConstraintPoint.prototype.equalizedMass = null;
    b2ContactConstraintPoint.prototype.velocityBias = null;
    var b2ControllerEdge = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2ControllerEdge.prototype.__constructor = function() {};
    b2ControllerEdge.prototype.__varz = function() {};
    b2ControllerEdge.prototype.controller = null;
    b2ControllerEdge.prototype.body = null;
    b2ControllerEdge.prototype.prevBody = null;
    b2ControllerEdge.prototype.nextBody = null;
    b2ControllerEdge.prototype.prevController = null;
    b2ControllerEdge.prototype.nextController = null;
    var b2DistanceInput = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2DistanceInput.prototype.__constructor = function() {};
    b2DistanceInput.prototype.__varz = function() {};
    b2DistanceInput.prototype.proxyA = null;
    b2DistanceInput.prototype.proxyB = null;
    b2DistanceInput.prototype.transformA = null;
    b2DistanceInput.prototype.transformB = null;
    b2DistanceInput.prototype.useRadii = null;
    var b2Settings = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2Settings.prototype.__constructor = function() {};
    b2Settings.prototype.__varz = function() {};
    b2Settings.b2MixFriction = function(friction1, friction2) {
        return Math.sqrt(friction1 * friction2)
    };
    b2Settings.b2MixRestitution = function(restitution1, restitution2) {
        return restitution1 > restitution2 ? restitution1 : restitution2
    };
    b2Settings.b2Assert = function(a) {
        if (!a) {
            throw "Assertion Failed"
        }
    };
    b2Settings.VERSION = "2.1alpha";
    b2Settings.USHRT_MAX = 65535;
    b2Settings.b2_pi = Math.PI;
    b2Settings.b2_maxManifoldPoints = 2;
    b2Settings.b2_aabbExtension = .1;
    b2Settings.b2_aabbMultiplier = 2;
    b2Settings.b2_polygonRadius = 2 * b2Settings.b2_linearSlop;
    b2Settings.b2_linearSlop = .005;
    b2Settings.b2_angularSlop = 2 / 180 * b2Settings.b2_pi;
    b2Settings.b2_toiSlop = 8 * b2Settings.b2_linearSlop;
    b2Settings.b2_maxTOIContactsPerIsland = 32;
    b2Settings.b2_maxTOIJointsPerIsland = 32;
    b2Settings.b2_velocityThreshold = 1;
    b2Settings.b2_maxLinearCorrection = .2;
    b2Settings.b2_maxAngularCorrection = 8 / 180 * b2Settings.b2_pi;
    b2Settings.b2_maxTranslation = 2;
    b2Settings.b2_maxTranslationSquared = b2Settings.b2_maxTranslation * b2Settings.b2_maxTranslation;
    b2Settings.b2_maxRotation = .5 * b2Settings.b2_pi;
    b2Settings.b2_maxRotationSquared = b2Settings.b2_maxRotation * b2Settings.b2_maxRotation;
    b2Settings.b2_contactBaumgarte = .2;
    b2Settings.b2_timeToSleep = .5;
    b2Settings.b2_linearSleepTolerance = .01;
    b2Settings.b2_angularSleepTolerance = 2 / 180 * b2Settings.b2_pi;
    var b2Proxy = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2Proxy.prototype.__constructor = function() {};
    b2Proxy.prototype.__varz = function() {
        this.lowerBounds = new Array(2);
        this.upperBounds = new Array(2);
        this.pairs = new Object
    };
    b2Proxy.prototype.IsValid = function() {
        return this.overlapCount != b2BroadPhase.b2_invalid
    };
    b2Proxy.prototype.lowerBounds = new Array(2);
    b2Proxy.prototype.upperBounds = new Array(2);
    b2Proxy.prototype.overlapCount = 0;
    b2Proxy.prototype.timeStamp = 0;
    b2Proxy.prototype.pairs = new Object;
    b2Proxy.prototype.next = null;
    b2Proxy.prototype.userData = null;
    var b2Point = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2Point.prototype.__constructor = function() {};
    b2Point.prototype.__varz = function() {
        this.p = new b2Vec2
    };
    b2Point.prototype.Support = function(xf, vX, vY) {
        return this.p
    };
    b2Point.prototype.GetFirstVertex = function(xf) {
        return this.p
    };
    b2Point.prototype.p = new b2Vec2;
    var b2WorldManifold = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2WorldManifold.prototype.__constructor = function() {
        this.m_points = new Array(b2Settings.b2_maxManifoldPoints);
        for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
            this.m_points[i] = new b2Vec2
        }
    };
    b2WorldManifold.prototype.__varz = function() {
        this.m_normal = new b2Vec2
    };
    b2WorldManifold.prototype.Initialize = function(manifold, xfA, radiusA, xfB, radiusB) {
        if (manifold.m_pointCount == 0) {
            return
        }
        var i = 0;
        var tVec;
        var tMat;
        var normalX;
        var normalY;
        var planePointX;
        var planePointY;
        var clipPointX;
        var clipPointY;
        switch (manifold.m_type) {
            case b2Manifold.e_circles:
                {
                    tMat = xfA.R;tVec = manifold.m_localPoint;
                    var pointAX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                    var pointAY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;tMat = xfB.R;tVec = manifold.m_points[0].m_localPoint;
                    var pointBX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                    var pointBY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                    var dX = pointBX - pointAX;
                    var dY = pointBY - pointAY;
                    var d2 = dX * dX + dY * dY;
                    if (d2 > Number.MIN_VALUE * Number.MIN_VALUE) {
                        var d = Math.sqrt(d2);
                        this.m_normal.x = dX / d;
                        this.m_normal.y = dY / d
                    } else {
                        this.m_normal.x = 1;
                        this.m_normal.y = 0
                    }
                    var cAX = pointAX + radiusA * this.m_normal.x;
                    var cAY = pointAY + radiusA * this.m_normal.y;
                    var cBX = pointBX - radiusB * this.m_normal.x;
                    var cBY = pointBY - radiusB * this.m_normal.y;this.m_points[0].x = .5 * (cAX + cBX);this.m_points[0].y = .5 * (cAY + cBY)
                }
                break;
            case b2Manifold.e_faceA:
                {
                    tMat = xfA.R;tVec = manifold.m_localPlaneNormal;normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;tMat = xfA.R;tVec = manifold.m_localPoint;planePointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;planePointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;this.m_normal.x = normalX;this.m_normal.y = normalY;
                    for (i = 0; i < manifold.m_pointCount; i++) {
                        tMat = xfB.R;
                        tVec = manifold.m_points[i].m_localPoint;
                        clipPointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                        clipPointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                        this.m_points[i].x = clipPointX + .5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalX;
                        this.m_points[i].y = clipPointY + .5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalY
                    }
                }
                break;
            case b2Manifold.e_faceB:
                {
                    tMat = xfB.R;tVec = manifold.m_localPlaneNormal;normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;tMat = xfB.R;tVec = manifold.m_localPoint;planePointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;planePointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;this.m_normal.x = -normalX;this.m_normal.y = -normalY;
                    for (i = 0; i < manifold.m_pointCount; i++) {
                        tMat = xfA.R;
                        tVec = manifold.m_points[i].m_localPoint;
                        clipPointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
                        clipPointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
                        this.m_points[i].x = clipPointX + .5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalX;
                        this.m_points[i].y = clipPointY + .5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalY
                    }
                }
                break
        }
    };
    b2WorldManifold.prototype.m_normal = new b2Vec2;
    b2WorldManifold.prototype.m_points = null;
    var b2RayCastOutput = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2RayCastOutput.prototype.__constructor = function() {};
    b2RayCastOutput.prototype.__varz = function() {
        this.normal = new b2Vec2
    };
    b2RayCastOutput.prototype.normal = new b2Vec2;
    b2RayCastOutput.prototype.fraction = null;
    var b2ConstantForceController = function() {
        b2Controller.prototype.__varz.call(this);
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    extend(b2ConstantForceController.prototype, b2Controller.prototype);
    b2ConstantForceController.prototype._super = b2Controller.prototype;
    b2ConstantForceController.prototype.__constructor = function() {
        this._super.__constructor.apply(this, arguments)
    };
    b2ConstantForceController.prototype.__varz = function() {
        this.F = new b2Vec2(0, 0)
    };
    b2ConstantForceController.prototype.Step = function(step) {
        for (var i = m_bodyList; i; i = i.nextBody) {
            var body = i.body;
            if (!body.IsAwake()) continue;
            body.ApplyForce(this.F, body.GetWorldCenter())
        }
    };
    b2ConstantForceController.prototype.F = new b2Vec2(0, 0);
    var b2MassData = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2MassData.prototype.__constructor = function() {};
    b2MassData.prototype.__varz = function() {
        this.center = new b2Vec2(0, 0)
    };
    b2MassData.prototype.mass = 0;
    b2MassData.prototype.center = new b2Vec2(0, 0);
    b2MassData.prototype.I = 0;
    var b2DynamicTree = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2DynamicTree.prototype.__constructor = function() {
        this.m_root = null;
        this.m_freeList = null;
        this.m_path = 0;
        this.m_insertionCount = 0
    };
    b2DynamicTree.prototype.__varz = function() {};
    b2DynamicTree.prototype.AllocateNode = function() {
        if (this.m_freeList) {
            var node = this.m_freeList;
            this.m_freeList = node.parent;
            node.parent = null;
            node.child1 = null;
            node.child2 = null;
            return node
        }
        return new b2DynamicTreeNode
    };
    b2DynamicTree.prototype.FreeNode = function(node) {
        node.parent = this.m_freeList;
        this.m_freeList = node
    };
    b2DynamicTree.prototype.InsertLeaf = function(leaf) {
        ++this.m_insertionCount;
        if (this.m_root == null) {
            this.m_root = leaf;
            this.m_root.parent = null;
            return
        }
        var center = leaf.aabb.GetCenter();
        var sibling = this.m_root;
        if (sibling.IsLeaf() == false) {
            do {
                var child1 = sibling.child1;
                var child2 = sibling.child2;
                var norm1 = Math.abs((child1.aabb.lowerBound.x + child1.aabb.upperBound.x) / 2 - center.x) + Math.abs((child1.aabb.lowerBound.y + child1.aabb.upperBound.y) / 2 - center.y);
                var norm2 = Math.abs((child2.aabb.lowerBound.x + child2.aabb.upperBound.x) / 2 - center.x) + Math.abs((child2.aabb.lowerBound.y + child2.aabb.upperBound.y) / 2 - center.y);
                if (norm1 < norm2) {
                    sibling = child1
                } else {
                    sibling = child2
                }
            } while (sibling.IsLeaf() == false)
        }
        var node1 = sibling.parent;
        var node2 = this.AllocateNode();
        node2.parent = node1;
        node2.userData = null;
        node2.aabb.Combine(leaf.aabb, sibling.aabb);
        if (node1) {
            if (sibling.parent.child1 == sibling) {
                node1.child1 = node2
            } else {
                node1.child2 = node2
            }
            node2.child1 = sibling;
            node2.child2 = leaf;
            sibling.parent = node2;
            leaf.parent = node2;
            do {
                if (node1.aabb.Contains(node2.aabb)) break;
                node1.aabb.Combine(node1.child1.aabb, node1.child2.aabb);
                node2 = node1;
                node1 = node1.parent
            } while (node1)
        } else {
            node2.child1 = sibling;
            node2.child2 = leaf;
            sibling.parent = node2;
            leaf.parent = node2;
            this.m_root = node2
        }
    };
    b2DynamicTree.prototype.RemoveLeaf = function(leaf) {
        if (leaf == this.m_root) {
            this.m_root = null;
            return
        }
        var node2 = leaf.parent;
        var node1 = node2.parent;
        var sibling;
        if (node2.child1 == leaf) {
            sibling = node2.child2
        } else {
            sibling = node2.child1
        }
        if (node1) {
            if (node1.child1 == node2) {
                node1.child1 = sibling
            } else {
                node1.child2 = sibling
            }
            sibling.parent = node1;
            this.FreeNode(node2);
            while (node1) {
                var oldAABB = node1.aabb;
                node1.aabb = b2AABB.Combine(node1.child1.aabb, node1.child2.aabb);
                if (oldAABB.Contains(node1.aabb)) break;
                node1 = node1.parent
            }
        } else {
            this.m_root = sibling;
            sibling.parent = null;
            this.FreeNode(node2)
        }
    };
    b2DynamicTree.prototype.CreateProxy = function(aabb, userData) {
        var node = this.AllocateNode();
        var extendX = b2Settings.b2_aabbExtension;
        var extendY = b2Settings.b2_aabbExtension;
        node.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
        node.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
        node.aabb.upperBound.x = aabb.upperBound.x + extendX;
        node.aabb.upperBound.y = aabb.upperBound.y + extendY;
        node.userData = userData;
        this.InsertLeaf(node);
        return node
    };
    b2DynamicTree.prototype.DestroyProxy = function(proxy) {
        this.RemoveLeaf(proxy);
        this.FreeNode(proxy)
    };
    b2DynamicTree.prototype.MoveProxy = function(proxy, aabb, displacement) {
        b2Settings.b2Assert(proxy.IsLeaf());
        if (proxy.aabb.Contains(aabb)) {
            return false
        }
        this.RemoveLeaf(proxy);
        var extendX = b2Settings.b2_aabbExtension + b2Settings.b2_aabbMultiplier * (displacement.x > 0 ? displacement.x : -displacement.x);
        var extendY = b2Settings.b2_aabbExtension + b2Settings.b2_aabbMultiplier * (displacement.y > 0 ? displacement.y : -displacement.y);
        proxy.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
        proxy.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
        proxy.aabb.upperBound.x = aabb.upperBound.x + extendX;
        proxy.aabb.upperBound.y = aabb.upperBound.y + extendY;
        this.InsertLeaf(proxy);
        return true
    };
    b2DynamicTree.prototype.Rebalance = function(iterations) {
        if (this.m_root == null) return;
        for (var i = 0; i < iterations; i++) {
            var node = this.m_root;
            var bit = 0;
            while (node.IsLeaf() == false) {
                node = this.m_path >> bit & 1 ? node.child2 : node.child1;
                bit = bit + 1 & 31
            }++this.m_path;
            this.RemoveLeaf(node);
            this.InsertLeaf(node)
        }
    };
    b2DynamicTree.prototype.GetFatAABB = function(proxy) {
        return proxy.aabb
    };
    b2DynamicTree.prototype.GetUserData = function(proxy) {
        return proxy.userData
    };
    b2DynamicTree.prototype.Query = function(callback, aabb) {
        if (this.m_root == null) return;
        var stack = new Array;
        var count = 0;
        stack[count++] = this.m_root;
        while (count > 0) {
            var node = stack[--count];
            if (node.aabb.TestOverlap(aabb)) {
                if (node.IsLeaf()) {
                    var proceed = callback(node);
                    if (!proceed) return
                } else {
                    stack[count++] = node.child1;
                    stack[count++] = node.child2
                }
            }
        }
    };
    b2DynamicTree.prototype.RayCast = function(callback, input) {
        if (this.m_root == null) return;
        var p1 = input.p1;
        var p2 = input.p2;
        var r = b2Math.SubtractVV(p1, p2);
        r.Normalize();
        var v = b2Math.CrossFV(1, r);
        var abs_v = b2Math.AbsV(v);
        var maxFraction = input.maxFraction;
        var segmentAABB = new b2AABB;
        var tX;
        var tY; {
            tX = p1.x + maxFraction * (p2.x - p1.x);
            tY = p1.y + maxFraction * (p2.y - p1.y);
            segmentAABB.lowerBound.x = Math.min(p1.x, tX);
            segmentAABB.lowerBound.y = Math.min(p1.y, tY);
            segmentAABB.upperBound.x = Math.max(p1.x, tX);
            segmentAABB.upperBound.y = Math.max(p1.y, tY)
        }
        var stack = new Array;
        var count = 0;
        stack[count++] = this.m_root;
        while (count > 0) {
            var node = stack[--count];
            if (node.aabb.TestOverlap(segmentAABB) == false) {
                continue
            }
            var c = node.aabb.GetCenter();
            var h = node.aabb.GetExtents();
            var separation = Math.abs(v.x * (p1.x - c.x) + v.y * (p1.y - c.y)) - abs_v.x * h.x - abs_v.y * h.y;
            if (separation > 0) continue;
            if (node.IsLeaf()) {
                var subInput = new b2RayCastInput;
                subInput.p1 = input.p1;
                subInput.p2 = input.p2;
                subInput.maxFraction = input.maxFraction;
                maxFraction = callback(subInput, node);
                if (maxFraction == 0) return; {
                    tX = p1.x + maxFraction * (p2.x - p1.x);
                    tY = p1.y + maxFraction * (p2.y - p1.y);
                    segmentAABB.lowerBound.x = Math.min(p1.x, tX);
                    segmentAABB.lowerBound.y = Math.min(p1.y, tY);
                    segmentAABB.upperBound.x = Math.max(p1.x, tX);
                    segmentAABB.upperBound.y = Math.max(p1.y, tY)
                }
            } else {
                stack[count++] = node.child1;
                stack[count++] = node.child2
            }
        }
    };
    b2DynamicTree.prototype.m_root = null;
    b2DynamicTree.prototype.m_freeList = null;
    b2DynamicTree.prototype.m_path = 0;
    b2DynamicTree.prototype.m_insertionCount = 0;
    var b2JointEdge = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2JointEdge.prototype.__constructor = function() {};
    b2JointEdge.prototype.__varz = function() {};
    b2JointEdge.prototype.other = null;
    b2JointEdge.prototype.joint = null;
    b2JointEdge.prototype.prev = null;
    b2JointEdge.prototype.next = null;
    var b2RayCastInput = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2RayCastInput.prototype.__constructor = function(p1, p2, maxFraction) {
        if (p1) this.p1.SetV(p1);
        if (p2) this.p2.SetV(p2);
        if (maxFraction) this.maxFraction = maxFraction
    };
    b2RayCastInput.prototype.__varz = function() {
        this.p1 = new b2Vec2;
        this.p2 = new b2Vec2
    };
    b2RayCastInput.prototype.p1 = new b2Vec2;
    b2RayCastInput.prototype.p2 = new b2Vec2;
    b2RayCastInput.prototype.maxFraction = null;
    var Features = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    Features.prototype.__constructor = function() {};
    Features.prototype.__varz = function() {};
    Features.prototype.__defineGetter__("referenceEdge", function() {
        return this._referenceEdge
    });
    Features.prototype.__defineSetter__("referenceEdge", function(value) {
        this._referenceEdge = value;
        this._m_id._key = this._m_id._key & 4294967040 | this._referenceEdge & 255
    });
    Features.prototype.__defineGetter__("incidentEdge", function() {
        return this._incidentEdge
    });
    Features.prototype.__defineSetter__("incidentEdge", function(value) {
        this._incidentEdge = value;
        this._m_id._key = this._m_id._key & 4294902015 | this._incidentEdge << 8 & 65280
    });
    Features.prototype.__defineGetter__("incidentVertex", function() {
        return this._incidentVertex
    });
    Features.prototype.__defineSetter__("incidentVertex", function(value) {
        this._incidentVertex = value;
        this._m_id._key = this._m_id._key & 4278255615 | this._incidentVertex << 16 & 16711680
    });
    Features.prototype.__defineGetter__("flip", function() {
        return this._flip
    });
    Features.prototype.__defineSetter__("flip", function(value) {
        this._flip = value;
        this._m_id._key = this._m_id._key & 16777215 | this._flip << 24 & 4278190080
    });
    Features.prototype._referenceEdge = 0;
    Features.prototype._incidentEdge = 0;
    Features.prototype._incidentVertex = 0;
    Features.prototype._flip = 0;
    Features.prototype._m_id = null;
    var b2FilterData = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2FilterData.prototype.__constructor = function() {};
    b2FilterData.prototype.__varz = function() {
        this.categoryBits = 1;
        this.maskBits = 4294967295
    };
    b2FilterData.prototype.Copy = function() {
        var copy = new b2FilterData;
        copy.categoryBits = this.categoryBits;
        copy.maskBits = this.maskBits;
        copy.groupIndex = this.groupIndex;
        return copy
    };
    b2FilterData.prototype.categoryBits = 1;
    b2FilterData.prototype.maskBits = 4294967295;
    b2FilterData.prototype.groupIndex = 0;
    var b2AABB = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2AABB.prototype.__constructor = function() {};
    b2AABB.prototype.__varz = function() {
        this.lowerBound = new b2Vec2;
        this.upperBound = new b2Vec2
    };
    b2AABB.Combine = function(aabb1, aabb2) {
        var aabb = new b2AABB;
        aabb.Combine(aabb1, aabb2);
        return aabb
    };
    b2AABB.prototype.IsValid = function() {
        var dX = this.upperBound.x - this.lowerBound.x;
        var dY = this.upperBound.y - this.lowerBound.y;
        var valid = dX >= 0 && dY >= 0;
        valid = valid && this.lowerBound.IsValid() && this.upperBound.IsValid();
        return valid
    };
    b2AABB.prototype.GetCenter = function() {
        return new b2Vec2((this.lowerBound.x + this.upperBound.x) / 2, (this.lowerBound.y + this.upperBound.y) / 2)
    };
    b2AABB.prototype.GetExtents = function() {
        return new b2Vec2((this.upperBound.x - this.lowerBound.x) / 2, (this.upperBound.y - this.lowerBound.y) / 2)
    };
    b2AABB.prototype.Contains = function(aabb) {
        var result = true && this.lowerBound.x <= aabb.lowerBound.x && this.lowerBound.y <= aabb.lowerBound.y && aabb.upperBound.x <= this.upperBound.x && aabb.upperBound.y <= this.upperBound.y;
        return result
    };
    b2AABB.prototype.RayCast = function(output, input) {
        var tmin = -Number.MAX_VALUE;
        var tmax = Number.MAX_VALUE;
        var pX = input.p1.x;
        var pY = input.p1.y;
        var dX = input.p2.x - input.p1.x;
        var dY = input.p2.y - input.p1.y;
        var absDX = Math.abs(dX);
        var absDY = Math.abs(dY);
        var normal = output.normal;
        var inv_d;
        var t1;
        var t2;
        var t3;
        var s; {
            if (absDX < Number.MIN_VALUE) {
                if (pX < this.lowerBound.x || this.upperBound.x < pX) return false
            } else {
                inv_d = 1 / dX;
                t1 = (this.lowerBound.x - pX) * inv_d;
                t2 = (this.upperBound.x - pX) * inv_d;
                s = -1;
                if (t1 > t2) {
                    t3 = t1;
                    t1 = t2;
                    t2 = t3;
                    s = 1
                }
                if (t1 > tmin) {
                    normal.x = s;
                    normal.y = 0;
                    tmin = t1
                }
                tmax = Math.min(tmax, t2);
                if (tmin > tmax) return false
            }
        } {
            if (absDY < Number.MIN_VALUE) {
                if (pY < this.lowerBound.y || this.upperBound.y < pY) return false
            } else {
                inv_d = 1 / dY;
                t1 = (this.lowerBound.y - pY) * inv_d;
                t2 = (this.upperBound.y - pY) * inv_d;
                s = -1;
                if (t1 > t2) {
                    t3 = t1;
                    t1 = t2;
                    t2 = t3;
                    s = 1
                }
                if (t1 > tmin) {
                    normal.y = s;
                    normal.x = 0;
                    tmin = t1
                }
                tmax = Math.min(tmax, t2);
                if (tmin > tmax) return false
            }
        }
        output.fraction = tmin;
        return true
    };
    b2AABB.prototype.TestOverlap = function(other) {
        var d1X = other.lowerBound.x - this.upperBound.x;
        var d1Y = other.lowerBound.y - this.upperBound.y;
        var d2X = this.lowerBound.x - other.upperBound.x;
        var d2Y = this.lowerBound.y - other.upperBound.y;
        if (d1X > 0 || d1Y > 0) return false;
        if (d2X > 0 || d2Y > 0) return false;
        return true
    };
    b2AABB.prototype.Combine = function(aabb1, aabb2) {
        this.lowerBound.x = Math.min(aabb1.lowerBound.x, aabb2.lowerBound.x);
        this.lowerBound.y = Math.min(aabb1.lowerBound.y, aabb2.lowerBound.y);
        this.upperBound.x = Math.max(aabb1.upperBound.x, aabb2.upperBound.x);
        this.upperBound.y = Math.max(aabb1.upperBound.y, aabb2.upperBound.y)
    };
    b2AABB.prototype.lowerBound = new b2Vec2;
    b2AABB.prototype.upperBound = new b2Vec2;
    var b2Jacobian = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2Jacobian.prototype.__constructor = function() {};
    b2Jacobian.prototype.__varz = function() {
        this.linearA = new b2Vec2;
        this.linearB = new b2Vec2
    };
    b2Jacobian.prototype.SetZero = function() {
        this.linearA.SetZero();
        this.angularA = 0;
        this.linearB.SetZero();
        this.angularB = 0
    };
    b2Jacobian.prototype.Set = function(x1, a1, x2, a2) {
        this.linearA.SetV(x1);
        this.angularA = a1;
        this.linearB.SetV(x2);
        this.angularB = a2
    };
    b2Jacobian.prototype.Compute = function(x1, a1, x2, a2) {
        return this.linearA.x * x1.x + this.linearA.y * x1.y + this.angularA * a1 + (this.linearB.x * x2.x + this.linearB.y * x2.y) + this.angularB * a2
    };
    b2Jacobian.prototype.linearA = new b2Vec2;
    b2Jacobian.prototype.angularA = null;
    b2Jacobian.prototype.linearB = new b2Vec2;
    b2Jacobian.prototype.angularB = null;
    var b2Bound = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2Bound.prototype.__constructor = function() {};
    b2Bound.prototype.__varz = function() {};
    b2Bound.prototype.IsLower = function() {
        return (this.value & 1) == 0
    };
    b2Bound.prototype.IsUpper = function() {
        return (this.value & 1) == 1
    };
    b2Bound.prototype.Swap = function(b) {
        var tempValue = this.value;
        var tempProxy = this.proxy;
        var tempStabbingCount = this.stabbingCount;
        this.value = b.value;
        this.proxy = b.proxy;
        this.stabbingCount = b.stabbingCount;
        b.value = tempValue;
        b.proxy = tempProxy;
        b.stabbingCount = tempStabbingCount
    };
    b2Bound.prototype.value = 0;
    b2Bound.prototype.proxy = null;
    b2Bound.prototype.stabbingCount = 0;
    var b2SimplexVertex = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2SimplexVertex.prototype.__constructor = function() {};
    b2SimplexVertex.prototype.__varz = function() {};
    b2SimplexVertex.prototype.Set = function(other) {
        this.wA.SetV(other.wA);
        this.wB.SetV(other.wB);
        this.w.SetV(other.w);
        this.a = other.a;
        this.indexA = other.indexA;
        this.indexB = other.indexB
    };
    b2SimplexVertex.prototype.wA = null;
    b2SimplexVertex.prototype.wB = null;
    b2SimplexVertex.prototype.w = null;
    b2SimplexVertex.prototype.a = null;
    b2SimplexVertex.prototype.indexA = 0;
    b2SimplexVertex.prototype.indexB = 0;
    var b2Mat22 = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2Mat22.prototype.__constructor = function() {
        this.col1.x = this.col2.y = 1
    };
    b2Mat22.prototype.__varz = function() {
        this.col1 = new b2Vec2;
        this.col2 = new b2Vec2
    };
    b2Mat22.FromAngle = function(angle) {
        var mat = new b2Mat22;
        mat.Set(angle);
        return mat
    };
    b2Mat22.FromVV = function(c1, c2) {
        var mat = new b2Mat22;
        mat.SetVV(c1, c2);
        return mat
    };
    b2Mat22.prototype.Set = function(angle) {
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        this.col1.x = c;
        this.col2.x = -s;
        this.col1.y = s;
        this.col2.y = c
    };
    b2Mat22.prototype.SetVV = function(c1, c2) {
        this.col1.SetV(c1);
        this.col2.SetV(c2)
    };
    b2Mat22.prototype.Copy = function() {
        var mat = new b2Mat22;
        mat.SetM(this);
        return mat
    };
    b2Mat22.prototype.SetM = function(m) {
        this.col1.SetV(m.col1);
        this.col2.SetV(m.col2)
    };
    b2Mat22.prototype.AddM = function(m) {
        this.col1.x += m.col1.x;
        this.col1.y += m.col1.y;
        this.col2.x += m.col2.x;
        this.col2.y += m.col2.y
    };
    b2Mat22.prototype.SetIdentity = function() {
        this.col1.x = 1;
        this.col2.x = 0;
        this.col1.y = 0;
        this.col2.y = 1
    };
    b2Mat22.prototype.SetZero = function() {
        this.col1.x = 0;
        this.col2.x = 0;
        this.col1.y = 0;
        this.col2.y = 0
    };
    b2Mat22.prototype.GetAngle = function() {
        return Math.atan2(this.col1.y, this.col1.x)
    };
    b2Mat22.prototype.GetInverse = function(out) {
        var a = this.col1.x;
        var b = this.col2.x;
        var c = this.col1.y;
        var d = this.col2.y;
        var det = a * d - b * c;
        if (det != 0) {
            det = 1 / det
        }
        out.col1.x = det * d;
        out.col2.x = -det * b;
        out.col1.y = -det * c;
        out.col2.y = det * a;
        return out
    };
    b2Mat22.prototype.Solve = function(out, bX, bY) {
        var a11 = this.col1.x;
        var a12 = this.col2.x;
        var a21 = this.col1.y;
        var a22 = this.col2.y;
        var det = a11 * a22 - a12 * a21;
        if (det != 0) {
            det = 1 / det
        }
        out.x = det * (a22 * bX - a12 * bY);
        out.y = det * (a11 * bY - a21 * bX);
        return out
    };
    b2Mat22.prototype.Abs = function() {
        this.col1.Abs();
        this.col2.Abs()
    };
    b2Mat22.prototype.col1 = new b2Vec2;
    b2Mat22.prototype.col2 = new b2Vec2;
    var b2SimplexCache = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2SimplexCache.prototype.__constructor = function() {};
    b2SimplexCache.prototype.__varz = function() {
        this.indexA = new Array(3);
        this.indexB = new Array(3)
    };
    b2SimplexCache.prototype.metric = null;
    b2SimplexCache.prototype.count = 0;
    b2SimplexCache.prototype.indexA = new Array(3);
    b2SimplexCache.prototype.indexB = new Array(3);
    var b2Shape = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2Shape.prototype.__constructor = function() {
        this.m_type = b2Shape.e_unknownShape;
        this.m_radius = b2Settings.b2_linearSlop
    };
    b2Shape.prototype.__varz = function() {};
    b2Shape.TestOverlap = function(shape1, transform1, shape2, transform2) {
        var input = new b2DistanceInput;
        input.proxyA = new b2DistanceProxy;
        input.proxyA.Set(shape1);
        input.proxyB = new b2DistanceProxy;
        input.proxyB.Set(shape2);
        input.transformA = transform1;
        input.transformB = transform2;
        input.useRadii = true;
        var simplexCache = new b2SimplexCache;
        simplexCache.count = 0;
        var output = new b2DistanceOutput;
        b2Distance.Distance(output, simplexCache, input);
        return output.distance < 10 * Number.MIN_VALUE
    };
    b2Shape.e_hitCollide = 1;
    b2Shape.e_missCollide = 0;
    b2Shape.e_startsInsideCollide = -1;
    b2Shape.e_unknownShape = -1;
    b2Shape.e_circleShape = 0;
    b2Shape.e_polygonShape = 1;
    b2Shape.e_edgeShape = 2;
    b2Shape.e_shapeTypeCount = 3;
    b2Shape.prototype.Copy = function() {
        return null
    };
    b2Shape.prototype.Set = function(other) {
        this.m_radius = other.m_radius
    };
    b2Shape.prototype.GetType = function() {
        return this.m_type
    };
    b2Shape.prototype.TestPoint = function(xf, p) {
        return false
    };
    b2Shape.prototype.RayCast = function(output, input, transform) {
        return false
    };
    b2Shape.prototype.ComputeAABB = function(aabb, xf) {};
    b2Shape.prototype.ComputeMass = function(massData, density) {};
    b2Shape.prototype.ComputeSubmergedArea = function(normal, offset, xf, c) {
        return 0
    };
    b2Shape.prototype.m_type = 0;
    b2Shape.prototype.m_radius = null;
    var b2Segment = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2Segment.prototype.__constructor = function() {};
    b2Segment.prototype.__varz = function() {
        this.p1 = new b2Vec2;
        this.p2 = new b2Vec2
    };
    b2Segment.prototype.TestSegment = function(lambda, normal, segment, maxLambda) {
        var s = segment.p1;
        var rX = segment.p2.x - s.x;
        var rY = segment.p2.y - s.y;
        var dX = this.p2.x - this.p1.x;
        var dY = this.p2.y - this.p1.y;
        var nX = dY;
        var nY = -dX;
        var k_slop = 100 * Number.MIN_VALUE;
        var denom = -(rX * nX + rY * nY);
        if (denom > k_slop) {
            var bX = s.x - this.p1.x;
            var bY = s.y - this.p1.y;
            var a = bX * nX + bY * nY;
            if (0 <= a && a <= maxLambda * denom) {
                var mu2 = -rX * bY + rY * bX;
                if (-k_slop * denom <= mu2 && mu2 <= denom * (1 + k_slop)) {
                    a /= denom;
                    var nLen = Math.sqrt(nX * nX + nY * nY);
                    nX /= nLen;
                    nY /= nLen;
                    lambda[0] = a;
                    normal.Set(nX, nY);
                    return true
                }
            }
        }
        return false
    };
    b2Segment.prototype.Extend = function(aabb) {
        this.ExtendForward(aabb);
        this.ExtendBackward(aabb)
    };
    b2Segment.prototype.ExtendForward = function(aabb) {
        var dX = this.p2.x - this.p1.x;
        var dY = this.p2.y - this.p1.y;
        var lambda = Math.min(dX > 0 ? (aabb.upperBound.x - this.p1.x) / dX : dX < 0 ? (aabb.lowerBound.x - this.p1.x) / dX : Number.POSITIVE_INFINITY, dY > 0 ? (aabb.upperBound.y - this.p1.y) / dY : dY < 0 ? (aabb.lowerBound.y - this.p1.y) / dY : Number.POSITIVE_INFINITY);
        this.p2.x = this.p1.x + dX * lambda;
        this.p2.y = this.p1.y + dY * lambda
    };
    b2Segment.prototype.ExtendBackward = function(aabb) {
        var dX = -this.p2.x + this.p1.x;
        var dY = -this.p2.y + this.p1.y;
        var lambda = Math.min(dX > 0 ? (aabb.upperBound.x - this.p2.x) / dX : dX < 0 ? (aabb.lowerBound.x - this.p2.x) / dX : Number.POSITIVE_INFINITY, dY > 0 ? (aabb.upperBound.y - this.p2.y) / dY : dY < 0 ? (aabb.lowerBound.y - this.p2.y) / dY : Number.POSITIVE_INFINITY);
        this.p1.x = this.p2.x + dX * lambda;
        this.p1.y = this.p2.y + dY * lambda
    };
    b2Segment.prototype.p1 = new b2Vec2;
    b2Segment.prototype.p2 = new b2Vec2;
    var b2ContactRegister = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2ContactRegister.prototype.__constructor = function() {};
    b2ContactRegister.prototype.__varz = function() {};
    b2ContactRegister.prototype.createFcn = null;
    b2ContactRegister.prototype.destroyFcn = null;
    b2ContactRegister.prototype.primary = null;
    b2ContactRegister.prototype.pool = null;
    b2ContactRegister.prototype.poolCount = 0;
    var b2DebugDraw = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2DebugDraw.prototype.__constructor = function() {
        this.m_drawFlags = 0
    };
    b2DebugDraw.prototype.__varz = function() {};
    b2DebugDraw.e_shapeBit = 1;
    b2DebugDraw.e_jointBit = 2;
    b2DebugDraw.e_aabbBit = 4;
    b2DebugDraw.e_pairBit = 8;
    b2DebugDraw.e_centerOfMassBit = 16;
    b2DebugDraw.e_controllerBit = 32;
    b2DebugDraw.prototype.SetFlags = function(flags) {
        this.m_drawFlags = flags
    };
    b2DebugDraw.prototype.GetFlags = function() {
        return this.m_drawFlags
    };
    b2DebugDraw.prototype.AppendFlags = function(flags) {
        this.m_drawFlags |= flags
    };
    b2DebugDraw.prototype.ClearFlags = function(flags) {
        this.m_drawFlags &= ~flags
    };
    b2DebugDraw.prototype.SetSprite = function(sprite) {
        this.m_sprite = sprite
    };
    b2DebugDraw.prototype.GetSprite = function() {
        return this.m_sprite
    };
    b2DebugDraw.prototype.SetDrawScale = function(drawScale) {
        this.m_drawScale = drawScale
    };
    b2DebugDraw.prototype.GetDrawScale = function() {
        return this.m_drawScale
    };
    b2DebugDraw.prototype.SetLineThickness = function(lineThickness) {
        this.m_lineThickness = lineThickness
    };
    b2DebugDraw.prototype.GetLineThickness = function() {
        return this.m_lineThickness
    };
    b2DebugDraw.prototype.SetAlpha = function(alpha) {
        this.m_alpha = alpha
    };
    b2DebugDraw.prototype.GetAlpha = function() {
        return this.m_alpha
    };
    b2DebugDraw.prototype.SetFillAlpha = function(alpha) {
        this.m_fillAlpha = alpha
    };
    b2DebugDraw.prototype.GetFillAlpha = function() {
        return this.m_fillAlpha
    };
    b2DebugDraw.prototype.SetXFormScale = function(xformScale) {
        this.m_xformScale = xformScale
    };
    b2DebugDraw.prototype.GetXFormScale = function() {
        return this.m_xformScale
    };
    b2DebugDraw.prototype.Clear = function() {
        this.m_sprite.clearRect(0, 0, this.m_sprite.canvas.width, this.m_sprite.canvas.height)
    };
    b2DebugDraw.prototype.Y = function(y) {
        return this.m_sprite.canvas.height - y
    };
    b2DebugDraw.prototype.ToWorldPoint = function(localPoint) {
        return new b2Vec2(localPoint.x / this.m_drawScale, this.Y(localPoint.y) / this.m_drawScale)
    };
    b2DebugDraw.prototype.ColorStyle = function(color, alpha) {
        return "rgba(" + color.r + ", " + color.g + ", " + color.b + ", " + alpha + ")"
    };
    b2DebugDraw.prototype.DrawPolygon = function(vertices, vertexCount, color) {
        this.m_sprite.graphics.lineStyle(this.m_lineThickness, color.color, this.m_alpha);
        this.m_sprite.graphics.moveTo(vertices[0].x * this.m_drawScale, vertices[0].y * this.m_drawScale);
        for (var i = 1; i < vertexCount; i++) {
            this.m_sprite.graphics.lineTo(vertices[i].x * this.m_drawScale, vertices[i].y * this.m_drawScale)
        }
        this.m_sprite.graphics.lineTo(vertices[0].x * this.m_drawScale, vertices[0].y * this.m_drawScale)
    };
    b2DebugDraw.prototype.DrawSolidPolygon = function(vertices, vertexCount, color) {
        this.m_sprite.strokeSyle = this.ColorStyle(color, this.m_alpha);
        this.m_sprite.lineWidth = this.m_lineThickness;
        this.m_sprite.fillStyle = this.ColorStyle(color, this.m_fillAlpha);
        this.m_sprite.beginPath();
        this.m_sprite.moveTo(vertices[0].x * this.m_drawScale, this.Y(vertices[0].y * this.m_drawScale));
        for (var i = 1; i < vertexCount; i++) {
            this.m_sprite.lineTo(vertices[i].x * this.m_drawScale, this.Y(vertices[i].y * this.m_drawScale))
        }
        this.m_sprite.lineTo(vertices[0].x * this.m_drawScale, this.Y(vertices[0].y * this.m_drawScale));
        this.m_sprite.fill();
        this.m_sprite.stroke();
        this.m_sprite.closePath()
    };
    b2DebugDraw.prototype.DrawCircle = function(center, radius, color) {
        this.m_sprite.graphics.lineStyle(this.m_lineThickness, color.color, this.m_alpha);
        this.m_sprite.graphics.drawCircle(center.x * this.m_drawScale, center.y * this.m_drawScale, radius * this.m_drawScale)
    };
    b2DebugDraw.prototype.DrawSolidCircle = function(center, radius, axis, color) {
        this.m_sprite.strokeSyle = this.ColorStyle(color, this.m_alpha);
        this.m_sprite.lineWidth = this.m_lineThickness;
        this.m_sprite.fillStyle = this.ColorStyle(color, this.m_fillAlpha);
        this.m_sprite.beginPath();
        this.m_sprite.arc(center.x * this.m_drawScale, this.Y(center.y * this.m_drawScale), radius * this.m_drawScale, 0, Math.PI * 2, true);
        this.m_sprite.fill();
        this.m_sprite.stroke();
        this.m_sprite.closePath()
    };
    b2DebugDraw.prototype.DrawSegment = function(p1, p2, color) {
        this.m_sprite.lineWidth = this.m_lineThickness;
        this.m_sprite.strokeSyle = this.ColorStyle(color, this.m_alpha);
        this.m_sprite.beginPath();
        this.m_sprite.moveTo(p1.x * this.m_drawScale, this.Y(p1.y * this.m_drawScale));
        this.m_sprite.lineTo(p2.x * this.m_drawScale, this.Y(p2.y * this.m_drawScale));
        this.m_sprite.stroke();
        this.m_sprite.closePath()
    };
    b2DebugDraw.prototype.DrawTransform = function(xf) {
        this.m_sprite.lineWidth = this.m_lineThickness;
        this.m_sprite.strokeSyle = this.ColorStyle(new b2Color(255, 0, 0), this.m_alpha);
        this.m_sprite.beginPath();
        this.m_sprite.moveTo(xf.position.x * this.m_drawScale, this.Y(xf.position.y * this.m_drawScale));
        this.m_sprite.lineTo((xf.position.x + this.m_xformScale * xf.R.col1.x) * this.m_drawScale, this.Y((xf.position.y + this.m_xformScale * xf.R.col1.y) * this.m_drawScale));
        this.m_sprite.stroke();
        this.m_sprite.closePath();
        this.m_sprite.strokeSyle = this.ColorStyle(new b2Color(0, 255, 0), this.m_alpha);
        this.m_sprite.beginPath();
        this.m_sprite.moveTo(xf.position.x * this.m_drawScale, this.Y(xf.position.y * this.m_drawScale));
        this.m_sprite.lineTo((xf.position.x + this.m_xformScale * xf.R.col2.x) * this.m_drawScale, this.Y((xf.position.y + this.m_xformScale * xf.R.col2.y) * this.m_drawScale));
        this.m_sprite.stroke();
        this.m_sprite.closePath()
    };
    b2DebugDraw.prototype.m_drawFlags = 0;
    b2DebugDraw.prototype.m_sprite = null;
    b2DebugDraw.prototype.m_drawScale = 1;
    b2DebugDraw.prototype.m_lineThickness = 1;
    b2DebugDraw.prototype.m_alpha = 1;
    b2DebugDraw.prototype.m_fillAlpha = 1;
    b2DebugDraw.prototype.m_xformScale = 1;
    var b2Sweep = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2Sweep.prototype.__constructor = function() {};
    b2Sweep.prototype.__varz = function() {
        this.localCenter = new b2Vec2;
        this.c0 = new b2Vec2;
        this.c = new b2Vec2
    };
    b2Sweep.prototype.Set = function(other) {
        this.localCenter.SetV(other.localCenter);
        this.c0.SetV(other.c0);
        this.c.SetV(other.c);
        this.a0 = other.a0;
        this.a = other.a;
        this.t0 = other.t0
    };
    b2Sweep.prototype.Copy = function() {
        var copy = new b2Sweep;
        copy.localCenter.SetV(this.localCenter);
        copy.c0.SetV(this.c0);
        copy.c.SetV(this.c);
        copy.a0 = this.a0;
        copy.a = this.a;
        copy.t0 = this.t0;
        return copy
    };
    b2Sweep.prototype.GetTransform = function(xf, alpha) {
        xf.position.x = (1 - alpha) * this.c0.x + alpha * this.c.x;
        xf.position.y = (1 - alpha) * this.c0.y + alpha * this.c.y;
        var angle = (1 - alpha) * this.a0 + alpha * this.a;
        xf.R.Set(angle);
        var tMat = xf.R;
        xf.position.x -= tMat.col1.x * this.localCenter.x + tMat.col2.x * this.localCenter.y;
        xf.position.y -= tMat.col1.y * this.localCenter.x + tMat.col2.y * this.localCenter.y
    };
    b2Sweep.prototype.Advance = function(t) {
        if (this.t0 < t && 1 - this.t0 > Number.MIN_VALUE) {
            var alpha = (t - this.t0) / (1 - this.t0);
            this.c0.x = (1 - alpha) * this.c0.x + alpha * this.c.x;
            this.c0.y = (1 - alpha) * this.c0.y + alpha * this.c.y;
            this.a0 = (1 - alpha) * this.a0 + alpha * this.a;
            this.t0 = t
        }
    };
    b2Sweep.prototype.localCenter = new b2Vec2;
    b2Sweep.prototype.c0 = new b2Vec2;
    b2Sweep.prototype.c = new b2Vec2;
    b2Sweep.prototype.a0 = null;
    b2Sweep.prototype.a = null;
    b2Sweep.prototype.t0 = null;
    var b2DistanceOutput = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2DistanceOutput.prototype.__constructor = function() {};
    b2DistanceOutput.prototype.__varz = function() {
        this.pointA = new b2Vec2;
        this.pointB = new b2Vec2
    };
    b2DistanceOutput.prototype.pointA = new b2Vec2;
    b2DistanceOutput.prototype.pointB = new b2Vec2;
    b2DistanceOutput.prototype.distance = null;
    b2DistanceOutput.prototype.iterations = 0;
    var b2Mat33 = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2Mat33.prototype.__constructor = function(c1, c2, c3) {
        if (!c1 && !c2 && !c3) {
            this.col1.SetZero();
            this.col2.SetZero();
            this.col3.SetZero()
        } else {
            this.col1.SetV(c1);
            this.col2.SetV(c2);
            this.col3.SetV(c3)
        }
    };
    b2Mat33.prototype.__varz = function() {
        this.col1 = new b2Vec3;
        this.col2 = new b2Vec3;
        this.col3 = new b2Vec3
    };
    b2Mat33.prototype.SetVVV = function(c1, c2, c3) {
        this.col1.SetV(c1);
        this.col2.SetV(c2);
        this.col3.SetV(c3)
    };
    b2Mat33.prototype.Copy = function() {
        return new b2Mat33(this.col1, this.col2, this.col3)
    };
    b2Mat33.prototype.SetM = function(m) {
        this.col1.SetV(m.col1);
        this.col2.SetV(m.col2);
        this.col3.SetV(m.col3)
    };
    b2Mat33.prototype.AddM = function(m) {
        this.col1.x += m.col1.x;
        this.col1.y += m.col1.y;
        this.col1.z += m.col1.z;
        this.col2.x += m.col2.x;
        this.col2.y += m.col2.y;
        this.col2.z += m.col2.z;
        this.col3.x += m.col3.x;
        this.col3.y += m.col3.y;
        this.col3.z += m.col3.z
    };
    b2Mat33.prototype.SetIdentity = function() {
        this.col1.x = 1;
        this.col2.x = 0;
        this.col3.x = 0;
        this.col1.y = 0;
        this.col2.y = 1;
        this.col3.y = 0;
        this.col1.z = 0;
        this.col2.z = 0;
        this.col3.z = 1
    };
    b2Mat33.prototype.SetZero = function() {
        this.col1.x = 0;
        this.col2.x = 0;
        this.col3.x = 0;
        this.col1.y = 0;
        this.col2.y = 0;
        this.col3.y = 0;
        this.col1.z = 0;
        this.col2.z = 0;
        this.col3.z = 0
    };
    b2Mat33.prototype.Solve22 = function(out, bX, bY) {
        var a11 = this.col1.x;
        var a12 = this.col2.x;
        var a21 = this.col1.y;
        var a22 = this.col2.y;
        var det = a11 * a22 - a12 * a21;
        if (det != 0) {
            det = 1 / det
        }
        out.x = det * (a22 * bX - a12 * bY);
        out.y = det * (a11 * bY - a21 * bX);
        return out
    };
    b2Mat33.prototype.Solve33 = function(out, bX, bY, bZ) {
        var a11 = this.col1.x;
        var a21 = this.col1.y;
        var a31 = this.col1.z;
        var a12 = this.col2.x;
        var a22 = this.col2.y;
        var a32 = this.col2.z;
        var a13 = this.col3.x;
        var a23 = this.col3.y;
        var a33 = this.col3.z;
        var det = a11 * (a22 * a33 - a32 * a23) + a21 * (a32 * a13 - a12 * a33) + a31 * (a12 * a23 - a22 * a13);
        if (det != 0) {
            det = 1 / det
        }
        out.x = det * (bX * (a22 * a33 - a32 * a23) + bY * (a32 * a13 - a12 * a33) + bZ * (a12 * a23 - a22 * a13));
        out.y = det * (a11 * (bY * a33 - bZ * a23) + a21 * (bZ * a13 - bX * a33) + a31 * (bX * a23 - bY * a13));
        out.z = det * (a11 * (a22 * bZ - a32 * bY) + a21 * (a32 * bX - a12 * bZ) + a31 * (a12 * bY - a22 * bX));
        return out
    };
    b2Mat33.prototype.col1 = new b2Vec3;
    b2Mat33.prototype.col2 = new b2Vec3;
    b2Mat33.prototype.col3 = new b2Vec3;
    var b2PositionSolverManifold = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2PositionSolverManifold.prototype.__constructor = function() {
        this.m_normal = new b2Vec2;
        this.m_separations = new Array(b2Settings.b2_maxManifoldPoints);
        this.m_points = new Array(b2Settings.b2_maxManifoldPoints);
        for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
            this.m_points[i] = new b2Vec2
        }
    };
    b2PositionSolverManifold.prototype.__varz = function() {};
    b2PositionSolverManifold.circlePointA = new b2Vec2;
    b2PositionSolverManifold.circlePointB = new b2Vec2;
    b2PositionSolverManifold.prototype.Initialize = function(cc) {
        b2Settings.b2Assert(cc.pointCount > 0);
        var i = 0;
        var clipPointX;
        var clipPointY;
        var tMat;
        var tVec;
        var planePointX;
        var planePointY;
        switch (cc.type) {
            case b2Manifold.e_circles:
                {
                    tMat = cc.bodyA.m_xf.R;tVec = cc.localPoint;
                    var pointAX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
                    var pointAY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);tMat = cc.bodyB.m_xf.R;tVec = cc.points[0].localPoint;
                    var pointBX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
                    var pointBY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
                    var dX = pointBX - pointAX;
                    var dY = pointBY - pointAY;
                    var d2 = dX * dX + dY * dY;
                    if (d2 > Number.MIN_VALUE * Number.MIN_VALUE) {
                        var d = Math.sqrt(d2);
                        this.m_normal.x = dX / d;
                        this.m_normal.y = dY / d
                    } else {
                        this.m_normal.x = 1;
                        this.m_normal.y = 0
                    }
                    this.m_points[0].x = .5 * (pointAX + pointBX);this.m_points[0].y = .5 * (pointAY + pointBY);this.m_separations[0] = dX * this.m_normal.x + dY * this.m_normal.y - cc.radius
                }
                break;
            case b2Manifold.e_faceA:
                {
                    tMat = cc.bodyA.m_xf.R;tVec = cc.localPlaneNormal;this.m_normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;this.m_normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;tMat = cc.bodyA.m_xf.R;tVec = cc.localPoint;planePointX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);planePointY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);tMat = cc.bodyB.m_xf.R;
                    for (i = 0; i < cc.pointCount; ++i) {
                        tVec = cc.points[i].localPoint;
                        clipPointX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
                        clipPointY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
                        this.m_separations[i] = (clipPointX - planePointX) * this.m_normal.x + (clipPointY - planePointY) * this.m_normal.y - cc.radius;
                        this.m_points[i].x = clipPointX;
                        this.m_points[i].y = clipPointY
                    }
                }
                break;
            case b2Manifold.e_faceB:
                {
                    tMat = cc.bodyB.m_xf.R;tVec = cc.localPlaneNormal;this.m_normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;this.m_normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;tMat = cc.bodyB.m_xf.R;tVec = cc.localPoint;planePointX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);planePointY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);tMat = cc.bodyA.m_xf.R;
                    for (i = 0; i < cc.pointCount; ++i) {
                        tVec = cc.points[i].localPoint;
                        clipPointX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
                        clipPointY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
                        this.m_separations[i] = (clipPointX - planePointX) * this.m_normal.x + (clipPointY - planePointY) * this.m_normal.y - cc.radius;
                        this.m_points[i].Set(clipPointX, clipPointY)
                    }
                    this.m_normal.x *= -1;this.m_normal.y *= -1
                }
                break
        }
    };
    b2PositionSolverManifold.prototype.m_normal = null;
    b2PositionSolverManifold.prototype.m_points = null;
    b2PositionSolverManifold.prototype.m_separations = null;
    var b2OBB = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2OBB.prototype.__constructor = function() {};
    b2OBB.prototype.__varz = function() {
        this.R = new b2Mat22;
        this.center = new b2Vec2;
        this.extents = new b2Vec2
    };
    b2OBB.prototype.R = new b2Mat22;
    b2OBB.prototype.center = new b2Vec2;
    b2OBB.prototype.extents = new b2Vec2;
    var b2Pair = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2Pair.prototype.__constructor = function() {};
    b2Pair.prototype.__varz = function() {};
    b2Pair.b2_nullProxy = b2Settings.USHRT_MAX;
    b2Pair.e_pairBuffered = 1;
    b2Pair.e_pairRemoved = 2;
    b2Pair.e_pairFinal = 4;
    b2Pair.prototype.SetBuffered = function() {
        this.status |= b2Pair.e_pairBuffered
    };
    b2Pair.prototype.ClearBuffered = function() {
        this.status &= ~b2Pair.e_pairBuffered
    };
    b2Pair.prototype.IsBuffered = function() {
        return (this.status & b2Pair.e_pairBuffered) == b2Pair.e_pairBuffered
    };
    b2Pair.prototype.SetRemoved = function() {
        this.status |= b2Pair.e_pairRemoved
    };
    b2Pair.prototype.ClearRemoved = function() {
        this.status &= ~b2Pair.e_pairRemoved
    };
    b2Pair.prototype.IsRemoved = function() {
        return (this.status & b2Pair.e_pairRemoved) == b2Pair.e_pairRemoved
    };
    b2Pair.prototype.SetFinal = function() {
        this.status |= b2Pair.e_pairFinal
    };
    b2Pair.prototype.IsFinal = function() {
        return (this.status & b2Pair.e_pairFinal) == b2Pair.e_pairFinal
    };
    b2Pair.prototype.userData = null;
    b2Pair.prototype.proxy1 = null;
    b2Pair.prototype.proxy2 = null;
    b2Pair.prototype.next = null;
    b2Pair.prototype.status = 0;
    var b2FixtureDef = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2FixtureDef.prototype.__constructor = function() {
        this.shape = null;
        this.userData = null;
        this.friction = .2;
        this.restitution = 0;
        this.density = 0;
        this.filter.categoryBits = 1;
        this.filter.maskBits = 4294967295;
        this.filter.groupIndex = 0;
        this.isSensor = false
    };
    b2FixtureDef.prototype.__varz = function() {
        this.filter = new b2FilterData
    };
    b2FixtureDef.prototype.shape = null;
    b2FixtureDef.prototype.userData = null;
    b2FixtureDef.prototype.friction = null;
    b2FixtureDef.prototype.restitution = null;
    b2FixtureDef.prototype.density = null;
    b2FixtureDef.prototype.isSensor = null;
    b2FixtureDef.prototype.filter = new b2FilterData;
    var b2ContactID = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2ContactID.prototype.__constructor = function() {
        this.features._m_id = this
    };
    b2ContactID.prototype.__varz = function() {
        this.features = new Features
    };
    b2ContactID.prototype.Set = function(id) {
        key = id._key
    };
    b2ContactID.prototype.Copy = function() {
        var id = new b2ContactID;
        id.key = key;
        return id
    };
    b2ContactID.prototype.__defineSetter__("key", function() {
        return this._key
    });
    b2ContactID.prototype.__defineSetter__("key", function(value) {
        this._key = value;
        this.features._referenceEdge = this._key & 255;
        this.features._incidentEdge = (this._key & 65280) >> 8 & 255;
        this.features._incidentVertex = (this._key & 16711680) >> 16 & 255;
        this.features._flip = (this._key & 4278190080) >> 24 & 255
    });
    b2ContactID.prototype._key = 0;
    b2ContactID.prototype.features = new Features;
    var b2Transform = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2Transform.prototype.__constructor = function(pos, r) {
        if (pos) {
            this.position.SetV(pos);
            this.R.SetM(r)
        }
    };
    b2Transform.prototype.__varz = function() {
        this.position = new b2Vec2;
        this.R = new b2Mat22
    };
    b2Transform.prototype.Initialize = function(pos, r) {
        this.position.SetV(pos);
        this.R.SetM(r)
    };
    b2Transform.prototype.SetIdentity = function() {
        this.position.SetZero();
        this.R.SetIdentity()
    };
    b2Transform.prototype.Set = function(x) {
        this.position.SetV(x.position);
        this.R.SetM(x.R)
    };
    b2Transform.prototype.GetAngle = function() {
        return Math.atan2(this.R.col1.y, this.R.col1.x)
    };
    b2Transform.prototype.position = new b2Vec2;
    b2Transform.prototype.R = new b2Mat22;
    var b2EdgeShape = function() {
        b2Shape.prototype.__varz.call(this);
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    extend(b2EdgeShape.prototype, b2Shape.prototype);
    b2EdgeShape.prototype._super = b2Shape.prototype;
    b2EdgeShape.prototype.__constructor = function(v1, v2) {
        this._super.__constructor.apply(this, []);
        this.m_type = b2Shape.e_edgeShape;
        this.m_prevEdge = null;
        this.m_nextEdge = null;
        this.m_v1 = v1;
        this.m_v2 = v2;
        this.m_direction.Set(this.m_v2.x - this.m_v1.x, this.m_v2.y - this.m_v1.y);
        this.m_length = this.m_direction.Normalize();
        this.m_normal.Set(this.m_direction.y, -this.m_direction.x);
        this.m_coreV1.Set(-b2Settings.b2_toiSlop * (this.m_normal.x - this.m_direction.x) + this.m_v1.x, -b2Settings.b2_toiSlop * (this.m_normal.y - this.m_direction.y) + this.m_v1.y);
        this.m_coreV2.Set(-b2Settings.b2_toiSlop * (this.m_normal.x + this.m_direction.x) + this.m_v2.x, -b2Settings.b2_toiSlop * (this.m_normal.y + this.m_direction.y) + this.m_v2.y);
        this.m_cornerDir1 = this.m_normal;
        this.m_cornerDir2.Set(-this.m_normal.x, -this.m_normal.y)
    };
    b2EdgeShape.prototype.__varz = function() {
        this.s_supportVec = new b2Vec2;
        this.m_v1 = new b2Vec2;
        this.m_v2 = new b2Vec2;
        this.m_coreV1 = new b2Vec2;
        this.m_coreV2 = new b2Vec2;
        this.m_normal = new b2Vec2;
        this.m_direction = new b2Vec2;
        this.m_cornerDir1 = new b2Vec2;
        this.m_cornerDir2 = new b2Vec2
    };
    b2EdgeShape.prototype.SetPrevEdge = function(edge, core, cornerDir, convex) {
        this.m_prevEdge = edge;
        this.m_coreV1 = core;
        this.m_cornerDir1 = cornerDir;
        this.m_cornerConvex1 = convex
    };
    b2EdgeShape.prototype.SetNextEdge = function(edge, core, cornerDir, convex) {
        this.m_nextEdge = edge;
        this.m_coreV2 = core;
        this.m_cornerDir2 = cornerDir;
        this.m_cornerConvex2 = convex
    };
    b2EdgeShape.prototype.TestPoint = function(transform, p) {
        return false
    };
    b2EdgeShape.prototype.RayCast = function(output, input, transform) {
        var tMat;
        var rX = input.p2.x - input.p1.x;
        var rY = input.p2.y - input.p1.y;
        tMat = transform.R;
        var v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
        var v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
        var nX = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y) - v1Y;
        var nY = -(transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y) - v1X);
        var k_slop = 100 * Number.MIN_VALUE;
        var denom = -(rX * nX + rY * nY);
        if (denom > k_slop) {
            var bX = input.p1.x - v1X;
            var bY = input.p1.y - v1Y;
            var a = bX * nX + bY * nY;
            if (0 <= a && a <= input.maxFraction * denom) {
                var mu2 = -rX * bY + rY * bX;
                if (-k_slop * denom <= mu2 && mu2 <= denom * (1 + k_slop)) {
                    a /= denom;
                    output.fraction = a;
                    var nLen = Math.sqrt(nX * nX + nY * nY);
                    output.normal.x = nX / nLen;
                    output.normal.y = nY / nLen;
                    return true
                }
            }
        }
        return false
    };
    b2EdgeShape.prototype.ComputeAABB = function(aabb, transform) {
        var tMat = transform.R;
        var v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
        var v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
        var v2X = transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y);
        var v2Y = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y);
        if (v1X < v2X) {
            aabb.lowerBound.x = v1X;
            aabb.upperBound.x = v2X
        } else {
            aabb.lowerBound.x = v2X;
            aabb.upperBound.x = v1X
        }
        if (v1Y < v2Y) {
            aabb.lowerBound.y = v1Y;
            aabb.upperBound.y = v2Y
        } else {
            aabb.lowerBound.y = v2Y;
            aabb.upperBound.y = v1Y
        }
    };
    b2EdgeShape.prototype.ComputeMass = function(massData, density) {
        massData.mass = 0;
        massData.center.SetV(this.m_v1);
        massData.I = 0
    };
    b2EdgeShape.prototype.ComputeSubmergedArea = function(normal, offset, xf, c) {
        var v0 = new b2Vec2(normal.x * offset, normal.y * offset);
        var v1 = b2Math.MulX(xf, this.m_v1);
        var v2 = b2Math.MulX(xf, this.m_v2);
        var d1 = b2Math.Dot(normal, v1) - offset;
        var d2 = b2Math.Dot(normal, v2) - offset;
        if (d1 > 0) {
            if (d2 > 0) {
                return 0
            } else {
                v1.x = -d2 / (d1 - d2) * v1.x + d1 / (d1 - d2) * v2.x;
                v1.y = -d2 / (d1 - d2) * v1.y + d1 / (d1 - d2) * v2.y
            }
        } else {
            if (d2 > 0) {
                v2.x = -d2 / (d1 - d2) * v1.x + d1 / (d1 - d2) * v2.x;
                v2.y = -d2 / (d1 - d2) * v1.y + d1 / (d1 - d2) * v2.y
            } else {}
        }
        c.x = (v0.x + v1.x + v2.x) / 3;
        c.y = (v0.y + v1.y + v2.y) / 3;
        return .5 * ((v1.x - v0.x) * (v2.y - v0.y) - (v1.y - v0.y) * (v2.x - v0.x))
    };
    b2EdgeShape.prototype.GetLength = function() {
        return this.m_length
    };
    b2EdgeShape.prototype.GetVertex1 = function() {
        return this.m_v1
    };
    b2EdgeShape.prototype.GetVertex2 = function() {
        return this.m_v2
    };
    b2EdgeShape.prototype.GetCoreVertex1 = function() {
        return this.m_coreV1
    };
    b2EdgeShape.prototype.GetCoreVertex2 = function() {
        return this.m_coreV2
    };
    b2EdgeShape.prototype.GetNormalVector = function() {
        return this.m_normal
    };
    b2EdgeShape.prototype.GetDirectionVector = function() {
        return this.m_direction
    };
    b2EdgeShape.prototype.GetCorner1Vector = function() {
        return this.m_cornerDir1
    };
    b2EdgeShape.prototype.GetCorner2Vector = function() {
        return this.m_cornerDir2
    };
    b2EdgeShape.prototype.Corner1IsConvex = function() {
        return this.m_cornerConvex1
    };
    b2EdgeShape.prototype.Corner2IsConvex = function() {
        return this.m_cornerConvex2
    };
    b2EdgeShape.prototype.GetFirstVertex = function(xf) {
        var tMat = xf.R;
        return new b2Vec2(xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y), xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y))
    };
    b2EdgeShape.prototype.GetNextEdge = function() {
        return this.m_nextEdge
    };
    b2EdgeShape.prototype.GetPrevEdge = function() {
        return this.m_prevEdge
    };
    b2EdgeShape.prototype.Support = function(xf, dX, dY) {
        var tMat = xf.R;
        var v1X = xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y);
        var v1Y = xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y);
        var v2X = xf.position.x + (tMat.col1.x * this.m_coreV2.x + tMat.col2.x * this.m_coreV2.y);
        var v2Y = xf.position.y + (tMat.col1.y * this.m_coreV2.x + tMat.col2.y * this.m_coreV2.y);
        if (v1X * dX + v1Y * dY > v2X * dX + v2Y * dY) {
            this.s_supportVec.x = v1X;
            this.s_supportVec.y = v1Y
        } else {
            this.s_supportVec.x = v2X;
            this.s_supportVec.y = v2Y
        }
        return this.s_supportVec
    };
    b2EdgeShape.prototype.s_supportVec = new b2Vec2;
    b2EdgeShape.prototype.m_v1 = new b2Vec2;
    b2EdgeShape.prototype.m_v2 = new b2Vec2;
    b2EdgeShape.prototype.m_coreV1 = new b2Vec2;
    b2EdgeShape.prototype.m_coreV2 = new b2Vec2;
    b2EdgeShape.prototype.m_length = null;
    b2EdgeShape.prototype.m_normal = new b2Vec2;
    b2EdgeShape.prototype.m_direction = new b2Vec2;
    b2EdgeShape.prototype.m_cornerDir1 = new b2Vec2;
    b2EdgeShape.prototype.m_cornerDir2 = new b2Vec2;
    b2EdgeShape.prototype.m_cornerConvex1 = null;
    b2EdgeShape.prototype.m_cornerConvex2 = null;
    b2EdgeShape.prototype.m_nextEdge = null;
    b2EdgeShape.prototype.m_prevEdge = null;
    var b2BuoyancyController = function() {
        b2Controller.prototype.__varz.call(this);
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    extend(b2BuoyancyController.prototype, b2Controller.prototype);
    b2BuoyancyController.prototype._super = b2Controller.prototype;
    b2BuoyancyController.prototype.__constructor = function() {
        this._super.__constructor.apply(this, arguments)
    };
    b2BuoyancyController.prototype.__varz = function() {
        this.normal = new b2Vec2(0, -1);
        this.velocity = new b2Vec2(0, 0)
    };
    b2BuoyancyController.prototype.Step = function(step) {
        if (!this.m_bodyList) return;
        if (this.useWorldGravity) {
            this.gravity = this.GetWorld().GetGravity().Copy()
        }
        for (var i = this.m_bodyList; i; i = i.nextBody) {
            var body = i.body;
            if (body.IsAwake() == false) {
                continue
            }
            var areac = new b2Vec2;
            var massc = new b2Vec2;
            var area = 0;
            var mass = 0;
            for (var fixture = body.GetFixtureList(); fixture; fixture = fixture.GetNext()) {
                var sc = new b2Vec2;
                var sarea = fixture.GetShape().ComputeSubmergedArea(this.normal, this.offset, body.GetTransform(), sc);
                area += sarea;
                areac.x += sarea * sc.x;
                areac.y += sarea * sc.y;
                var shapeDensity;
                if (this.useDensity) {
                    shapeDensity = 1
                } else {
                    shapeDensity = 1
                }
                mass += sarea * shapeDensity;
                massc.x += sarea * sc.x * shapeDensity;
                massc.y += sarea * sc.y * shapeDensity
            }
            areac.x /= area;
            areac.y /= area;
            massc.x /= mass;
            massc.y /= mass;
            if (area < Number.MIN_VALUE) continue;
            var buoyancyForce = this.gravity.GetNegative();
            buoyancyForce.Multiply(this.density * area);
            body.ApplyForce(buoyancyForce, massc);
            var dragForce = body.GetLinearVelocityFromWorldPoint(areac);
            dragForce.Subtract(this.velocity);
            dragForce.Multiply(-this.linearDrag * area);
            body.ApplyForce(dragForce, areac);
            body.ApplyTorque(-body.GetInertia() / body.GetMass() * area * body.GetAngularVelocity() * this.angularDrag)
        }
    };
    b2BuoyancyController.prototype.Draw = function(debugDraw) {
        var r = 1e3;
        var p1 = new b2Vec2;
        var p2 = new b2Vec2;
        p1.x = this.normal.x * this.offset + this.normal.y * r;
        p1.y = this.normal.y * this.offset - this.normal.x * r;
        p2.x = this.normal.x * this.offset - this.normal.y * r;
        p2.y = this.normal.y * this.offset + this.normal.x * r;
        var color = new b2Color(0, 0, 1);
        debugDraw.DrawSegment(p1, p2, color)
    };
    b2BuoyancyController.prototype.normal = new b2Vec2(0, -1);
    b2BuoyancyController.prototype.offset = 0;
    b2BuoyancyController.prototype.density = 0;
    b2BuoyancyController.prototype.velocity = new b2Vec2(0, 0);
    b2BuoyancyController.prototype.linearDrag = 2;
    b2BuoyancyController.prototype.angularDrag = 1;
    b2BuoyancyController.prototype.useDensity = false;
    b2BuoyancyController.prototype.useWorldGravity = true;
    b2BuoyancyController.prototype.gravity = null;
    var b2Body = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2Body.prototype.__constructor = function(bd, world) {
        this.m_flags = 0;
        if (bd.bullet) {
            this.m_flags |= b2Body.e_bulletFlag
        }
        if (bd.fixedRotation) {
            this.m_flags |= b2Body.e_fixedRotationFlag
        }
        if (bd.allowSleep) {
            this.m_flags |= b2Body.e_allowSleepFlag
        }
        if (bd.awake) {
            this.m_flags |= b2Body.e_awakeFlag
        }
        if (bd.active) {
            this.m_flags |= b2Body.e_activeFlag
        }
        this.m_world = world;
        this.m_xf.position.SetV(bd.position);
        this.m_xf.R.Set(bd.angle);
        this.m_sweep.localCenter.SetZero();
        this.m_sweep.t0 = 1;
        this.m_sweep.a0 = this.m_sweep.a = bd.angle;
        var tMat = this.m_xf.R;
        var tVec = this.m_sweep.localCenter;
        this.m_sweep.c.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
        this.m_sweep.c.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
        this.m_sweep.c.x += this.m_xf.position.x;
        this.m_sweep.c.y += this.m_xf.position.y;
        this.m_sweep.c0.SetV(this.m_sweep.c);
        this.m_jointList = null;
        this.m_controllerList = null;
        this.m_contactList = null;
        this.m_controllerCount = 0;
        this.m_prev = null;
        this.m_next = null;
        this.m_linearVelocity.SetV(bd.linearVelocity);
        this.m_angularVelocity = bd.angularVelocity;
        this.m_linearDamping = bd.linearDamping;
        this.m_angularDamping = bd.angularDamping;
        this.m_force.Set(0, 0);
        this.m_torque = 0;
        this.m_sleepTime = 0;
        this.m_type = bd.type;
        if (this.m_type == b2Body.b2_dynamicBody) {
            this.m_mass = 1;
            this.m_invMass = 1
        } else {
            this.m_mass = 0;
            this.m_invMass = 0
        }
        this.m_I = 0;
        this.m_invI = 0;
        this.m_inertiaScale = bd.inertiaScale;
        this.m_userData = bd.userData;
        this.m_fixtureList = null;
        this.m_fixtureCount = 0
    };
    b2Body.prototype.__varz = function() {
        this.m_xf = new b2Transform;
        this.m_sweep = new b2Sweep;
        this.m_linearVelocity = new b2Vec2;
        this.m_force = new b2Vec2
    };
    b2Body.b2_staticBody = 0;
    b2Body.b2_kinematicBody = 1;
    b2Body.b2_dynamicBody = 2;
    b2Body.s_xf1 = new b2Transform;
    b2Body.e_islandFlag = 1;
    b2Body.e_awakeFlag = 2;
    b2Body.e_allowSleepFlag = 4;
    b2Body.e_bulletFlag = 8;
    b2Body.e_fixedRotationFlag = 16;
    b2Body.e_activeFlag = 32;
    b2Body.prototype.connectEdges = function(s1, s2, angle1) {
        var angle2 = Math.atan2(s2.GetDirectionVector().y, s2.GetDirectionVector().x);
        var coreOffset = Math.tan((angle2 - angle1) * .5);
        var core = b2Math.MulFV(coreOffset, s2.GetDirectionVector());
        core = b2Math.SubtractVV(core, s2.GetNormalVector());
        core = b2Math.MulFV(b2Settings.b2_toiSlop, core);
        core = b2Math.AddVV(core, s2.GetVertex1());
        var cornerDir = b2Math.AddVV(s1.GetDirectionVector(), s2.GetDirectionVector());
        cornerDir.Normalize();
        var convex = b2Math.Dot(s1.GetDirectionVector(), s2.GetNormalVector()) > 0;
        s1.SetNextEdge(s2, core, cornerDir, convex);
        s2.SetPrevEdge(s1, core, cornerDir, convex);
        return angle2
    };
    b2Body.prototype.SynchronizeFixtures = function() {
        var xf1 = b2Body.s_xf1;
        xf1.R.Set(this.m_sweep.a0);
        var tMat = xf1.R;
        var tVec = this.m_sweep.localCenter;
        xf1.position.x = this.m_sweep.c0.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        xf1.position.y = this.m_sweep.c0.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        var f;
        var broadPhase = this.m_world.m_contactManager.m_broadPhase;
        for (f = this.m_fixtureList; f; f = f.m_next) {
            f.Synchronize(broadPhase, xf1, this.m_xf)
        }
    };
    b2Body.prototype.SynchronizeTransform = function() {
        this.m_xf.R.Set(this.m_sweep.a);
        var tMat = this.m_xf.R;
        var tVec = this.m_sweep.localCenter;
        this.m_xf.position.x = this.m_sweep.c.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        this.m_xf.position.y = this.m_sweep.c.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y)
    };
    b2Body.prototype.ShouldCollide = function(other) {
        if (this.m_type != b2Body.b2_dynamicBody && other.m_type != b2Body.b2_dynamicBody) {
            return false
        }
        for (var jn = this.m_jointList; jn; jn = jn.next) {
            if (jn.other == other)
                if (jn.joint.m_collideConnected == false) {
                    return false
                }
        }
        return true
    };
    b2Body.prototype.Advance = function(t) {
        this.m_sweep.Advance(t);
        this.m_sweep.c.SetV(this.m_sweep.c0);
        this.m_sweep.a = this.m_sweep.a0;
        this.SynchronizeTransform()
    };
    b2Body.prototype.CreateFixture = function(def) {
        if (this.m_world.IsLocked() == true) {
            return null
        }
        var fixture = new b2Fixture;
        fixture.Create(this, this.m_xf, def);
        if (this.m_flags & b2Body.e_activeFlag) {
            var broadPhase = this.m_world.m_contactManager.m_broadPhase;
            fixture.CreateProxy(broadPhase, this.m_xf)
        }
        fixture.m_next = this.m_fixtureList;
        this.m_fixtureList = fixture;
        ++this.m_fixtureCount;
        fixture.m_body = this;
        if (fixture.m_density > 0) {
            this.ResetMassData()
        }
        this.m_world.m_flags |= b2World.e_newFixture;
        return fixture
    };
    b2Body.prototype.CreateFixture2 = function(shape, density) {
        var def = new b2FixtureDef;
        def.shape = shape;
        def.density = density;
        return this.CreateFixture(def)
    };
    b2Body.prototype.DestroyFixture = function(fixture) {
        if (this.m_world.IsLocked() == true) {
            return
        }
        var node = this.m_fixtureList;
        var ppF = null;
        var found = false;
        while (node != null) {
            if (node == fixture) {
                if (ppF) ppF.m_next = fixture.m_next;
                else this.m_fixtureList = fixture.m_next;
                found = true;
                break
            }
            ppF = node;
            node = node.m_next
        }
        var edge = this.m_contactList;
        while (edge) {
            var c = edge.contact;
            edge = edge.next;
            var fixtureA = c.GetFixtureA();
            var fixtureB = c.GetFixtureB();
            if (fixture == fixtureA || fixture == fixtureB) {
                this.m_world.m_contactManager.Destroy(c)
            }
        }
        if (this.m_flags & b2Body.e_activeFlag) {
            var broadPhase = this.m_world.m_contactManager.m_broadPhase;
            fixture.DestroyProxy(broadPhase)
        } else {}
        fixture.Destroy();
        fixture.m_body = null;
        fixture.m_next = null;
        --this.m_fixtureCount;
        this.ResetMassData()
    };
    b2Body.prototype.SetPositionAndAngle = function(position, angle) {
        var f;
        if (this.m_world.IsLocked() == true) {
            return
        }
        this.m_xf.R.Set(angle);
        this.m_xf.position.SetV(position);
        var tMat = this.m_xf.R;
        var tVec = this.m_sweep.localCenter;
        this.m_sweep.c.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
        this.m_sweep.c.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
        this.m_sweep.c.x += this.m_xf.position.x;
        this.m_sweep.c.y += this.m_xf.position.y;
        this.m_sweep.c0.SetV(this.m_sweep.c);
        this.m_sweep.a0 = this.m_sweep.a = angle;
        var broadPhase = this.m_world.m_contactManager.m_broadPhase;
        for (f = this.m_fixtureList; f; f = f.m_next) {
            f.Synchronize(broadPhase, this.m_xf, this.m_xf)
        }
        this.m_world.m_contactManager.FindNewContacts()
    };
    b2Body.prototype.SetTransform = function(xf) {
        this.SetPositionAndAngle(xf.position, xf.GetAngle())
    };
    b2Body.prototype.GetTransform = function() {
        return this.m_xf
    };
    b2Body.prototype.GetPosition = function() {
        return this.m_xf.position
    };
    b2Body.prototype.SetPosition = function(position) {
        this.SetPositionAndAngle(position, this.GetAngle())
    };
    b2Body.prototype.GetAngle = function() {
        return this.m_sweep.a
    };
    b2Body.prototype.SetAngle = function(angle) {
        this.SetPositionAndAngle(this.GetPosition(), angle)
    };
    b2Body.prototype.GetWorldCenter = function() {
        return this.m_sweep.c
    };
    b2Body.prototype.GetLocalCenter = function() {
        return this.m_sweep.localCenter
    };
    b2Body.prototype.SetLinearVelocity = function(v) {
        if (this.m_type == b2Body.b2_staticBody) {
            return
        }
        this.m_linearVelocity.SetV(v)
    };
    b2Body.prototype.GetLinearVelocity = function() {
        return this.m_linearVelocity
    };
    b2Body.prototype.SetAngularVelocity = function(omega) {
        if (this.m_type == b2Body.b2_staticBody) {
            return
        }
        this.m_angularVelocity = omega
    };
    b2Body.prototype.GetAngularVelocity = function() {
        return this.m_angularVelocity
    };
    b2Body.prototype.GetDefinition = function() {
        var bd = new b2BodyDef;
        bd.type = this.GetType();
        bd.allowSleep = (this.m_flags & b2Body.e_allowSleepFlag) == b2Body.e_allowSleepFlag;
        bd.angle = this.GetAngle();
        bd.angularDamping = this.m_angularDamping;
        bd.angularVelocity = this.m_angularVelocity;
        bd.fixedRotation = (this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag;
        bd.bullet = (this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag;
        bd.awake = (this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag;
        bd.linearDamping = this.m_linearDamping;
        bd.linearVelocity.SetV(this.GetLinearVelocity());
        bd.position = this.GetPosition();
        bd.userData = this.GetUserData();
        return bd
    };
    b2Body.prototype.ApplyForce = function(force, point) {
        if (this.m_type != b2Body.b2_dynamicBody) {
            return
        }
        if (this.IsAwake() == false) {
            this.SetAwake(true)
        }
        this.m_force.x += force.x;
        this.m_force.y += force.y;
        this.m_torque += (point.x - this.m_sweep.c.x) * force.y - (point.y - this.m_sweep.c.y) * force.x
    };
    b2Body.prototype.ApplyTorque = function(torque) {
        if (this.m_type != b2Body.b2_dynamicBody) {
            return
        }
        if (this.IsAwake() == false) {
            this.SetAwake(true)
        }
        this.m_torque += torque
    };
    b2Body.prototype.ApplyImpulse = function(impulse, point) {
        if (this.m_type != b2Body.b2_dynamicBody) {
            return
        }
        if (this.IsAwake() == false) {
            this.SetAwake(true)
        }
        this.m_linearVelocity.x += this.m_invMass * impulse.x;
        this.m_linearVelocity.y += this.m_invMass * impulse.y;
        this.m_angularVelocity += this.m_invI * ((point.x - this.m_sweep.c.x) * impulse.y - (point.y - this.m_sweep.c.y) * impulse.x)
    };
    b2Body.prototype.Split = function(callback) {
        var linearVelocity = this.GetLinearVelocity().Copy();
        var angularVelocity = this.GetAngularVelocity();
        var center = this.GetWorldCenter();
        var body1 = this;
        var body2 = this.m_world.CreateBody(this.GetDefinition());
        var prev;
        for (var f = body1.m_fixtureList; f;) {
            if (callback(f)) {
                var next = f.m_next;
                if (prev) {
                    prev.m_next = next
                } else {
                    body1.m_fixtureList = next
                }
                body1.m_fixtureCount--;
                f.m_next = body2.m_fixtureList;
                body2.m_fixtureList = f;
                body2.m_fixtureCount++;
                f.m_body = body2;
                f = next
            } else {
                prev = f;
                f = f.m_next
            }
        }
        body1.ResetMassData();
        body2.ResetMassData();
        var center1 = body1.GetWorldCenter();
        var center2 = body2.GetWorldCenter();
        var velocity1 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center1, center)));
        var velocity2 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center2, center)));
        body1.SetLinearVelocity(velocity1);
        body2.SetLinearVelocity(velocity2);
        body1.SetAngularVelocity(angularVelocity);
        body2.SetAngularVelocity(angularVelocity);
        body1.SynchronizeFixtures();
        body2.SynchronizeFixtures();
        return body2
    };
    b2Body.prototype.Merge = function(other) {
        var f;
        for (f = other.m_fixtureList; f;) {
            var next = f.m_next;
            other.m_fixtureCount--;
            f.m_next = this.m_fixtureList;
            this.m_fixtureList = f;
            this.m_fixtureCount++;
            f.m_body = body2;
            f = next
        }
        body1.m_fixtureCount = 0;
        var body1 = this;
        var body2 = other;
        var center1 = body1.GetWorldCenter();
        var center2 = body2.GetWorldCenter();
        var velocity1 = body1.GetLinearVelocity().Copy();
        var velocity2 = body2.GetLinearVelocity().Copy();
        var angular1 = body1.GetAngularVelocity();
        var angular = body2.GetAngularVelocity();
        body1.ResetMassData();
        this.SynchronizeFixtures()
    };
    b2Body.prototype.GetMass = function() {
        return this.m_mass
    };
    b2Body.prototype.GetInertia = function() {
        return this.m_I
    };
    b2Body.prototype.GetMassData = function(data) {
        data.mass = this.m_mass;
        data.I = this.m_I;
        data.center.SetV(this.m_sweep.localCenter)
    };
    b2Body.prototype.SetMassData = function(massData) {
        b2Settings.b2Assert(this.m_world.IsLocked() == false);
        if (this.m_world.IsLocked() == true) {
            return
        }
        if (this.m_type != b2Body.b2_dynamicBody) {
            return
        }
        this.m_invMass = 0;
        this.m_I = 0;
        this.m_invI = 0;
        this.m_mass = massData.mass;
        if (this.m_mass <= 0) {
            this.m_mass = 1
        }
        this.m_invMass = 1 / this.m_mass;
        if (massData.I > 0 && (this.m_flags & b2Body.e_fixedRotationFlag) == 0) {
            this.m_I = massData.I - this.m_mass * (massData.center.x * massData.center.x + massData.center.y * massData.center.y);
            this.m_invI = 1 / this.m_I
        }
        var oldCenter = this.m_sweep.c.Copy();
        this.m_sweep.localCenter.SetV(massData.center);
        this.m_sweep.c0.SetV(b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
        this.m_sweep.c.SetV(this.m_sweep.c0);
        this.m_linearVelocity.x += this.m_angularVelocity * -(this.m_sweep.c.y - oldCenter.y);
        this.m_linearVelocity.y += this.m_angularVelocity * +(this.m_sweep.c.x - oldCenter.x)
    };
    b2Body.prototype.ResetMassData = function() {
        this.m_mass = 0;
        this.m_invMass = 0;
        this.m_I = 0;
        this.m_invI = 0;
        this.m_sweep.localCenter.SetZero();
        if (this.m_type == b2Body.b2_staticBody || this.m_type == b2Body.b2_kinematicBody) {
            return
        }
        var center = b2Vec2.Make(0, 0);
        for (var f = this.m_fixtureList; f; f = f.m_next) {
            if (f.m_density == 0) {
                continue
            }
            var massData = f.GetMassData();
            this.m_mass += massData.mass;
            center.x += massData.center.x * massData.mass;
            center.y += massData.center.y * massData.mass;
            this.m_I += massData.I
        }
        if (this.m_mass > 0) {
            this.m_invMass = 1 / this.m_mass;
            center.x *= this.m_invMass;
            center.y *= this.m_invMass
        } else {
            this.m_mass = 1;
            this.m_invMass = 1
        }
        if (this.m_I > 0 && (this.m_flags & b2Body.e_fixedRotationFlag) == 0) {
            this.m_I -= this.m_mass * (center.x * center.x + center.y * center.y);
            this.m_I *= this.m_inertiaScale;
            b2Settings.b2Assert(this.m_I > 0);
            this.m_invI = 1 / this.m_I
        } else {
            this.m_I = 0;
            this.m_invI = 0
        }
        var oldCenter = this.m_sweep.c.Copy();
        this.m_sweep.localCenter.SetV(center);
        this.m_sweep.c0.SetV(b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
        this.m_sweep.c.SetV(this.m_sweep.c0);
        this.m_linearVelocity.x += this.m_angularVelocity * -(this.m_sweep.c.y - oldCenter.y);
        this.m_linearVelocity.y += this.m_angularVelocity * +(this.m_sweep.c.x - oldCenter.x)
    };
    b2Body.prototype.GetWorldPoint = function(localPoint) {
        var A = this.m_xf.R;
        var u = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
        u.x += this.m_xf.position.x;
        u.y += this.m_xf.position.y;
        return u
    };
    b2Body.prototype.GetWorldVector = function(localVector) {
        return b2Math.MulMV(this.m_xf.R, localVector)
    };
    b2Body.prototype.GetLocalPoint = function(worldPoint) {
        return b2Math.MulXT(this.m_xf, worldPoint)
    };
    b2Body.prototype.GetLocalVector = function(worldVector) {
        return b2Math.MulTMV(this.m_xf.R, worldVector)
    };
    b2Body.prototype.GetLinearVelocityFromWorldPoint = function(worldPoint) {
        return new b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x))
    };
    b2Body.prototype.GetLinearVelocityFromLocalPoint = function(localPoint) {
        var A = this.m_xf.R;
        var worldPoint = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
        worldPoint.x += this.m_xf.position.x;
        worldPoint.y += this.m_xf.position.y;
        return new b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x))
    };
    b2Body.prototype.GetLinearDamping = function() {
        return this.m_linearDamping
    };
    b2Body.prototype.SetLinearDamping = function(linearDamping) {
        this.m_linearDamping = linearDamping
    };
    b2Body.prototype.GetAngularDamping = function() {
        return this.m_angularDamping
    };
    b2Body.prototype.SetAngularDamping = function(angularDamping) {
        this.m_angularDamping = angularDamping
    };
    b2Body.prototype.SetType = function(type) {
        if (this.m_type == type) {
            return
        }
        this.m_type = type;
        this.ResetMassData();
        if (this.m_type == b2Body.b2_staticBody) {
            this.m_linearVelocity.SetZero();
            this.m_angularVelocity = 0
        }
        this.SetAwake(true);
        this.m_force.SetZero();
        this.m_torque = 0;
        for (var ce = this.m_contactList; ce; ce = ce.next) {
            ce.contact.FlagForFiltering()
        }
    };
    b2Body.prototype.GetType = function() {
        return this.m_type
    };
    b2Body.prototype.SetBullet = function(flag) {
        if (flag) {
            this.m_flags |= b2Body.e_bulletFlag
        } else {
            this.m_flags &= ~b2Body.e_bulletFlag
        }
    };
    b2Body.prototype.IsBullet = function() {
        return (this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag
    };
    b2Body.prototype.SetSleepingAllowed = function(flag) {
        if (flag) {
            this.m_flags |= b2Body.e_allowSleepFlag
        } else {
            this.m_flags &= ~b2Body.e_allowSleepFlag;
            this.SetAwake(true)
        }
    };
    b2Body.prototype.SetAwake = function(flag) {
        if (flag) {
            this.m_flags |= b2Body.e_awakeFlag;
            this.m_sleepTime = 0
        } else {
            this.m_flags &= ~b2Body.e_awakeFlag;
            this.m_sleepTime = 0;
            this.m_linearVelocity.SetZero();
            this.m_angularVelocity = 0;
            this.m_force.SetZero();
            this.m_torque = 0
        }
    };
    b2Body.prototype.IsAwake = function() {
        return (this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag
    };
    b2Body.prototype.SetFixedRotation = function(fixed) {
        if (fixed) {
            this.m_flags |= b2Body.e_fixedRotationFlag
        } else {
            this.m_flags &= ~b2Body.e_fixedRotationFlag
        }
        this.ResetMassData()
    };
    b2Body.prototype.IsFixedRotation = function() {
        return (this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag
    };
    b2Body.prototype.SetActive = function(flag) {
        if (flag == this.IsActive()) {
            return
        }
        var broadPhase;
        var f;
        if (flag) {
            this.m_flags |= b2Body.e_activeFlag;
            broadPhase = this.m_world.m_contactManager.m_broadPhase;
            for (f = this.m_fixtureList; f; f = f.m_next) {
                f.CreateProxy(broadPhase, this.m_xf)
            }
        } else {
            this.m_flags &= ~b2Body.e_activeFlag;
            broadPhase = this.m_world.m_contactManager.m_broadPhase;
            for (f = this.m_fixtureList; f; f = f.m_next) {
                f.DestroyProxy(broadPhase)
            }
            var ce = this.m_contactList;
            while (ce) {
                var ce0 = ce;
                ce = ce.next;
                this.m_world.m_contactManager.Destroy(ce0.contact)
            }
            this.m_contactList = null
        }
    };
    b2Body.prototype.IsActive = function() {
        return (this.m_flags & b2Body.e_activeFlag) == b2Body.e_activeFlag
    };
    b2Body.prototype.IsSleepingAllowed = function() {
        return (this.m_flags & b2Body.e_allowSleepFlag) == b2Body.e_allowSleepFlag
    };
    b2Body.prototype.GetFixtureList = function() {
        return this.m_fixtureList
    };
    b2Body.prototype.GetJointList = function() {
        return this.m_jointList
    };
    b2Body.prototype.GetControllerList = function() {
        return this.m_controllerList
    };
    b2Body.prototype.GetContactList = function() {
        return this.m_contactList
    };
    b2Body.prototype.GetNext = function() {
        return this.m_next
    };
    b2Body.prototype.GetUserData = function() {
        return this.m_userData
    };
    b2Body.prototype.SetUserData = function(data) {
        this.m_userData = data
    };
    b2Body.prototype.GetWorld = function() {
        return this.m_world
    };
    b2Body.prototype.m_flags = 0;
    b2Body.prototype.m_type = 0;
    b2Body.prototype.m_islandIndex = 0;
    b2Body.prototype.m_xf = new b2Transform;
    b2Body.prototype.m_sweep = new b2Sweep;
    b2Body.prototype.m_linearVelocity = new b2Vec2;
    b2Body.prototype.m_angularVelocity = null;
    b2Body.prototype.m_force = new b2Vec2;
    b2Body.prototype.m_torque = null;
    b2Body.prototype.m_world = null;
    b2Body.prototype.m_prev = null;
    b2Body.prototype.m_next = null;
    b2Body.prototype.m_fixtureList = null;
    b2Body.prototype.m_fixtureCount = 0;
    b2Body.prototype.m_controllerList = null;
    b2Body.prototype.m_controllerCount = 0;
    b2Body.prototype.m_jointList = null;
    b2Body.prototype.m_contactList = null;
    b2Body.prototype.m_mass = null;
    b2Body.prototype.m_invMass = null;
    b2Body.prototype.m_I = null;
    b2Body.prototype.m_invI = null;
    b2Body.prototype.m_inertiaScale = null;
    b2Body.prototype.m_linearDamping = null;
    b2Body.prototype.m_angularDamping = null;
    b2Body.prototype.m_sleepTime = null;
    b2Body.prototype.m_userData = null;
    var b2ContactImpulse = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2ContactImpulse.prototype.__constructor = function() {};
    b2ContactImpulse.prototype.__varz = function() {
        this.normalImpulses = new Array(b2Settings.b2_maxManifoldPoints);
        this.tangentImpulses = new Array(b2Settings.b2_maxManifoldPoints)
    };
    b2ContactImpulse.prototype.normalImpulses = new Array(b2Settings.b2_maxManifoldPoints);
    b2ContactImpulse.prototype.tangentImpulses = new Array(b2Settings.b2_maxManifoldPoints);
    var b2TensorDampingController = function() {
        b2Controller.prototype.__varz.call(this);
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    extend(b2TensorDampingController.prototype, b2Controller.prototype);
    b2TensorDampingController.prototype._super = b2Controller.prototype;
    b2TensorDampingController.prototype.__constructor = function() {
        this._super.__constructor.apply(this, arguments)
    };
    b2TensorDampingController.prototype.__varz = function() {
        this.T = new b2Mat22
    };
    b2TensorDampingController.prototype.SetAxisAligned = function(xDamping, yDamping) {
        this.T.col1.x = -xDamping;
        this.T.col1.y = 0;
        this.T.col2.x = 0;
        this.T.col2.y = -yDamping;
        if (xDamping > 0 || yDamping > 0) {
            this.maxTimestep = 1 / Math.max(xDamping, yDamping)
        } else {
            this.maxTimestep = 0
        }
    };
    b2TensorDampingController.prototype.Step = function(step) {
        var timestep = step.dt;
        if (timestep <= Number.MIN_VALUE) return;
        if (timestep > this.maxTimestep && this.maxTimestep > 0) timestep = this.maxTimestep;
        for (var i = m_bodyList; i; i = i.nextBody) {
            var body = i.body;
            if (!body.IsAwake()) {
                continue
            }
            var damping = body.GetWorldVector(b2Math.MulMV(this.T, body.GetLocalVector(body.GetLinearVelocity())));
            body.SetLinearVelocity(new b2Vec2(body.GetLinearVelocity().x + damping.x * timestep, body.GetLinearVelocity().y + damping.y * timestep))
        }
    };
    b2TensorDampingController.prototype.T = new b2Mat22;
    b2TensorDampingController.prototype.maxTimestep = 0;
    var b2ManifoldPoint = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2ManifoldPoint.prototype.__constructor = function() {
        this.Reset()
    };
    b2ManifoldPoint.prototype.__varz = function() {
        this.m_localPoint = new b2Vec2;
        this.m_id = new b2ContactID
    };
    b2ManifoldPoint.prototype.Reset = function() {
        this.m_localPoint.SetZero();
        this.m_normalImpulse = 0;
        this.m_tangentImpulse = 0;
        this.m_id.key = 0
    };
    b2ManifoldPoint.prototype.Set = function(m) {
        this.m_localPoint.SetV(m.m_localPoint);
        this.m_normalImpulse = m.m_normalImpulse;
        this.m_tangentImpulse = m.m_tangentImpulse;
        this.m_id.Set(m.m_id)
    };
    b2ManifoldPoint.prototype.m_localPoint = new b2Vec2;
    b2ManifoldPoint.prototype.m_normalImpulse = null;
    b2ManifoldPoint.prototype.m_tangentImpulse = null;
    b2ManifoldPoint.prototype.m_id = new b2ContactID;
    var b2PolygonShape = function() {
        b2Shape.prototype.__varz.call(this);
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    extend(b2PolygonShape.prototype, b2Shape.prototype);
    b2PolygonShape.prototype._super = b2Shape.prototype;
    b2PolygonShape.prototype.__constructor = function() {
        this._super.__constructor.apply(this, arguments);
        this.m_type = b2Shape.e_polygonShape;
        this.m_centroid = new b2Vec2;
        this.m_vertices = new Array;
        this.m_normals = new Array
    };
    b2PolygonShape.prototype.__varz = function() {};
    b2PolygonShape.AsArray = function(vertices, vertexCount) {
        var polygonShape = new b2PolygonShape;
        polygonShape.SetAsArray(vertices, vertexCount);
        return polygonShape
    };
    b2PolygonShape.AsVector = function(vertices, vertexCount) {
        var polygonShape = new b2PolygonShape;
        polygonShape.SetAsVector(vertices, vertexCount);
        return polygonShape
    };
    b2PolygonShape.AsBox = function(hx, hy) {
        var polygonShape = new b2PolygonShape;
        polygonShape.SetAsBox(hx, hy);
        return polygonShape
    };
    b2PolygonShape.AsOrientedBox = function(hx, hy, center, angle) {
        var polygonShape = new b2PolygonShape;
        polygonShape.SetAsOrientedBox(hx, hy, center, angle);
        return polygonShape
    };
    b2PolygonShape.AsEdge = function(v1, v2) {
        var polygonShape = new b2PolygonShape;
        polygonShape.SetAsEdge(v1, v2);
        return polygonShape
    };
    b2PolygonShape.ComputeCentroid = function(vs, count) {
        var c = new b2Vec2;
        var area = 0;
        var p1X = 0;
        var p1Y = 0;
        var inv3 = 1 / 3;
        for (var i = 0; i < count; ++i) {
            var p2 = vs[i];
            var p3 = i + 1 < count ? vs[parseInt(i + 1)] : vs[0];
            var e1X = p2.x - p1X;
            var e1Y = p2.y - p1Y;
            var e2X = p3.x - p1X;
            var e2Y = p3.y - p1Y;
            var D = e1X * e2Y - e1Y * e2X;
            var triangleArea = .5 * D;
            area += triangleArea;
            c.x += triangleArea * inv3 * (p1X + p2.x + p3.x);
            c.y += triangleArea * inv3 * (p1Y + p2.y + p3.y)
        }
        c.x *= 1 / area;
        c.y *= 1 / area;
        return c
    };
    b2PolygonShape.ComputeOBB = function(obb, vs, count) {
        var i = 0;
        var p = new Array(count + 1);
        for (i = 0; i < count; ++i) {
            p[i] = vs[i]
        }
        p[count] = p[0];
        var minArea = Number.MAX_VALUE;
        for (i = 1; i <= count; ++i) {
            var root = p[parseInt(i - 1)];
            var uxX = p[i].x - root.x;
            var uxY = p[i].y - root.y;
            var length = Math.sqrt(uxX * uxX + uxY * uxY);
            uxX /= length;
            uxY /= length;
            var uyX = -uxY;
            var uyY = uxX;
            var lowerX = Number.MAX_VALUE;
            var lowerY = Number.MAX_VALUE;
            var upperX = -Number.MAX_VALUE;
            var upperY = -Number.MAX_VALUE;
            for (var j = 0; j < count; ++j) {
                var dX = p[j].x - root.x;
                var dY = p[j].y - root.y;
                var rX = uxX * dX + uxY * dY;
                var rY = uyX * dX + uyY * dY;
                if (rX < lowerX) lowerX = rX;
                if (rY < lowerY) lowerY = rY;
                if (rX > upperX) upperX = rX;
                if (rY > upperY) upperY = rY
            }
            var area = (upperX - lowerX) * (upperY - lowerY);
            if (area < .95 * minArea) {
                minArea = area;
                obb.R.col1.x = uxX;
                obb.R.col1.y = uxY;
                obb.R.col2.x = uyX;
                obb.R.col2.y = uyY;
                var centerX = .5 * (lowerX + upperX);
                var centerY = .5 * (lowerY + upperY);
                var tMat = obb.R;
                obb.center.x = root.x + (tMat.col1.x * centerX + tMat.col2.x * centerY);
                obb.center.y = root.y + (tMat.col1.y * centerX + tMat.col2.y * centerY);
                obb.extents.x = .5 * (upperX - lowerX);
                obb.extents.y = .5 * (upperY - lowerY)
            }
        }
    };
    b2PolygonShape.s_mat = new b2Mat22;
    b2PolygonShape.prototype.Validate = function() {
        return false
    };
    b2PolygonShape.prototype.Reserve = function(count) {
        for (var i = this.m_vertices.length; i < count; i++) {
            this.m_vertices[i] = new b2Vec2;
            this.m_normals[i] = new b2Vec2
        }
    };
    b2PolygonShape.prototype.Copy = function() {
        var s = new b2PolygonShape;
        s.Set(this);
        return s
    };
    b2PolygonShape.prototype.Set = function(other) {
        this._super.Set.apply(this, [other]);
        if (isInstanceOf(other, b2PolygonShape)) {
            var other2 = other;
            this.m_centroid.SetV(other2.m_centroid);
            this.m_vertexCount = other2.m_vertexCount;
            this.Reserve(this.m_vertexCount);
            for (var i = 0; i < this.m_vertexCount; i++) {
                this.m_vertices[i].SetV(other2.m_vertices[i]);
                this.m_normals[i].SetV(other2.m_normals[i])
            }
        }
    };
    b2PolygonShape.prototype.SetAsArray = function(vertices, vertexCount) {
        var v = new Array;
        for (var i = 0, tVec = null; i < vertices.length, tVec = vertices[i]; i++) {
            v.push(tVec)
        }
        this.SetAsVector(v, vertexCount)
    };
    b2PolygonShape.prototype.SetAsVector = function(vertices, vertexCount) {
        if (typeof vertexCount == "undefined") vertexCount = vertices.length;
        b2Settings.b2Assert(2 <= vertexCount);
        this.m_vertexCount = vertexCount;
        this.Reserve(vertexCount);
        var i = 0;
        for (i = 0; i < this.m_vertexCount; i++) {
            this.m_vertices[i].SetV(vertices[i])
        }
        for (i = 0; i < this.m_vertexCount; ++i) {
            var i1 = i;
            var i2 = i + 1 < this.m_vertexCount ? i + 1 : 0;
            var edge = b2Math.SubtractVV(this.m_vertices[i2], this.m_vertices[i1]);
            b2Settings.b2Assert(edge.LengthSquared() > Number.MIN_VALUE);
            this.m_normals[i].SetV(b2Math.CrossVF(edge, 1));
            this.m_normals[i].Normalize()
        }
        this.m_centroid = b2PolygonShape.ComputeCentroid(this.m_vertices, this.m_vertexCount)
    };
    b2PolygonShape.prototype.SetAsBox = function(hx, hy) {
        this.m_vertexCount = 4;
        this.Reserve(4);
        this.m_vertices[0].Set(-hx, -hy);
        this.m_vertices[1].Set(hx, -hy);
        this.m_vertices[2].Set(hx, hy);
        this.m_vertices[3].Set(-hx, hy);
        this.m_normals[0].Set(0, -1);
        this.m_normals[1].Set(1, 0);
        this.m_normals[2].Set(0, 1);
        this.m_normals[3].Set(-1, 0);
        this.m_centroid.SetZero()
    };
    b2PolygonShape.prototype.SetAsOrientedBox = function(hx, hy, center, angle) {
        this.m_vertexCount = 4;
        this.Reserve(4);
        this.m_vertices[0].Set(-hx, -hy);
        this.m_vertices[1].Set(hx, -hy);
        this.m_vertices[2].Set(hx, hy);
        this.m_vertices[3].Set(-hx, hy);
        this.m_normals[0].Set(0, -1);
        this.m_normals[1].Set(1, 0);
        this.m_normals[2].Set(0, 1);
        this.m_normals[3].Set(-1, 0);
        this.m_centroid = center;
        var xf = new b2Transform;
        xf.position = center;
        xf.R.Set(angle);
        for (var i = 0; i < this.m_vertexCount; ++i) {
            this.m_vertices[i] = b2Math.MulX(xf, this.m_vertices[i]);
            this.m_normals[i] = b2Math.MulMV(xf.R, this.m_normals[i])
        }
    };
    b2PolygonShape.prototype.SetAsEdge = function(v1, v2) {
        this.m_vertexCount = 2;
        this.Reserve(2);
        this.m_vertices[0].SetV(v1);
        this.m_vertices[1].SetV(v2);
        this.m_centroid.x = .5 * (v1.x + v2.x);
        this.m_centroid.y = .5 * (v1.y + v2.y);
        this.m_normals[0] = b2Math.CrossVF(b2Math.SubtractVV(v2, v1), 1);
        this.m_normals[0].Normalize();
        this.m_normals[1].x = -this.m_normals[0].x;
        this.m_normals[1].y = -this.m_normals[0].y
    };
    b2PolygonShape.prototype.TestPoint = function(xf, p) {
        var tVec;
        var tMat = xf.R;
        var tX = p.x - xf.position.x;
        var tY = p.y - xf.position.y;
        var pLocalX = tX * tMat.col1.x + tY * tMat.col1.y;
        var pLocalY = tX * tMat.col2.x + tY * tMat.col2.y;
        for (var i = 0; i < this.m_vertexCount; ++i) {
            tVec = this.m_vertices[i];
            tX = pLocalX - tVec.x;
            tY = pLocalY - tVec.y;
            tVec = this.m_normals[i];
            var dot = tVec.x * tX + tVec.y * tY;
            if (dot > 0) {
                return false
            }
        }
        return true
    };
    b2PolygonShape.prototype.RayCast = function(output, input, transform) {
        var lower = 0;
        var upper = input.maxFraction;
        var tX;
        var tY;
        var tMat;
        var tVec;
        tX = input.p1.x - transform.position.x;
        tY = input.p1.y - transform.position.y;
        tMat = transform.R;
        var p1X = tX * tMat.col1.x + tY * tMat.col1.y;
        var p1Y = tX * tMat.col2.x + tY * tMat.col2.y;
        tX = input.p2.x - transform.position.x;
        tY = input.p2.y - transform.position.y;
        tMat = transform.R;
        var p2X = tX * tMat.col1.x + tY * tMat.col1.y;
        var p2Y = tX * tMat.col2.x + tY * tMat.col2.y;
        var dX = p2X - p1X;
        var dY = p2Y - p1Y;
        var index = -1;
        for (var i = 0; i < this.m_vertexCount; ++i) {
            tVec = this.m_vertices[i];
            tX = tVec.x - p1X;
            tY = tVec.y - p1Y;
            tVec = this.m_normals[i];
            var numerator = tVec.x * tX + tVec.y * tY;
            var denominator = tVec.x * dX + tVec.y * dY;
            if (denominator == 0) {
                if (numerator < 0) {
                    return false
                }
            } else {
                if (denominator < 0 && numerator < lower * denominator) {
                    lower = numerator / denominator;
                    index = i
                } else if (denominator > 0 && numerator < upper * denominator) {
                    upper = numerator / denominator
                }
            }
            if (upper < lower - Number.MIN_VALUE) {
                return false
            }
        }
        if (index >= 0) {
            output.fraction = lower;
            tMat = transform.R;
            tVec = this.m_normals[index];
            output.normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            output.normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            return true
        }
        return false
    };
    b2PolygonShape.prototype.ComputeAABB = function(aabb, xf) {
        var tMat = xf.R;
        var tVec = this.m_vertices[0];
        var lowerX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        var lowerY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        var upperX = lowerX;
        var upperY = lowerY;
        for (var i = 1; i < this.m_vertexCount; ++i) {
            tVec = this.m_vertices[i];
            var vX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            var vY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            lowerX = lowerX < vX ? lowerX : vX;
            lowerY = lowerY < vY ? lowerY : vY;
            upperX = upperX > vX ? upperX : vX;
            upperY = upperY > vY ? upperY : vY
        }
        aabb.lowerBound.x = lowerX - this.m_radius;
        aabb.lowerBound.y = lowerY - this.m_radius;
        aabb.upperBound.x = upperX + this.m_radius;
        aabb.upperBound.y = upperY + this.m_radius
    };
    b2PolygonShape.prototype.ComputeMass = function(massData, density) {
        if (this.m_vertexCount == 2) {
            massData.center.x = .5 * (this.m_vertices[0].x + this.m_vertices[1].x);
            massData.center.y = .5 * (this.m_vertices[0].y + this.m_vertices[1].y);
            massData.mass = 0;
            massData.I = 0;
            return
        }
        var centerX = 0;
        var centerY = 0;
        var area = 0;
        var I = 0;
        var p1X = 0;
        var p1Y = 0;
        var k_inv3 = 1 / 3;
        for (var i = 0; i < this.m_vertexCount; ++i) {
            var p2 = this.m_vertices[i];
            var p3 = i + 1 < this.m_vertexCount ? this.m_vertices[parseInt(i + 1)] : this.m_vertices[0];
            var e1X = p2.x - p1X;
            var e1Y = p2.y - p1Y;
            var e2X = p3.x - p1X;
            var e2Y = p3.y - p1Y;
            var D = e1X * e2Y - e1Y * e2X;
            var triangleArea = .5 * D;
            area += triangleArea;
            centerX += triangleArea * k_inv3 * (p1X + p2.x + p3.x);
            centerY += triangleArea * k_inv3 * (p1Y + p2.y + p3.y);
            var px = p1X;
            var py = p1Y;
            var ex1 = e1X;
            var ey1 = e1Y;
            var ex2 = e2X;
            var ey2 = e2Y;
            var intx2 = k_inv3 * (.25 * (ex1 * ex1 + ex2 * ex1 + ex2 * ex2) + (px * ex1 + px * ex2)) + .5 * px * px;
            var inty2 = k_inv3 * (.25 * (ey1 * ey1 + ey2 * ey1 + ey2 * ey2) + (py * ey1 + py * ey2)) + .5 * py * py;
            I += D * (intx2 + inty2)
        }
        massData.area = area;
        massData.mass = density * area;
        centerX *= 1 / area;
        centerY *= 1 / area;
        massData.center.Set(centerX, centerY);
        massData.I = density * I
    };
    b2PolygonShape.prototype.ComputeSubmergedArea = function(normal, offset, xf, c) {
        var normalL = b2Math.MulTMV(xf.R, normal);
        var offsetL = offset - b2Math.Dot(normal, xf.position);
        var depths = new Array;
        var diveCount = 0;
        var intoIndex = -1;
        var outoIndex = -1;
        var tVec = null;
        var lastSubmerged = false;
        var i = 0;
        for (i = 0; i < this.m_vertexCount; ++i) {
            tVec = this.m_vertices[i];
            depths[i] = normalL.x * tVec.x + normalL.y * tVec.y - offsetL;
            var isSubmerged = depths[i] < -Number.MIN_VALUE;
            if (i > 0) {
                if (isSubmerged) {
                    if (!lastSubmerged) {
                        intoIndex = i - 1;
                        diveCount++
                    }
                } else {
                    if (lastSubmerged) {
                        outoIndex = i - 1;
                        diveCount++
                    }
                }
            }
            lastSubmerged = isSubmerged
        }
        switch (diveCount) {
            case 0:
                if (lastSubmerged) {
                    var md = new b2MassData;
                    this.ComputeMass(md, 1);
                    c.SetV(b2Math.MulX(xf, md.center));
                    return md.mass
                } else {
                    return 0
                }
                break;
            case 1:
                if (intoIndex == -1) {
                    intoIndex = this.m_vertexCount - 1
                } else {
                    outoIndex = this.m_vertexCount - 1
                }
                break
        }
        var intoIndex2 = (intoIndex + 1) % this.m_vertexCount;
        var outoIndex2 = (outoIndex + 1) % this.m_vertexCount;
        var intoLamdda = (0 - depths[intoIndex]) / (depths[intoIndex2] - depths[intoIndex]);
        var outoLamdda = (0 - depths[outoIndex]) / (depths[outoIndex2] - depths[outoIndex]);
        var intoVec = new b2Vec2(this.m_vertices[intoIndex].x * (1 - intoLamdda) + this.m_vertices[intoIndex2].x * intoLamdda, this.m_vertices[intoIndex].y * (1 - intoLamdda) + this.m_vertices[intoIndex2].y * intoLamdda);
        var outoVec = new b2Vec2(this.m_vertices[outoIndex].x * (1 - outoLamdda) + this.m_vertices[outoIndex2].x * outoLamdda, this.m_vertices[outoIndex].y * (1 - outoLamdda) + this.m_vertices[outoIndex2].y * outoLamdda);
        var area = 0;
        var center = new b2Vec2;
        var p2 = this.m_vertices[intoIndex2];
        var p3;
        i = intoIndex2;
        while (i != outoIndex2) {
            i = (i + 1) % this.m_vertexCount;
            if (i == outoIndex2) p3 = outoVec;
            else p3 = this.m_vertices[i];
            var triangleArea = .5 * ((p2.x - intoVec.x) * (p3.y - intoVec.y) - (p2.y - intoVec.y) * (p3.x - intoVec.x));
            area += triangleArea;
            center.x += triangleArea * (intoVec.x + p2.x + p3.x) / 3;
            center.y += triangleArea * (intoVec.y + p2.y + p3.y) / 3;
            p2 = p3
        }
        center.Multiply(1 / area);
        c.SetV(b2Math.MulX(xf, center));
        return area
    };
    b2PolygonShape.prototype.GetVertexCount = function() {
        return this.m_vertexCount
    };
    b2PolygonShape.prototype.GetVertices = function() {
        return this.m_vertices
    };
    b2PolygonShape.prototype.GetNormals = function() {
        return this.m_normals
    };
    b2PolygonShape.prototype.GetSupport = function(d) {
        var bestIndex = 0;
        var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
        for (var i = 1; i < this.m_vertexCount; ++i) {
            var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
            if (value > bestValue) {
                bestIndex = i;
                bestValue = value
            }
        }
        return bestIndex
    };
    b2PolygonShape.prototype.GetSupportVertex = function(d) {
        var bestIndex = 0;
        var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
        for (var i = 1; i < this.m_vertexCount; ++i) {
            var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
            if (value > bestValue) {
                bestIndex = i;
                bestValue = value
            }
        }
        return this.m_vertices[bestIndex]
    };
    b2PolygonShape.prototype.m_centroid = null;
    b2PolygonShape.prototype.m_vertices = null;
    b2PolygonShape.prototype.m_normals = null;
    b2PolygonShape.prototype.m_vertexCount = 0;
    var b2Fixture = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2Fixture.prototype.__constructor = function() {
        this.m_aabb = new b2AABB;
        this.m_userData = null;
        this.m_body = null;
        this.m_next = null;
        this.m_shape = null;
        this.m_density = 0;
        this.m_friction = 0;
        this.m_restitution = 0
    };
    b2Fixture.prototype.__varz = function() {
        this.m_filter = new b2FilterData
    };
    b2Fixture.prototype.Create = function(body, xf, def) {
        this.m_userData = def.userData;
        this.m_friction = def.friction;
        this.m_restitution = def.restitution;
        this.m_body = body;
        this.m_next = null;
        this.m_filter = def.filter.Copy();
        this.m_isSensor = def.isSensor;
        this.m_shape = def.shape.Copy();
        this.m_density = def.density
    };
    b2Fixture.prototype.Destroy = function() {
        this.m_shape = null
    };
    b2Fixture.prototype.CreateProxy = function(broadPhase, xf) {
        this.m_shape.ComputeAABB(this.m_aabb, xf);
        this.m_proxy = broadPhase.CreateProxy(this.m_aabb, this)
    };
    b2Fixture.prototype.DestroyProxy = function(broadPhase) {
        if (this.m_proxy == null) {
            return
        }
        broadPhase.DestroyProxy(this.m_proxy);
        this.m_proxy = null
    };
    b2Fixture.prototype.Synchronize = function(broadPhase, transform1, transform2) {
        if (!this.m_proxy) return;
        var aabb1 = new b2AABB;
        var aabb2 = new b2AABB;
        this.m_shape.ComputeAABB(aabb1, transform1);
        this.m_shape.ComputeAABB(aabb2, transform2);
        this.m_aabb.Combine(aabb1, aabb2);
        var displacement = b2Math.SubtractVV(transform2.position, transform1.position);
        broadPhase.MoveProxy(this.m_proxy, this.m_aabb, displacement)
    };
    b2Fixture.prototype.GetType = function() {
        return this.m_shape.GetType()
    };
    b2Fixture.prototype.GetShape = function() {
        return this.m_shape
    };
    b2Fixture.prototype.SetSensor = function(sensor) {
        if (this.m_isSensor == sensor) return;
        this.m_isSensor = sensor;
        if (this.m_body == null) return;
        var edge = this.m_body.GetContactList();
        while (edge) {
            var contact = edge.contact;
            var fixtureA = contact.GetFixtureA();
            var fixtureB = contact.GetFixtureB();
            if (fixtureA == this || fixtureB == this) contact.SetSensor(fixtureA.IsSensor() || fixtureB.IsSensor());
            edge = edge.next
        }
    };
    b2Fixture.prototype.IsSensor = function() {
        return this.m_isSensor
    };
    b2Fixture.prototype.SetFilterData = function(filter) {
        this.m_filter = filter.Copy();
        if (this.m_body) return;
        var edge = this.m_body.GetContactList();
        while (edge) {
            var contact = edge.contact;
            var fixtureA = contact.GetFixtureA();
            var fixtureB = contact.GetFixtureB();
            if (fixtureA == this || fixtureB == this) contact.FlagForFiltering();
            edge = edge.next
        }
    };
    b2Fixture.prototype.GetFilterData = function() {
        return this.m_filter.Copy()
    };
    b2Fixture.prototype.GetBody = function() {
        return this.m_body
    };
    b2Fixture.prototype.GetNext = function() {
        return this.m_next
    };
    b2Fixture.prototype.GetUserData = function() {
        return this.m_userData
    };
    b2Fixture.prototype.SetUserData = function(data) {
        this.m_userData = data
    };
    b2Fixture.prototype.TestPoint = function(p) {
        return this.m_shape.TestPoint(this.m_body.GetTransform(), p)
    };
    b2Fixture.prototype.RayCast = function(output, input) {
        return this.m_shape.RayCast(output, input, this.m_body.GetTransform())
    };
    b2Fixture.prototype.GetMassData = function(massData) {
        if (massData == null) {
            massData = new b2MassData
        }
        this.m_shape.ComputeMass(massData, this.m_density);
        return massData
    };
    b2Fixture.prototype.SetDensity = function(density) {
        this.m_density = density
    };
    b2Fixture.prototype.GetDensity = function() {
        return this.m_density
    };
    b2Fixture.prototype.GetFriction = function() {
        return this.m_friction
    };
    b2Fixture.prototype.SetFriction = function(friction) {
        this.m_friction = friction
    };
    b2Fixture.prototype.GetRestitution = function() {
        return this.m_restitution
    };
    b2Fixture.prototype.SetRestitution = function(restitution) {
        this.m_restitution = restitution
    };
    b2Fixture.prototype.GetAABB = function() {
        return this.m_aabb
    };
    b2Fixture.prototype.m_massData = null;
    b2Fixture.prototype.m_aabb = null;
    b2Fixture.prototype.m_density = null;
    b2Fixture.prototype.m_next = null;
    b2Fixture.prototype.m_body = null;
    b2Fixture.prototype.m_shape = null;
    b2Fixture.prototype.m_friction = null;
    b2Fixture.prototype.m_restitution = null;
    b2Fixture.prototype.m_proxy = null;
    b2Fixture.prototype.m_filter = new b2FilterData;
    b2Fixture.prototype.m_isSensor = null;
    b2Fixture.prototype.m_userData = null;
    var b2DynamicTreeNode = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2DynamicTreeNode.prototype.__constructor = function() {};
    b2DynamicTreeNode.prototype.__varz = function() {
        this.aabb = new b2AABB
    };
    b2DynamicTreeNode.prototype.IsLeaf = function() {
        return this.child1 == null
    };
    b2DynamicTreeNode.prototype.userData = null;
    b2DynamicTreeNode.prototype.aabb = new b2AABB;
    b2DynamicTreeNode.prototype.parent = null;
    b2DynamicTreeNode.prototype.child1 = null;
    b2DynamicTreeNode.prototype.child2 = null;
    var b2BodyDef = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2BodyDef.prototype.__constructor = function() {
        this.userData = null;
        this.position.Set(0, 0);
        this.angle = 0;
        this.linearVelocity.Set(0, 0);
        this.angularVelocity = 0;
        this.linearDamping = 0;
        this.angularDamping = 0;
        this.allowSleep = true;
        this.awake = true;
        this.fixedRotation = false;
        this.bullet = false;
        this.type = b2Body.b2_staticBody;
        this.active = true;
        this.inertiaScale = 1
    };
    b2BodyDef.prototype.__varz = function() {
        this.position = new b2Vec2;
        this.linearVelocity = new b2Vec2
    };
    b2BodyDef.prototype.type = 0;
    b2BodyDef.prototype.position = new b2Vec2;
    b2BodyDef.prototype.angle = null;
    b2BodyDef.prototype.linearVelocity = new b2Vec2;
    b2BodyDef.prototype.angularVelocity = null;
    b2BodyDef.prototype.linearDamping = null;
    b2BodyDef.prototype.angularDamping = null;
    b2BodyDef.prototype.allowSleep = null;
    b2BodyDef.prototype.awake = null;
    b2BodyDef.prototype.fixedRotation = null;
    b2BodyDef.prototype.bullet = null;
    b2BodyDef.prototype.active = null;
    b2BodyDef.prototype.userData = null;
    b2BodyDef.prototype.inertiaScale = null;
    var b2DynamicTreeBroadPhase = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2DynamicTreeBroadPhase.prototype.__constructor = function() {};
    b2DynamicTreeBroadPhase.prototype.__varz = function() {
        this.m_tree = new b2DynamicTree;
        this.m_moveBuffer = new Array;
        this.m_pairBuffer = new Array
    };
    b2DynamicTreeBroadPhase.prototype.BufferMove = function(proxy) {
        this.m_moveBuffer[this.m_moveBuffer.length] = proxy
    };
    b2DynamicTreeBroadPhase.prototype.UnBufferMove = function(proxy) {
        var i = this.m_moveBuffer.indexOf(proxy);
        this.m_moveBuffer.splice(i, 1)
    };
    b2DynamicTreeBroadPhase.prototype.ComparePairs = function(pair1, pair2) {
        return 0
    };
    b2DynamicTreeBroadPhase.prototype.CreateProxy = function(aabb, userData) {
        var proxy = this.m_tree.CreateProxy(aabb, userData);
        ++this.m_proxyCount;
        this.BufferMove(proxy);
        return proxy
    };
    b2DynamicTreeBroadPhase.prototype.DestroyProxy = function(proxy) {
        this.UnBufferMove(proxy);
        --this.m_proxyCount;
        this.m_tree.DestroyProxy(proxy)
    };
    b2DynamicTreeBroadPhase.prototype.MoveProxy = function(proxy, aabb, displacement) {
        var buffer = this.m_tree.MoveProxy(proxy, aabb, displacement);
        if (buffer) {
            this.BufferMove(proxy)
        }
    };
    b2DynamicTreeBroadPhase.prototype.TestOverlap = function(proxyA, proxyB) {
        var aabbA = this.m_tree.GetFatAABB(proxyA);
        var aabbB = this.m_tree.GetFatAABB(proxyB);
        return aabbA.TestOverlap(aabbB)
    };
    b2DynamicTreeBroadPhase.prototype.GetUserData = function(proxy) {
        return this.m_tree.GetUserData(proxy)
    };
    b2DynamicTreeBroadPhase.prototype.GetFatAABB = function(proxy) {
        return this.m_tree.GetFatAABB(proxy)
    };
    b2DynamicTreeBroadPhase.prototype.GetProxyCount = function() {
        return this.m_proxyCount
    };
    b2DynamicTreeBroadPhase.prototype.UpdatePairs = function(callback) {
        this.m_pairCount = 0;
        for (var i = 0, queryProxy = null; i < this.m_moveBuffer.length, queryProxy = this.m_moveBuffer[i]; i++) {
            var that = this;

            function QueryCallback(proxy) {
                if (proxy == queryProxy) return true;
                if (that.m_pairCount == that.m_pairBuffer.length) {
                    that.m_pairBuffer[that.m_pairCount] = new b2DynamicTreePair
                }
                var pair = that.m_pairBuffer[that.m_pairCount];
                pair.proxyA = proxy < queryProxy ? proxy : queryProxy;
                pair.proxyB = proxy >= queryProxy ? proxy : queryProxy;
                ++that.m_pairCount;
                return true
            }
            var fatAABB = this.m_tree.GetFatAABB(queryProxy);
            this.m_tree.Query(QueryCallback, fatAABB)
        }
        this.m_moveBuffer.length = 0;
        for (var i = 0; i < this.m_pairCount;) {
            var primaryPair = this.m_pairBuffer[i];
            var userDataA = this.m_tree.GetUserData(primaryPair.proxyA);
            var userDataB = this.m_tree.GetUserData(primaryPair.proxyB);
            callback(userDataA, userDataB);
            ++i;
            while (i < this.m_pairCount) {
                var pair = this.m_pairBuffer[i];
                if (pair.proxyA != primaryPair.proxyA || pair.proxyB != primaryPair.proxyB) {
                    break
                }++i
            }
        }
    };
    b2DynamicTreeBroadPhase.prototype.Query = function(callback, aabb) {
        this.m_tree.Query(callback, aabb)
    };
    b2DynamicTreeBroadPhase.prototype.RayCast = function(callback, input) {
        this.m_tree.RayCast(callback, input)
    };
    b2DynamicTreeBroadPhase.prototype.Validate = function() {};
    b2DynamicTreeBroadPhase.prototype.Rebalance = function(iterations) {
        this.m_tree.Rebalance(iterations)
    };
    b2DynamicTreeBroadPhase.prototype.m_tree = new b2DynamicTree;
    b2DynamicTreeBroadPhase.prototype.m_proxyCount = 0;
    b2DynamicTreeBroadPhase.prototype.m_moveBuffer = new Array;
    b2DynamicTreeBroadPhase.prototype.m_pairBuffer = new Array;
    b2DynamicTreeBroadPhase.prototype.m_pairCount = 0;
    var b2BroadPhase = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2BroadPhase.prototype.__constructor = function(worldAABB) {
        var i = 0;
        this.m_pairManager.Initialize(this);
        this.m_worldAABB = worldAABB;
        this.m_proxyCount = 0;
        this.m_bounds = new Array;
        for (i = 0; i < 2; i++) {
            this.m_bounds[i] = new Array
        }
        var dX = worldAABB.upperBound.x - worldAABB.lowerBound.x;
        var dY = worldAABB.upperBound.y - worldAABB.lowerBound.y;
        this.m_quantizationFactor.x = b2Settings.USHRT_MAX / dX;
        this.m_quantizationFactor.y = b2Settings.USHRT_MAX / dY;
        this.m_timeStamp = 1;
        this.m_queryResultCount = 0
    };
    b2BroadPhase.prototype.__varz = function() {
        this.m_pairManager = new b2PairManager;
        this.m_proxyPool = new Array;
        this.m_querySortKeys = new Array;
        this.m_queryResults = new Array;
        this.m_quantizationFactor = new b2Vec2
    };
    b2BroadPhase.BinarySearch = function(bounds, count, value) {
        var low = 0;
        var high = count - 1;
        while (low <= high) {
            var mid = Math.round((low + high) / 2);
            var bound = bounds[mid];
            if (bound.value > value) {
                high = mid - 1
            } else if (bound.value < value) {
                low = mid + 1
            } else {
                return parseInt(mid)
            }
        }
        return parseInt(low)
    };
    b2BroadPhase.s_validate = false;
    b2BroadPhase.b2_invalid = b2Settings.USHRT_MAX;
    b2BroadPhase.b2_nullEdge = b2Settings.USHRT_MAX;
    b2BroadPhase.prototype.ComputeBounds = function(lowerValues, upperValues, aabb) {
        var minVertexX = aabb.lowerBound.x;
        var minVertexY = aabb.lowerBound.y;
        minVertexX = b2Math.Min(minVertexX, this.m_worldAABB.upperBound.x);
        minVertexY = b2Math.Min(minVertexY, this.m_worldAABB.upperBound.y);
        minVertexX = b2Math.Max(minVertexX, this.m_worldAABB.lowerBound.x);
        minVertexY = b2Math.Max(minVertexY, this.m_worldAABB.lowerBound.y);
        var maxVertexX = aabb.upperBound.x;
        var maxVertexY = aabb.upperBound.y;
        maxVertexX = b2Math.Min(maxVertexX, this.m_worldAABB.upperBound.x);
        maxVertexY = b2Math.Min(maxVertexY, this.m_worldAABB.upperBound.y);
        maxVertexX = b2Math.Max(maxVertexX, this.m_worldAABB.lowerBound.x);
        maxVertexY = b2Math.Max(maxVertexY, this.m_worldAABB.lowerBound.y);
        lowerValues[0] = parseInt(this.m_quantizationFactor.x * (minVertexX - this.m_worldAABB.lowerBound.x)) & b2Settings.USHRT_MAX - 1;
        upperValues[0] = parseInt(this.m_quantizationFactor.x * (maxVertexX - this.m_worldAABB.lowerBound.x)) % 65535 | 1;
        lowerValues[1] = parseInt(this.m_quantizationFactor.y * (minVertexY - this.m_worldAABB.lowerBound.y)) & b2Settings.USHRT_MAX - 1;
        upperValues[1] = parseInt(this.m_quantizationFactor.y * (maxVertexY - this.m_worldAABB.lowerBound.y)) % 65535 | 1
    };
    b2BroadPhase.prototype.TestOverlapValidate = function(p1, p2) {
        for (var axis = 0; axis < 2; ++axis) {
            var bounds = this.m_bounds[axis];
            var bound1 = bounds[p1.lowerBounds[axis]];
            var bound2 = bounds[p2.upperBounds[axis]];
            if (bound1.value > bound2.value) return false;
            bound1 = bounds[p1.upperBounds[axis]];
            bound2 = bounds[p2.lowerBounds[axis]];
            if (bound1.value < bound2.value) return false
        }
        return true
    };
    b2BroadPhase.prototype.QueryAxis = function(lowerQueryOut, upperQueryOut, lowerValue, upperValue, bounds, boundCount, axis) {
        var lowerQuery = b2BroadPhase.BinarySearch(bounds, boundCount, lowerValue);
        var upperQuery = b2BroadPhase.BinarySearch(bounds, boundCount, upperValue);
        var bound;
        for (var j = lowerQuery; j < upperQuery; ++j) {
            bound = bounds[j];
            if (bound.IsLower()) {
                this.IncrementOverlapCount(bound.proxy)
            }
        }
        if (lowerQuery > 0) {
            var i = lowerQuery - 1;
            bound = bounds[i];
            var s = bound.stabbingCount;
            while (s) {
                bound = bounds[i];
                if (bound.IsLower()) {
                    var proxy = bound.proxy;
                    if (lowerQuery <= proxy.upperBounds[axis]) {
                        this.IncrementOverlapCount(bound.proxy);
                        --s
                    }
                }--i
            }
        }
        lowerQueryOut[0] = lowerQuery;
        upperQueryOut[0] = upperQuery
    };
    b2BroadPhase.prototype.IncrementOverlapCount = function(proxy) {
        if (proxy.timeStamp < this.m_timeStamp) {
            proxy.timeStamp = this.m_timeStamp;
            proxy.overlapCount = 1
        } else {
            proxy.overlapCount = 2;
            this.m_queryResults[this.m_queryResultCount] = proxy;
            ++this.m_queryResultCount
        }
    };
    b2BroadPhase.prototype.IncrementTimeStamp = function() {
        if (this.m_timeStamp == b2Settings.USHRT_MAX) {
            for (var i = 0; i < this.m_proxyPool.length; ++i) {
                this.m_proxyPool[i].timeStamp = 0
            }
            this.m_timeStamp = 1
        } else {
            ++this.m_timeStamp
        }
    };
    b2BroadPhase.prototype.InRange = function(aabb) {
        var dX;
        var dY;
        var d2X;
        var d2Y;
        dX = aabb.lowerBound.x;
        dY = aabb.lowerBound.y;
        dX -= this.m_worldAABB.upperBound.x;
        dY -= this.m_worldAABB.upperBound.y;
        d2X = this.m_worldAABB.lowerBound.x;
        d2Y = this.m_worldAABB.lowerBound.y;
        d2X -= aabb.upperBound.x;
        d2Y -= aabb.upperBound.y;
        dX = b2Math.Max(dX, d2X);
        dY = b2Math.Max(dY, d2Y);
        return b2Math.Max(dX, dY) < 0
    };
    b2BroadPhase.prototype.CreateProxy = function(aabb, userData) {
        var index = 0;
        var proxy;
        var i = 0;
        var j = 0;
        if (!this.m_freeProxy) {
            this.m_freeProxy = this.m_proxyPool[this.m_proxyCount] = new b2Proxy;
            this.m_freeProxy.next = null;
            this.m_freeProxy.timeStamp = 0;
            this.m_freeProxy.overlapCount = b2BroadPhase.b2_invalid;
            this.m_freeProxy.userData = null;
            for (i = 0; i < 2; i++) {
                j = this.m_proxyCount * 2;
                this.m_bounds[i][j++] = new b2Bound;
                this.m_bounds[i][j] = new b2Bound
            }
        }
        proxy = this.m_freeProxy;
        this.m_freeProxy = proxy.next;
        proxy.overlapCount = 0;
        proxy.userData = userData;
        var boundCount = 2 * this.m_proxyCount;
        var lowerValues = new Array;
        var upperValues = new Array;
        this.ComputeBounds(lowerValues, upperValues, aabb);
        for (var axis = 0; axis < 2; ++axis) {
            var bounds = this.m_bounds[axis];
            var lowerIndex = 0;
            var upperIndex = 0;
            var lowerIndexOut = new Array;
            lowerIndexOut.push(lowerIndex);
            var upperIndexOut = new Array;
            upperIndexOut.push(upperIndex);
            this.QueryAxis(lowerIndexOut, upperIndexOut, lowerValues[axis], upperValues[axis], bounds, boundCount, axis);
            lowerIndex = lowerIndexOut[0];
            upperIndex = upperIndexOut[0];
            bounds.splice(upperIndex, 0, bounds[bounds.length - 1]);
            bounds.length--;
            bounds.splice(lowerIndex, 0, bounds[bounds.length - 1]);
            bounds.length--;
            ++upperIndex;
            var tBound1 = bounds[lowerIndex];
            var tBound2 = bounds[upperIndex];
            tBound1.value = lowerValues[axis];
            tBound1.proxy = proxy;
            tBound2.value = upperValues[axis];
            tBound2.proxy = proxy;
            var tBoundAS3 = bounds[parseInt(lowerIndex - 1)];
            tBound1.stabbingCount = lowerIndex == 0 ? 0 : tBoundAS3.stabbingCount;
            tBoundAS3 = bounds[parseInt(upperIndex - 1)];
            tBound2.stabbingCount = tBoundAS3.stabbingCount;
            for (index = lowerIndex; index < upperIndex; ++index) {
                tBoundAS3 = bounds[index];
                tBoundAS3.stabbingCount++
            }
            for (index = lowerIndex; index < boundCount + 2; ++index) {
                tBound1 = bounds[index];
                var proxy2 = tBound1.proxy;
                if (tBound1.IsLower()) {
                    proxy2.lowerBounds[axis] = index
                } else {
                    proxy2.upperBounds[axis] = index
                }
            }
        }++this.m_proxyCount;
        for (i = 0; i < this.m_queryResultCount; ++i) {
            this.m_pairManager.AddBufferedPair(proxy, this.m_queryResults[i])
        }
        this.m_queryResultCount = 0;
        this.IncrementTimeStamp();
        return proxy
    };
    b2BroadPhase.prototype.DestroyProxy = function(proxy_) {
        var proxy = proxy_;
        var tBound1;
        var tBound2;
        var boundCount = 2 * this.m_proxyCount;
        for (var axis = 0; axis < 2; ++axis) {
            var bounds = this.m_bounds[axis];
            var lowerIndex = proxy.lowerBounds[axis];
            var upperIndex = proxy.upperBounds[axis];
            tBound1 = bounds[lowerIndex];
            var lowerValue = tBound1.value;
            tBound2 = bounds[upperIndex];
            var upperValue = tBound2.value;
            bounds.splice(upperIndex, 1);
            bounds.splice(lowerIndex, 1);
            bounds.push(tBound1);
            bounds.push(tBound2);
            var tEnd = boundCount - 2;
            for (var index = lowerIndex; index < tEnd; ++index) {
                tBound1 = bounds[index];
                var proxy2 = tBound1.proxy;
                if (tBound1.IsLower()) {
                    proxy2.lowerBounds[axis] = index
                } else {
                    proxy2.upperBounds[axis] = index
                }
            }
            tEnd = upperIndex - 1;
            for (var index2 = lowerIndex; index2 < tEnd; ++index2) {
                tBound1 = bounds[index2];
                tBound1.stabbingCount--
            }
            var ignore = new Array;
            this.QueryAxis(ignore, ignore, lowerValue, upperValue, bounds, boundCount - 2, axis)
        }
        for (var i = 0; i < this.m_queryResultCount; ++i) {
            this.m_pairManager.RemoveBufferedPair(proxy, this.m_queryResults[i])
        }
        this.m_queryResultCount = 0;
        this.IncrementTimeStamp();
        proxy.userData = null;
        proxy.overlapCount = b2BroadPhase.b2_invalid;
        proxy.lowerBounds[0] = b2BroadPhase.b2_invalid;
        proxy.lowerBounds[1] = b2BroadPhase.b2_invalid;
        proxy.upperBounds[0] = b2BroadPhase.b2_invalid;
        proxy.upperBounds[1] = b2BroadPhase.b2_invalid;
        proxy.next = this.m_freeProxy;
        this.m_freeProxy = proxy;
        --this.m_proxyCount
    };
    b2BroadPhase.prototype.MoveProxy = function(proxy_, aabb, displacement) {
        var proxy = proxy_;
        var as3arr;
        var as3int = 0;
        var axis = 0;
        var index = 0;
        var bound;
        var prevBound;
        var nextBound;
        var nextProxyId = 0;
        var nextProxy;
        if (proxy == null) {
            return
        }
        if (aabb.IsValid() == false) {
            return
        }
        var boundCount = 2 * this.m_proxyCount;
        var newValues = new b2BoundValues;
        this.ComputeBounds(newValues.lowerValues, newValues.upperValues, aabb);
        var oldValues = new b2BoundValues;
        for (axis = 0; axis < 2; ++axis) {
            bound = this.m_bounds[axis][proxy.lowerBounds[axis]];
            oldValues.lowerValues[axis] = bound.value;
            bound = this.m_bounds[axis][proxy.upperBounds[axis]];
            oldValues.upperValues[axis] = bound.value
        }
        for (axis = 0; axis < 2; ++axis) {
            var bounds = this.m_bounds[axis];
            var lowerIndex = proxy.lowerBounds[axis];
            var upperIndex = proxy.upperBounds[axis];
            var lowerValue = newValues.lowerValues[axis];
            var upperValue = newValues.upperValues[axis];
            bound = bounds[lowerIndex];
            var deltaLower = lowerValue - bound.value;
            bound.value = lowerValue;
            bound = bounds[upperIndex];
            var deltaUpper = upperValue - bound.value;
            bound.value = upperValue;
            if (deltaLower < 0) {
                index = lowerIndex;
                while (index > 0 && lowerValue < bounds[parseInt(index - 1)].value) {
                    bound = bounds[index];
                    prevBound = bounds[parseInt(index - 1)];
                    var prevProxy = prevBound.proxy;
                    prevBound.stabbingCount++;
                    if (prevBound.IsUpper() == true) {
                        if (this.TestOverlapBound(newValues, prevProxy)) {
                            this.m_pairManager.AddBufferedPair(proxy, prevProxy)
                        }
                        as3arr = prevProxy.upperBounds;
                        as3int = as3arr[axis];
                        as3int++;
                        as3arr[axis] = as3int;
                        bound.stabbingCount++
                    } else {
                        as3arr = prevProxy.lowerBounds;
                        as3int = as3arr[axis];
                        as3int++;
                        as3arr[axis] = as3int;
                        bound.stabbingCount--
                    }
                    as3arr = proxy.lowerBounds;
                    as3int = as3arr[axis];
                    as3int--;
                    as3arr[axis] = as3int;
                    bound.Swap(prevBound);
                    --index
                }
            }
            if (deltaUpper > 0) {
                index = upperIndex;
                while (index < boundCount - 1 && bounds[parseInt(index + 1)].value <= upperValue) {
                    bound = bounds[index];
                    nextBound = bounds[parseInt(index + 1)];
                    nextProxy = nextBound.proxy;
                    nextBound.stabbingCount++;
                    if (nextBound.IsLower() == true) {
                        if (this.TestOverlapBound(newValues, nextProxy)) {
                            this.m_pairManager.AddBufferedPair(proxy, nextProxy)
                        }
                        as3arr = nextProxy.lowerBounds;
                        as3int = as3arr[axis];
                        as3int--;
                        as3arr[axis] = as3int;
                        bound.stabbingCount++
                    } else {
                        as3arr = nextProxy.upperBounds;
                        as3int = as3arr[axis];
                        as3int--;
                        as3arr[axis] = as3int;
                        bound.stabbingCount--
                    }
                    as3arr = proxy.upperBounds;
                    as3int = as3arr[axis];
                    as3int++;
                    as3arr[axis] = as3int;
                    bound.Swap(nextBound);
                    index++
                }
            }
            if (deltaLower > 0) {
                index = lowerIndex;
                while (index < boundCount - 1 && bounds[parseInt(index + 1)].value <= lowerValue) {
                    bound = bounds[index];
                    nextBound = bounds[parseInt(index + 1)];
                    nextProxy = nextBound.proxy;
                    nextBound.stabbingCount--;
                    if (nextBound.IsUpper()) {
                        if (this.TestOverlapBound(oldValues, nextProxy)) {
                            this.m_pairManager.RemoveBufferedPair(proxy, nextProxy)
                        }
                        as3arr = nextProxy.upperBounds;
                        as3int = as3arr[axis];
                        as3int--;
                        as3arr[axis] = as3int;
                        bound.stabbingCount--
                    } else {
                        as3arr = nextProxy.lowerBounds;
                        as3int = as3arr[axis];
                        as3int--;
                        as3arr[axis] = as3int;
                        bound.stabbingCount++
                    }
                    as3arr = proxy.lowerBounds;
                    as3int = as3arr[axis];
                    as3int++;
                    as3arr[axis] = as3int;
                    bound.Swap(nextBound);
                    index++
                }
            }
            if (deltaUpper < 0) {
                index = upperIndex;
                while (index > 0 && upperValue < bounds[parseInt(index - 1)].value) {
                    bound = bounds[index];
                    prevBound = bounds[parseInt(index - 1)];
                    prevProxy = prevBound.proxy;
                    prevBound.stabbingCount--;
                    if (prevBound.IsLower() == true) {
                        if (this.TestOverlapBound(oldValues, prevProxy)) {
                            this.m_pairManager.RemoveBufferedPair(proxy, prevProxy)
                        }
                        as3arr = prevProxy.lowerBounds;
                        as3int = as3arr[axis];
                        as3int++;
                        as3arr[axis] = as3int;
                        bound.stabbingCount--
                    } else {
                        as3arr = prevProxy.upperBounds;
                        as3int = as3arr[axis];
                        as3int++;
                        as3arr[axis] = as3int;
                        bound.stabbingCount++
                    }
                    as3arr = proxy.upperBounds;
                    as3int = as3arr[axis];
                    as3int--;
                    as3arr[axis] = as3int;
                    bound.Swap(prevBound);
                    index--
                }
            }
        }
    };
    b2BroadPhase.prototype.UpdatePairs = function(callback) {
        this.m_pairManager.Commit(callback)
    };
    b2BroadPhase.prototype.TestOverlap = function(proxyA, proxyB) {
        var proxyA_ = proxyA;
        var proxyB_ = proxyB;
        if (proxyA_.lowerBounds[0] > proxyB_.upperBounds[0]) return false;
        if (proxyB_.lowerBounds[0] > proxyA_.upperBounds[0]) return false;
        if (proxyA_.lowerBounds[1] > proxyB_.upperBounds[1]) return false;
        if (proxyB_.lowerBounds[1] > proxyA_.upperBounds[1]) return false;
        return true
    };
    b2BroadPhase.prototype.GetUserData = function(proxy) {
        return proxy.userData
    };
    b2BroadPhase.prototype.GetFatAABB = function(proxy_) {
        var aabb = new b2AABB;
        var proxy = proxy_;
        aabb.lowerBound.x = this.m_worldAABB.lowerBound.x + this.m_bounds[0][proxy.lowerBounds[0]].value / this.m_quantizationFactor.x;
        aabb.lowerBound.y = this.m_worldAABB.lowerBound.y + this.m_bounds[1][proxy.lowerBounds[1]].value / this.m_quantizationFactor.y;
        aabb.upperBound.x = this.m_worldAABB.lowerBound.x + this.m_bounds[0][proxy.upperBounds[0]].value / this.m_quantizationFactor.x;
        aabb.upperBound.y = this.m_worldAABB.lowerBound.y + this.m_bounds[1][proxy.upperBounds[1]].value / this.m_quantizationFactor.y;
        return aabb
    };
    b2BroadPhase.prototype.GetProxyCount = function() {
        return this.m_proxyCount
    };
    b2BroadPhase.prototype.Query = function(callback, aabb) {
        var lowerValues = new Array;
        var upperValues = new Array;
        this.ComputeBounds(lowerValues, upperValues, aabb);
        var lowerIndex = 0;
        var upperIndex = 0;
        var lowerIndexOut = new Array;
        lowerIndexOut.push(lowerIndex);
        var upperIndexOut = new Array;
        upperIndexOut.push(upperIndex);
        this.QueryAxis(lowerIndexOut, upperIndexOut, lowerValues[0], upperValues[0], this.m_bounds[0], 2 * this.m_proxyCount, 0);
        this.QueryAxis(lowerIndexOut, upperIndexOut, lowerValues[1], upperValues[1], this.m_bounds[1], 2 * this.m_proxyCount, 1);
        for (var i = 0; i < this.m_queryResultCount; ++i) {
            var proxy = this.m_queryResults[i];
            if (!callback(proxy)) {
                break
            }
        }
        this.m_queryResultCount = 0;
        this.IncrementTimeStamp()
    };
    b2BroadPhase.prototype.Validate = function() {
        var pair;
        var proxy1;
        var proxy2;
        var overlap;
        for (var axis = 0; axis < 2; ++axis) {
            var bounds = this.m_bounds[axis];
            var boundCount = 2 * this.m_proxyCount;
            var stabbingCount = 0;
            for (var i = 0; i < boundCount; ++i) {
                var bound = bounds[i];
                if (bound.IsLower() == true) {
                    stabbingCount++
                } else {
                    stabbingCount--
                }
            }
        }
    };
    b2BroadPhase.prototype.Rebalance = function(iterations) {};
    b2BroadPhase.prototype.RayCast = function(callback, input) {
        var subInput = new b2RayCastInput;
        subInput.p1.SetV(input.p1);
        subInput.p2.SetV(input.p2);
        subInput.maxFraction = input.maxFraction;
        var dx = (input.p2.x - input.p1.x) * this.m_quantizationFactor.x;
        var dy = (input.p2.y - input.p1.y) * this.m_quantizationFactor.y;
        var sx = dx < -Number.MIN_VALUE ? -1 : dx > Number.MIN_VALUE ? 1 : 0;
        var sy = dy < -Number.MIN_VALUE ? -1 : dy > Number.MIN_VALUE ? 1 : 0;
        var p1x = this.m_quantizationFactor.x * (input.p1.x - this.m_worldAABB.lowerBound.x);
        var p1y = this.m_quantizationFactor.y * (input.p1.y - this.m_worldAABB.lowerBound.y);
        var startValues = new Array;
        var startValues2 = new Array;
        startValues[0] = parseInt(p1x) & b2Settings.USHRT_MAX - 1;
        startValues[1] = parseInt(p1y) & b2Settings.USHRT_MAX - 1;
        startValues2[0] = startValues[0] + 1;
        startValues2[1] = startValues[1] + 1;
        var startIndices = new Array;
        var xIndex = 0;
        var yIndex = 0;
        var proxy;
        var lowerIndex = 0;
        var upperIndex = 0;
        var lowerIndexOut = new Array;
        lowerIndexOut.push(lowerIndex);
        var upperIndexOut = new Array;
        upperIndexOut.push(upperIndex);
        this.QueryAxis(lowerIndexOut, upperIndexOut, startValues[0], startValues2[0], this.m_bounds[0], 2 * this.m_proxyCount, 0);
        if (sx >= 0) xIndex = upperIndexOut[0] - 1;
        else xIndex = lowerIndexOut[0];
        this.QueryAxis(lowerIndexOut, upperIndexOut, startValues[1], startValues2[1], this.m_bounds[1], 2 * this.m_proxyCount, 1);
        if (sy >= 0) yIndex = upperIndexOut[0] - 1;
        else yIndex = lowerIndexOut[0];
        for (var i = 0; i < this.m_queryResultCount; i++) {
            subInput.maxFraction = callback(this.m_queryResults[i], subInput)
        }
        for (;;) {
            var xProgress = 0;
            var yProgress = 0;
            xIndex += sx >= 0 ? 1 : -1;
            if (xIndex < 0 || xIndex >= this.m_proxyCount * 2) break;
            if (sx != 0) {
                xProgress = (this.m_bounds[0][xIndex].value - p1x) / dx
            }
            yIndex += sy >= 0 ? 1 : -1;
            if (yIndex < 0 || yIndex >= this.m_proxyCount * 2) break;
            if (sy != 0) {
                yProgress = (this.m_bounds[1][yIndex].value - p1y) / dy
            }
            for (;;) {
                if (sy == 0 || sx != 0 && xProgress < yProgress) {
                    if (xProgress > subInput.maxFraction) break;
                    if (sx > 0 ? this.m_bounds[0][xIndex].IsLower() : this.m_bounds[0][xIndex].IsUpper()) {
                        proxy = this.m_bounds[0][xIndex].proxy;
                        if (sy >= 0) {
                            if (proxy.lowerBounds[1] <= yIndex - 1 && proxy.upperBounds[1] >= yIndex) {
                                subInput.maxFraction = callback(proxy, subInput)
                            }
                        } else {
                            if (proxy.lowerBounds[1] <= yIndex && proxy.upperBounds[1] >= yIndex + 1) {
                                subInput.maxFraction = callback(proxy, subInput)
                            }
                        }
                    }
                    if (subInput.maxFraction == 0) break;
                    if (sx > 0) {
                        xIndex++;
                        if (xIndex == this.m_proxyCount * 2) break
                    } else {
                        xIndex--;
                        if (xIndex < 0) break
                    }
                    xProgress = (this.m_bounds[0][xIndex].value - p1x) / dx
                } else {
                    if (yProgress > subInput.maxFraction) break;
                    if (sy > 0 ? this.m_bounds[1][yIndex].IsLower() : this.m_bounds[1][yIndex].IsUpper()) {
                        proxy = this.m_bounds[1][yIndex].proxy;
                        if (sx >= 0) {
                            if (proxy.lowerBounds[0] <= xIndex - 1 && proxy.upperBounds[0] >= xIndex) {
                                subInput.maxFraction = callback(proxy, subInput)
                            }
                        } else {
                            if (proxy.lowerBounds[0] <= xIndex && proxy.upperBounds[0] >= xIndex + 1) {
                                subInput.maxFraction = callback(proxy, subInput)
                            }
                        }
                    }
                    if (subInput.maxFraction == 0) break;
                    if (sy > 0) {
                        yIndex++;
                        if (yIndex == this.m_proxyCount * 2) break
                    } else {
                        yIndex--;
                        if (yIndex < 0) break
                    }
                    yProgress = (this.m_bounds[1][yIndex].value - p1y) / dy
                }
            }
            break
        }
        this.m_queryResultCount = 0;
        this.IncrementTimeStamp();
        return
    };
    b2BroadPhase.prototype.TestOverlapBound = function(b, p) {
        for (var axis = 0; axis < 2; ++axis) {
            var bounds = this.m_bounds[axis];
            var bound = bounds[p.upperBounds[axis]];
            if (b.lowerValues[axis] > bound.value) return false;
            bound = bounds[p.lowerBounds[axis]];
            if (b.upperValues[axis] < bound.value) return false
        }
        return true
    };
    b2BroadPhase.prototype.m_pairManager = new b2PairManager;
    b2BroadPhase.prototype.m_proxyPool = new Array;
    b2BroadPhase.prototype.m_freeProxy = null;
    b2BroadPhase.prototype.m_bounds = null;
    b2BroadPhase.prototype.m_querySortKeys = new Array;
    b2BroadPhase.prototype.m_queryResults = new Array;
    b2BroadPhase.prototype.m_queryResultCount = 0;
    b2BroadPhase.prototype.m_worldAABB = null;
    b2BroadPhase.prototype.m_quantizationFactor = new b2Vec2;
    b2BroadPhase.prototype.m_proxyCount = 0;
    b2BroadPhase.prototype.m_timeStamp = 0;
    var b2Manifold = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2Manifold.prototype.__constructor = function() {
        this.m_points = new Array(b2Settings.b2_maxManifoldPoints);
        for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
            this.m_points[i] = new b2ManifoldPoint
        }
        this.m_localPlaneNormal = new b2Vec2;
        this.m_localPoint = new b2Vec2
    };
    b2Manifold.prototype.__varz = function() {};
    b2Manifold.e_circles = 1;
    b2Manifold.e_faceA = 2;
    b2Manifold.e_faceB = 4;
    b2Manifold.prototype.Reset = function() {
        for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
            this.m_points[i].Reset()
        }
        this.m_localPlaneNormal.SetZero();
        this.m_localPoint.SetZero();
        this.m_type = 0;
        this.m_pointCount = 0
    };
    b2Manifold.prototype.Set = function(m) {
        this.m_pointCount = m.m_pointCount;
        for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
            this.m_points[i].Set(m.m_points[i])
        }
        this.m_localPlaneNormal.SetV(m.m_localPlaneNormal);
        this.m_localPoint.SetV(m.m_localPoint);
        this.m_type = m.m_type
    };
    b2Manifold.prototype.Copy = function() {
        var copy = new b2Manifold;
        copy.Set(this);
        return copy
    };
    b2Manifold.prototype.m_points = null;
    b2Manifold.prototype.m_localPlaneNormal = null;
    b2Manifold.prototype.m_localPoint = null;
    b2Manifold.prototype.m_type = 0;
    b2Manifold.prototype.m_pointCount = 0;
    var b2CircleShape = function() {
        b2Shape.prototype.__varz.call(this);
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    extend(b2CircleShape.prototype, b2Shape.prototype);
    b2CircleShape.prototype._super = b2Shape.prototype;
    b2CircleShape.prototype.__constructor = function(radius) {
        this._super.__constructor.apply(this, []);
        this.m_type = b2Shape.e_circleShape;
        this.m_radius = radius
    };
    b2CircleShape.prototype.__varz = function() {
        this.m_p = new b2Vec2
    };
    b2CircleShape.prototype.Copy = function() {
        var s = new b2CircleShape;
        s.Set(this);
        return s
    };
    b2CircleShape.prototype.Set = function(other) {
        this._super.Set.apply(this, [other]);
        if (isInstanceOf(other, b2CircleShape)) {
            var other2 = other;
            this.m_p.SetV(other2.m_p)
        }
    };
    b2CircleShape.prototype.TestPoint = function(transform, p) {
        var tMat = transform.R;
        var dX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
        var dY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
        dX = p.x - dX;
        dY = p.y - dY;
        return dX * dX + dY * dY <= this.m_radius * this.m_radius
    };
    b2CircleShape.prototype.RayCast = function(output, input, transform) {
        var tMat = transform.R;
        var positionX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
        var positionY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
        var sX = input.p1.x - positionX;
        var sY = input.p1.y - positionY;
        var b = sX * sX + sY * sY - this.m_radius * this.m_radius;
        var rX = input.p2.x - input.p1.x;
        var rY = input.p2.y - input.p1.y;
        var c = sX * rX + sY * rY;
        var rr = rX * rX + rY * rY;
        var sigma = c * c - rr * b;
        if (sigma < 0 || rr < Number.MIN_VALUE) {
            return false
        }
        var a = -(c + Math.sqrt(sigma));
        if (0 <= a && a <= input.maxFraction * rr) {
            a /= rr;
            output.fraction = a;
            output.normal.x = sX + a * rX;
            output.normal.y = sY + a * rY;
            output.normal.Normalize();
            return true
        }
        return false
    };
    b2CircleShape.prototype.ComputeAABB = function(aabb, transform) {
        var tMat = transform.R;
        var pX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
        var pY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
        aabb.lowerBound.Set(pX - this.m_radius, pY - this.m_radius);
        aabb.upperBound.Set(pX + this.m_radius, pY + this.m_radius)
    };
    b2CircleShape.prototype.ComputeMass = function(massData, density) {
        massData.mass = density * b2Settings.b2_pi * this.m_radius * this.m_radius;
        massData.center.SetV(this.m_p);
        massData.I = massData.mass * (.5 * this.m_radius * this.m_radius + (this.m_p.x * this.m_p.x + this.m_p.y * this.m_p.y))
    };
    b2CircleShape.prototype.ComputeSubmergedArea = function(normal, offset, xf, c) {
        var p = b2Math.MulX(xf, this.m_p);
        var l = -(b2Math.Dot(normal, p) - offset);
        if (l < -this.m_radius + Number.MIN_VALUE) {
            return 0
        }
        if (l > this.m_radius) {
            c.SetV(p);
            return Math.PI * this.m_radius * this.m_radius
        }
        var r2 = this.m_radius * this.m_radius;
        var l2 = l * l;
        var area = r2 * (Math.asin(l / this.m_radius) + Math.PI / 2) + l * Math.sqrt(r2 - l2);
        var com = -2 / 3 * Math.pow(r2 - l2, 1.5) / area;
        c.x = p.x + normal.x * com;
        c.y = p.y + normal.y * com;
        return area
    };
    b2CircleShape.prototype.GetLocalPosition = function() {
        return this.m_p
    };
    b2CircleShape.prototype.SetLocalPosition = function(position) {
        this.m_p.SetV(position)
    };
    b2CircleShape.prototype.GetRadius = function() {
        return this.m_radius
    };
    b2CircleShape.prototype.SetRadius = function(radius) {
        this.m_radius = radius
    };
    b2CircleShape.prototype.m_p = new b2Vec2;
    var b2Joint = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2Joint.prototype.__constructor = function(def) {
        b2Settings.b2Assert(def.bodyA != def.bodyB);
        this.m_type = def.type;
        this.m_prev = null;
        this.m_next = null;
        this.m_bodyA = def.bodyA;
        this.m_bodyB = def.bodyB;
        this.m_collideConnected = def.collideConnected;
        this.m_islandFlag = false;
        this.m_userData = def.userData
    };
    b2Joint.prototype.__varz = function() {
        this.m_edgeA = new b2JointEdge;
        this.m_edgeB = new b2JointEdge;
        this.m_localCenterA = new b2Vec2;
        this.m_localCenterB = new b2Vec2
    };
    b2Joint.Create = function(def, allocator) {
        var joint = null;
        switch (def.type) {
            case b2Joint.e_distanceJoint:
                {
                    joint = new b2DistanceJoint(def)
                }
                break;
            case b2Joint.e_mouseJoint:
                {
                    joint = new b2MouseJoint(def)
                }
                break;
            case b2Joint.e_prismaticJoint:
                {
                    joint = new b2PrismaticJoint(def)
                }
                break;
            case b2Joint.e_revoluteJoint:
                {
                    joint = new b2RevoluteJoint(def)
                }
                break;
            case b2Joint.e_pulleyJoint:
                {
                    joint = new b2PulleyJoint(def)
                }
                break;
            case b2Joint.e_gearJoint:
                {
                    joint = new b2GearJoint(def)
                }
                break;
            case b2Joint.e_lineJoint:
                {
                    joint = new b2LineJoint(def)
                }
                break;
            case b2Joint.e_weldJoint:
                {
                    joint = new b2WeldJoint(def)
                }
                break;
            case b2Joint.e_frictionJoint:
                {
                    joint = new b2FrictionJoint(def)
                }
                break;
            case b2Joint.e_ropeJoint:
                {
                    joint = new b2RopeJoint(def)
                }
                break;
            default:
                break
        }
        return joint
    };
    b2Joint.Destroy = function(joint, allocator) {};
    b2Joint.e_unknownJoint = 0;
    b2Joint.e_revoluteJoint = 1;
    b2Joint.e_prismaticJoint = 2;
    b2Joint.e_distanceJoint = 3;
    b2Joint.e_pulleyJoint = 4;
    b2Joint.e_mouseJoint = 5;
    b2Joint.e_gearJoint = 6;
    b2Joint.e_lineJoint = 7;
    b2Joint.e_weldJoint = 8;
    b2Joint.e_frictionJoint = 9;
    b2Joint.e_ropeJoint = 10;
    b2Joint.e_inactiveLimit = 0;
    b2Joint.e_atLowerLimit = 1;
    b2Joint.e_atUpperLimit = 2;
    b2Joint.e_equalLimits = 3;
    b2Joint.prototype.InitVelocityConstraints = function(step) {};
    b2Joint.prototype.SolveVelocityConstraints = function(step) {};
    b2Joint.prototype.FinalizeVelocityConstraints = function() {};
    b2Joint.prototype.SolvePositionConstraints = function(baumgarte) {
        return false
    };
    b2Joint.prototype.GetType = function() {
        return this.m_type
    };
    b2Joint.prototype.GetAnchorA = function() {
        return null
    };
    b2Joint.prototype.GetAnchorB = function() {
        return null
    };
    b2Joint.prototype.GetReactionForce = function(inv_dt) {
        return null
    };
    b2Joint.prototype.GetReactionTorque = function(inv_dt) {
        return 0
    };
    b2Joint.prototype.GetBodyA = function() {
        return this.m_bodyA
    };
    b2Joint.prototype.GetBodyB = function() {
        return this.m_bodyB
    };
    b2Joint.prototype.GetNext = function() {
        return this.m_next
    };
    b2Joint.prototype.GetUserData = function() {
        return this.m_userData
    };
    b2Joint.prototype.SetUserData = function(data) {
        this.m_userData = data
    };
    b2Joint.prototype.IsActive = function() {
        return this.m_bodyA.IsActive() && this.m_bodyB.IsActive()
    };
    b2Joint.prototype.m_type = 0;
    b2Joint.prototype.m_prev = null;
    b2Joint.prototype.m_next = null;
    b2Joint.prototype.m_edgeA = new b2JointEdge;
    b2Joint.prototype.m_edgeB = new b2JointEdge;
    b2Joint.prototype.m_bodyA = null;
    b2Joint.prototype.m_bodyB = null;
    b2Joint.prototype.m_islandFlag = null;
    b2Joint.prototype.m_collideConnected = null;
    b2Joint.prototype.m_userData = null;
    b2Joint.prototype.m_localCenterA = new b2Vec2;
    b2Joint.prototype.m_localCenterB = new b2Vec2;
    b2Joint.prototype.m_invMassA = null;
    b2Joint.prototype.m_invMassB = null;
    b2Joint.prototype.m_invIA = null;
    b2Joint.prototype.m_invIB = null;
    var b2LineJoint = function() {
        b2Joint.prototype.__varz.call(this);
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    extend(b2LineJoint.prototype, b2Joint.prototype);
    b2LineJoint.prototype._super = b2Joint.prototype;
    b2LineJoint.prototype.__constructor = function(def) {
        this._super.__constructor.apply(this, [def]);
        var tMat;
        var tX;
        var tY;
        this.m_localAnchor1.SetV(def.localAnchorA);
        this.m_localAnchor2.SetV(def.localAnchorB);
        this.m_localXAxis1.SetV(def.localAxisA);
        this.m_localYAxis1.x = -this.m_localXAxis1.y;
        this.m_localYAxis1.y = this.m_localXAxis1.x;
        this.m_impulse.SetZero();
        this.m_motorMass = 0;
        this.m_motorImpulse = 0;
        this.m_lowerTranslation = def.lowerTranslation;
        this.m_upperTranslation = def.upperTranslation;
        this.m_maxMotorForce = def.maxMotorForce;
        this.m_motorSpeed = def.motorSpeed;
        this.m_enableLimit = def.enableLimit;
        this.m_enableMotor = def.enableMotor;
        this.m_limitState = b2Joint.e_inactiveLimit;
        this.m_axis.SetZero();
        this.m_perp.SetZero()
    };
    b2LineJoint.prototype.__varz = function() {
        this.m_localAnchor1 = new b2Vec2;
        this.m_localAnchor2 = new b2Vec2;
        this.m_localXAxis1 = new b2Vec2;
        this.m_localYAxis1 = new b2Vec2;
        this.m_axis = new b2Vec2;
        this.m_perp = new b2Vec2;
        this.m_K = new b2Mat22;
        this.m_impulse = new b2Vec2
    };
    b2LineJoint.prototype.InitVelocityConstraints = function(step) {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        var tX;
        this.m_localCenterA.SetV(bA.GetLocalCenter());
        this.m_localCenterB.SetV(bB.GetLocalCenter());
        var xf1 = bA.GetTransform();
        var xf2 = bB.GetTransform();
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
        var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
        tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
        r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
        var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
        tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
        r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
        r2X = tX;
        var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
        var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
        this.m_invMassA = bA.m_invMass;
        this.m_invMassB = bB.m_invMass;
        this.m_invIA = bA.m_invI;
        this.m_invIB = bB.m_invI; {
            this.m_axis.SetV(b2Math.MulMV(xf1.R, this.m_localXAxis1));
            this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
            this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
            this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
            this.m_motorMass = this.m_motorMass > Number.MIN_VALUE ? 1 / this.m_motorMass : 0
        } {
            this.m_perp.SetV(b2Math.MulMV(xf1.R, this.m_localYAxis1));
            this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
            this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
            var m1 = this.m_invMassA;
            var m2 = this.m_invMassB;
            var i1 = this.m_invIA;
            var i2 = this.m_invIB;
            this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
            this.m_K.col1.y = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
            this.m_K.col2.x = this.m_K.col1.y;
            this.m_K.col2.y = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2
        }
        if (this.m_enableLimit) {
            var jointTransition = this.m_axis.x * dX + this.m_axis.y * dY;
            if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b2Settings.b2_linearSlop) {
                this.m_limitState = b2Joint.e_equalLimits
            } else if (jointTransition <= this.m_lowerTranslation) {
                if (this.m_limitState != b2Joint.e_atLowerLimit) {
                    this.m_limitState = b2Joint.e_atLowerLimit;
                    this.m_impulse.y = 0
                }
            } else if (jointTransition >= this.m_upperTranslation) {
                if (this.m_limitState != b2Joint.e_atUpperLimit) {
                    this.m_limitState = b2Joint.e_atUpperLimit;
                    this.m_impulse.y = 0
                }
            } else {
                this.m_limitState = b2Joint.e_inactiveLimit;
                this.m_impulse.y = 0
            }
        } else {
            this.m_limitState = b2Joint.e_inactiveLimit
        }
        if (this.m_enableMotor == false) {
            this.m_motorImpulse = 0
        }
        if (step.warmStarting) {
            this.m_impulse.x *= step.dtRatio;
            this.m_impulse.y *= step.dtRatio;
            this.m_motorImpulse *= step.dtRatio;
            var PX = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x;
            var PY = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y;
            var L1 = this.m_impulse.x * this.m_s1 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a1;
            var L2 = this.m_impulse.x * this.m_s2 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a2;
            bA.m_linearVelocity.x -= this.m_invMassA * PX;
            bA.m_linearVelocity.y -= this.m_invMassA * PY;
            bA.m_angularVelocity -= this.m_invIA * L1;
            bB.m_linearVelocity.x += this.m_invMassB * PX;
            bB.m_linearVelocity.y += this.m_invMassB * PY;
            bB.m_angularVelocity += this.m_invIB * L2
        } else {
            this.m_impulse.SetZero();
            this.m_motorImpulse = 0
        }
    };
    b2LineJoint.prototype.SolveVelocityConstraints = function(step) {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var v1 = bA.m_linearVelocity;
        var w1 = bA.m_angularVelocity;
        var v2 = bB.m_linearVelocity;
        var w2 = bB.m_angularVelocity;
        var PX;
        var PY;
        var L1;
        var L2;
        if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
            var Cdot = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
            var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
            var oldImpulse = this.m_motorImpulse;
            var maxImpulse = step.dt * this.m_maxMotorForce;
            this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
            impulse = this.m_motorImpulse - oldImpulse;
            PX = impulse * this.m_axis.x;
            PY = impulse * this.m_axis.y;
            L1 = impulse * this.m_a1;
            L2 = impulse * this.m_a2;
            v1.x -= this.m_invMassA * PX;
            v1.y -= this.m_invMassA * PY;
            w1 -= this.m_invIA * L1;
            v2.x += this.m_invMassB * PX;
            v2.y += this.m_invMassB * PY;
            w2 += this.m_invIB * L2
        }
        var Cdot1 = this.m_perp.x * (v2.x - v1.x) + this.m_perp.y * (v2.y - v1.y) + this.m_s2 * w2 - this.m_s1 * w1;
        if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
            var Cdot2 = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
            var f1 = this.m_impulse.Copy();
            var df = this.m_K.Solve(new b2Vec2, -Cdot1, -Cdot2);
            this.m_impulse.Add(df);
            if (this.m_limitState == b2Joint.e_atLowerLimit) {
                this.m_impulse.y = b2Math.Max(this.m_impulse.y, 0)
            } else if (this.m_limitState == b2Joint.e_atUpperLimit) {
                this.m_impulse.y = b2Math.Min(this.m_impulse.y, 0)
            }
            var b = -Cdot1 - (this.m_impulse.y - f1.y) * this.m_K.col2.x;
            var f2r;
            if (this.m_K.col1.x != 0) {
                f2r = b / this.m_K.col1.x + f1.x
            } else {
                f2r = f1.x
            }
            this.m_impulse.x = f2r;
            df.x = this.m_impulse.x - f1.x;
            df.y = this.m_impulse.y - f1.y;
            PX = df.x * this.m_perp.x + df.y * this.m_axis.x;
            PY = df.x * this.m_perp.y + df.y * this.m_axis.y;
            L1 = df.x * this.m_s1 + df.y * this.m_a1;
            L2 = df.x * this.m_s2 + df.y * this.m_a2;
            v1.x -= this.m_invMassA * PX;
            v1.y -= this.m_invMassA * PY;
            w1 -= this.m_invIA * L1;
            v2.x += this.m_invMassB * PX;
            v2.y += this.m_invMassB * PY;
            w2 += this.m_invIB * L2
        } else {
            var df2;
            if (this.m_K.col1.x != 0) {
                df2 = -Cdot1 / this.m_K.col1.x
            } else {
                df2 = 0
            }
            this.m_impulse.x += df2;
            PX = df2 * this.m_perp.x;
            PY = df2 * this.m_perp.y;
            L1 = df2 * this.m_s1;
            L2 = df2 * this.m_s2;
            v1.x -= this.m_invMassA * PX;
            v1.y -= this.m_invMassA * PY;
            w1 -= this.m_invIA * L1;
            v2.x += this.m_invMassB * PX;
            v2.y += this.m_invMassB * PY;
            w2 += this.m_invIB * L2
        }
        bA.m_linearVelocity.SetV(v1);
        bA.m_angularVelocity = w1;
        bB.m_linearVelocity.SetV(v2);
        bB.m_angularVelocity = w2
    };
    b2LineJoint.prototype.SolvePositionConstraints = function(baumgarte) {
        var limitC;
        var oldLimitImpulse;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var c1 = bA.m_sweep.c;
        var a1 = bA.m_sweep.a;
        var c2 = bB.m_sweep.c;
        var a2 = bB.m_sweep.a;
        var tMat;
        var tX;
        var m1;
        var m2;
        var i1;
        var i2;
        var linearError = 0;
        var angularError = 0;
        var active = false;
        var C2 = 0;
        var R1 = b2Mat22.FromAngle(a1);
        var R2 = b2Mat22.FromAngle(a2);
        tMat = R1;
        var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
        var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
        tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
        r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
        r1X = tX;
        tMat = R2;
        var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
        var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
        tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
        r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
        r2X = tX;
        var dX = c2.x + r2X - c1.x - r1X;
        var dY = c2.y + r2Y - c1.y - r1Y;
        if (this.m_enableLimit) {
            this.m_axis = b2Math.MulMV(R1, this.m_localXAxis1);
            this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
            this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
            var translation = this.m_axis.x * dX + this.m_axis.y * dY;
            if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b2Settings.b2_linearSlop) {
                C2 = b2Math.Clamp(translation, -b2Settings.b2_maxLinearCorrection, b2Settings.b2_maxLinearCorrection);
                linearError = b2Math.Abs(translation);
                active = true
            } else if (translation <= this.m_lowerTranslation) {
                C2 = b2Math.Clamp(translation - this.m_lowerTranslation + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0);
                linearError = this.m_lowerTranslation - translation;
                active = true
            } else if (translation >= this.m_upperTranslation) {
                C2 = b2Math.Clamp(translation - this.m_upperTranslation + b2Settings.b2_linearSlop, 0, b2Settings.b2_maxLinearCorrection);
                linearError = translation - this.m_upperTranslation;
                active = true
            }
        }
        this.m_perp = b2Math.MulMV(R1, this.m_localYAxis1);
        this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
        this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
        var impulse = new b2Vec2;
        var C1 = this.m_perp.x * dX + this.m_perp.y * dY;
        linearError = b2Math.Max(linearError, b2Math.Abs(C1));
        angularError = 0;
        if (active) {
            m1 = this.m_invMassA;
            m2 = this.m_invMassB;
            i1 = this.m_invIA;
            i2 = this.m_invIB;
            this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
            this.m_K.col1.y = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
            this.m_K.col2.x = this.m_K.col1.y;
            this.m_K.col2.y = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
            this.m_K.Solve(impulse, -C1, -C2)
        } else {
            m1 = this.m_invMassA;
            m2 = this.m_invMassB;
            i1 = this.m_invIA;
            i2 = this.m_invIB;
            var k11 = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
            var impulse1;
            if (k11 != 0) {
                impulse1 = -C1 / k11
            } else {
                impulse1 = 0
            }
            impulse.x = impulse1;
            impulse.y = 0
        }
        var PX = impulse.x * this.m_perp.x + impulse.y * this.m_axis.x;
        var PY = impulse.x * this.m_perp.y + impulse.y * this.m_axis.y;
        var L1 = impulse.x * this.m_s1 + impulse.y * this.m_a1;
        var L2 = impulse.x * this.m_s2 + impulse.y * this.m_a2;
        c1.x -= this.m_invMassA * PX;
        c1.y -= this.m_invMassA * PY;
        a1 -= this.m_invIA * L1;
        c2.x += this.m_invMassB * PX;
        c2.y += this.m_invMassB * PY;
        a2 += this.m_invIB * L2;
        bA.m_sweep.a = a1;
        bB.m_sweep.a = a2;
        bA.SynchronizeTransform();
        bB.SynchronizeTransform();
        return linearError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop
    };
    b2LineJoint.prototype.GetAnchorA = function() {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
    };
    b2LineJoint.prototype.GetAnchorB = function() {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
    };
    b2LineJoint.prototype.GetReactionForce = function(inv_dt) {
        return new b2Vec2(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y))
    };
    b2LineJoint.prototype.GetReactionTorque = function(inv_dt) {
        return inv_dt * this.m_impulse.y
    };
    b2LineJoint.prototype.GetJointTranslation = function() {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        var p1 = bA.GetWorldPoint(this.m_localAnchor1);
        var p2 = bB.GetWorldPoint(this.m_localAnchor2);
        var dX = p2.x - p1.x;
        var dY = p2.y - p1.y;
        var axis = bA.GetWorldVector(this.m_localXAxis1);
        var translation = axis.x * dX + axis.y * dY;
        return translation
    };
    b2LineJoint.prototype.GetJointSpeed = function() {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
        var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
        var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
        r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
        var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
        tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
        r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
        r2X = tX;
        var p1X = bA.m_sweep.c.x + r1X;
        var p1Y = bA.m_sweep.c.y + r1Y;
        var p2X = bB.m_sweep.c.x + r2X;
        var p2Y = bB.m_sweep.c.y + r2Y;
        var dX = p2X - p1X;
        var dY = p2Y - p1Y;
        var axis = bA.GetWorldVector(this.m_localXAxis1);
        var v1 = bA.m_linearVelocity;
        var v2 = bB.m_linearVelocity;
        var w1 = bA.m_angularVelocity;
        var w2 = bB.m_angularVelocity;
        var speed = dX * (-w1 * axis.y) + dY * (w1 * axis.x) + (axis.x * (v2.x + -w2 * r2Y - v1.x - -w1 * r1Y) + axis.y * (v2.y + w2 * r2X - v1.y - w1 * r1X));
        return speed
    };
    b2LineJoint.prototype.IsLimitEnabled = function() {
        return this.m_enableLimit
    };
    b2LineJoint.prototype.EnableLimit = function(flag) {
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_enableLimit = flag
    };
    b2LineJoint.prototype.GetLowerLimit = function() {
        return this.m_lowerTranslation
    };
    b2LineJoint.prototype.GetUpperLimit = function() {
        return this.m_upperTranslation
    };
    b2LineJoint.prototype.SetLimits = function(lower, upper) {
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_lowerTranslation = lower;
        this.m_upperTranslation = upper
    };
    b2LineJoint.prototype.IsMotorEnabled = function() {
        return this.m_enableMotor
    };
    b2LineJoint.prototype.EnableMotor = function(flag) {
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_enableMotor = flag
    };
    b2LineJoint.prototype.SetMotorSpeed = function(speed) {
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_motorSpeed = speed
    };
    b2LineJoint.prototype.GetMotorSpeed = function() {
        return this.m_motorSpeed
    };
    b2LineJoint.prototype.SetMaxMotorForce = function(force) {
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_maxMotorForce = force
    };
    b2LineJoint.prototype.GetMaxMotorForce = function() {
        return this.m_maxMotorForce
    };
    b2LineJoint.prototype.GetMotorForce = function() {
        return this.m_motorImpulse
    };
    b2LineJoint.prototype.m_localAnchor1 = new b2Vec2;
    b2LineJoint.prototype.m_localAnchor2 = new b2Vec2;
    b2LineJoint.prototype.m_localXAxis1 = new b2Vec2;
    b2LineJoint.prototype.m_localYAxis1 = new b2Vec2;
    b2LineJoint.prototype.m_axis = new b2Vec2;
    b2LineJoint.prototype.m_perp = new b2Vec2;
    b2LineJoint.prototype.m_s1 = null;
    b2LineJoint.prototype.m_s2 = null;
    b2LineJoint.prototype.m_a1 = null;
    b2LineJoint.prototype.m_a2 = null;
    b2LineJoint.prototype.m_K = new b2Mat22;
    b2LineJoint.prototype.m_impulse = new b2Vec2;
    b2LineJoint.prototype.m_motorMass = null;
    b2LineJoint.prototype.m_motorImpulse = null;
    b2LineJoint.prototype.m_lowerTranslation = null;
    b2LineJoint.prototype.m_upperTranslation = null;
    b2LineJoint.prototype.m_maxMotorForce = null;
    b2LineJoint.prototype.m_motorSpeed = null;
    b2LineJoint.prototype.m_enableLimit = null;
    b2LineJoint.prototype.m_enableMotor = null;
    b2LineJoint.prototype.m_limitState = 0;
    var b2ContactSolver = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2ContactSolver.prototype.__constructor = function() {};
    b2ContactSolver.prototype.__varz = function() {
        this.m_step = new b2TimeStep;
        this.m_constraints = new Array
    };
    b2ContactSolver.s_worldManifold = new b2WorldManifold;
    b2ContactSolver.s_psm = new b2PositionSolverManifold;
    b2ContactSolver.prototype.Initialize = function(step, contacts, contactCount, allocator) {
        var contact;
        this.m_step.Set(step);
        this.m_allocator = allocator;
        var i = 0;
        var tVec;
        var tMat;
        this.m_constraintCount = contactCount;
        while (this.m_constraints.length < this.m_constraintCount) {
            this.m_constraints[this.m_constraints.length] = new b2ContactConstraint
        }
        for (i = 0; i < contactCount; ++i) {
            contact = contacts[i];
            var fixtureA = contact.m_fixtureA;
            var fixtureB = contact.m_fixtureB;
            var shapeA = fixtureA.m_shape;
            var shapeB = fixtureB.m_shape;
            var radiusA = shapeA.m_radius;
            var radiusB = shapeB.m_radius;
            var bodyA = fixtureA.m_body;
            var bodyB = fixtureB.m_body;
            var manifold = contact.GetManifold();
            var friction = b2Settings.b2MixFriction(fixtureA.GetFriction(), fixtureB.GetFriction());
            var restitution = b2Settings.b2MixRestitution(fixtureA.GetRestitution(), fixtureB.GetRestitution());
            var vAX = bodyA.m_linearVelocity.x;
            var vAY = bodyA.m_linearVelocity.y;
            var vBX = bodyB.m_linearVelocity.x;
            var vBY = bodyB.m_linearVelocity.y;
            var wA = bodyA.m_angularVelocity;
            var wB = bodyB.m_angularVelocity;
            b2Settings.b2Assert(manifold.m_pointCount > 0);
            b2ContactSolver.s_worldManifold.Initialize(manifold, bodyA.m_xf, radiusA, bodyB.m_xf, radiusB);
            var normalX = b2ContactSolver.s_worldManifold.m_normal.x;
            var normalY = b2ContactSolver.s_worldManifold.m_normal.y;
            var cc = this.m_constraints[i];
            cc.bodyA = bodyA;
            cc.bodyB = bodyB;
            cc.manifold = manifold;
            cc.normal.x = normalX;
            cc.normal.y = normalY;
            cc.pointCount = manifold.m_pointCount;
            cc.friction = friction;
            cc.restitution = restitution;
            cc.localPlaneNormal.x = manifold.m_localPlaneNormal.x;
            cc.localPlaneNormal.y = manifold.m_localPlaneNormal.y;
            cc.localPoint.x = manifold.m_localPoint.x;
            cc.localPoint.y = manifold.m_localPoint.y;
            cc.radius = radiusA + radiusB;
            cc.type = manifold.m_type;
            for (var k = 0; k < cc.pointCount; ++k) {
                var cp = manifold.m_points[k];
                var ccp = cc.points[k];
                ccp.normalImpulse = cp.m_normalImpulse;
                ccp.tangentImpulse = cp.m_tangentImpulse;
                ccp.localPoint.SetV(cp.m_localPoint);
                var rAX = ccp.rA.x = b2ContactSolver.s_worldManifold.m_points[k].x - bodyA.m_sweep.c.x;
                var rAY = ccp.rA.y = b2ContactSolver.s_worldManifold.m_points[k].y - bodyA.m_sweep.c.y;
                var rBX = ccp.rB.x = b2ContactSolver.s_worldManifold.m_points[k].x - bodyB.m_sweep.c.x;
                var rBY = ccp.rB.y = b2ContactSolver.s_worldManifold.m_points[k].y - bodyB.m_sweep.c.y;
                var rnA = rAX * normalY - rAY * normalX;
                var rnB = rBX * normalY - rBY * normalX;
                rnA *= rnA;
                rnB *= rnB;
                var kNormal = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rnA + bodyB.m_invI * rnB;
                ccp.normalMass = 1 / kNormal;
                var kEqualized = bodyA.m_mass * bodyA.m_invMass + bodyB.m_mass * bodyB.m_invMass;
                kEqualized += bodyA.m_mass * bodyA.m_invI * rnA + bodyB.m_mass * bodyB.m_invI * rnB;
                ccp.equalizedMass = 1 / kEqualized;
                var tangentX = normalY;
                var tangentY = -normalX;
                var rtA = rAX * tangentY - rAY * tangentX;
                var rtB = rBX * tangentY - rBY * tangentX;
                rtA *= rtA;
                rtB *= rtB;
                var kTangent = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rtA + bodyB.m_invI * rtB;
                ccp.tangentMass = 1 / kTangent;
                ccp.velocityBias = 0;
                var tX = vBX + -wB * rBY - vAX - -wA * rAY;
                var tY = vBY + wB * rBX - vAY - wA * rAX;
                var vRel = cc.normal.x * tX + cc.normal.y * tY;
                if (vRel < -b2Settings.b2_velocityThreshold) {
                    ccp.velocityBias += -cc.restitution * vRel
                }
            }
            if (cc.pointCount == 2) {
                var ccp1 = cc.points[0];
                var ccp2 = cc.points[1];
                var invMassA = bodyA.m_invMass;
                var invIA = bodyA.m_invI;
                var invMassB = bodyB.m_invMass;
                var invIB = bodyB.m_invI;
                var rn1A = ccp1.rA.x * normalY - ccp1.rA.y * normalX;
                var rn1B = ccp1.rB.x * normalY - ccp1.rB.y * normalX;
                var rn2A = ccp2.rA.x * normalY - ccp2.rA.y * normalX;
                var rn2B = ccp2.rB.x * normalY - ccp2.rB.y * normalX;
                var k11 = invMassA + invMassB + invIA * rn1A * rn1A + invIB * rn1B * rn1B;
                var k22 = invMassA + invMassB + invIA * rn2A * rn2A + invIB * rn2B * rn2B;
                var k12 = invMassA + invMassB + invIA * rn1A * rn2A + invIB * rn1B * rn2B;
                var k_maxConditionNumber = 100;
                if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {
                    cc.K.col1.Set(k11, k12);
                    cc.K.col2.Set(k12, k22);
                    cc.K.GetInverse(cc.normalMass)
                } else {
                    cc.pointCount = 1
                }
            }
        }
    };
    b2ContactSolver.prototype.InitVelocityConstraints = function(step) {
        var tVec;
        var tVec2;
        var tMat;
        for (var i = 0; i < this.m_constraintCount; ++i) {
            var c = this.m_constraints[i];
            var bodyA = c.bodyA;
            var bodyB = c.bodyB;
            var invMassA = bodyA.m_invMass;
            var invIA = bodyA.m_invI;
            var invMassB = bodyB.m_invMass;
            var invIB = bodyB.m_invI;
            var normalX = c.normal.x;
            var normalY = c.normal.y;
            var tangentX = normalY;
            var tangentY = -normalX;
            var tX;
            var j = 0;
            var tCount = 0;
            if (step.warmStarting) {
                tCount = c.pointCount;
                for (j = 0; j < tCount; ++j) {
                    var ccp = c.points[j];
                    ccp.normalImpulse *= step.dtRatio;
                    ccp.tangentImpulse *= step.dtRatio;
                    var PX = ccp.normalImpulse * normalX + ccp.tangentImpulse * tangentX;
                    var PY = ccp.normalImpulse * normalY + ccp.tangentImpulse * tangentY;
                    bodyA.m_angularVelocity -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
                    bodyA.m_linearVelocity.x -= invMassA * PX;
                    bodyA.m_linearVelocity.y -= invMassA * PY;
                    bodyB.m_angularVelocity += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
                    bodyB.m_linearVelocity.x += invMassB * PX;
                    bodyB.m_linearVelocity.y += invMassB * PY
                }
            } else {
                tCount = c.pointCount;
                for (j = 0; j < tCount; ++j) {
                    var ccp2 = c.points[j];
                    ccp2.normalImpulse = 0;
                    ccp2.tangentImpulse = 0
                }
            }
        }
    };
    b2ContactSolver.prototype.SolveVelocityConstraints = function() {
        var j = 0;
        var ccp;
        var rAX;
        var rAY;
        var rBX;
        var rBY;
        var dvX;
        var dvY;
        var vn;
        var vt;
        var lambda;
        var maxFriction;
        var newImpulse;
        var PX;
        var PY;
        var dX;
        var dY;
        var P1X;
        var P1Y;
        var P2X;
        var P2Y;
        var tMat;
        var tVec;
        for (var i = 0; i < this.m_constraintCount; ++i) {
            var c = this.m_constraints[i];
            var bodyA = c.bodyA;
            var bodyB = c.bodyB;
            var wA = bodyA.m_angularVelocity;
            var wB = bodyB.m_angularVelocity;
            var vA = bodyA.m_linearVelocity;
            var vB = bodyB.m_linearVelocity;
            var invMassA = bodyA.m_invMass;
            var invIA = bodyA.m_invI;
            var invMassB = bodyB.m_invMass;
            var invIB = bodyB.m_invI;
            var normalX = c.normal.x;
            var normalY = c.normal.y;
            var tangentX = normalY;
            var tangentY = -normalX;
            var friction = c.friction;
            var tX;
            for (j = 0; j < c.pointCount; j++) {
                ccp = c.points[j];
                dvX = vB.x - wB * ccp.rB.y - vA.x + wA * ccp.rA.y;
                dvY = vB.y + wB * ccp.rB.x - vA.y - wA * ccp.rA.x;
                vt = dvX * tangentX + dvY * tangentY;
                lambda = ccp.tangentMass * -vt;
                maxFriction = friction * ccp.normalImpulse;
                newImpulse = b2Math.Clamp(ccp.tangentImpulse + lambda, -maxFriction, maxFriction);
                lambda = newImpulse - ccp.tangentImpulse;
                PX = lambda * tangentX;
                PY = lambda * tangentY;
                vA.x -= invMassA * PX;
                vA.y -= invMassA * PY;
                wA -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
                vB.x += invMassB * PX;
                vB.y += invMassB * PY;
                wB += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
                ccp.tangentImpulse = newImpulse
            }
            var tCount = c.pointCount;
            if (c.pointCount == 1) {
                ccp = c.points[0];
                dvX = vB.x + -wB * ccp.rB.y - vA.x - -wA * ccp.rA.y;
                dvY = vB.y + wB * ccp.rB.x - vA.y - wA * ccp.rA.x;
                vn = dvX * normalX + dvY * normalY;
                lambda = -ccp.normalMass * (vn - ccp.velocityBias);
                newImpulse = ccp.normalImpulse + lambda;
                newImpulse = newImpulse > 0 ? newImpulse : 0;
                lambda = newImpulse - ccp.normalImpulse;
                PX = lambda * normalX;
                PY = lambda * normalY;
                vA.x -= invMassA * PX;
                vA.y -= invMassA * PY;
                wA -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
                vB.x += invMassB * PX;
                vB.y += invMassB * PY;
                wB += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
                ccp.normalImpulse = newImpulse
            } else {
                var cp1 = c.points[0];
                var cp2 = c.points[1];
                var aX = cp1.normalImpulse;
                var aY = cp2.normalImpulse;
                var dv1X = vB.x - wB * cp1.rB.y - vA.x + wA * cp1.rA.y;
                var dv1Y = vB.y + wB * cp1.rB.x - vA.y - wA * cp1.rA.x;
                var dv2X = vB.x - wB * cp2.rB.y - vA.x + wA * cp2.rA.y;
                var dv2Y = vB.y + wB * cp2.rB.x - vA.y - wA * cp2.rA.x;
                var vn1 = dv1X * normalX + dv1Y * normalY;
                var vn2 = dv2X * normalX + dv2Y * normalY;
                var bX = vn1 - cp1.velocityBias;
                var bY = vn2 - cp2.velocityBias;
                tMat = c.K;
                bX -= tMat.col1.x * aX + tMat.col2.x * aY;
                bY -= tMat.col1.y * aX + tMat.col2.y * aY;
                var k_errorTol = .001;
                for (;;) {
                    tMat = c.normalMass;
                    var xX = -(tMat.col1.x * bX + tMat.col2.x * bY);
                    var xY = -(tMat.col1.y * bX + tMat.col2.y * bY);
                    if (xX >= 0 && xY >= 0) {
                        dX = xX - aX;
                        dY = xY - aY;
                        P1X = dX * normalX;
                        P1Y = dX * normalY;
                        P2X = dY * normalX;
                        P2Y = dY * normalY;
                        vA.x -= invMassA * (P1X + P2X);
                        vA.y -= invMassA * (P1Y + P2Y);
                        wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                        vB.x += invMassB * (P1X + P2X);
                        vB.y += invMassB * (P1Y + P2Y);
                        wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                        cp1.normalImpulse = xX;
                        cp2.normalImpulse = xY;
                        break
                    }
                    xX = -cp1.normalMass * bX;
                    xY = 0;
                    vn1 = 0;
                    vn2 = c.K.col1.y * xX + bY;
                    if (xX >= 0 && vn2 >= 0) {
                        dX = xX - aX;
                        dY = xY - aY;
                        P1X = dX * normalX;
                        P1Y = dX * normalY;
                        P2X = dY * normalX;
                        P2Y = dY * normalY;
                        vA.x -= invMassA * (P1X + P2X);
                        vA.y -= invMassA * (P1Y + P2Y);
                        wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                        vB.x += invMassB * (P1X + P2X);
                        vB.y += invMassB * (P1Y + P2Y);
                        wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                        cp1.normalImpulse = xX;
                        cp2.normalImpulse = xY;
                        break
                    }
                    xX = 0;
                    xY = -cp2.normalMass * bY;
                    vn1 = c.K.col2.x * xY + bX;
                    vn2 = 0;
                    if (xY >= 0 && vn1 >= 0) {
                        dX = xX - aX;
                        dY = xY - aY;
                        P1X = dX * normalX;
                        P1Y = dX * normalY;
                        P2X = dY * normalX;
                        P2Y = dY * normalY;
                        vA.x -= invMassA * (P1X + P2X);
                        vA.y -= invMassA * (P1Y + P2Y);
                        wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                        vB.x += invMassB * (P1X + P2X);
                        vB.y += invMassB * (P1Y + P2Y);
                        wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                        cp1.normalImpulse = xX;
                        cp2.normalImpulse = xY;
                        break
                    }
                    xX = 0;
                    xY = 0;
                    vn1 = bX;
                    vn2 = bY;
                    if (vn1 >= 0 && vn2 >= 0) {
                        dX = xX - aX;
                        dY = xY - aY;
                        P1X = dX * normalX;
                        P1Y = dX * normalY;
                        P2X = dY * normalX;
                        P2Y = dY * normalY;
                        vA.x -= invMassA * (P1X + P2X);
                        vA.y -= invMassA * (P1Y + P2Y);
                        wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                        vB.x += invMassB * (P1X + P2X);
                        vB.y += invMassB * (P1Y + P2Y);
                        wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                        cp1.normalImpulse = xX;
                        cp2.normalImpulse = xY;
                        break
                    }
                    break
                }
            }
            bodyA.m_angularVelocity = wA;
            bodyB.m_angularVelocity = wB
        }
    };
    b2ContactSolver.prototype.FinalizeVelocityConstraints = function() {
        for (var i = 0; i < this.m_constraintCount; ++i) {
            var c = this.m_constraints[i];
            var m = c.manifold;
            for (var j = 0; j < c.pointCount; ++j) {
                var point1 = m.m_points[j];
                var point2 = c.points[j];
                point1.m_normalImpulse = point2.normalImpulse;
                point1.m_tangentImpulse = point2.tangentImpulse
            }
        }
    };
    b2ContactSolver.prototype.SolvePositionConstraints = function(baumgarte) {
        var minSeparation = 0;
        for (var i = 0; i < this.m_constraintCount; i++) {
            var c = this.m_constraints[i];
            var bodyA = c.bodyA;
            var bodyB = c.bodyB;
            var invMassA = bodyA.m_mass * bodyA.m_invMass;
            var invIA = bodyA.m_mass * bodyA.m_invI;
            var invMassB = bodyB.m_mass * bodyB.m_invMass;
            var invIB = bodyB.m_mass * bodyB.m_invI;
            b2ContactSolver.s_psm.Initialize(c);
            var normal = b2ContactSolver.s_psm.m_normal;
            for (var j = 0; j < c.pointCount; j++) {
                var ccp = c.points[j];
                var point = b2ContactSolver.s_psm.m_points[j];
                var separation = b2ContactSolver.s_psm.m_separations[j];
                var rAX = point.x - bodyA.m_sweep.c.x;
                var rAY = point.y - bodyA.m_sweep.c.y;
                var rBX = point.x - bodyB.m_sweep.c.x;
                var rBY = point.y - bodyB.m_sweep.c.y;
                minSeparation = minSeparation < separation ? minSeparation : separation;
                var C = b2Math.Clamp(baumgarte * (separation + b2Settings.b2_linearSlop), -b2Settings.b2_maxLinearCorrection, 0);
                var impulse = -ccp.equalizedMass * C;
                var PX = impulse * normal.x;
                var PY = impulse * normal.y;
                bodyA.m_sweep.c.x -= invMassA * PX;
                bodyA.m_sweep.c.y -= invMassA * PY;
                bodyA.m_sweep.a -= invIA * (rAX * PY - rAY * PX);
                bodyA.SynchronizeTransform();
                bodyB.m_sweep.c.x += invMassB * PX;
                bodyB.m_sweep.c.y += invMassB * PY;
                bodyB.m_sweep.a += invIB * (rBX * PY - rBY * PX);
                bodyB.SynchronizeTransform()
            }
        }
        return minSeparation > -1.5 * b2Settings.b2_linearSlop
    };
    b2ContactSolver.prototype.m_step = new b2TimeStep;
    b2ContactSolver.prototype.m_allocator = null;
    b2ContactSolver.prototype.m_constraints = new Array;
    b2ContactSolver.prototype.m_constraintCount = 0;
    var b2Simplex = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2Simplex.prototype.__constructor = function() {
        this.m_vertices[0] = this.m_v1;
        this.m_vertices[1] = this.m_v2;
        this.m_vertices[2] = this.m_v3
    };
    b2Simplex.prototype.__varz = function() {
        this.m_v1 = new b2SimplexVertex;
        this.m_v2 = new b2SimplexVertex;
        this.m_v3 = new b2SimplexVertex;
        this.m_vertices = new Array(3)
    };
    b2Simplex.prototype.ReadCache = function(cache, proxyA, transformA, proxyB, transformB) {
        b2Settings.b2Assert(0 <= cache.count && cache.count <= 3);
        var wALocal;
        var wBLocal;
        this.m_count = cache.count;
        var vertices = this.m_vertices;
        for (var i = 0; i < this.m_count; i++) {
            var v = vertices[i];
            v.indexA = cache.indexA[i];
            v.indexB = cache.indexB[i];
            wALocal = proxyA.GetVertex(v.indexA);
            wBLocal = proxyB.GetVertex(v.indexB);
            v.wA = b2Math.MulX(transformA, wALocal);
            v.wB = b2Math.MulX(transformB, wBLocal);
            v.w = b2Math.SubtractVV(v.wB, v.wA);
            v.a = 0
        }
        if (this.m_count > 1) {
            var metric1 = cache.metric;
            var metric2 = this.GetMetric();
            if (metric2 < .5 * metric1 || 2 * metric1 < metric2 || metric2 < Number.MIN_VALUE) {
                this.m_count = 0
            }
        }
        if (this.m_count == 0) {
            v = vertices[0];
            v.indexA = 0;
            v.indexB = 0;
            wALocal = proxyA.GetVertex(0);
            wBLocal = proxyB.GetVertex(0);
            v.wA = b2Math.MulX(transformA, wALocal);
            v.wB = b2Math.MulX(transformB, wBLocal);
            v.w = b2Math.SubtractVV(v.wB, v.wA);
            this.m_count = 1
        }
    };
    b2Simplex.prototype.WriteCache = function(cache) {
        cache.metric = this.GetMetric();
        cache.count = parseInt(this.m_count);
        var vertices = this.m_vertices;
        for (var i = 0; i < this.m_count; i++) {
            cache.indexA[i] = parseInt(vertices[i].indexA);
            cache.indexB[i] = parseInt(vertices[i].indexB)
        }
    };
    b2Simplex.prototype.GetSearchDirection = function() {
        switch (this.m_count) {
            case 1:
                return this.m_v1.w.GetNegative();
            case 2:
                {
                    var e12 = b2Math.SubtractVV(this.m_v2.w, this.m_v1.w);
                    var sgn = b2Math.CrossVV(e12, this.m_v1.w.GetNegative());
                    if (sgn > 0) {
                        return b2Math.CrossFV(1, e12)
                    } else {
                        return b2Math.CrossVF(e12, 1)
                    }
                }
            default:
                b2Settings.b2Assert(false);
                return new b2Vec2
        }
    };
    b2Simplex.prototype.GetClosestPoint = function() {
        switch (this.m_count) {
            case 0:
                b2Settings.b2Assert(false);
                return new b2Vec2;
            case 1:
                return this.m_v1.w;
            case 2:
                return new b2Vec2(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);
            default:
                b2Settings.b2Assert(false);
                return new b2Vec2
        }
    };
    b2Simplex.prototype.GetWitnessPoints = function(pA, pB) {
        switch (this.m_count) {
            case 0:
                b2Settings.b2Assert(false);
                break;
            case 1:
                pA.SetV(this.m_v1.wA);
                pB.SetV(this.m_v1.wB);
                break;
            case 2:
                pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x;
                pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y;
                pB.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x;
                pB.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;
                break;
            case 3:
                pB.x = pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x;
                pB.y = pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y;
                break;
            default:
                b2Settings.b2Assert(false);
                break
        }
    };
    b2Simplex.prototype.GetMetric = function() {
        switch (this.m_count) {
            case 0:
                b2Settings.b2Assert(false);
                return 0;
            case 1:
                return 0;
            case 2:
                return b2Math.SubtractVV(this.m_v1.w, this.m_v2.w).Length();
            case 3:
                return b2Math.CrossVV(b2Math.SubtractVV(this.m_v2.w, this.m_v1.w), b2Math.SubtractVV(this.m_v3.w, this.m_v1.w));
            default:
                b2Settings.b2Assert(false);
                return 0
        }
    };
    b2Simplex.prototype.Solve2 = function() {
        var w1 = this.m_v1.w;
        var w2 = this.m_v2.w;
        var e12 = b2Math.SubtractVV(w2, w1);
        var d12_2 = -(w1.x * e12.x + w1.y * e12.y);
        if (d12_2 <= 0) {
            this.m_v1.a = 1;
            this.m_count = 1;
            return
        }
        var d12_1 = w2.x * e12.x + w2.y * e12.y;
        if (d12_1 <= 0) {
            this.m_v2.a = 1;
            this.m_count = 1;
            this.m_v1.Set(this.m_v2);
            return
        }
        var inv_d12 = 1 / (d12_1 + d12_2);
        this.m_v1.a = d12_1 * inv_d12;
        this.m_v2.a = d12_2 * inv_d12;
        this.m_count = 2
    };
    b2Simplex.prototype.Solve3 = function() {
        var w1 = this.m_v1.w;
        var w2 = this.m_v2.w;
        var w3 = this.m_v3.w;
        var e12 = b2Math.SubtractVV(w2, w1);
        var w1e12 = b2Math.Dot(w1, e12);
        var w2e12 = b2Math.Dot(w2, e12);
        var d12_1 = w2e12;
        var d12_2 = -w1e12;
        var e13 = b2Math.SubtractVV(w3, w1);
        var w1e13 = b2Math.Dot(w1, e13);
        var w3e13 = b2Math.Dot(w3, e13);
        var d13_1 = w3e13;
        var d13_2 = -w1e13;
        var e23 = b2Math.SubtractVV(w3, w2);
        var w2e23 = b2Math.Dot(w2, e23);
        var w3e23 = b2Math.Dot(w3, e23);
        var d23_1 = w3e23;
        var d23_2 = -w2e23;
        var n123 = b2Math.CrossVV(e12, e13);
        var d123_1 = n123 * b2Math.CrossVV(w2, w3);
        var d123_2 = n123 * b2Math.CrossVV(w3, w1);
        var d123_3 = n123 * b2Math.CrossVV(w1, w2);
        if (d12_2 <= 0 && d13_2 <= 0) {
            this.m_v1.a = 1;
            this.m_count = 1;
            return
        }
        if (d12_1 > 0 && d12_2 > 0 && d123_3 <= 0) {
            var inv_d12 = 1 / (d12_1 + d12_2);
            this.m_v1.a = d12_1 * inv_d12;
            this.m_v2.a = d12_2 * inv_d12;
            this.m_count = 2;
            return
        }
        if (d13_1 > 0 && d13_2 > 0 && d123_2 <= 0) {
            var inv_d13 = 1 / (d13_1 + d13_2);
            this.m_v1.a = d13_1 * inv_d13;
            this.m_v3.a = d13_2 * inv_d13;
            this.m_count = 2;
            this.m_v2.Set(this.m_v3);
            return
        }
        if (d12_1 <= 0 && d23_2 <= 0) {
            this.m_v2.a = 1;
            this.m_count = 1;
            this.m_v1.Set(this.m_v2);
            return
        }
        if (d13_1 <= 0 && d23_1 <= 0) {
            this.m_v3.a = 1;
            this.m_count = 1;
            this.m_v1.Set(this.m_v3);
            return
        }
        if (d23_1 > 0 && d23_2 > 0 && d123_1 <= 0) {
            var inv_d23 = 1 / (d23_1 + d23_2);
            this.m_v2.a = d23_1 * inv_d23;
            this.m_v3.a = d23_2 * inv_d23;
            this.m_count = 2;
            this.m_v1.Set(this.m_v3);
            return
        }
        var inv_d123 = 1 / (d123_1 + d123_2 + d123_3);
        this.m_v1.a = d123_1 * inv_d123;
        this.m_v2.a = d123_2 * inv_d123;
        this.m_v3.a = d123_3 * inv_d123;
        this.m_count = 3
    };
    b2Simplex.prototype.m_v1 = new b2SimplexVertex;
    b2Simplex.prototype.m_v2 = new b2SimplexVertex;
    b2Simplex.prototype.m_v3 = new b2SimplexVertex;
    b2Simplex.prototype.m_vertices = new Array(3);
    b2Simplex.prototype.m_count = 0;
    var b2WeldJoint = function() {
        b2Joint.prototype.__varz.call(this);
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    extend(b2WeldJoint.prototype, b2Joint.prototype);
    b2WeldJoint.prototype._super = b2Joint.prototype;
    b2WeldJoint.prototype.__constructor = function(def) {
        this._super.__constructor.apply(this, [def]);
        this.m_localAnchorA.SetV(def.localAnchorA);
        this.m_localAnchorB.SetV(def.localAnchorB);
        this.m_referenceAngle = def.referenceAngle;
        this.m_impulse.SetZero();
        this.m_mass = new b2Mat33
    };
    b2WeldJoint.prototype.__varz = function() {
        this.m_localAnchorA = new b2Vec2;
        this.m_localAnchorB = new b2Vec2;
        this.m_impulse = new b2Vec3;
        this.m_mass = new b2Mat33
    };
    b2WeldJoint.prototype.InitVelocityConstraints = function(step) {
        var tMat;
        var tX;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        tMat = bA.m_xf.R;
        var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
        var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
        tX = tMat.col1.x * rAX + tMat.col2.x * rAY;
        rAY = tMat.col1.y * rAX + tMat.col2.y * rAY;
        rAX = tX;
        tMat = bB.m_xf.R;
        var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
        var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
        tX = tMat.col1.x * rBX + tMat.col2.x * rBY;
        rBY = tMat.col1.y * rBX + tMat.col2.y * rBY;
        rBX = tX;
        var mA = bA.m_invMass;
        var mB = bB.m_invMass;
        var iA = bA.m_invI;
        var iB = bB.m_invI;
        this.m_mass.col1.x = mA + mB + rAY * rAY * iA + rBY * rBY * iB;
        this.m_mass.col2.x = -rAY * rAX * iA - rBY * rBX * iB;
        this.m_mass.col3.x = -rAY * iA - rBY * iB;
        this.m_mass.col1.y = this.m_mass.col2.x;
        this.m_mass.col2.y = mA + mB + rAX * rAX * iA + rBX * rBX * iB;
        this.m_mass.col3.y = rAX * iA + rBX * iB;
        this.m_mass.col1.z = this.m_mass.col3.x;
        this.m_mass.col2.z = this.m_mass.col3.y;
        this.m_mass.col3.z = iA + iB;
        if (step.warmStarting) {
            this.m_impulse.x *= step.dtRatio;
            this.m_impulse.y *= step.dtRatio;
            this.m_impulse.z *= step.dtRatio;
            bA.m_linearVelocity.x -= mA * this.m_impulse.x;
            bA.m_linearVelocity.y -= mA * this.m_impulse.y;
            bA.m_angularVelocity -= iA * (rAX * this.m_impulse.y - rAY * this.m_impulse.x + this.m_impulse.z);
            bB.m_linearVelocity.x += mB * this.m_impulse.x;
            bB.m_linearVelocity.y += mB * this.m_impulse.y;
            bB.m_angularVelocity += iB * (rBX * this.m_impulse.y - rBY * this.m_impulse.x + this.m_impulse.z)
        } else {
            this.m_impulse.SetZero()
        }
    };
    b2WeldJoint.prototype.SolveVelocityConstraints = function(step) {
        var tMat;
        var tX;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var vA = bA.m_linearVelocity;
        var wA = bA.m_angularVelocity;
        var vB = bB.m_linearVelocity;
        var wB = bB.m_angularVelocity;
        var mA = bA.m_invMass;
        var mB = bB.m_invMass;
        var iA = bA.m_invI;
        var iB = bB.m_invI;
        tMat = bA.m_xf.R;
        var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
        var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
        tX = tMat.col1.x * rAX + tMat.col2.x * rAY;
        rAY = tMat.col1.y * rAX + tMat.col2.y * rAY;
        rAX = tX;
        tMat = bB.m_xf.R;
        var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
        var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
        tX = tMat.col1.x * rBX + tMat.col2.x * rBY;
        rBY = tMat.col1.y * rBX + tMat.col2.y * rBY;
        rBX = tX;
        var Cdot1X = vB.x - wB * rBY - vA.x + wA * rAY;
        var Cdot1Y = vB.y + wB * rBX - vA.y - wA * rAX;
        var Cdot2 = wB - wA;
        var impulse = new b2Vec3;
        this.m_mass.Solve33(impulse, -Cdot1X, -Cdot1Y, -Cdot2);
        this.m_impulse.Add(impulse);
        vA.x -= mA * impulse.x;
        vA.y -= mA * impulse.y;
        wA -= iA * (rAX * impulse.y - rAY * impulse.x + impulse.z);
        vB.x += mB * impulse.x;
        vB.y += mB * impulse.y;
        wB += iB * (rBX * impulse.y - rBY * impulse.x + impulse.z);
        bA.m_angularVelocity = wA;
        bB.m_angularVelocity = wB
    };
    b2WeldJoint.prototype.SolvePositionConstraints = function(baumgarte) {
        var tMat;
        var tX;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        tMat = bA.m_xf.R;
        var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
        var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
        tX = tMat.col1.x * rAX + tMat.col2.x * rAY;
        rAY = tMat.col1.y * rAX + tMat.col2.y * rAY;
        rAX = tX;
        tMat = bB.m_xf.R;
        var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
        var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
        tX = tMat.col1.x * rBX + tMat.col2.x * rBY;
        rBY = tMat.col1.y * rBX + tMat.col2.y * rBY;
        rBX = tX;
        var mA = bA.m_invMass;
        var mB = bB.m_invMass;
        var iA = bA.m_invI;
        var iB = bB.m_invI;
        var C1X = bB.m_sweep.c.x + rBX - bA.m_sweep.c.x - rAX;
        var C1Y = bB.m_sweep.c.y + rBY - bA.m_sweep.c.y - rAY;
        var C2 = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
        var k_allowedStretch = 10 * b2Settings.b2_linearSlop;
        var positionError = Math.sqrt(C1X * C1X + C1Y * C1Y);
        var angularError = b2Math.Abs(C2);
        if (positionError > k_allowedStretch) {
            iA *= 1;
            iB *= 1
        }
        this.m_mass.col1.x = mA + mB + rAY * rAY * iA + rBY * rBY * iB;
        this.m_mass.col2.x = -rAY * rAX * iA - rBY * rBX * iB;
        this.m_mass.col3.x = -rAY * iA - rBY * iB;
        this.m_mass.col1.y = this.m_mass.col2.x;
        this.m_mass.col2.y = mA + mB + rAX * rAX * iA + rBX * rBX * iB;
        this.m_mass.col3.y = rAX * iA + rBX * iB;
        this.m_mass.col1.z = this.m_mass.col3.x;
        this.m_mass.col2.z = this.m_mass.col3.y;
        this.m_mass.col3.z = iA + iB;
        var impulse = new b2Vec3;
        this.m_mass.Solve33(impulse, -C1X, -C1Y, -C2);
        bA.m_sweep.c.x -= mA * impulse.x;
        bA.m_sweep.c.y -= mA * impulse.y;
        bA.m_sweep.a -= iA * (rAX * impulse.y - rAY * impulse.x + impulse.z);
        bB.m_sweep.c.x += mB * impulse.x;
        bB.m_sweep.c.y += mB * impulse.y;
        bB.m_sweep.a += iB * (rBX * impulse.y - rBY * impulse.x + impulse.z);
        bA.SynchronizeTransform();
        bB.SynchronizeTransform();
        return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop
    };
    b2WeldJoint.prototype.GetAnchorA = function() {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchorA)
    };
    b2WeldJoint.prototype.GetAnchorB = function() {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchorB)
    };
    b2WeldJoint.prototype.GetReactionForce = function(inv_dt) {
        return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y)
    };
    b2WeldJoint.prototype.GetReactionTorque = function(inv_dt) {
        return inv_dt * this.m_impulse.z
    };
    b2WeldJoint.prototype.m_localAnchorA = new b2Vec2;
    b2WeldJoint.prototype.m_localAnchorB = new b2Vec2;
    b2WeldJoint.prototype.m_referenceAngle = null;
    b2WeldJoint.prototype.m_impulse = new b2Vec3;
    b2WeldJoint.prototype.m_mass = new b2Mat33;
    var b2Math = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2Math.prototype.__constructor = function() {};
    b2Math.prototype.__varz = function() {};
    b2Math.IsValid = function(x) {
        return isFinite(x)
    };
    b2Math.Dot = function(a, b) {
        return a.x * b.x + a.y * b.y
    };
    b2Math.CrossVV = function(a, b) {
        return a.x * b.y - a.y * b.x
    };
    b2Math.CrossVF = function(a, s) {
        var v = new b2Vec2(s * a.y, -s * a.x);
        return v
    };
    b2Math.CrossFV = function(s, a) {
        var v = new b2Vec2(-s * a.y, s * a.x);
        return v
    };
    b2Math.MulMV = function(A, v) {
        var u = new b2Vec2(A.col1.x * v.x + A.col2.x * v.y, A.col1.y * v.x + A.col2.y * v.y);
        return u
    };
    b2Math.MulTMV = function(A, v) {
        var u = new b2Vec2(b2Math.Dot(v, A.col1), b2Math.Dot(v, A.col2));
        return u
    };
    b2Math.MulX = function(T, v) {
        var a = b2Math.MulMV(T.R, v);
        a.x += T.position.x;
        a.y += T.position.y;
        return a
    };
    b2Math.MulXT = function(T, v) {
        var a = b2Math.SubtractVV(v, T.position);
        var tX = a.x * T.R.col1.x + a.y * T.R.col1.y;
        a.y = a.x * T.R.col2.x + a.y * T.R.col2.y;
        a.x = tX;
        return a
    };
    b2Math.AddVV = function(a, b) {
        var v = new b2Vec2(a.x + b.x, a.y + b.y);
        return v
    };
    b2Math.SubtractVV = function(a, b) {
        var v = new b2Vec2(a.x - b.x, a.y - b.y);
        return v
    };
    b2Math.Distance = function(a, b) {
        var cX = a.x - b.x;
        var cY = a.y - b.y;
        return Math.sqrt(cX * cX + cY * cY)
    };
    b2Math.DistanceSquared = function(a, b) {
        var cX = a.x - b.x;
        var cY = a.y - b.y;
        return cX * cX + cY * cY
    };
    b2Math.MulFV = function(s, a) {
        var v = new b2Vec2(s * a.x, s * a.y);
        return v
    };
    b2Math.AddMM = function(A, B) {
        var C = b2Mat22.FromVV(b2Math.AddVV(A.col1, B.col1), b2Math.AddVV(A.col2, B.col2));
        return C
    };
    b2Math.MulMM = function(A, B) {
        var C = b2Mat22.FromVV(b2Math.MulMV(A, B.col1), b2Math.MulMV(A, B.col2));
        return C
    };
    b2Math.MulTMM = function(A, B) {
        var c1 = new b2Vec2(b2Math.Dot(A.col1, B.col1), b2Math.Dot(A.col2, B.col1));
        var c2 = new b2Vec2(b2Math.Dot(A.col1, B.col2), b2Math.Dot(A.col2, B.col2));
        var C = b2Mat22.FromVV(c1, c2);
        return C
    };
    b2Math.Abs = function(a) {
        return a > 0 ? a : -a
    };
    b2Math.AbsV = function(a) {
        var b = new b2Vec2(b2Math.Abs(a.x), b2Math.Abs(a.y));
        return b
    };
    b2Math.AbsM = function(A) {
        var B = b2Mat22.FromVV(b2Math.AbsV(A.col1), b2Math.AbsV(A.col2));
        return B
    };
    b2Math.Min = function(a, b) {
        return a < b ? a : b
    };
    b2Math.MinV = function(a, b) {
        var c = new b2Vec2(b2Math.Min(a.x, b.x), b2Math.Min(a.y, b.y));
        return c
    };
    b2Math.Max = function(a, b) {
        return a > b ? a : b
    };
    b2Math.MaxV = function(a, b) {
        var c = new b2Vec2(b2Math.Max(a.x, b.x), b2Math.Max(a.y, b.y));
        return c
    };
    b2Math.Clamp = function(a, low, high) {
        return a < low ? low : a > high ? high : a
    };
    b2Math.ClampV = function(a, low, high) {
        return b2Math.MaxV(low, b2Math.MinV(a, high))
    };
    b2Math.Swap = function(a, b) {
        var tmp = a[0];
        a[0] = b[0];
        b[0] = tmp
    };
    b2Math.Random = function() {
        return Math.random() * 2 - 1
    };
    b2Math.RandomRange = function(lo, hi) {
        var r = Math.random();
        r = (hi - lo) * r + lo;
        return r
    };
    b2Math.NextPowerOfTwo = function(x) {
        x |= x >> 1 & 2147483647;
        x |= x >> 2 & 1073741823;
        x |= x >> 4 & 268435455;
        x |= x >> 8 & 16777215;
        x |= x >> 16 & 65535;
        return x + 1
    };
    b2Math.IsPowerOfTwo = function(x) {
        var result = x > 0 && (x & x - 1) == 0;
        return result
    };
    b2Math.b2Vec2_zero = new b2Vec2(0, 0);
    b2Math.b2Mat22_identity = b2Mat22.FromVV(new b2Vec2(1, 0), new b2Vec2(0, 1));
    b2Math.b2Transform_identity = new b2Transform(b2Math.b2Vec2_zero, b2Math.b2Mat22_identity);
    var b2PulleyJoint = function() {
        b2Joint.prototype.__varz.call(this);
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    extend(b2PulleyJoint.prototype, b2Joint.prototype);
    b2PulleyJoint.prototype._super = b2Joint.prototype;
    b2PulleyJoint.prototype.__constructor = function(def) {
        this._super.__constructor.apply(this, [def]);
        var tMat;
        var tX;
        var tY;
        this.m_ground = this.m_bodyA.m_world.m_groundBody;
        this.m_groundAnchor1.x = def.groundAnchorA.x - this.m_ground.m_xf.position.x;
        this.m_groundAnchor1.y = def.groundAnchorA.y - this.m_ground.m_xf.position.y;
        this.m_groundAnchor2.x = def.groundAnchorB.x - this.m_ground.m_xf.position.x;
        this.m_groundAnchor2.y = def.groundAnchorB.y - this.m_ground.m_xf.position.y;
        this.m_localAnchor1.SetV(def.localAnchorA);
        this.m_localAnchor2.SetV(def.localAnchorB);
        this.m_ratio = def.ratio;
        this.m_constant = def.lengthA + this.m_ratio * def.lengthB;
        this.m_maxLength1 = b2Math.Min(def.maxLengthA, this.m_constant - this.m_ratio * b2PulleyJoint.b2_minPulleyLength);
        this.m_maxLength2 = b2Math.Min(def.maxLengthB, (this.m_constant - b2PulleyJoint.b2_minPulleyLength) / this.m_ratio);
        this.m_impulse = 0;
        this.m_limitImpulse1 = 0;
        this.m_limitImpulse2 = 0
    };
    b2PulleyJoint.prototype.__varz = function() {
        this.m_groundAnchor1 = new b2Vec2;
        this.m_groundAnchor2 = new b2Vec2;
        this.m_localAnchor1 = new b2Vec2;
        this.m_localAnchor2 = new b2Vec2;
        this.m_u1 = new b2Vec2;
        this.m_u2 = new b2Vec2
    };
    b2PulleyJoint.b2_minPulleyLength = 2;
    b2PulleyJoint.prototype.InitVelocityConstraints = function(step) {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
        var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
        var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
        r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
        var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
        tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
        r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
        r2X = tX;
        var p1X = bA.m_sweep.c.x + r1X;
        var p1Y = bA.m_sweep.c.y + r1Y;
        var p2X = bB.m_sweep.c.x + r2X;
        var p2Y = bB.m_sweep.c.y + r2Y;
        var s1X = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
        var s1Y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
        var s2X = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
        var s2Y = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
        this.m_u1.Set(p1X - s1X, p1Y - s1Y);
        this.m_u2.Set(p2X - s2X, p2Y - s2Y);
        var length1 = this.m_u1.Length();
        var length2 = this.m_u2.Length();
        if (length1 > b2Settings.b2_linearSlop) {
            this.m_u1.Multiply(1 / length1)
        } else {
            this.m_u1.SetZero()
        }
        if (length2 > b2Settings.b2_linearSlop) {
            this.m_u2.Multiply(1 / length2)
        } else {
            this.m_u2.SetZero()
        }
        var C = this.m_constant - length1 - this.m_ratio * length2;
        if (C > 0) {
            this.m_state = b2Joint.e_inactiveLimit;
            this.m_impulse = 0
        } else {
            this.m_state = b2Joint.e_atUpperLimit
        }
        if (length1 < this.m_maxLength1) {
            this.m_limitState1 = b2Joint.e_inactiveLimit;
            this.m_limitImpulse1 = 0
        } else {
            this.m_limitState1 = b2Joint.e_atUpperLimit
        }
        if (length2 < this.m_maxLength2) {
            this.m_limitState2 = b2Joint.e_inactiveLimit;
            this.m_limitImpulse2 = 0
        } else {
            this.m_limitState2 = b2Joint.e_atUpperLimit
        }
        var cr1u1 = r1X * this.m_u1.y - r1Y * this.m_u1.x;
        var cr2u2 = r2X * this.m_u2.y - r2Y * this.m_u2.x;
        this.m_limitMass1 = bA.m_invMass + bA.m_invI * cr1u1 * cr1u1;
        this.m_limitMass2 = bB.m_invMass + bB.m_invI * cr2u2 * cr2u2;
        this.m_pulleyMass = this.m_limitMass1 + this.m_ratio * this.m_ratio * this.m_limitMass2;
        this.m_limitMass1 = 1 / this.m_limitMass1;
        this.m_limitMass2 = 1 / this.m_limitMass2;
        this.m_pulleyMass = 1 / this.m_pulleyMass;
        if (step.warmStarting) {
            this.m_impulse *= step.dtRatio;
            this.m_limitImpulse1 *= step.dtRatio;
            this.m_limitImpulse2 *= step.dtRatio;
            var P1X = (-this.m_impulse - this.m_limitImpulse1) * this.m_u1.x;
            var P1Y = (-this.m_impulse - this.m_limitImpulse1) * this.m_u1.y;
            var P2X = (-this.m_ratio * this.m_impulse - this.m_limitImpulse2) * this.m_u2.x;
            var P2Y = (-this.m_ratio * this.m_impulse - this.m_limitImpulse2) * this.m_u2.y;
            bA.m_linearVelocity.x += bA.m_invMass * P1X;
            bA.m_linearVelocity.y += bA.m_invMass * P1Y;
            bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
            bB.m_linearVelocity.x += bB.m_invMass * P2X;
            bB.m_linearVelocity.y += bB.m_invMass * P2Y;
            bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X)
        } else {
            this.m_impulse = 0;
            this.m_limitImpulse1 = 0;
            this.m_limitImpulse2 = 0
        }
    };
    b2PulleyJoint.prototype.SolveVelocityConstraints = function(step) {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
        var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
        var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
        r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
        var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
        tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
        r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
        r2X = tX;
        var v1X;
        var v1Y;
        var v2X;
        var v2Y;
        var P1X;
        var P1Y;
        var P2X;
        var P2Y;
        var Cdot;
        var impulse;
        var oldImpulse;
        if (this.m_state == b2Joint.e_atUpperLimit) {
            v1X = bA.m_linearVelocity.x + -bA.m_angularVelocity * r1Y;
            v1Y = bA.m_linearVelocity.y + bA.m_angularVelocity * r1X;
            v2X = bB.m_linearVelocity.x + -bB.m_angularVelocity * r2Y;
            v2Y = bB.m_linearVelocity.y + bB.m_angularVelocity * r2X;
            Cdot = -(this.m_u1.x * v1X + this.m_u1.y * v1Y) - this.m_ratio * (this.m_u2.x * v2X + this.m_u2.y * v2Y);
            impulse = this.m_pulleyMass * -Cdot;
            oldImpulse = this.m_impulse;
            this.m_impulse = b2Math.Max(0, this.m_impulse + impulse);
            impulse = this.m_impulse - oldImpulse;
            P1X = -impulse * this.m_u1.x;
            P1Y = -impulse * this.m_u1.y;
            P2X = -this.m_ratio * impulse * this.m_u2.x;
            P2Y = -this.m_ratio * impulse * this.m_u2.y;
            bA.m_linearVelocity.x += bA.m_invMass * P1X;
            bA.m_linearVelocity.y += bA.m_invMass * P1Y;
            bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
            bB.m_linearVelocity.x += bB.m_invMass * P2X;
            bB.m_linearVelocity.y += bB.m_invMass * P2Y;
            bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X)
        }
        if (this.m_limitState1 == b2Joint.e_atUpperLimit) {
            v1X = bA.m_linearVelocity.x + -bA.m_angularVelocity * r1Y;
            v1Y = bA.m_linearVelocity.y + bA.m_angularVelocity * r1X;
            Cdot = -(this.m_u1.x * v1X + this.m_u1.y * v1Y);
            impulse = -this.m_limitMass1 * Cdot;
            oldImpulse = this.m_limitImpulse1;
            this.m_limitImpulse1 = b2Math.Max(0, this.m_limitImpulse1 + impulse);
            impulse = this.m_limitImpulse1 - oldImpulse;
            P1X = -impulse * this.m_u1.x;
            P1Y = -impulse * this.m_u1.y;
            bA.m_linearVelocity.x += bA.m_invMass * P1X;
            bA.m_linearVelocity.y += bA.m_invMass * P1Y;
            bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X)
        }
        if (this.m_limitState2 == b2Joint.e_atUpperLimit) {
            v2X = bB.m_linearVelocity.x + -bB.m_angularVelocity * r2Y;
            v2Y = bB.m_linearVelocity.y + bB.m_angularVelocity * r2X;
            Cdot = -(this.m_u2.x * v2X + this.m_u2.y * v2Y);
            impulse = -this.m_limitMass2 * Cdot;
            oldImpulse = this.m_limitImpulse2;
            this.m_limitImpulse2 = b2Math.Max(0, this.m_limitImpulse2 + impulse);
            impulse = this.m_limitImpulse2 - oldImpulse;
            P2X = -impulse * this.m_u2.x;
            P2Y = -impulse * this.m_u2.y;
            bB.m_linearVelocity.x += bB.m_invMass * P2X;
            bB.m_linearVelocity.y += bB.m_invMass * P2Y;
            bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X)
        }
    };
    b2PulleyJoint.prototype.SolvePositionConstraints = function(baumgarte) {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        var s1X = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
        var s1Y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
        var s2X = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
        var s2Y = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
        var r1X;
        var r1Y;
        var r2X;
        var r2Y;
        var p1X;
        var p1Y;
        var p2X;
        var p2Y;
        var length1;
        var length2;
        var C;
        var impulse;
        var oldImpulse;
        var oldLimitPositionImpulse;
        var tX;
        var linearError = 0;
        if (this.m_state == b2Joint.e_atUpperLimit) {
            tMat = bA.m_xf.R;
            r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
            r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
            tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
            r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
            r1X = tX;
            tMat = bB.m_xf.R;
            r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
            r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
            tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
            r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
            r2X = tX;
            p1X = bA.m_sweep.c.x + r1X;
            p1Y = bA.m_sweep.c.y + r1Y;
            p2X = bB.m_sweep.c.x + r2X;
            p2Y = bB.m_sweep.c.y + r2Y;
            this.m_u1.Set(p1X - s1X, p1Y - s1Y);
            this.m_u2.Set(p2X - s2X, p2Y - s2Y);
            length1 = this.m_u1.Length();
            length2 = this.m_u2.Length();
            if (length1 > b2Settings.b2_linearSlop) {
                this.m_u1.Multiply(1 / length1)
            } else {
                this.m_u1.SetZero()
            }
            if (length2 > b2Settings.b2_linearSlop) {
                this.m_u2.Multiply(1 / length2)
            } else {
                this.m_u2.SetZero()
            }
            C = this.m_constant - length1 - this.m_ratio * length2;
            linearError = b2Math.Max(linearError, -C);
            C = b2Math.Clamp(C + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0);
            impulse = -this.m_pulleyMass * C;
            p1X = -impulse * this.m_u1.x;
            p1Y = -impulse * this.m_u1.y;
            p2X = -this.m_ratio * impulse * this.m_u2.x;
            p2Y = -this.m_ratio * impulse * this.m_u2.y;
            bA.m_sweep.c.x += bA.m_invMass * p1X;
            bA.m_sweep.c.y += bA.m_invMass * p1Y;
            bA.m_sweep.a += bA.m_invI * (r1X * p1Y - r1Y * p1X);
            bB.m_sweep.c.x += bB.m_invMass * p2X;
            bB.m_sweep.c.y += bB.m_invMass * p2Y;
            bB.m_sweep.a += bB.m_invI * (r2X * p2Y - r2Y * p2X);
            bA.SynchronizeTransform();
            bB.SynchronizeTransform()
        }
        if (this.m_limitState1 == b2Joint.e_atUpperLimit) {
            tMat = bA.m_xf.R;
            r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
            r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
            tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
            r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
            r1X = tX;
            p1X = bA.m_sweep.c.x + r1X;
            p1Y = bA.m_sweep.c.y + r1Y;
            this.m_u1.Set(p1X - s1X, p1Y - s1Y);
            length1 = this.m_u1.Length();
            if (length1 > b2Settings.b2_linearSlop) {
                this.m_u1.x *= 1 / length1;
                this.m_u1.y *= 1 / length1
            } else {
                this.m_u1.SetZero()
            }
            C = this.m_maxLength1 - length1;
            linearError = b2Math.Max(linearError, -C);
            C = b2Math.Clamp(C + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0);
            impulse = -this.m_limitMass1 * C;
            p1X = -impulse * this.m_u1.x;
            p1Y = -impulse * this.m_u1.y;
            bA.m_sweep.c.x += bA.m_invMass * p1X;
            bA.m_sweep.c.y += bA.m_invMass * p1Y;
            bA.m_sweep.a += bA.m_invI * (r1X * p1Y - r1Y * p1X);
            bA.SynchronizeTransform()
        }
        if (this.m_limitState2 == b2Joint.e_atUpperLimit) {
            tMat = bB.m_xf.R;
            r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
            r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
            tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
            r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
            r2X = tX;
            p2X = bB.m_sweep.c.x + r2X;
            p2Y = bB.m_sweep.c.y + r2Y;
            this.m_u2.Set(p2X - s2X, p2Y - s2Y);
            length2 = this.m_u2.Length();
            if (length2 > b2Settings.b2_linearSlop) {
                this.m_u2.x *= 1 / length2;
                this.m_u2.y *= 1 / length2
            } else {
                this.m_u2.SetZero()
            }
            C = this.m_maxLength2 - length2;
            linearError = b2Math.Max(linearError, -C);
            C = b2Math.Clamp(C + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0);
            impulse = -this.m_limitMass2 * C;
            p2X = -impulse * this.m_u2.x;
            p2Y = -impulse * this.m_u2.y;
            bB.m_sweep.c.x += bB.m_invMass * p2X;
            bB.m_sweep.c.y += bB.m_invMass * p2Y;
            bB.m_sweep.a += bB.m_invI * (r2X * p2Y - r2Y * p2X);
            bB.SynchronizeTransform()
        }
        return linearError < b2Settings.b2_linearSlop
    };
    b2PulleyJoint.prototype.GetAnchorA = function() {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
    };
    b2PulleyJoint.prototype.GetAnchorB = function() {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
    };
    b2PulleyJoint.prototype.GetReactionForce = function(inv_dt) {
        return new b2Vec2(inv_dt * this.m_impulse * this.m_u2.x, inv_dt * this.m_impulse * this.m_u2.y)
    };
    b2PulleyJoint.prototype.GetReactionTorque = function(inv_dt) {
        return 0
    };
    b2PulleyJoint.prototype.GetGroundAnchorA = function() {
        var a = this.m_ground.m_xf.position.Copy();
        a.Add(this.m_groundAnchor1);
        return a
    };
    b2PulleyJoint.prototype.GetGroundAnchorB = function() {
        var a = this.m_ground.m_xf.position.Copy();
        a.Add(this.m_groundAnchor2);
        return a
    };
    b2PulleyJoint.prototype.GetLength1 = function() {
        var p = this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
        var sX = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
        var sY = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
        var dX = p.x - sX;
        var dY = p.y - sY;
        return Math.sqrt(dX * dX + dY * dY)
    };
    b2PulleyJoint.prototype.GetLength2 = function() {
        var p = this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
        var sX = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
        var sY = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
        var dX = p.x - sX;
        var dY = p.y - sY;
        return Math.sqrt(dX * dX + dY * dY)
    };
    b2PulleyJoint.prototype.GetRatio = function() {
        return this.m_ratio
    };
    b2PulleyJoint.prototype.m_ground = null;
    b2PulleyJoint.prototype.m_groundAnchor1 = new b2Vec2;
    b2PulleyJoint.prototype.m_groundAnchor2 = new b2Vec2;
    b2PulleyJoint.prototype.m_localAnchor1 = new b2Vec2;
    b2PulleyJoint.prototype.m_localAnchor2 = new b2Vec2;
    b2PulleyJoint.prototype.m_u1 = new b2Vec2;
    b2PulleyJoint.prototype.m_u2 = new b2Vec2;
    b2PulleyJoint.prototype.m_constant = null;
    b2PulleyJoint.prototype.m_ratio = null;
    b2PulleyJoint.prototype.m_maxLength1 = null;
    b2PulleyJoint.prototype.m_maxLength2 = null;
    b2PulleyJoint.prototype.m_pulleyMass = null;
    b2PulleyJoint.prototype.m_limitMass1 = null;
    b2PulleyJoint.prototype.m_limitMass2 = null;
    b2PulleyJoint.prototype.m_impulse = null;
    b2PulleyJoint.prototype.m_limitImpulse1 = null;
    b2PulleyJoint.prototype.m_limitImpulse2 = null;
    b2PulleyJoint.prototype.m_state = 0;
    b2PulleyJoint.prototype.m_limitState1 = 0;
    b2PulleyJoint.prototype.m_limitState2 = 0;
    var b2PrismaticJoint = function() {
        b2Joint.prototype.__varz.call(this);
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    extend(b2PrismaticJoint.prototype, b2Joint.prototype);
    b2PrismaticJoint.prototype._super = b2Joint.prototype;
    b2PrismaticJoint.prototype.__constructor = function(def) {
        this._super.__constructor.apply(this, [def]);
        var tMat;
        var tX;
        var tY;
        this.m_localAnchor1.SetV(def.localAnchorA);
        this.m_localAnchor2.SetV(def.localAnchorB);
        this.m_localXAxis1.SetV(def.localAxisA);
        this.m_localYAxis1.x = -this.m_localXAxis1.y;
        this.m_localYAxis1.y = this.m_localXAxis1.x;
        this.m_refAngle = def.referenceAngle;
        this.m_impulse.SetZero();
        this.m_motorMass = 0;
        this.m_motorImpulse = 0;
        this.m_lowerTranslation = def.lowerTranslation;
        this.m_upperTranslation = def.upperTranslation;
        this.m_maxMotorForce = def.maxMotorForce;
        this.m_motorSpeed = def.motorSpeed;
        this.m_enableLimit = def.enableLimit;
        this.m_enableMotor = def.enableMotor;
        this.m_limitState = b2Joint.e_inactiveLimit;
        this.m_axis.SetZero();
        this.m_perp.SetZero()
    };
    b2PrismaticJoint.prototype.__varz = function() {
        this.m_localAnchor1 = new b2Vec2;
        this.m_localAnchor2 = new b2Vec2;
        this.m_localXAxis1 = new b2Vec2;
        this.m_localYAxis1 = new b2Vec2;
        this.m_axis = new b2Vec2;
        this.m_perp = new b2Vec2;
        this.m_K = new b2Mat33;
        this.m_impulse = new b2Vec3
    };
    b2PrismaticJoint.prototype.InitVelocityConstraints = function(step) {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        var tX;
        this.m_localCenterA.SetV(bA.GetLocalCenter());
        this.m_localCenterB.SetV(bB.GetLocalCenter());
        var xf1 = bA.GetTransform();
        var xf2 = bB.GetTransform();
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
        var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
        tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
        r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
        var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
        tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
        r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
        r2X = tX;
        var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
        var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
        this.m_invMassA = bA.m_invMass;
        this.m_invMassB = bB.m_invMass;
        this.m_invIA = bA.m_invI;
        this.m_invIB = bB.m_invI; {
            this.m_axis.SetV(b2Math.MulMV(xf1.R, this.m_localXAxis1));
            this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
            this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
            this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
            if (this.m_motorMass > Number.MIN_VALUE) this.m_motorMass = 1 / this.m_motorMass
        } {
            this.m_perp.SetV(b2Math.MulMV(xf1.R, this.m_localYAxis1));
            this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
            this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
            var m1 = this.m_invMassA;
            var m2 = this.m_invMassB;
            var i1 = this.m_invIA;
            var i2 = this.m_invIB;
            this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
            this.m_K.col1.y = i1 * this.m_s1 + i2 * this.m_s2;
            this.m_K.col1.z = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
            this.m_K.col2.x = this.m_K.col1.y;
            this.m_K.col2.y = i1 + i2;
            this.m_K.col2.z = i1 * this.m_a1 + i2 * this.m_a2;
            this.m_K.col3.x = this.m_K.col1.z;
            this.m_K.col3.y = this.m_K.col2.z;
            this.m_K.col3.z = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2
        }
        if (this.m_enableLimit) {
            var jointTransition = this.m_axis.x * dX + this.m_axis.y * dY;
            if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b2Settings.b2_linearSlop) {
                this.m_limitState = b2Joint.e_equalLimits
            } else if (jointTransition <= this.m_lowerTranslation) {
                if (this.m_limitState != b2Joint.e_atLowerLimit) {
                    this.m_limitState = b2Joint.e_atLowerLimit;
                    this.m_impulse.z = 0
                }
            } else if (jointTransition >= this.m_upperTranslation) {
                if (this.m_limitState != b2Joint.e_atUpperLimit) {
                    this.m_limitState = b2Joint.e_atUpperLimit;
                    this.m_impulse.z = 0
                }
            } else {
                this.m_limitState = b2Joint.e_inactiveLimit;
                this.m_impulse.z = 0
            }
        } else {
            this.m_limitState = b2Joint.e_inactiveLimit
        }
        if (this.m_enableMotor == false) {
            this.m_motorImpulse = 0
        }
        if (step.warmStarting) {
            this.m_impulse.x *= step.dtRatio;
            this.m_impulse.y *= step.dtRatio;
            this.m_motorImpulse *= step.dtRatio;
            var PX = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x;
            var PY = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y;
            var L1 = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;
            var L2 = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;
            bA.m_linearVelocity.x -= this.m_invMassA * PX;
            bA.m_linearVelocity.y -= this.m_invMassA * PY;
            bA.m_angularVelocity -= this.m_invIA * L1;
            bB.m_linearVelocity.x += this.m_invMassB * PX;
            bB.m_linearVelocity.y += this.m_invMassB * PY;
            bB.m_angularVelocity += this.m_invIB * L2
        } else {
            this.m_impulse.SetZero();
            this.m_motorImpulse = 0
        }
    };
    b2PrismaticJoint.prototype.SolveVelocityConstraints = function(step) {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var v1 = bA.m_linearVelocity;
        var w1 = bA.m_angularVelocity;
        var v2 = bB.m_linearVelocity;
        var w2 = bB.m_angularVelocity;
        var PX;
        var PY;
        var L1;
        var L2;
        if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
            var Cdot = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
            var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
            var oldImpulse = this.m_motorImpulse;
            var maxImpulse = step.dt * this.m_maxMotorForce;
            this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
            impulse = this.m_motorImpulse - oldImpulse;
            PX = impulse * this.m_axis.x;
            PY = impulse * this.m_axis.y;
            L1 = impulse * this.m_a1;
            L2 = impulse * this.m_a2;
            v1.x -= this.m_invMassA * PX;
            v1.y -= this.m_invMassA * PY;
            w1 -= this.m_invIA * L1;
            v2.x += this.m_invMassB * PX;
            v2.y += this.m_invMassB * PY;
            w2 += this.m_invIB * L2
        }
        var Cdot1X = this.m_perp.x * (v2.x - v1.x) + this.m_perp.y * (v2.y - v1.y) + this.m_s2 * w2 - this.m_s1 * w1;
        var Cdot1Y = w2 - w1;
        if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
            var Cdot2 = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
            var f1 = this.m_impulse.Copy();
            var df = this.m_K.Solve33(new b2Vec3, -Cdot1X, -Cdot1Y, -Cdot2);
            this.m_impulse.Add(df);
            if (this.m_limitState == b2Joint.e_atLowerLimit) {
                this.m_impulse.z = b2Math.Max(this.m_impulse.z, 0)
            } else if (this.m_limitState == b2Joint.e_atUpperLimit) {
                this.m_impulse.z = b2Math.Min(this.m_impulse.z, 0)
            }
            var bX = -Cdot1X - (this.m_impulse.z - f1.z) * this.m_K.col3.x;
            var bY = -Cdot1Y - (this.m_impulse.z - f1.z) * this.m_K.col3.y;
            var f2r = this.m_K.Solve22(new b2Vec2, bX, bY);
            f2r.x += f1.x;
            f2r.y += f1.y;
            this.m_impulse.x = f2r.x;
            this.m_impulse.y = f2r.y;
            df.x = this.m_impulse.x - f1.x;
            df.y = this.m_impulse.y - f1.y;
            df.z = this.m_impulse.z - f1.z;
            PX = df.x * this.m_perp.x + df.z * this.m_axis.x;
            PY = df.x * this.m_perp.y + df.z * this.m_axis.y;
            L1 = df.x * this.m_s1 + df.y + df.z * this.m_a1;
            L2 = df.x * this.m_s2 + df.y + df.z * this.m_a2;
            v1.x -= this.m_invMassA * PX;
            v1.y -= this.m_invMassA * PY;
            w1 -= this.m_invIA * L1;
            v2.x += this.m_invMassB * PX;
            v2.y += this.m_invMassB * PY;
            w2 += this.m_invIB * L2
        } else {
            var df2 = this.m_K.Solve22(new b2Vec2, -Cdot1X, -Cdot1Y);
            this.m_impulse.x += df2.x;
            this.m_impulse.y += df2.y;
            PX = df2.x * this.m_perp.x;
            PY = df2.x * this.m_perp.y;
            L1 = df2.x * this.m_s1 + df2.y;
            L2 = df2.x * this.m_s2 + df2.y;
            v1.x -= this.m_invMassA * PX;
            v1.y -= this.m_invMassA * PY;
            w1 -= this.m_invIA * L1;
            v2.x += this.m_invMassB * PX;
            v2.y += this.m_invMassB * PY;
            w2 += this.m_invIB * L2
        }
        bA.m_linearVelocity.SetV(v1);
        bA.m_angularVelocity = w1;
        bB.m_linearVelocity.SetV(v2);
        bB.m_angularVelocity = w2
    };
    b2PrismaticJoint.prototype.SolvePositionConstraints = function(baumgarte) {
        var limitC;
        var oldLimitImpulse;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var c1 = bA.m_sweep.c;
        var a1 = bA.m_sweep.a;
        var c2 = bB.m_sweep.c;
        var a2 = bB.m_sweep.a;
        var tMat;
        var tX;
        var m1;
        var m2;
        var i1;
        var i2;
        var linearError = 0;
        var angularError = 0;
        var active = false;
        var C2 = 0;
        var R1 = b2Mat22.FromAngle(a1);
        var R2 = b2Mat22.FromAngle(a2);
        tMat = R1;
        var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
        var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
        tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
        r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
        r1X = tX;
        tMat = R2;
        var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
        var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
        tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
        r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
        r2X = tX;
        var dX = c2.x + r2X - c1.x - r1X;
        var dY = c2.y + r2Y - c1.y - r1Y;
        if (this.m_enableLimit) {
            this.m_axis = b2Math.MulMV(R1, this.m_localXAxis1);
            this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
            this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
            var translation = this.m_axis.x * dX + this.m_axis.y * dY;
            if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b2Settings.b2_linearSlop) {
                C2 = b2Math.Clamp(translation, -b2Settings.b2_maxLinearCorrection, b2Settings.b2_maxLinearCorrection);
                linearError = b2Math.Abs(translation);
                active = true
            } else if (translation <= this.m_lowerTranslation) {
                C2 = b2Math.Clamp(translation - this.m_lowerTranslation + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0);
                linearError = this.m_lowerTranslation - translation;
                active = true
            } else if (translation >= this.m_upperTranslation) {
                C2 = b2Math.Clamp(translation - this.m_upperTranslation + b2Settings.b2_linearSlop, 0, b2Settings.b2_maxLinearCorrection);
                linearError = translation - this.m_upperTranslation;
                active = true
            }
        }
        this.m_perp = b2Math.MulMV(R1, this.m_localYAxis1);
        this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
        this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
        var impulse = new b2Vec3;
        var C1X = this.m_perp.x * dX + this.m_perp.y * dY;
        var C1Y = a2 - a1 - this.m_refAngle;
        linearError = b2Math.Max(linearError, b2Math.Abs(C1X));
        angularError = b2Math.Abs(C1Y);
        if (active) {
            m1 = this.m_invMassA;
            m2 = this.m_invMassB;
            i1 = this.m_invIA;
            i2 = this.m_invIB;
            this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
            this.m_K.col1.y = i1 * this.m_s1 + i2 * this.m_s2;
            this.m_K.col1.z = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
            this.m_K.col2.x = this.m_K.col1.y;
            this.m_K.col2.y = i1 + i2;
            this.m_K.col2.z = i1 * this.m_a1 + i2 * this.m_a2;
            this.m_K.col3.x = this.m_K.col1.z;
            this.m_K.col3.y = this.m_K.col2.z;
            this.m_K.col3.z = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
            this.m_K.Solve33(impulse, -C1X, -C1Y, -C2)
        } else {
            m1 = this.m_invMassA;
            m2 = this.m_invMassB;
            i1 = this.m_invIA;
            i2 = this.m_invIB;
            var k11 = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
            var k12 = i1 * this.m_s1 + i2 * this.m_s2;
            var k22 = i1 + i2;
            this.m_K.col1.Set(k11, k12, 0);
            this.m_K.col2.Set(k12, k22, 0);
            var impulse1 = this.m_K.Solve22(new b2Vec2, -C1X, -C1Y);
            impulse.x = impulse1.x;
            impulse.y = impulse1.y;
            impulse.z = 0
        }
        var PX = impulse.x * this.m_perp.x + impulse.z * this.m_axis.x;
        var PY = impulse.x * this.m_perp.y + impulse.z * this.m_axis.y;
        var L1 = impulse.x * this.m_s1 + impulse.y + impulse.z * this.m_a1;
        var L2 = impulse.x * this.m_s2 + impulse.y + impulse.z * this.m_a2;
        c1.x -= this.m_invMassA * PX;
        c1.y -= this.m_invMassA * PY;
        a1 -= this.m_invIA * L1;
        c2.x += this.m_invMassB * PX;
        c2.y += this.m_invMassB * PY;
        a2 += this.m_invIB * L2;
        bA.m_sweep.a = a1;
        bB.m_sweep.a = a2;
        bA.SynchronizeTransform();
        bB.SynchronizeTransform();
        return linearError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop
    };
    b2PrismaticJoint.prototype.GetAnchorA = function() {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
    };
    b2PrismaticJoint.prototype.GetAnchorB = function() {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
    };
    b2PrismaticJoint.prototype.GetReactionForce = function(inv_dt) {
        return new b2Vec2(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y))
    };
    b2PrismaticJoint.prototype.GetReactionTorque = function(inv_dt) {
        return inv_dt * this.m_impulse.y
    };
    b2PrismaticJoint.prototype.GetJointTranslation = function() {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        var p1 = bA.GetWorldPoint(this.m_localAnchor1);
        var p2 = bB.GetWorldPoint(this.m_localAnchor2);
        var dX = p2.x - p1.x;
        var dY = p2.y - p1.y;
        var axis = bA.GetWorldVector(this.m_localXAxis1);
        var translation = axis.x * dX + axis.y * dY;
        return translation
    };
    b2PrismaticJoint.prototype.GetJointSpeed = function() {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
        var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
        var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
        r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
        var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
        tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
        r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
        r2X = tX;
        var p1X = bA.m_sweep.c.x + r1X;
        var p1Y = bA.m_sweep.c.y + r1Y;
        var p2X = bB.m_sweep.c.x + r2X;
        var p2Y = bB.m_sweep.c.y + r2Y;
        var dX = p2X - p1X;
        var dY = p2Y - p1Y;
        var axis = bA.GetWorldVector(this.m_localXAxis1);
        var v1 = bA.m_linearVelocity;
        var v2 = bB.m_linearVelocity;
        var w1 = bA.m_angularVelocity;
        var w2 = bB.m_angularVelocity;
        var speed = dX * (-w1 * axis.y) + dY * (w1 * axis.x) + (axis.x * (v2.x + -w2 * r2Y - v1.x - -w1 * r1Y) + axis.y * (v2.y + w2 * r2X - v1.y - w1 * r1X));
        return speed
    };
    b2PrismaticJoint.prototype.IsLimitEnabled = function() {
        return this.m_enableLimit
    };
    b2PrismaticJoint.prototype.EnableLimit = function(flag) {
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_enableLimit = flag
    };
    b2PrismaticJoint.prototype.GetLowerLimit = function() {
        return this.m_lowerTranslation
    };
    b2PrismaticJoint.prototype.GetUpperLimit = function() {
        return this.m_upperTranslation
    };
    b2PrismaticJoint.prototype.SetLimits = function(lower, upper) {
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_lowerTranslation = lower;
        this.m_upperTranslation = upper
    };
    b2PrismaticJoint.prototype.IsMotorEnabled = function() {
        return this.m_enableMotor
    };
    b2PrismaticJoint.prototype.EnableMotor = function(flag) {
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_enableMotor = flag
    };
    b2PrismaticJoint.prototype.SetMotorSpeed = function(speed) {
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_motorSpeed = speed
    };
    b2PrismaticJoint.prototype.GetMotorSpeed = function() {
        return this.m_motorSpeed
    };
    b2PrismaticJoint.prototype.SetMaxMotorForce = function(force) {
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_maxMotorForce = force
    };
    b2PrismaticJoint.prototype.GetMotorForce = function() {
        return this.m_motorImpulse
    };
    b2PrismaticJoint.prototype.m_localAnchor1 = new b2Vec2;
    b2PrismaticJoint.prototype.m_localAnchor2 = new b2Vec2;
    b2PrismaticJoint.prototype.m_localXAxis1 = new b2Vec2;
    b2PrismaticJoint.prototype.m_localYAxis1 = new b2Vec2;
    b2PrismaticJoint.prototype.m_refAngle = null;
    b2PrismaticJoint.prototype.m_axis = new b2Vec2;
    b2PrismaticJoint.prototype.m_perp = new b2Vec2;
    b2PrismaticJoint.prototype.m_s1 = null;
    b2PrismaticJoint.prototype.m_s2 = null;
    b2PrismaticJoint.prototype.m_a1 = null;
    b2PrismaticJoint.prototype.m_a2 = null;
    b2PrismaticJoint.prototype.m_K = new b2Mat33;
    b2PrismaticJoint.prototype.m_impulse = new b2Vec3;
    b2PrismaticJoint.prototype.m_motorMass = null;
    b2PrismaticJoint.prototype.m_motorImpulse = null;
    b2PrismaticJoint.prototype.m_lowerTranslation = null;
    b2PrismaticJoint.prototype.m_upperTranslation = null;
    b2PrismaticJoint.prototype.m_maxMotorForce = null;
    b2PrismaticJoint.prototype.m_motorSpeed = null;
    b2PrismaticJoint.prototype.m_enableLimit = null;
    b2PrismaticJoint.prototype.m_enableMotor = null;
    b2PrismaticJoint.prototype.m_limitState = 0;
    var b2RevoluteJoint = function() {
        b2Joint.prototype.__varz.call(this);
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    extend(b2RevoluteJoint.prototype, b2Joint.prototype);
    b2RevoluteJoint.prototype._super = b2Joint.prototype;
    b2RevoluteJoint.prototype.__constructor = function(def) {
        this._super.__constructor.apply(this, [def]);
        this.m_localAnchor1.SetV(def.localAnchorA);
        this.m_localAnchor2.SetV(def.localAnchorB);
        this.m_referenceAngle = def.referenceAngle;
        this.m_impulse.SetZero();
        this.m_motorImpulse = 0;
        this.m_lowerAngle = def.lowerAngle;
        this.m_upperAngle = def.upperAngle;
        this.m_maxMotorTorque = def.maxMotorTorque;
        this.m_motorSpeed = def.motorSpeed;
        this.m_enableLimit = def.enableLimit;
        this.m_enableMotor = def.enableMotor;
        this.m_limitState = b2Joint.e_inactiveLimit
    };
    b2RevoluteJoint.prototype.__varz = function() {
        this.K = new b2Mat22;
        this.K1 = new b2Mat22;
        this.K2 = new b2Mat22;
        this.K3 = new b2Mat22;
        this.impulse3 = new b2Vec3;
        this.impulse2 = new b2Vec2;
        this.reduced = new b2Vec2;
        this.m_localAnchor1 = new b2Vec2;
        this.m_localAnchor2 = new b2Vec2;
        this.m_impulse = new b2Vec3;
        this.m_mass = new b2Mat33
    };
    b2RevoluteJoint.tImpulse = new b2Vec2;
    b2RevoluteJoint.prototype.InitVelocityConstraints = function(step) {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        var tX;
        if (this.m_enableMotor || this.m_enableLimit) {}
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
        var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
        tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
        r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
        var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
        tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
        r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
        r2X = tX;
        var m1 = bA.m_invMass;
        var m2 = bB.m_invMass;
        var i1 = bA.m_invI;
        var i2 = bB.m_invI;
        this.m_mass.col1.x = m1 + m2 + r1Y * r1Y * i1 + r2Y * r2Y * i2;
        this.m_mass.col2.x = -r1Y * r1X * i1 - r2Y * r2X * i2;
        this.m_mass.col3.x = -r1Y * i1 - r2Y * i2;
        this.m_mass.col1.y = this.m_mass.col2.x;
        this.m_mass.col2.y = m1 + m2 + r1X * r1X * i1 + r2X * r2X * i2;
        this.m_mass.col3.y = r1X * i1 + r2X * i2;
        this.m_mass.col1.z = this.m_mass.col3.x;
        this.m_mass.col2.z = this.m_mass.col3.y;
        this.m_mass.col3.z = i1 + i2;
        this.m_motorMass = 1 / (i1 + i2);
        if (this.m_enableMotor == false) {
            this.m_motorImpulse = 0
        }
        if (this.m_enableLimit) {
            var jointAngle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
            if (b2Math.Abs(this.m_upperAngle - this.m_lowerAngle) < 2 * b2Settings.b2_angularSlop) {
                this.m_limitState = b2Joint.e_equalLimits
            } else if (jointAngle <= this.m_lowerAngle) {
                if (this.m_limitState != b2Joint.e_atLowerLimit) {
                    this.m_impulse.z = 0
                }
                this.m_limitState = b2Joint.e_atLowerLimit
            } else if (jointAngle >= this.m_upperAngle) {
                if (this.m_limitState != b2Joint.e_atUpperLimit) {
                    this.m_impulse.z = 0
                }
                this.m_limitState = b2Joint.e_atUpperLimit
            } else {
                this.m_limitState = b2Joint.e_inactiveLimit;
                this.m_impulse.z = 0
            }
        } else {
            this.m_limitState = b2Joint.e_inactiveLimit
        }
        if (step.warmStarting) {
            this.m_impulse.x *= step.dtRatio;
            this.m_impulse.y *= step.dtRatio;
            this.m_motorImpulse *= step.dtRatio;
            var PX = this.m_impulse.x;
            var PY = this.m_impulse.y;
            bA.m_linearVelocity.x -= m1 * PX;
            bA.m_linearVelocity.y -= m1 * PY;
            bA.m_angularVelocity -= i1 * (r1X * PY - r1Y * PX + this.m_motorImpulse + this.m_impulse.z);
            bB.m_linearVelocity.x += m2 * PX;
            bB.m_linearVelocity.y += m2 * PY;
            bB.m_angularVelocity += i2 * (r2X * PY - r2Y * PX + this.m_motorImpulse + this.m_impulse.z)
        } else {
            this.m_impulse.SetZero();
            this.m_motorImpulse = 0
        }
    };
    b2RevoluteJoint.prototype.SolveVelocityConstraints = function(step) {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var tMat;
        var tX;
        var newImpulse;
        var r1X;
        var r1Y;
        var r2X;
        var r2Y;
        var v1 = bA.m_linearVelocity;
        var w1 = bA.m_angularVelocity;
        var v2 = bB.m_linearVelocity;
        var w2 = bB.m_angularVelocity;
        var m1 = bA.m_invMass;
        var m2 = bB.m_invMass;
        var i1 = bA.m_invI;
        var i2 = bB.m_invI;
        if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
            var Cdot = w2 - w1 - this.m_motorSpeed;
            var impulse = this.m_motorMass * -Cdot;
            var oldImpulse = this.m_motorImpulse;
            var maxImpulse = step.dt * this.m_maxMotorTorque;
            this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
            impulse = this.m_motorImpulse - oldImpulse;
            w1 -= i1 * impulse;
            w2 += i2 * impulse
        }
        if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
            tMat = bA.m_xf.R;
            r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
            r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
            tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
            r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
            r1X = tX;
            tMat = bB.m_xf.R;
            r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
            r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
            tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
            r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
            r2X = tX;
            var Cdot1X = v2.x + -w2 * r2Y - v1.x - -w1 * r1Y;
            var Cdot1Y = v2.y + w2 * r2X - v1.y - w1 * r1X;
            var Cdot2 = w2 - w1;
            this.m_mass.Solve33(this.impulse3, -Cdot1X, -Cdot1Y, -Cdot2);
            if (this.m_limitState == b2Joint.e_equalLimits) {
                this.m_impulse.Add(this.impulse3)
            } else if (this.m_limitState == b2Joint.e_atLowerLimit) {
                newImpulse = this.m_impulse.z + this.impulse3.z;
                if (newImpulse < 0) {
                    this.m_mass.Solve22(this.reduced, -Cdot1X, -Cdot1Y);
                    this.impulse3.x = this.reduced.x;
                    this.impulse3.y = this.reduced.y;
                    this.impulse3.z = -this.m_impulse.z;
                    this.m_impulse.x += this.reduced.x;
                    this.m_impulse.y += this.reduced.y;
                    this.m_impulse.z = 0
                }
            } else if (this.m_limitState == b2Joint.e_atUpperLimit) {
                newImpulse = this.m_impulse.z + this.impulse3.z;
                if (newImpulse > 0) {
                    this.m_mass.Solve22(this.reduced, -Cdot1X, -Cdot1Y);
                    this.impulse3.x = this.reduced.x;
                    this.impulse3.y = this.reduced.y;
                    this.impulse3.z = -this.m_impulse.z;
                    this.m_impulse.x += this.reduced.x;
                    this.m_impulse.y += this.reduced.y;
                    this.m_impulse.z = 0
                }
            }
            v1.x -= m1 * this.impulse3.x;
            v1.y -= m1 * this.impulse3.y;
            w1 -= i1 * (r1X * this.impulse3.y - r1Y * this.impulse3.x + this.impulse3.z);
            v2.x += m2 * this.impulse3.x;
            v2.y += m2 * this.impulse3.y;
            w2 += i2 * (r2X * this.impulse3.y - r2Y * this.impulse3.x + this.impulse3.z)
        } else {
            tMat = bA.m_xf.R;
            r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
            r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
            tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
            r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
            r1X = tX;
            tMat = bB.m_xf.R;
            r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
            r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
            tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
            r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
            r2X = tX;
            var CdotX = v2.x + -w2 * r2Y - v1.x - -w1 * r1Y;
            var CdotY = v2.y + w2 * r2X - v1.y - w1 * r1X;
            this.m_mass.Solve22(this.impulse2, -CdotX, -CdotY);
            this.m_impulse.x += this.impulse2.x;
            this.m_impulse.y += this.impulse2.y;
            v1.x -= m1 * this.impulse2.x;
            v1.y -= m1 * this.impulse2.y;
            w1 -= i1 * (r1X * this.impulse2.y - r1Y * this.impulse2.x);
            v2.x += m2 * this.impulse2.x;
            v2.y += m2 * this.impulse2.y;
            w2 += i2 * (r2X * this.impulse2.y - r2Y * this.impulse2.x)
        }
        bA.m_linearVelocity.SetV(v1);
        bA.m_angularVelocity = w1;
        bB.m_linearVelocity.SetV(v2);
        bB.m_angularVelocity = w2
    };
    b2RevoluteJoint.prototype.SolvePositionConstraints = function(baumgarte) {
        var oldLimitImpulse;
        var C;
        var tMat;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var angularError = 0;
        var positionError = 0;
        var tX;
        var impulseX;
        var impulseY;
        if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
            var angle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
            var limitImpulse = 0;
            if (this.m_limitState == b2Joint.e_equalLimits) {
                C = b2Math.Clamp(angle - this.m_lowerAngle, -b2Settings.b2_maxAngularCorrection, b2Settings.b2_maxAngularCorrection);
                limitImpulse = -this.m_motorMass * C;
                angularError = b2Math.Abs(C)
            } else if (this.m_limitState == b2Joint.e_atLowerLimit) {
                C = angle - this.m_lowerAngle;
                angularError = -C;
                C = b2Math.Clamp(C + b2Settings.b2_angularSlop, -b2Settings.b2_maxAngularCorrection, 0);
                limitImpulse = -this.m_motorMass * C
            } else if (this.m_limitState == b2Joint.e_atUpperLimit) {
                C = angle - this.m_upperAngle;
                angularError = C;
                C = b2Math.Clamp(C - b2Settings.b2_angularSlop, 0, b2Settings.b2_maxAngularCorrection);
                limitImpulse = -this.m_motorMass * C
            }
            bA.m_sweep.a -= bA.m_invI * limitImpulse;
            bB.m_sweep.a += bB.m_invI * limitImpulse;
            bA.SynchronizeTransform();
            bB.SynchronizeTransform()
        } {
            tMat = bA.m_xf.R;
            var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
            var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
            tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
            r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
            r1X = tX;
            tMat = bB.m_xf.R;
            var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
            var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
            tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
            r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
            r2X = tX;
            var CX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
            var CY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
            var CLengthSquared = CX * CX + CY * CY;
            var CLength = Math.sqrt(CLengthSquared);
            positionError = CLength;
            var invMass1 = bA.m_invMass;
            var invMass2 = bB.m_invMass;
            var invI1 = bA.m_invI;
            var invI2 = bB.m_invI;
            var k_allowedStretch = 10 * b2Settings.b2_linearSlop;
            if (CLengthSquared > k_allowedStretch * k_allowedStretch) {
                var uX = CX / CLength;
                var uY = CY / CLength;
                var k = invMass1 + invMass2;
                var m = 1 / k;
                impulseX = m * -CX;
                impulseY = m * -CY;
                var k_beta = .5;
                bA.m_sweep.c.x -= k_beta * invMass1 * impulseX;
                bA.m_sweep.c.y -= k_beta * invMass1 * impulseY;
                bB.m_sweep.c.x += k_beta * invMass2 * impulseX;
                bB.m_sweep.c.y += k_beta * invMass2 * impulseY;
                CX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
                CY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y
            }
            this.K1.col1.x = invMass1 + invMass2;
            this.K1.col2.x = 0;
            this.K1.col1.y = 0;
            this.K1.col2.y = invMass1 + invMass2;
            this.K2.col1.x = invI1 * r1Y * r1Y;
            this.K2.col2.x = -invI1 * r1X * r1Y;
            this.K2.col1.y = -invI1 * r1X * r1Y;
            this.K2.col2.y = invI1 * r1X * r1X;
            this.K3.col1.x = invI2 * r2Y * r2Y;
            this.K3.col2.x = -invI2 * r2X * r2Y;
            this.K3.col1.y = -invI2 * r2X * r2Y;
            this.K3.col2.y = invI2 * r2X * r2X;
            this.K.SetM(this.K1);
            this.K.AddM(this.K2);
            this.K.AddM(this.K3);
            this.K.Solve(b2RevoluteJoint.tImpulse, -CX, -CY);
            impulseX = b2RevoluteJoint.tImpulse.x;
            impulseY = b2RevoluteJoint.tImpulse.y;
            bA.m_sweep.c.x -= bA.m_invMass * impulseX;
            bA.m_sweep.c.y -= bA.m_invMass * impulseY;
            bA.m_sweep.a -= bA.m_invI * (r1X * impulseY - r1Y * impulseX);
            bB.m_sweep.c.x += bB.m_invMass * impulseX;
            bB.m_sweep.c.y += bB.m_invMass * impulseY;
            bB.m_sweep.a += bB.m_invI * (r2X * impulseY - r2Y * impulseX);
            bA.SynchronizeTransform();
            bB.SynchronizeTransform()
        }
        return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop
    };
    b2RevoluteJoint.prototype.GetAnchorA = function() {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
    };
    b2RevoluteJoint.prototype.GetAnchorB = function() {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
    };
    b2RevoluteJoint.prototype.GetReactionForce = function(inv_dt) {
        return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y)
    };
    b2RevoluteJoint.prototype.GetReactionTorque = function(inv_dt) {
        return inv_dt * this.m_impulse.z
    };
    b2RevoluteJoint.prototype.GetJointAngle = function() {
        return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle
    };
    b2RevoluteJoint.prototype.GetJointSpeed = function() {
        return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity
    };
    b2RevoluteJoint.prototype.IsLimitEnabled = function() {
        return this.m_enableLimit
    };
    b2RevoluteJoint.prototype.EnableLimit = function(flag) {
        this.m_enableLimit = flag
    };
    b2RevoluteJoint.prototype.GetLowerLimit = function() {
        return this.m_lowerAngle
    };
    b2RevoluteJoint.prototype.GetUpperLimit = function() {
        return this.m_upperAngle
    };
    b2RevoluteJoint.prototype.SetLimits = function(lower, upper) {
        this.m_lowerAngle = lower;
        this.m_upperAngle = upper
    };
    b2RevoluteJoint.prototype.IsMotorEnabled = function() {
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        return this.m_enableMotor
    };
    b2RevoluteJoint.prototype.EnableMotor = function(flag) {
        this.m_enableMotor = flag
    };
    b2RevoluteJoint.prototype.SetMotorSpeed = function(speed) {
        this.m_bodyA.SetAwake(true);
        this.m_bodyB.SetAwake(true);
        this.m_motorSpeed = speed
    };
    b2RevoluteJoint.prototype.GetMotorSpeed = function() {
        return this.m_motorSpeed
    };
    b2RevoluteJoint.prototype.SetMaxMotorTorque = function(torque) {
        this.m_maxMotorTorque = torque
    };
    b2RevoluteJoint.prototype.GetMotorTorque = function() {
        return this.m_maxMotorTorque
    };
    b2RevoluteJoint.prototype.K = new b2Mat22;
    b2RevoluteJoint.prototype.K1 = new b2Mat22;
    b2RevoluteJoint.prototype.K2 = new b2Mat22;
    b2RevoluteJoint.prototype.K3 = new b2Mat22;
    b2RevoluteJoint.prototype.impulse3 = new b2Vec3;
    b2RevoluteJoint.prototype.impulse2 = new b2Vec2;
    b2RevoluteJoint.prototype.reduced = new b2Vec2;
    b2RevoluteJoint.prototype.m_localAnchor1 = new b2Vec2;
    b2RevoluteJoint.prototype.m_localAnchor2 = new b2Vec2;
    b2RevoluteJoint.prototype.m_impulse = new b2Vec3;
    b2RevoluteJoint.prototype.m_motorImpulse = null;
    b2RevoluteJoint.prototype.m_mass = new b2Mat33;
    b2RevoluteJoint.prototype.m_motorMass = null;
    b2RevoluteJoint.prototype.m_enableMotor = null;
    b2RevoluteJoint.prototype.m_maxMotorTorque = null;
    b2RevoluteJoint.prototype.m_motorSpeed = null;
    b2RevoluteJoint.prototype.m_enableLimit = null;
    b2RevoluteJoint.prototype.m_referenceAngle = null;
    b2RevoluteJoint.prototype.m_lowerAngle = null;
    b2RevoluteJoint.prototype.m_upperAngle = null;
    b2RevoluteJoint.prototype.m_limitState = 0;
    var b2RopeJoint = function() {
        b2Joint.prototype.__varz.call(this);
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    extend(b2RopeJoint.prototype, b2Joint.prototype);
    b2RopeJoint.prototype._super = b2Joint.prototype;
    b2RopeJoint.prototype.__constructor = function(def) {
        this._super.__constructor.apply(this, [def]);
        var tMat;
        var tX;
        var tY;
        this.m_localAnchor1.SetV(def.localAnchorA);
        this.m_localAnchor2.SetV(def.localAnchorB);
        this.m_maxLength = def.maxLength;
        this.m_mass = 0;
        this.m_impulse = 0;
        this.m_state = b2Joint.e_inactiveLimit;
        this.m_length = 0
    };
    b2RopeJoint.prototype.__varz = function() {
        this.m_localAnchor1 = new b2Vec2;
        this.m_localAnchor2 = new b2Vec2;
        this.m_u = new b2Vec2
    };
    b2RopeJoint.tImpulse = new b2Vec2;
    b2RopeJoint.prototype.InitVelocityConstraints = function(step) {
        var tMat;
        var tX;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
        var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
        tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
        r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
        var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
        tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
        r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
        r2X = tX;
        this.m_u.x = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
        this.m_u.y = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
        this.m_length = Math.sqrt(this.m_u.x * this.m_u.x + this.m_u.y * this.m_u.y);
        var C = this.m_length - this.m_maxLength;
        if (C > 0) {
            this.m_state = b2Joint.e_atUpperLimit
        } else {
            this.m_state = b2Joint.e_inactiveLimit
        }
        if (this.m_length > b2Settings.b2_linearSlop) {
            this.m_u.Multiply(1 / this.m_length)
        } else {
            this.m_u.SetZero();
            this.m_mass = 0;
            this.m_impulse = 0;
            return
        }
        var cr1u = r1X * this.m_u.y - r1Y * this.m_u.x;
        var cr2u = r2X * this.m_u.y - r2Y * this.m_u.x;
        var invMass = bA.m_invMass + bA.m_invI * cr1u * cr1u + bB.m_invMass + bB.m_invI * cr2u * cr2u;
        this.m_mass = invMass != 0 ? 1 / invMass : 0;
        if (step.warmStarting) {
            this.m_impulse *= step.dtRatio;
            var PX = this.m_impulse * this.m_u.x;
            var PY = this.m_impulse * this.m_u.y;
            bA.m_linearVelocity.x -= bA.m_invMass * PX;
            bA.m_linearVelocity.y -= bA.m_invMass * PY;
            bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
            bB.m_linearVelocity.x += bB.m_invMass * PX;
            bB.m_linearVelocity.y += bB.m_invMass * PY;
            bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX)
        } else {
            this.m_impulse = 0
        }
    };
    b2RopeJoint.prototype.SolveVelocityConstraints = function(step) {
        var tMat;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
        var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
        var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
        r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
        var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
        tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
        r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
        r2X = tX;
        var v1X = bA.m_linearVelocity.x + -bA.m_angularVelocity * r1Y;
        var v1Y = bA.m_linearVelocity.y + bA.m_angularVelocity * r1X;
        var v2X = bB.m_linearVelocity.x + -bB.m_angularVelocity * r2Y;
        var v2Y = bB.m_linearVelocity.y + bB.m_angularVelocity * r2X;
        var Cdot = this.m_u.x * (v2X - v1X) + this.m_u.y * (v2Y - v1Y);
        var C = this.m_length - this.m_maxLength;
        if (Cdot < 0) {
            Cdot += step.inv_dt * C
        }
        var impulse = -this.m_mass * Cdot;
        var oldImpulse = this.m_impulse;
        if (0 < this.m_impulse + impulse) {
            this.m_impulse = 0
        } else {
            this.m_impulse = this.m_impulse + impulse
        }
        impulse = this.m_impulse - oldImpulse;
        var PX = impulse * this.m_u.x;
        var PY = impulse * this.m_u.y;
        bA.m_linearVelocity.x -= bA.m_invMass * PX;
        bA.m_linearVelocity.y -= bA.m_invMass * PY;
        bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
        bB.m_linearVelocity.x += bB.m_invMass * PX;
        bB.m_linearVelocity.y += bB.m_invMass * PY;
        bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX)
    };
    b2RopeJoint.prototype.SolvePositionConstraints = function(baumgarte) {
        var tMat;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
        var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
        var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
        r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
        var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
        tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
        r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
        r2X = tX;
        var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
        var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
        var length = Math.sqrt(dX * dX + dY * dY);
        dX /= length;
        dY /= length;
        var C = length - this.m_maxLength;
        C = b2Math.Clamp(C, 0, b2Settings.b2_maxLinearCorrection);
        var impulse = -this.m_mass * C;
        this.m_u.Set(dX, dY);
        var PX = impulse * this.m_u.x;
        var PY = impulse * this.m_u.y;
        bA.m_sweep.c.x -= bA.m_invMass * PX;
        bA.m_sweep.c.y -= bA.m_invMass * PY;
        bA.m_sweep.a -= bA.m_invI * (r1X * PY - r1Y * PX);
        bB.m_sweep.c.x += bB.m_invMass * PX;
        bB.m_sweep.c.y += bB.m_invMass * PY;
        bB.m_sweep.a += bB.m_invI * (r2X * PY - r2Y * PX);
        bA.SynchronizeTransform();
        bB.SynchronizeTransform();
        return length - this.m_maxLength < b2Settings.b2_linearSlop
    };
    b2RopeJoint.prototype.GetAnchorA = function() {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
    };
    b2RopeJoint.prototype.GetAnchorB = function() {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
    };
    b2RopeJoint.prototype.GetReactionForce = function(inv_dt) {
        return new b2Vec2(inv_dt * this.m_impulse * this.m_u.x, inv_dt * this.m_impulse * this.m_u.y)
    };
    b2RopeJoint.prototype.GetReactionTorque = function(inv_dt) {
        return 0
    };
    b2RopeJoint.prototype.GetMaxLength = function() {
        return this.m_maxLength
    };
    b2RopeJoint.prototype.GetLimitState = function() {
        return this.m_state
    };
    b2RopeJoint.prototype.m_localAnchor1 = new b2Vec2;
    b2RopeJoint.prototype.m_localAnchor2 = new b2Vec2;
    b2RopeJoint.prototype.m_u = new b2Vec2;
    b2RopeJoint.prototype.m_maxLength = null;
    b2RopeJoint.prototype.m_mass = null;
    b2RopeJoint.prototype.m_impulse = null;
    b2RopeJoint.prototype.m_state = null;
    b2RopeJoint.prototype.m_length = null;
    var b2JointDef = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2JointDef.prototype.__constructor = function() {
        this.type = b2Joint.e_unknownJoint;
        this.userData = null;
        this.bodyA = null;
        this.bodyB = null;
        this.collideConnected = false
    };
    b2JointDef.prototype.__varz = function() {};
    b2JointDef.prototype.type = 0;
    b2JointDef.prototype.userData = null;
    b2JointDef.prototype.bodyA = null;
    b2JointDef.prototype.bodyB = null;
    b2JointDef.prototype.collideConnected = null;
    var b2LineJointDef = function() {
        b2JointDef.prototype.__varz.call(this);
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    extend(b2LineJointDef.prototype, b2JointDef.prototype);
    b2LineJointDef.prototype._super = b2JointDef.prototype;
    b2LineJointDef.prototype.__constructor = function() {
        this._super.__constructor.apply(this, arguments);
        this.type = b2Joint.e_lineJoint;
        this.localAxisA.Set(1, 0);
        this.enableLimit = false;
        this.lowerTranslation = 0;
        this.upperTranslation = 0;
        this.enableMotor = false;
        this.maxMotorForce = 0;
        this.motorSpeed = 0
    };
    b2LineJointDef.prototype.__varz = function() {
        this.localAnchorA = new b2Vec2;
        this.localAnchorB = new b2Vec2;
        this.localAxisA = new b2Vec2
    };
    b2LineJointDef.prototype.Initialize = function(bA, bB, anchor, axis) {
        this.bodyA = bA;
        this.bodyB = bB;
        this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
        this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
        this.localAxisA = this.bodyA.GetLocalVector(axis)
    };
    b2LineJointDef.prototype.localAnchorA = new b2Vec2;
    b2LineJointDef.prototype.localAnchorB = new b2Vec2;
    b2LineJointDef.prototype.localAxisA = new b2Vec2;
    b2LineJointDef.prototype.enableLimit = null;
    b2LineJointDef.prototype.lowerTranslation = null;
    b2LineJointDef.prototype.upperTranslation = null;
    b2LineJointDef.prototype.enableMotor = null;
    b2LineJointDef.prototype.maxMotorForce = null;
    b2LineJointDef.prototype.motorSpeed = null;
    var b2DistanceJoint = function() {
        b2Joint.prototype.__varz.call(this);
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    extend(b2DistanceJoint.prototype, b2Joint.prototype);
    b2DistanceJoint.prototype._super = b2Joint.prototype;
    b2DistanceJoint.prototype.__constructor = function(def) {
        this._super.__constructor.apply(this, [def]);
        var tMat;
        var tX;
        var tY;
        this.m_localAnchor1.SetV(def.localAnchorA);
        this.m_localAnchor2.SetV(def.localAnchorB);
        this.m_length = def.length;
        this.m_frequencyHz = def.frequencyHz;
        this.m_dampingRatio = def.dampingRatio;
        this.m_impulse = 0;
        this.m_gamma = 0;
        this.m_bias = 0
    };
    b2DistanceJoint.prototype.__varz = function() {
        this.m_localAnchor1 = new b2Vec2;
        this.m_localAnchor2 = new b2Vec2;
        this.m_u = new b2Vec2
    };
    b2DistanceJoint.prototype.InitVelocityConstraints = function(step) {
        var tMat;
        var tX;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
        var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
        tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
        r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
        var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
        tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
        r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
        r2X = tX;
        this.m_u.x = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
        this.m_u.y = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
        var length = Math.sqrt(this.m_u.x * this.m_u.x + this.m_u.y * this.m_u.y);
        if (length > b2Settings.b2_linearSlop) {
            this.m_u.Multiply(1 / length)
        } else {
            this.m_u.SetZero()
        }
        var cr1u = r1X * this.m_u.y - r1Y * this.m_u.x;
        var cr2u = r2X * this.m_u.y - r2Y * this.m_u.x;
        var invMass = bA.m_invMass + bA.m_invI * cr1u * cr1u + bB.m_invMass + bB.m_invI * cr2u * cr2u;
        this.m_mass = invMass != 0 ? 1 / invMass : 0;
        if (this.m_frequencyHz > 0) {
            var C = length - this.m_length;
            var omega = 2 * Math.PI * this.m_frequencyHz;
            var d = 2 * this.m_mass * this.m_dampingRatio * omega;
            var k = this.m_mass * omega * omega;
            this.m_gamma = step.dt * (d + step.dt * k);
            this.m_gamma = this.m_gamma != 0 ? 1 / this.m_gamma : 0;
            this.m_bias = C * step.dt * k * this.m_gamma;
            this.m_mass = invMass + this.m_gamma;
            this.m_mass = this.m_mass != 0 ? 1 / this.m_mass : 0
        }
        if (step.warmStarting) {
            this.m_impulse *= step.dtRatio;
            var PX = this.m_impulse * this.m_u.x;
            var PY = this.m_impulse * this.m_u.y;
            bA.m_linearVelocity.x -= bA.m_invMass * PX;
            bA.m_linearVelocity.y -= bA.m_invMass * PY;
            bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
            bB.m_linearVelocity.x += bB.m_invMass * PX;
            bB.m_linearVelocity.y += bB.m_invMass * PY;
            bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX)
        } else {
            this.m_impulse = 0
        }
    };
    b2DistanceJoint.prototype.SolveVelocityConstraints = function(step) {
        var tMat;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
        var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
        var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
        r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
        var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
        tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
        r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
        r2X = tX;
        var v1X = bA.m_linearVelocity.x + -bA.m_angularVelocity * r1Y;
        var v1Y = bA.m_linearVelocity.y + bA.m_angularVelocity * r1X;
        var v2X = bB.m_linearVelocity.x + -bB.m_angularVelocity * r2Y;
        var v2Y = bB.m_linearVelocity.y + bB.m_angularVelocity * r2X;
        var Cdot = this.m_u.x * (v2X - v1X) + this.m_u.y * (v2Y - v1Y);
        var impulse = -this.m_mass * (Cdot + this.m_bias + this.m_gamma * this.m_impulse);
        this.m_impulse += impulse;
        var PX = impulse * this.m_u.x;
        var PY = impulse * this.m_u.y;
        bA.m_linearVelocity.x -= bA.m_invMass * PX;
        bA.m_linearVelocity.y -= bA.m_invMass * PY;
        bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
        bB.m_linearVelocity.x += bB.m_invMass * PX;
        bB.m_linearVelocity.y += bB.m_invMass * PY;
        bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX)
    };
    b2DistanceJoint.prototype.SolvePositionConstraints = function(baumgarte) {
        var tMat;
        if (this.m_frequencyHz > 0) {
            return true
        }
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        tMat = bA.m_xf.R;
        var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
        var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
        var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
        r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
        r1X = tX;
        tMat = bB.m_xf.R;
        var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
        var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
        tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
        r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
        r2X = tX;
        var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
        var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
        var length = Math.sqrt(dX * dX + dY * dY);
        dX /= length;
        dY /= length;
        var C = length - this.m_length;
        C = b2Math.Clamp(C, -b2Settings.b2_maxLinearCorrection, b2Settings.b2_maxLinearCorrection);
        var impulse = -this.m_mass * C;
        this.m_u.Set(dX, dY);
        var PX = impulse * this.m_u.x;
        var PY = impulse * this.m_u.y;
        bA.m_sweep.c.x -= bA.m_invMass * PX;
        bA.m_sweep.c.y -= bA.m_invMass * PY;
        bA.m_sweep.a -= bA.m_invI * (r1X * PY - r1Y * PX);
        bB.m_sweep.c.x += bB.m_invMass * PX;
        bB.m_sweep.c.y += bB.m_invMass * PY;
        bB.m_sweep.a += bB.m_invI * (r2X * PY - r2Y * PX);
        bA.SynchronizeTransform();
        bB.SynchronizeTransform();
        return b2Math.Abs(C) < b2Settings.b2_linearSlop
    };
    b2DistanceJoint.prototype.GetAnchorA = function() {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
    };
    b2DistanceJoint.prototype.GetAnchorB = function() {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
    };
    b2DistanceJoint.prototype.GetReactionForce = function(inv_dt) {
        return new b2Vec2(inv_dt * this.m_impulse * this.m_u.x, inv_dt * this.m_impulse * this.m_u.y)
    };
    b2DistanceJoint.prototype.GetReactionTorque = function(inv_dt) {
        return 0
    };
    b2DistanceJoint.prototype.GetLength = function() {
        return this.m_length
    };
    b2DistanceJoint.prototype.SetLength = function(length) {
        this.m_length = length
    };
    b2DistanceJoint.prototype.GetFrequency = function() {
        return this.m_frequencyHz
    };
    b2DistanceJoint.prototype.SetFrequency = function(hz) {
        this.m_frequencyHz = hz
    };
    b2DistanceJoint.prototype.GetDampingRatio = function() {
        return this.m_dampingRatio
    };
    b2DistanceJoint.prototype.SetDampingRatio = function(ratio) {
        this.m_dampingRatio = ratio
    };
    b2DistanceJoint.prototype.m_localAnchor1 = new b2Vec2;
    b2DistanceJoint.prototype.m_localAnchor2 = new b2Vec2;
    b2DistanceJoint.prototype.m_u = new b2Vec2;
    b2DistanceJoint.prototype.m_frequencyHz = null;
    b2DistanceJoint.prototype.m_dampingRatio = null;
    b2DistanceJoint.prototype.m_gamma = null;
    b2DistanceJoint.prototype.m_bias = null;
    b2DistanceJoint.prototype.m_impulse = null;
    b2DistanceJoint.prototype.m_mass = null;
    b2DistanceJoint.prototype.m_length = null;
    var b2PulleyJointDef = function() {
        b2JointDef.prototype.__varz.call(this);
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    extend(b2PulleyJointDef.prototype, b2JointDef.prototype);
    b2PulleyJointDef.prototype._super = b2JointDef.prototype;
    b2PulleyJointDef.prototype.__constructor = function() {
        this._super.__constructor.apply(this, arguments);
        this.type = b2Joint.e_pulleyJoint;
        this.groundAnchorA.Set(-1, 1);
        this.groundAnchorB.Set(1, 1);
        this.localAnchorA.Set(-1, 0);
        this.localAnchorB.Set(1, 0);
        this.lengthA = 0;
        this.maxLengthA = 0;
        this.lengthB = 0;
        this.maxLengthB = 0;
        this.ratio = 1;
        this.collideConnected = true
    };
    b2PulleyJointDef.prototype.__varz = function() {
        this.groundAnchorA = new b2Vec2;
        this.groundAnchorB = new b2Vec2;
        this.localAnchorA = new b2Vec2;
        this.localAnchorB = new b2Vec2
    };
    b2PulleyJointDef.prototype.Initialize = function(bA, bB, gaA, gaB, anchorA, anchorB, r) {
        this.bodyA = bA;
        this.bodyB = bB;
        this.groundAnchorA.SetV(gaA);
        this.groundAnchorB.SetV(gaB);
        this.localAnchorA = this.bodyA.GetLocalPoint(anchorA);
        this.localAnchorB = this.bodyB.GetLocalPoint(anchorB);
        var d1X = anchorA.x - gaA.x;
        var d1Y = anchorA.y - gaA.y;
        this.lengthA = Math.sqrt(d1X * d1X + d1Y * d1Y);
        var d2X = anchorB.x - gaB.x;
        var d2Y = anchorB.y - gaB.y;
        this.lengthB = Math.sqrt(d2X * d2X + d2Y * d2Y);
        this.ratio = r;
        var C = this.lengthA + this.ratio * this.lengthB;
        this.maxLengthA = C - this.ratio * b2PulleyJoint.b2_minPulleyLength;
        this.maxLengthB = (C - b2PulleyJoint.b2_minPulleyLength) / this.ratio
    };
    b2PulleyJointDef.prototype.groundAnchorA = new b2Vec2;
    b2PulleyJointDef.prototype.groundAnchorB = new b2Vec2;
    b2PulleyJointDef.prototype.localAnchorA = new b2Vec2;
    b2PulleyJointDef.prototype.localAnchorB = new b2Vec2;
    b2PulleyJointDef.prototype.lengthA = null;
    b2PulleyJointDef.prototype.maxLengthA = null;
    b2PulleyJointDef.prototype.lengthB = null;
    b2PulleyJointDef.prototype.maxLengthB = null;
    b2PulleyJointDef.prototype.ratio = null;
    var b2DistanceJointDef = function() {
        b2JointDef.prototype.__varz.call(this);
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    extend(b2DistanceJointDef.prototype, b2JointDef.prototype);
    b2DistanceJointDef.prototype._super = b2JointDef.prototype;
    b2DistanceJointDef.prototype.__constructor = function() {
        this._super.__constructor.apply(this, arguments);
        this.type = b2Joint.e_distanceJoint;
        this.length = 1;
        this.frequencyHz = 0;
        this.dampingRatio = 0
    };
    b2DistanceJointDef.prototype.__varz = function() {
        this.localAnchorA = new b2Vec2;
        this.localAnchorB = new b2Vec2
    };
    b2DistanceJointDef.prototype.Initialize = function(bA, bB, anchorA, anchorB) {
        this.bodyA = bA;
        this.bodyB = bB;
        this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchorA));
        this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchorB));
        var dX = anchorB.x - anchorA.x;
        var dY = anchorB.y - anchorA.y;
        this.length = Math.sqrt(dX * dX + dY * dY);
        this.frequencyHz = 0;
        this.dampingRatio = 0
    };
    b2DistanceJointDef.prototype.localAnchorA = new b2Vec2;
    b2DistanceJointDef.prototype.localAnchorB = new b2Vec2;
    b2DistanceJointDef.prototype.length = null;
    b2DistanceJointDef.prototype.frequencyHz = null;
    b2DistanceJointDef.prototype.dampingRatio = null;
    var b2FrictionJointDef = function() {
        b2JointDef.prototype.__varz.call(this);
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    extend(b2FrictionJointDef.prototype, b2JointDef.prototype);
    b2FrictionJointDef.prototype._super = b2JointDef.prototype;
    b2FrictionJointDef.prototype.__constructor = function() {
        this._super.__constructor.apply(this, arguments);
        this.type = b2Joint.e_frictionJoint;
        this.maxForce = 0;
        this.maxTorque = 0
    };
    b2FrictionJointDef.prototype.__varz = function() {
        this.localAnchorA = new b2Vec2;
        this.localAnchorB = new b2Vec2
    };
    b2FrictionJointDef.prototype.Initialize = function(bA, bB, anchor) {
        this.bodyA = bA;
        this.bodyB = bB;
        this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
        this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor))
    };
    b2FrictionJointDef.prototype.localAnchorA = new b2Vec2;
    b2FrictionJointDef.prototype.localAnchorB = new b2Vec2;
    b2FrictionJointDef.prototype.maxForce = null;
    b2FrictionJointDef.prototype.maxTorque = null;
    var b2WeldJointDef = function() {
        b2JointDef.prototype.__varz.call(this);
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    extend(b2WeldJointDef.prototype, b2JointDef.prototype);
    b2WeldJointDef.prototype._super = b2JointDef.prototype;
    b2WeldJointDef.prototype.__constructor = function() {
        this._super.__constructor.apply(this, arguments);
        this.type = b2Joint.e_weldJoint;
        this.referenceAngle = 0
    };
    b2WeldJointDef.prototype.__varz = function() {
        this.localAnchorA = new b2Vec2;
        this.localAnchorB = new b2Vec2
    };
    b2WeldJointDef.prototype.Initialize = function(bA, bB, anchor) {
        this.bodyA = bA;
        this.bodyB = bB;
        this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
        this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor));
        this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()
    };
    b2WeldJointDef.prototype.localAnchorA = new b2Vec2;
    b2WeldJointDef.prototype.localAnchorB = new b2Vec2;
    b2WeldJointDef.prototype.referenceAngle = null;
    var b2GearJointDef = function() {
        b2JointDef.prototype.__varz.call(this);
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    extend(b2GearJointDef.prototype, b2JointDef.prototype);
    b2GearJointDef.prototype._super = b2JointDef.prototype;
    b2GearJointDef.prototype.__constructor = function() {
        this._super.__constructor.apply(this, arguments);
        this.type = b2Joint.e_gearJoint;
        this.joint1 = null;
        this.joint2 = null;
        this.ratio = 1
    };
    b2GearJointDef.prototype.__varz = function() {};
    b2GearJointDef.prototype.joint1 = null;
    b2GearJointDef.prototype.joint2 = null;
    b2GearJointDef.prototype.ratio = null;
    var b2Color = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2Color.prototype.__constructor = function(rr, gg, bb) {
        this._r = parseInt(255 * b2Math.Clamp(rr, 0, 1));
        this._g = parseInt(255 * b2Math.Clamp(gg, 0, 1));
        this._b = parseInt(255 * b2Math.Clamp(bb, 0, 1))
    };
    b2Color.prototype.__varz = function() {};
    b2Color.prototype.Set = function(rr, gg, bb) {
        this._r = parseInt(255 * b2Math.Clamp(rr, 0, 1));
        this._g = parseInt(255 * b2Math.Clamp(gg, 0, 1));
        this._b = parseInt(255 * b2Math.Clamp(bb, 0, 1))
    };
    b2Color.prototype.__defineGetter__("r", function() {
        return this._r
    });
    b2Color.prototype.__defineSetter__("r", function(rr) {
        this._r = parseInt(255 * b2Math.Clamp(rr, 0, 1))
    });
    b2Color.prototype.__defineGetter__("g", function() {
        return this._g
    });
    b2Color.prototype.__defineSetter__("g", function(gg) {
        this._g = parseInt(255 * b2Math.Clamp(gg, 0, 1))
    });
    b2Color.prototype.__defineGetter__("b", function() {
        return this._b
    });
    b2Color.prototype.__defineSetter__("b", function(bb) {
        this._b = parseInt(255 * b2Math.Clamp(bb, 0, 1))
    });
    b2Color.prototype.__defineGetter__("color", function() {
        return this._r << 16 | this._g << 8 | this._b
    });
    b2Color.prototype._r = 0;
    b2Color.prototype._g = 0;
    b2Color.prototype._b = 0;
    var b2FrictionJoint = function() {
        b2Joint.prototype.__varz.call(this);
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    extend(b2FrictionJoint.prototype, b2Joint.prototype);
    b2FrictionJoint.prototype._super = b2Joint.prototype;
    b2FrictionJoint.prototype.__constructor = function(def) {
        this._super.__constructor.apply(this, [def]);
        this.m_localAnchorA.SetV(def.localAnchorA);
        this.m_localAnchorB.SetV(def.localAnchorB);
        this.m_linearMass.SetZero();
        this.m_angularMass = 0;
        this.m_linearImpulse.SetZero();
        this.m_angularImpulse = 0;
        this.m_maxForce = def.maxForce;
        this.m_maxTorque = def.maxTorque
    };
    b2FrictionJoint.prototype.__varz = function() {
        this.m_localAnchorA = new b2Vec2;
        this.m_localAnchorB = new b2Vec2;
        this.m_linearImpulse = new b2Vec2;
        this.m_linearMass = new b2Mat22
    };
    b2FrictionJoint.prototype.InitVelocityConstraints = function(step) {
        var tMat;
        var tX;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        tMat = bA.m_xf.R;
        var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
        var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
        tX = tMat.col1.x * rAX + tMat.col2.x * rAY;
        rAY = tMat.col1.y * rAX + tMat.col2.y * rAY;
        rAX = tX;
        tMat = bB.m_xf.R;
        var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
        var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
        tX = tMat.col1.x * rBX + tMat.col2.x * rBY;
        rBY = tMat.col1.y * rBX + tMat.col2.y * rBY;
        rBX = tX;
        var mA = bA.m_invMass;
        var mB = bB.m_invMass;
        var iA = bA.m_invI;
        var iB = bB.m_invI;
        var K = new b2Mat22;
        K.col1.x = mA + mB;
        K.col2.x = 0;
        K.col1.y = 0;
        K.col2.y = mA + mB;
        K.col1.x += iA * rAY * rAY;
        K.col2.x += -iA * rAX * rAY;
        K.col1.y += -iA * rAX * rAY;
        K.col2.y += iA * rAX * rAX;
        K.col1.x += iB * rBY * rBY;
        K.col2.x += -iB * rBX * rBY;
        K.col1.y += -iB * rBX * rBY;
        K.col2.y += iB * rBX * rBX;
        K.GetInverse(this.m_linearMass);
        this.m_angularMass = iA + iB;
        if (this.m_angularMass > 0) {
            this.m_angularMass = 1 / this.m_angularMass
        }
        if (step.warmStarting) {
            this.m_linearImpulse.x *= step.dtRatio;
            this.m_linearImpulse.y *= step.dtRatio;
            this.m_angularImpulse *= step.dtRatio;
            var P = this.m_linearImpulse;
            bA.m_linearVelocity.x -= mA * P.x;
            bA.m_linearVelocity.y -= mA * P.y;
            bA.m_angularVelocity -= iA * (rAX * P.y - rAY * P.x + this.m_angularImpulse);
            bB.m_linearVelocity.x += mB * P.x;
            bB.m_linearVelocity.y += mB * P.y;
            bB.m_angularVelocity += iB * (rBX * P.y - rBY * P.x + this.m_angularImpulse)
        } else {
            this.m_linearImpulse.SetZero();
            this.m_angularImpulse = 0
        }
    };
    b2FrictionJoint.prototype.SolveVelocityConstraints = function(step) {
        var tMat;
        var tX;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var vA = bA.m_linearVelocity;
        var wA = bA.m_angularVelocity;
        var vB = bB.m_linearVelocity;
        var wB = bB.m_angularVelocity;
        var mA = bA.m_invMass;
        var mB = bB.m_invMass;
        var iA = bA.m_invI;
        var iB = bB.m_invI;
        tMat = bA.m_xf.R;
        var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
        var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
        tX = tMat.col1.x * rAX + tMat.col2.x * rAY;
        rAY = tMat.col1.y * rAX + tMat.col2.y * rAY;
        rAX = tX;
        tMat = bB.m_xf.R;
        var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
        var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
        tX = tMat.col1.x * rBX + tMat.col2.x * rBY;
        rBY = tMat.col1.y * rBX + tMat.col2.y * rBY;
        rBX = tX;
        var maxImpulse; {
            var Cdot = wB - wA;
            var impulse = -this.m_angularMass * Cdot;
            var oldImpulse = this.m_angularImpulse;
            maxImpulse = step.dt * this.m_maxTorque;
            this.m_angularImpulse = b2Math.Clamp(this.m_angularImpulse + impulse, -maxImpulse, maxImpulse);
            impulse = this.m_angularImpulse - oldImpulse;
            wA -= iA * impulse;
            wB += iB * impulse
        } {
            var CdotX = vB.x - wB * rBY - vA.x + wA * rAY;
            var CdotY = vB.y + wB * rBX - vA.y - wA * rAX;
            var impulseV = b2Math.MulMV(this.m_linearMass, new b2Vec2(-CdotX, -CdotY));
            var oldImpulseV = this.m_linearImpulse.Copy();
            this.m_linearImpulse.Add(impulseV);
            maxImpulse = step.dt * this.m_maxForce;
            if (this.m_linearImpulse.LengthSquared() > maxImpulse * maxImpulse) {
                this.m_linearImpulse.Normalize();
                this.m_linearImpulse.Multiply(maxImpulse)
            }
            impulseV = b2Math.SubtractVV(this.m_linearImpulse, oldImpulseV);
            vA.x -= mA * impulseV.x;
            vA.y -= mA * impulseV.y;
            wA -= iA * (rAX * impulseV.y - rAY * impulseV.x);
            vB.x += mB * impulseV.x;
            vB.y += mB * impulseV.y;
            wB += iB * (rBX * impulseV.y - rBY * impulseV.x)
        }
        bA.m_angularVelocity = wA;
        bB.m_angularVelocity = wB
    };
    b2FrictionJoint.prototype.SolvePositionConstraints = function(baumgarte) {
        return true
    };
    b2FrictionJoint.prototype.GetAnchorA = function() {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchorA)
    };
    b2FrictionJoint.prototype.GetAnchorB = function() {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchorB)
    };
    b2FrictionJoint.prototype.GetReactionForce = function(inv_dt) {
        return new b2Vec2(inv_dt * this.m_linearImpulse.x, inv_dt * this.m_linearImpulse.y)
    };
    b2FrictionJoint.prototype.GetReactionTorque = function(inv_dt) {
        return inv_dt * this.m_angularImpulse
    };
    b2FrictionJoint.prototype.SetMaxForce = function(force) {
        this.m_maxForce = force
    };
    b2FrictionJoint.prototype.GetMaxForce = function() {
        return this.m_maxForce
    };
    b2FrictionJoint.prototype.SetMaxTorque = function(torque) {
        this.m_maxTorque = torque
    };
    b2FrictionJoint.prototype.GetMaxTorque = function() {
        return this.m_maxTorque
    };
    b2FrictionJoint.prototype.m_localAnchorA = new b2Vec2;
    b2FrictionJoint.prototype.m_localAnchorB = new b2Vec2;
    b2FrictionJoint.prototype.m_linearImpulse = new b2Vec2;
    b2FrictionJoint.prototype.m_angularImpulse = null;
    b2FrictionJoint.prototype.m_maxForce = null;
    b2FrictionJoint.prototype.m_maxTorque = null;
    b2FrictionJoint.prototype.m_linearMass = new b2Mat22;
    b2FrictionJoint.prototype.m_angularMass = null;
    var b2Distance = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2Distance.prototype.__constructor = function() {};
    b2Distance.prototype.__varz = function() {};
    b2Distance.Distance = function(output, cache, input) {
        ++b2Distance.b2_gjkCalls;
        var proxyA = input.proxyA;
        var proxyB = input.proxyB;
        var transformA = input.transformA;
        var transformB = input.transformB;
        var simplex = b2Distance.s_simplex;
        simplex.ReadCache(cache, proxyA, transformA, proxyB, transformB);
        var vertices = simplex.m_vertices;
        var k_maxIters = 20;
        var saveA = b2Distance.s_saveA;
        var saveB = b2Distance.s_saveB;
        var saveCount = 0;
        var closestPoint = simplex.GetClosestPoint();
        var distanceSqr1 = closestPoint.LengthSquared();
        var distanceSqr2 = distanceSqr1;
        var i = 0;
        var p;
        var iter = 0;
        while (iter < k_maxIters) {
            saveCount = simplex.m_count;
            for (i = 0; i < saveCount; i++) {
                saveA[i] = vertices[i].indexA;
                saveB[i] = vertices[i].indexB
            }
            switch (simplex.m_count) {
                case 1:
                    break;
                case 2:
                    simplex.Solve2();
                    break;
                case 3:
                    simplex.Solve3();
                    break;
                default:
                    b2Settings.b2Assert(false)
            }
            if (simplex.m_count == 3) {
                break
            }
            p = simplex.GetClosestPoint();
            distanceSqr2 = p.LengthSquared();
            if (distanceSqr2 > distanceSqr1) {}
            distanceSqr1 = distanceSqr2;
            var d = simplex.GetSearchDirection();
            if (d.LengthSquared() < Number.MIN_VALUE * Number.MIN_VALUE) {
                break
            }
            var vertex = vertices[simplex.m_count];
            vertex.indexA = proxyA.GetSupport(b2Math.MulTMV(transformA.R, d.GetNegative()));
            vertex.wA = b2Math.MulX(transformA, proxyA.GetVertex(vertex.indexA));
            vertex.indexB = proxyB.GetSupport(b2Math.MulTMV(transformB.R, d));
            vertex.wB = b2Math.MulX(transformB, proxyB.GetVertex(vertex.indexB));
            vertex.w = b2Math.SubtractVV(vertex.wB, vertex.wA);
            ++iter;
            ++b2Distance.b2_gjkIters;
            var duplicate = false;
            for (i = 0; i < saveCount; i++) {
                if (vertex.indexA == saveA[i] && vertex.indexB == saveB[i]) {
                    duplicate = true;
                    break
                }
            }
            if (duplicate) {
                break
            }++simplex.m_count
        }
        b2Distance.b2_gjkMaxIters = b2Math.Max(b2Distance.b2_gjkMaxIters, iter);
        simplex.GetWitnessPoints(output.pointA, output.pointB);
        output.distance = b2Math.SubtractVV(output.pointA, output.pointB).Length();
        output.iterations = iter;
        simplex.WriteCache(cache);
        if (input.useRadii) {
            var rA = proxyA.m_radius;
            var rB = proxyB.m_radius;
            if (output.distance > rA + rB && output.distance > Number.MIN_VALUE) {
                output.distance -= rA + rB;
                var normal = b2Math.SubtractVV(output.pointB, output.pointA);
                normal.Normalize();
                output.pointA.x += rA * normal.x;
                output.pointA.y += rA * normal.y;
                output.pointB.x -= rB * normal.x;
                output.pointB.y -= rB * normal.y
            } else {
                p = new b2Vec2;
                p.x = .5 * (output.pointA.x + output.pointB.x);
                p.y = .5 * (output.pointA.y + output.pointB.y);
                output.pointA.x = output.pointB.x = p.x;
                output.pointA.y = output.pointB.y = p.y;
                output.distance = 0
            }
        }
    };
    b2Distance.b2_gjkCalls = 0;
    b2Distance.b2_gjkIters = 0;
    b2Distance.b2_gjkMaxIters = 0;
    b2Distance.s_simplex = new b2Simplex;
    b2Distance.s_saveA = new Array(3);
    b2Distance.s_saveB = new Array(3);
    var b2MouseJoint = function() {
        b2Joint.prototype.__varz.call(this);
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    extend(b2MouseJoint.prototype, b2Joint.prototype);
    b2MouseJoint.prototype._super = b2Joint.prototype;
    b2MouseJoint.prototype.__constructor = function(def) {
        this._super.__constructor.apply(this, [def]);
        this.m_target.SetV(def.target);
        var tX = this.m_target.x - this.m_bodyB.m_xf.position.x;
        var tY = this.m_target.y - this.m_bodyB.m_xf.position.y;
        var tMat = this.m_bodyB.m_xf.R;
        this.m_localAnchor.x = tX * tMat.col1.x + tY * tMat.col1.y;
        this.m_localAnchor.y = tX * tMat.col2.x + tY * tMat.col2.y;
        this.m_maxForce = def.maxForce;
        this.m_impulse.SetZero();
        this.m_frequencyHz = def.frequencyHz;
        this.m_dampingRatio = def.dampingRatio;
        this.m_beta = 0;
        this.m_gamma = 0
    };
    b2MouseJoint.prototype.__varz = function() {
        this.K = new b2Mat22;
        this.K1 = new b2Mat22;
        this.K2 = new b2Mat22;
        this.m_localAnchor = new b2Vec2;
        this.m_target = new b2Vec2;
        this.m_impulse = new b2Vec2;
        this.m_mass = new b2Mat22;
        this.m_C = new b2Vec2
    };
    b2MouseJoint.prototype.InitVelocityConstraints = function(step) {
        var b = this.m_bodyB;
        var mass = b.GetMass();
        var omega = 2 * Math.PI * this.m_frequencyHz;
        var d = 2 * mass * this.m_dampingRatio * omega;
        var k = mass * omega * omega;
        this.m_gamma = step.dt * (d + step.dt * k);
        this.m_gamma = this.m_gamma != 0 ? 1 / this.m_gamma : 0;
        this.m_beta = step.dt * k * this.m_gamma;
        var tMat;
        tMat = b.m_xf.R;
        var rX = this.m_localAnchor.x - b.m_sweep.localCenter.x;
        var rY = this.m_localAnchor.y - b.m_sweep.localCenter.y;
        var tX = tMat.col1.x * rX + tMat.col2.x * rY;
        rY = tMat.col1.y * rX + tMat.col2.y * rY;
        rX = tX;
        var invMass = b.m_invMass;
        var invI = b.m_invI;
        this.K1.col1.x = invMass;
        this.K1.col2.x = 0;
        this.K1.col1.y = 0;
        this.K1.col2.y = invMass;
        this.K2.col1.x = invI * rY * rY;
        this.K2.col2.x = -invI * rX * rY;
        this.K2.col1.y = -invI * rX * rY;
        this.K2.col2.y = invI * rX * rX;
        this.K.SetM(this.K1);
        this.K.AddM(this.K2);
        this.K.col1.x += this.m_gamma;
        this.K.col2.y += this.m_gamma;
        this.K.GetInverse(this.m_mass);
        this.m_C.x = b.m_sweep.c.x + rX - this.m_target.x;
        this.m_C.y = b.m_sweep.c.y + rY - this.m_target.y;
        b.m_angularVelocity *= .98;
        this.m_impulse.x *= step.dtRatio;
        this.m_impulse.y *= step.dtRatio;
        b.m_linearVelocity.x += invMass * this.m_impulse.x;
        b.m_linearVelocity.y += invMass * this.m_impulse.y;
        b.m_angularVelocity += invI * (rX * this.m_impulse.y - rY * this.m_impulse.x)
    };
    b2MouseJoint.prototype.SolveVelocityConstraints = function(step) {
        var b = this.m_bodyB;
        var tMat;
        var tX;
        var tY;
        tMat = b.m_xf.R;
        var rX = this.m_localAnchor.x - b.m_sweep.localCenter.x;
        var rY = this.m_localAnchor.y - b.m_sweep.localCenter.y;
        tX = tMat.col1.x * rX + tMat.col2.x * rY;
        rY = tMat.col1.y * rX + tMat.col2.y * rY;
        rX = tX;
        var CdotX = b.m_linearVelocity.x + -b.m_angularVelocity * rY;
        var CdotY = b.m_linearVelocity.y + b.m_angularVelocity * rX;
        tMat = this.m_mass;
        tX = CdotX + this.m_beta * this.m_C.x + this.m_gamma * this.m_impulse.x;
        tY = CdotY + this.m_beta * this.m_C.y + this.m_gamma * this.m_impulse.y;
        var impulseX = -(tMat.col1.x * tX + tMat.col2.x * tY);
        var impulseY = -(tMat.col1.y * tX + tMat.col2.y * tY);
        var oldImpulseX = this.m_impulse.x;
        var oldImpulseY = this.m_impulse.y;
        this.m_impulse.x += impulseX;
        this.m_impulse.y += impulseY;
        var maxImpulse = step.dt * this.m_maxForce;
        if (this.m_impulse.LengthSquared() > maxImpulse * maxImpulse) {
            this.m_impulse.Multiply(maxImpulse / this.m_impulse.Length())
        }
        impulseX = this.m_impulse.x - oldImpulseX;
        impulseY = this.m_impulse.y - oldImpulseY;
        b.m_linearVelocity.x += b.m_invMass * impulseX;
        b.m_linearVelocity.y += b.m_invMass * impulseY;
        b.m_angularVelocity += b.m_invI * (rX * impulseY - rY * impulseX)
    };
    b2MouseJoint.prototype.SolvePositionConstraints = function(baumgarte) {
        return true
    };
    b2MouseJoint.prototype.GetAnchorA = function() {
        return this.m_target
    };
    b2MouseJoint.prototype.GetAnchorB = function() {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor)
    };
    b2MouseJoint.prototype.GetReactionForce = function(inv_dt) {
        return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y)
    };
    b2MouseJoint.prototype.GetReactionTorque = function(inv_dt) {
        return 0
    };
    b2MouseJoint.prototype.GetTarget = function() {
        return this.m_target
    };
    b2MouseJoint.prototype.SetTarget = function(target) {
        if (this.m_bodyB.IsAwake() == false) {
            this.m_bodyB.SetAwake(true)
        }
        this.m_target = target
    };
    b2MouseJoint.prototype.GetMaxForce = function() {
        return this.m_maxForce
    };
    b2MouseJoint.prototype.SetMaxForce = function(maxForce) {
        this.m_maxForce = maxForce
    };
    b2MouseJoint.prototype.GetFrequency = function() {
        return this.m_frequencyHz
    };
    b2MouseJoint.prototype.SetFrequency = function(hz) {
        this.m_frequencyHz = hz
    };
    b2MouseJoint.prototype.GetDampingRatio = function() {
        return this.m_dampingRatio
    };
    b2MouseJoint.prototype.SetDampingRatio = function(ratio) {
        this.m_dampingRatio = ratio
    };
    b2MouseJoint.prototype.K = new b2Mat22;
    b2MouseJoint.prototype.K1 = new b2Mat22;
    b2MouseJoint.prototype.K2 = new b2Mat22;
    b2MouseJoint.prototype.m_localAnchor = new b2Vec2;
    b2MouseJoint.prototype.m_target = new b2Vec2;
    b2MouseJoint.prototype.m_impulse = new b2Vec2;
    b2MouseJoint.prototype.m_mass = new b2Mat22;
    b2MouseJoint.prototype.m_C = new b2Vec2;
    b2MouseJoint.prototype.m_maxForce = null;
    b2MouseJoint.prototype.m_frequencyHz = null;
    b2MouseJoint.prototype.m_dampingRatio = null;
    b2MouseJoint.prototype.m_beta = null;
    b2MouseJoint.prototype.m_gamma = null;
    var b2PrismaticJointDef = function() {
        b2JointDef.prototype.__varz.call(this);
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    extend(b2PrismaticJointDef.prototype, b2JointDef.prototype);
    b2PrismaticJointDef.prototype._super = b2JointDef.prototype;
    b2PrismaticJointDef.prototype.__constructor = function() {
        this._super.__constructor.apply(this, arguments);
        this.type = b2Joint.e_prismaticJoint;
        this.localAxisA.Set(1, 0);
        this.referenceAngle = 0;
        this.enableLimit = false;
        this.lowerTranslation = 0;
        this.upperTranslation = 0;
        this.enableMotor = false;
        this.maxMotorForce = 0;
        this.motorSpeed = 0
    };
    b2PrismaticJointDef.prototype.__varz = function() {
        this.localAnchorA = new b2Vec2;
        this.localAnchorB = new b2Vec2;
        this.localAxisA = new b2Vec2
    };
    b2PrismaticJointDef.prototype.Initialize = function(bA, bB, anchor, axis) {
        this.bodyA = bA;
        this.bodyB = bB;
        this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
        this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
        this.localAxisA = this.bodyA.GetLocalVector(axis);
        this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()
    };
    b2PrismaticJointDef.prototype.localAnchorA = new b2Vec2;
    b2PrismaticJointDef.prototype.localAnchorB = new b2Vec2;
    b2PrismaticJointDef.prototype.localAxisA = new b2Vec2;
    b2PrismaticJointDef.prototype.referenceAngle = null;
    b2PrismaticJointDef.prototype.enableLimit = null;
    b2PrismaticJointDef.prototype.lowerTranslation = null;
    b2PrismaticJointDef.prototype.upperTranslation = null;
    b2PrismaticJointDef.prototype.enableMotor = null;
    b2PrismaticJointDef.prototype.maxMotorForce = null;
    b2PrismaticJointDef.prototype.motorSpeed = null;
    var b2TimeOfImpact = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2TimeOfImpact.prototype.__constructor = function() {};
    b2TimeOfImpact.prototype.__varz = function() {};
    b2TimeOfImpact.TimeOfImpact = function(input) {
        ++b2TimeOfImpact.b2_toiCalls;
        var proxyA = input.proxyA;
        var proxyB = input.proxyB;
        var sweepA = input.sweepA;
        var sweepB = input.sweepB;
        b2Settings.b2Assert(sweepA.t0 == sweepB.t0);
        b2Settings.b2Assert(1 - sweepA.t0 > Number.MIN_VALUE);
        var radius = proxyA.m_radius + proxyB.m_radius;
        var tolerance = input.tolerance;
        var alpha = 0;
        var k_maxIterations = 1e3;
        var iter = 0;
        var target = 0;
        b2TimeOfImpact.s_cache.count = 0;
        b2TimeOfImpact.s_distanceInput.useRadii = false;
        for (;;) {
            sweepA.GetTransform(b2TimeOfImpact.s_xfA, alpha);
            sweepB.GetTransform(b2TimeOfImpact.s_xfB, alpha);
            b2TimeOfImpact.s_distanceInput.proxyA = proxyA;
            b2TimeOfImpact.s_distanceInput.proxyB = proxyB;
            b2TimeOfImpact.s_distanceInput.transformA = b2TimeOfImpact.s_xfA;
            b2TimeOfImpact.s_distanceInput.transformB = b2TimeOfImpact.s_xfB;
            b2Distance.Distance(b2TimeOfImpact.s_distanceOutput, b2TimeOfImpact.s_cache, b2TimeOfImpact.s_distanceInput);
            if (b2TimeOfImpact.s_distanceOutput.distance <= 0) {
                alpha = 1;
                break
            }
            b2TimeOfImpact.s_fcn.Initialize(b2TimeOfImpact.s_cache, proxyA, b2TimeOfImpact.s_xfA, proxyB, b2TimeOfImpact.s_xfB);
            var separation = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
            if (separation <= 0) {
                alpha = 1;
                break
            }
            if (iter == 0) {
                if (separation > radius) {
                    target = b2Math.Max(radius - tolerance, .75 * radius)
                } else {
                    target = b2Math.Max(separation - tolerance, .02 * radius)
                }
            }
            if (separation - target < .5 * tolerance) {
                if (iter == 0) {
                    alpha = 1;
                    break
                }
                break
            }
            var newAlpha = alpha; {
                var x1 = alpha;
                var x2 = 1;
                var f1 = separation;
                sweepA.GetTransform(b2TimeOfImpact.s_xfA, x2);
                sweepB.GetTransform(b2TimeOfImpact.s_xfB, x2);
                var f2 = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
                if (f2 >= target) {
                    alpha = 1;
                    break
                }
                var rootIterCount = 0;
                for (;;) {
                    var x;
                    if (rootIterCount & 1) {
                        x = x1 + (target - f1) * (x2 - x1) / (f2 - f1)
                    } else {
                        x = .5 * (x1 + x2)
                    }
                    sweepA.GetTransform(b2TimeOfImpact.s_xfA, x);
                    sweepB.GetTransform(b2TimeOfImpact.s_xfB, x);
                    var f = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
                    if (b2Math.Abs(f - target) < .025 * tolerance) {
                        newAlpha = x;
                        break
                    }
                    if (f > target) {
                        x1 = x;
                        f1 = f
                    } else {
                        x2 = x;
                        f2 = f
                    }++rootIterCount;
                    ++b2TimeOfImpact.b2_toiRootIters;
                    if (rootIterCount == 50) {
                        break
                    }
                }
                b2TimeOfImpact.b2_toiMaxRootIters = b2Math.Max(b2TimeOfImpact.b2_toiMaxRootIters, rootIterCount)
            }
            if (newAlpha < (1 + 100 * Number.MIN_VALUE) * alpha) {
                break
            }
            alpha = newAlpha;
            iter++;
            ++b2TimeOfImpact.b2_toiIters;
            if (iter == k_maxIterations) {
                break
            }
        }
        b2TimeOfImpact.b2_toiMaxIters = b2Math.Max(b2TimeOfImpact.b2_toiMaxIters, iter);
        return alpha
    };
    b2TimeOfImpact.b2_toiCalls = 0;
    b2TimeOfImpact.b2_toiIters = 0;
    b2TimeOfImpact.b2_toiMaxIters = 0;
    b2TimeOfImpact.b2_toiRootIters = 0;
    b2TimeOfImpact.b2_toiMaxRootIters = 0;
    b2TimeOfImpact.s_cache = new b2SimplexCache;
    b2TimeOfImpact.s_distanceInput = new b2DistanceInput;
    b2TimeOfImpact.s_xfA = new b2Transform;
    b2TimeOfImpact.s_xfB = new b2Transform;
    b2TimeOfImpact.s_fcn = new b2SeparationFunction;
    b2TimeOfImpact.s_distanceOutput = new b2DistanceOutput;
    var b2GearJoint = function() {
        b2Joint.prototype.__varz.call(this);
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    extend(b2GearJoint.prototype, b2Joint.prototype);
    b2GearJoint.prototype._super = b2Joint.prototype;
    b2GearJoint.prototype.__constructor = function(def) {
        this._super.__constructor.apply(this, [def]);
        var type1 = def.joint1.m_type;
        var type2 = def.joint2.m_type;
        this.m_revolute1 = null;
        this.m_prismatic1 = null;
        this.m_revolute2 = null;
        this.m_prismatic2 = null;
        var coordinate1;
        var coordinate2;
        this.m_ground1 = def.joint1.GetBodyA();
        this.m_bodyA = def.joint1.GetBodyB();
        if (type1 == b2Joint.e_revoluteJoint) {
            this.m_revolute1 = def.joint1;
            this.m_groundAnchor1.SetV(this.m_revolute1.m_localAnchor1);
            this.m_localAnchor1.SetV(this.m_revolute1.m_localAnchor2);
            coordinate1 = this.m_revolute1.GetJointAngle()
        } else {
            this.m_prismatic1 = def.joint1;
            this.m_groundAnchor1.SetV(this.m_prismatic1.m_localAnchor1);
            this.m_localAnchor1.SetV(this.m_prismatic1.m_localAnchor2);
            coordinate1 = this.m_prismatic1.GetJointTranslation()
        }
        this.m_ground2 = def.joint2.GetBodyA();
        this.m_bodyB = def.joint2.GetBodyB();
        if (type2 == b2Joint.e_revoluteJoint) {
            this.m_revolute2 = def.joint2;
            this.m_groundAnchor2.SetV(this.m_revolute2.m_localAnchor1);
            this.m_localAnchor2.SetV(this.m_revolute2.m_localAnchor2);
            coordinate2 = this.m_revolute2.GetJointAngle()
        } else {
            this.m_prismatic2 = def.joint2;
            this.m_groundAnchor2.SetV(this.m_prismatic2.m_localAnchor1);
            this.m_localAnchor2.SetV(this.m_prismatic2.m_localAnchor2);
            coordinate2 = this.m_prismatic2.GetJointTranslation()
        }
        this.m_ratio = def.ratio;
        this.m_constant = coordinate1 + this.m_ratio * coordinate2;
        this.m_impulse = 0
    };
    b2GearJoint.prototype.__varz = function() {
        this.m_groundAnchor1 = new b2Vec2;
        this.m_groundAnchor2 = new b2Vec2;
        this.m_localAnchor1 = new b2Vec2;
        this.m_localAnchor2 = new b2Vec2;
        this.m_J = new b2Jacobian
    };
    b2GearJoint.prototype.InitVelocityConstraints = function(step) {
        var g1 = this.m_ground1;
        var g2 = this.m_ground2;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var ugX;
        var ugY;
        var rX;
        var rY;
        var tMat;
        var tVec;
        var crug;
        var tX;
        var K = 0;
        this.m_J.SetZero();
        if (this.m_revolute1) {
            this.m_J.angularA = -1;
            K += bA.m_invI
        } else {
            tMat = g1.m_xf.R;
            tVec = this.m_prismatic1.m_localXAxis1;
            ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = bA.m_xf.R;
            rX = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
            rY = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
            tX = tMat.col1.x * rX + tMat.col2.x * rY;
            rY = tMat.col1.y * rX + tMat.col2.y * rY;
            rX = tX;
            crug = rX * ugY - rY * ugX;
            this.m_J.linearA.Set(-ugX, -ugY);
            this.m_J.angularA = -crug;
            K += bA.m_invMass + bA.m_invI * crug * crug
        }
        if (this.m_revolute2) {
            this.m_J.angularB = -this.m_ratio;
            K += this.m_ratio * this.m_ratio * bB.m_invI
        } else {
            tMat = g2.m_xf.R;
            tVec = this.m_prismatic2.m_localXAxis1;
            ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = bB.m_xf.R;
            rX = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
            rY = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
            tX = tMat.col1.x * rX + tMat.col2.x * rY;
            rY = tMat.col1.y * rX + tMat.col2.y * rY;
            rX = tX;
            crug = rX * ugY - rY * ugX;
            this.m_J.linearB.Set(-this.m_ratio * ugX, -this.m_ratio * ugY);
            this.m_J.angularB = -this.m_ratio * crug;
            K += this.m_ratio * this.m_ratio * (bB.m_invMass + bB.m_invI * crug * crug)
        }
        this.m_mass = K > 0 ? 1 / K : 0;
        if (step.warmStarting) {
            bA.m_linearVelocity.x += bA.m_invMass * this.m_impulse * this.m_J.linearA.x;
            bA.m_linearVelocity.y += bA.m_invMass * this.m_impulse * this.m_J.linearA.y;
            bA.m_angularVelocity += bA.m_invI * this.m_impulse * this.m_J.angularA;
            bB.m_linearVelocity.x += bB.m_invMass * this.m_impulse * this.m_J.linearB.x;
            bB.m_linearVelocity.y += bB.m_invMass * this.m_impulse * this.m_J.linearB.y;
            bB.m_angularVelocity += bB.m_invI * this.m_impulse * this.m_J.angularB
        } else {
            this.m_impulse = 0
        }
    };
    b2GearJoint.prototype.SolveVelocityConstraints = function(step) {
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var Cdot = this.m_J.Compute(bA.m_linearVelocity, bA.m_angularVelocity, bB.m_linearVelocity, bB.m_angularVelocity);
        var impulse = -this.m_mass * Cdot;
        this.m_impulse += impulse;
        bA.m_linearVelocity.x += bA.m_invMass * impulse * this.m_J.linearA.x;
        bA.m_linearVelocity.y += bA.m_invMass * impulse * this.m_J.linearA.y;
        bA.m_angularVelocity += bA.m_invI * impulse * this.m_J.angularA;
        bB.m_linearVelocity.x += bB.m_invMass * impulse * this.m_J.linearB.x;
        bB.m_linearVelocity.y += bB.m_invMass * impulse * this.m_J.linearB.y;
        bB.m_angularVelocity += bB.m_invI * impulse * this.m_J.angularB
    };
    b2GearJoint.prototype.SolvePositionConstraints = function(baumgarte) {
        var linearError = 0;
        var bA = this.m_bodyA;
        var bB = this.m_bodyB;
        var coordinate1;
        var coordinate2;
        if (this.m_revolute1) {
            coordinate1 = this.m_revolute1.GetJointAngle()
        } else {
            coordinate1 = this.m_prismatic1.GetJointTranslation()
        }
        if (this.m_revolute2) {
            coordinate2 = this.m_revolute2.GetJointAngle()
        } else {
            coordinate2 = this.m_prismatic2.GetJointTranslation()
        }
        var C = this.m_constant - (coordinate1 + this.m_ratio * coordinate2);
        var impulse = -this.m_mass * C;
        bA.m_sweep.c.x += bA.m_invMass * impulse * this.m_J.linearA.x;
        bA.m_sweep.c.y += bA.m_invMass * impulse * this.m_J.linearA.y;
        bA.m_sweep.a += bA.m_invI * impulse * this.m_J.angularA;
        bB.m_sweep.c.x += bB.m_invMass * impulse * this.m_J.linearB.x;
        bB.m_sweep.c.y += bB.m_invMass * impulse * this.m_J.linearB.y;
        bB.m_sweep.a += bB.m_invI * impulse * this.m_J.angularB;
        bA.SynchronizeTransform();
        bB.SynchronizeTransform();
        return linearError < b2Settings.b2_linearSlop
    };
    b2GearJoint.prototype.GetAnchorA = function() {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
    };
    b2GearJoint.prototype.GetAnchorB = function() {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
    };
    b2GearJoint.prototype.GetReactionForce = function(inv_dt) {
        return new b2Vec2(inv_dt * this.m_impulse * this.m_J.linearB.x, inv_dt * this.m_impulse * this.m_J.linearB.y)
    };
    b2GearJoint.prototype.GetReactionTorque = function(inv_dt) {
        var tMat = this.m_bodyB.m_xf.R;
        var rX = this.m_localAnchor1.x - this.m_bodyB.m_sweep.localCenter.x;
        var rY = this.m_localAnchor1.y - this.m_bodyB.m_sweep.localCenter.y;
        var tX = tMat.col1.x * rX + tMat.col2.x * rY;
        rY = tMat.col1.y * rX + tMat.col2.y * rY;
        rX = tX;
        var PX = this.m_impulse * this.m_J.linearB.x;
        var PY = this.m_impulse * this.m_J.linearB.y;
        return inv_dt * (this.m_impulse * this.m_J.angularB - rX * PY + rY * PX)
    };
    b2GearJoint.prototype.GetRatio = function() {
        return this.m_ratio
    };
    b2GearJoint.prototype.SetRatio = function(ratio) {
        this.m_ratio = ratio
    };
    b2GearJoint.prototype.m_ground1 = null;
    b2GearJoint.prototype.m_ground2 = null;
    b2GearJoint.prototype.m_revolute1 = null;
    b2GearJoint.prototype.m_prismatic1 = null;
    b2GearJoint.prototype.m_revolute2 = null;
    b2GearJoint.prototype.m_prismatic2 = null;
    b2GearJoint.prototype.m_groundAnchor1 = new b2Vec2;
    b2GearJoint.prototype.m_groundAnchor2 = new b2Vec2;
    b2GearJoint.prototype.m_localAnchor1 = new b2Vec2;
    b2GearJoint.prototype.m_localAnchor2 = new b2Vec2;
    b2GearJoint.prototype.m_J = new b2Jacobian;
    b2GearJoint.prototype.m_constant = null;
    b2GearJoint.prototype.m_ratio = null;
    b2GearJoint.prototype.m_mass = null;
    b2GearJoint.prototype.m_impulse = null;
    var b2TOIInput = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2TOIInput.prototype.__constructor = function() {};
    b2TOIInput.prototype.__varz = function() {
        this.proxyA = new b2DistanceProxy;
        this.proxyB = new b2DistanceProxy;
        this.sweepA = new b2Sweep;
        this.sweepB = new b2Sweep
    };
    b2TOIInput.prototype.proxyA = new b2DistanceProxy;
    b2TOIInput.prototype.proxyB = new b2DistanceProxy;
    b2TOIInput.prototype.sweepA = new b2Sweep;
    b2TOIInput.prototype.sweepB = new b2Sweep;
    b2TOIInput.prototype.tolerance = null;
    var b2RevoluteJointDef = function() {
        b2JointDef.prototype.__varz.call(this);
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    extend(b2RevoluteJointDef.prototype, b2JointDef.prototype);
    b2RevoluteJointDef.prototype._super = b2JointDef.prototype;
    b2RevoluteJointDef.prototype.__constructor = function() {
        this._super.__constructor.apply(this, arguments);
        this.type = b2Joint.e_revoluteJoint;
        this.localAnchorA.Set(0, 0);
        this.localAnchorB.Set(0, 0);
        this.referenceAngle = 0;
        this.lowerAngle = 0;
        this.upperAngle = 0;
        this.maxMotorTorque = 0;
        this.motorSpeed = 0;
        this.enableLimit = false;
        this.enableMotor = false
    };
    b2RevoluteJointDef.prototype.__varz = function() {
        this.localAnchorA = new b2Vec2;
        this.localAnchorB = new b2Vec2
    };
    b2RevoluteJointDef.prototype.Initialize = function(bA, bB, anchor) {
        this.bodyA = bA;
        this.bodyB = bB;
        this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
        this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
        this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()
    };
    b2RevoluteJointDef.prototype.localAnchorA = new b2Vec2;
    b2RevoluteJointDef.prototype.localAnchorB = new b2Vec2;
    b2RevoluteJointDef.prototype.referenceAngle = null;
    b2RevoluteJointDef.prototype.enableLimit = null;
    b2RevoluteJointDef.prototype.lowerAngle = null;
    b2RevoluteJointDef.prototype.upperAngle = null;
    b2RevoluteJointDef.prototype.enableMotor = null;
    b2RevoluteJointDef.prototype.motorSpeed = null;
    b2RevoluteJointDef.prototype.maxMotorTorque = null;
    var b2RopeJointDef = function() {
        b2JointDef.prototype.__varz.call(this);
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    extend(b2RopeJointDef.prototype, b2JointDef.prototype);
    b2RopeJointDef.prototype._super = b2JointDef.prototype;
    b2RopeJointDef.prototype.__constructor = function() {
        this._super.__constructor.apply(this, arguments);
        this.type = b2Joint.e_ropeJoint;
        this.localAnchorA.Set(-1, 0);
        this.localAnchorB.Set(1, 0);
        this.maxLength = 0
    };
    b2RopeJointDef.prototype.__varz = function() {
        this.localAnchorA = new b2Vec2;
        this.localAnchorB = new b2Vec2
    };
    b2RopeJointDef.prototype.Initialize = function(bA, bB, anchorA, anchorB) {
        this.bodyA = bA;
        this.bodyB = bB;
        this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchorA));
        this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchorB));
        var dX = anchorB.x - anchorA.x;
        var dY = anchorB.y - anchorA.y;
        this.maxLength = Math.sqrt(dX * dX + dY * dY)
    };
    b2RopeJointDef.prototype.localAnchorA = new b2Vec2;
    b2RopeJointDef.prototype.localAnchorB = new b2Vec2;
    b2RopeJointDef.prototype.maxLength = null;
    var b2MouseJointDef = function() {
        b2JointDef.prototype.__varz.call(this);
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    extend(b2MouseJointDef.prototype, b2JointDef.prototype);
    b2MouseJointDef.prototype._super = b2JointDef.prototype;
    b2MouseJointDef.prototype.__constructor = function() {
        this._super.__constructor.apply(this, arguments);
        this.type = b2Joint.e_mouseJoint;
        this.maxForce = 0;
        this.frequencyHz = 5;
        this.dampingRatio = .7
    };
    b2MouseJointDef.prototype.__varz = function() {
        this.target = new b2Vec2
    };
    b2MouseJointDef.prototype.target = new b2Vec2;
    b2MouseJointDef.prototype.maxForce = null;
    b2MouseJointDef.prototype.frequencyHz = null;
    b2MouseJointDef.prototype.dampingRatio = null;
    var b2Contact = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2Contact.prototype.__constructor = function() {};
    b2Contact.prototype.__varz = function() {
        this.m_nodeA = new b2ContactEdge;
        this.m_nodeB = new b2ContactEdge;
        this.m_manifold = new b2Manifold;
        this.m_oldManifold = new b2Manifold
    };
    b2Contact.s_input = new b2TOIInput;
    b2Contact.e_sensorFlag = 1;
    b2Contact.e_continuousFlag = 2;
    b2Contact.e_islandFlag = 4;
    b2Contact.e_toiFlag = 8;
    b2Contact.e_touchingFlag = 16;
    b2Contact.e_enabledFlag = 32;
    b2Contact.e_filterFlag = 64;
    b2Contact.prototype.Reset = function(fixtureA, fixtureB) {
        this.m_flags = b2Contact.e_enabledFlag;
        if (!fixtureA || !fixtureB) {
            this.m_fixtureA = null;
            this.m_fixtureB = null;
            return
        }
        if (fixtureA.IsSensor() || fixtureB.IsSensor()) {
            this.m_flags |= b2Contact.e_sensorFlag
        }
        var bodyA = fixtureA.GetBody();
        var bodyB = fixtureB.GetBody();
        if (bodyA.GetType() != b2Body.b2_dynamicBody || bodyA.IsBullet() || bodyB.GetType() != b2Body.b2_dynamicBody || bodyB.IsBullet()) {
            this.m_flags |= b2Contact.e_continuousFlag
        }
        this.m_fixtureA = fixtureA;
        this.m_fixtureB = fixtureB;
        this.m_manifold.m_pointCount = 0;
        this.m_prev = null;
        this.m_next = null;
        this.m_nodeA.contact = null;
        this.m_nodeA.prev = null;
        this.m_nodeA.next = null;
        this.m_nodeA.other = null;
        this.m_nodeB.contact = null;
        this.m_nodeB.prev = null;
        this.m_nodeB.next = null;
        this.m_nodeB.other = null
    };
    b2Contact.prototype.Update = function(listener) {
        var tManifold = this.m_oldManifold;
        this.m_oldManifold = this.m_manifold;
        this.m_manifold = tManifold;
        this.m_flags |= b2Contact.e_enabledFlag;
        var touching = false;
        var wasTouching = (this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag;
        var bodyA = this.m_fixtureA.m_body;
        var bodyB = this.m_fixtureB.m_body;
        var aabbOverlap = this.m_fixtureA.m_aabb.TestOverlap(this.m_fixtureB.m_aabb);
        if (this.m_flags & b2Contact.e_sensorFlag) {
            if (aabbOverlap) {
                var shapeA = this.m_fixtureA.GetShape();
                var shapeB = this.m_fixtureB.GetShape();
                var xfA = bodyA.GetTransform();
                var xfB = bodyB.GetTransform();
                touching = b2Shape.TestOverlap(shapeA, xfA, shapeB, xfB)
            }
            this.m_manifold.m_pointCount = 0
        } else {
            if (bodyA.GetType() != b2Body.b2_dynamicBody || bodyA.IsBullet() || bodyB.GetType() != b2Body.b2_dynamicBody || bodyB.IsBullet()) {
                this.m_flags |= b2Contact.e_continuousFlag
            } else {
                this.m_flags &= ~b2Contact.e_continuousFlag
            }
            if (aabbOverlap) {
                this.Evaluate();
                touching = this.m_manifold.m_pointCount > 0;
                for (var i = 0; i < this.m_manifold.m_pointCount; ++i) {
                    var mp2 = this.m_manifold.m_points[i];
                    mp2.m_normalImpulse = 0;
                    mp2.m_tangentImpulse = 0;
                    var id2 = mp2.m_id;
                    for (var j = 0; j < this.m_oldManifold.m_pointCount; ++j) {
                        var mp1 = this.m_oldManifold.m_points[j];
                        if (mp1.m_id.key == id2.key) {
                            mp2.m_normalImpulse = mp1.m_normalImpulse;
                            mp2.m_tangentImpulse = mp1.m_tangentImpulse;
                            break
                        }
                    }
                }
            } else {
                this.m_manifold.m_pointCount = 0
            }
            if (touching != wasTouching) {
                bodyA.SetAwake(true);
                bodyB.SetAwake(true)
            }
        }
        if (touching) {
            this.m_flags |= b2Contact.e_touchingFlag
        } else {
            this.m_flags &= ~b2Contact.e_touchingFlag
        }
        if (wasTouching == false && touching == true) {
            listener.BeginContact(this)
        }
        if (wasTouching == true && touching == false) {
            listener.EndContact(this)
        }
        if ((this.m_flags & b2Contact.e_sensorFlag) == 0) {
            listener.PreSolve(this, this.m_oldManifold)
        }
    };
    b2Contact.prototype.Evaluate = function() {};
    b2Contact.prototype.ComputeTOI = function(sweepA, sweepB) {
        b2Contact.s_input.proxyA.Set(this.m_fixtureA.GetShape());
        b2Contact.s_input.proxyB.Set(this.m_fixtureB.GetShape());
        b2Contact.s_input.sweepA = sweepA;
        b2Contact.s_input.sweepB = sweepB;
        b2Contact.s_input.tolerance = b2Settings.b2_linearSlop;
        return b2TimeOfImpact.TimeOfImpact(b2Contact.s_input)
    };
    b2Contact.prototype.GetManifold = function() {
        return this.m_manifold
    };
    b2Contact.prototype.GetWorldManifold = function(worldManifold) {
        var bodyA = this.m_fixtureA.GetBody();
        var bodyB = this.m_fixtureB.GetBody();
        var shapeA = this.m_fixtureA.GetShape();
        var shapeB = this.m_fixtureB.GetShape();
        worldManifold.Initialize(this.m_manifold, bodyA.GetTransform(), shapeA.m_radius, bodyB.GetTransform(), shapeB.m_radius)
    };
    b2Contact.prototype.IsTouching = function() {
        return (this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag
    };
    b2Contact.prototype.IsContinuous = function() {
        return (this.m_flags & b2Contact.e_continuousFlag) == b2Contact.e_continuousFlag
    };
    b2Contact.prototype.SetSensor = function(sensor) {
        if (sensor) {
            this.m_flags |= b2Contact.e_sensorFlag
        } else {
            this.m_flags &= ~b2Contact.e_sensorFlag
        }
    };
    b2Contact.prototype.IsSensor = function() {
        return (this.m_flags & b2Contact.e_sensorFlag) == b2Contact.e_sensorFlag
    };
    b2Contact.prototype.SetEnabled = function(flag) {
        if (flag) {
            this.m_flags |= b2Contact.e_enabledFlag
        } else {
            this.m_flags &= ~b2Contact.e_enabledFlag
        }
    };
    b2Contact.prototype.IsEnabled = function() {
        return (this.m_flags & b2Contact.e_enabledFlag) == b2Contact.e_enabledFlag
    };
    b2Contact.prototype.GetNext = function() {
        return this.m_next
    };
    b2Contact.prototype.GetFixtureA = function() {
        return this.m_fixtureA
    };
    b2Contact.prototype.GetFixtureB = function() {
        return this.m_fixtureB
    };
    b2Contact.prototype.FlagForFiltering = function() {
        this.m_flags |= b2Contact.e_filterFlag
    };
    b2Contact.prototype.m_flags = 0;
    b2Contact.prototype.m_prev = null;
    b2Contact.prototype.m_next = null;
    b2Contact.prototype.m_nodeA = new b2ContactEdge;
    b2Contact.prototype.m_nodeB = new b2ContactEdge;
    b2Contact.prototype.m_fixtureA = null;
    b2Contact.prototype.m_fixtureB = null;
    b2Contact.prototype.m_manifold = new b2Manifold;
    b2Contact.prototype.m_oldManifold = new b2Manifold;
    b2Contact.prototype.m_toi = null;
    var b2ContactConstraint = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2ContactConstraint.prototype.__constructor = function() {
        this.points = new Array(b2Settings.b2_maxManifoldPoints);
        for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
            this.points[i] = new b2ContactConstraintPoint
        }
    };
    b2ContactConstraint.prototype.__varz = function() {
        this.localPlaneNormal = new b2Vec2;
        this.localPoint = new b2Vec2;
        this.normal = new b2Vec2;
        this.normalMass = new b2Mat22;
        this.K = new b2Mat22
    };
    b2ContactConstraint.prototype.points = null;
    b2ContactConstraint.prototype.localPlaneNormal = new b2Vec2;
    b2ContactConstraint.prototype.localPoint = new b2Vec2;
    b2ContactConstraint.prototype.normal = new b2Vec2;
    b2ContactConstraint.prototype.normalMass = new b2Mat22;
    b2ContactConstraint.prototype.K = new b2Mat22;
    b2ContactConstraint.prototype.bodyA = null;
    b2ContactConstraint.prototype.bodyB = null;
    b2ContactConstraint.prototype.type = 0;
    b2ContactConstraint.prototype.radius = null;
    b2ContactConstraint.prototype.friction = null;
    b2ContactConstraint.prototype.restitution = null;
    b2ContactConstraint.prototype.pointCount = 0;
    b2ContactConstraint.prototype.manifold = null;
    var b2ContactResult = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2ContactResult.prototype.__constructor = function() {};
    b2ContactResult.prototype.__varz = function() {
        this.position = new b2Vec2;
        this.normal = new b2Vec2;
        this.id = new b2ContactID
    };
    b2ContactResult.prototype.shape1 = null;
    b2ContactResult.prototype.shape2 = null;
    b2ContactResult.prototype.position = new b2Vec2;
    b2ContactResult.prototype.normal = new b2Vec2;
    b2ContactResult.prototype.normalImpulse = null;
    b2ContactResult.prototype.tangentImpulse = null;
    b2ContactResult.prototype.id = new b2ContactID;
    var b2PolygonContact = function() {
        b2Contact.prototype.__varz.call(this);
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    extend(b2PolygonContact.prototype, b2Contact.prototype);
    b2PolygonContact.prototype._super = b2Contact.prototype;
    b2PolygonContact.prototype.__constructor = function() {
        this._super.__constructor.apply(this, arguments)
    };
    b2PolygonContact.prototype.__varz = function() {};
    b2PolygonContact.Create = function(allocator) {
        return new b2PolygonContact
    };
    b2PolygonContact.Destroy = function(contact, allocator) {};
    b2PolygonContact.prototype.Evaluate = function() {
        var bA = this.m_fixtureA.GetBody();
        var bB = this.m_fixtureB.GetBody();
        b2Collision.CollidePolygons(this.m_manifold, this.m_fixtureA.GetShape(), bA.m_xf, this.m_fixtureB.GetShape(), bB.m_xf)
    };
    b2PolygonContact.prototype.Reset = function(fixtureA, fixtureB) {
        this._super.Reset.apply(this, [fixtureA, fixtureB])
    };
    var ClipVertex = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    ClipVertex.prototype.__constructor = function() {};
    ClipVertex.prototype.__varz = function() {
        this.v = new b2Vec2;
        this.id = new b2ContactID
    };
    ClipVertex.prototype.Set = function(other) {
        this.v.SetV(other.v);
        this.id.Set(other.id)
    };
    ClipVertex.prototype.v = new b2Vec2;
    ClipVertex.prototype.id = new b2ContactID;
    var b2ContactFilter = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2ContactFilter.prototype.__constructor = function() {};
    b2ContactFilter.prototype.__varz = function() {};
    b2ContactFilter.b2_defaultFilter = new b2ContactFilter;
    b2ContactFilter.prototype.ShouldCollide = function(fixtureA, fixtureB) {
        var filter1 = fixtureA.GetFilterData();
        var filter2 = fixtureB.GetFilterData();
        if (filter1.groupIndex == filter2.groupIndex && filter1.groupIndex != 0) {
            return filter1.groupIndex > 0
        }
        var collide = (filter1.maskBits & filter2.categoryBits) != 0 && (filter1.categoryBits & filter2.maskBits) != 0;
        return collide
    };
    b2ContactFilter.prototype.RayCollide = function(userData, fixture) {
        if (!userData) return true;
        return this.ShouldCollide(userData, fixture)
    };
    var b2NullContact = function() {
        b2Contact.prototype.__varz.call(this);
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    extend(b2NullContact.prototype, b2Contact.prototype);
    b2NullContact.prototype._super = b2Contact.prototype;
    b2NullContact.prototype.__constructor = function() {
        this._super.__constructor.apply(this, arguments)
    };
    b2NullContact.prototype.__varz = function() {};
    b2NullContact.prototype.Evaluate = function() {};
    var b2ContactListener = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2ContactListener.prototype.__constructor = function() {};
    b2ContactListener.prototype.__varz = function() {};
    b2ContactListener.b2_defaultListener = new b2ContactListener;
    b2ContactListener.prototype.BeginContact = function(contact) {};
    b2ContactListener.prototype.EndContact = function(contact) {};
    b2ContactListener.prototype.PreSolve = function(contact, oldManifold) {};
    b2ContactListener.prototype.PostSolve = function(contact, impulse) {};
    var b2Island = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2Island.prototype.__constructor = function() {
        this.m_bodies = new Array;
        this.m_contacts = new Array;
        this.m_joints = new Array
    };
    b2Island.prototype.__varz = function() {};
    b2Island.s_impulse = new b2ContactImpulse;
    b2Island.prototype.Initialize = function(bodyCapacity, contactCapacity, jointCapacity, allocator, listener, contactSolver) {
        var i = 0;
        this.m_bodyCapacity = bodyCapacity;
        this.m_contactCapacity = contactCapacity;
        this.m_jointCapacity = jointCapacity;
        this.m_bodyCount = 0;
        this.m_contactCount = 0;
        this.m_jointCount = 0;
        this.m_allocator = allocator;
        this.m_listener = listener;
        this.m_contactSolver = contactSolver;
        for (i = this.m_bodies.length; i < bodyCapacity; i++) this.m_bodies[i] = null;
        for (i = this.m_contacts.length; i < contactCapacity; i++) this.m_contacts[i] = null;
        for (i = this.m_joints.length; i < jointCapacity; i++) this.m_joints[i] = null
    };
    b2Island.prototype.Clear = function() {
        this.m_bodyCount = 0;
        this.m_contactCount = 0;
        this.m_jointCount = 0
    };
    b2Island.prototype.Solve = function(step, gravity, allowSleep) {
        var i = 0;
        var j = 0;
        var b;
        var joint;
        for (i = 0; i < this.m_bodyCount; ++i) {
            b = this.m_bodies[i];
            if (b.GetType() != b2Body.b2_dynamicBody) continue;
            b.m_linearVelocity.x += step.dt * (gravity.x + b.m_invMass * b.m_force.x);
            b.m_linearVelocity.y += step.dt * (gravity.y + b.m_invMass * b.m_force.y);
            b.m_angularVelocity += step.dt * b.m_invI * b.m_torque;
            b.m_linearVelocity.Multiply(b2Math.Clamp(1 - step.dt * b.m_linearDamping, 0, 1));
            b.m_angularVelocity *= b2Math.Clamp(1 - step.dt * b.m_angularDamping, 0, 1)
        }
        this.m_contactSolver.Initialize(step, this.m_contacts, this.m_contactCount, this.m_allocator);
        var contactSolver = this.m_contactSolver;
        contactSolver.InitVelocityConstraints(step);
        for (i = 0; i < this.m_jointCount; ++i) {
            joint = this.m_joints[i];
            joint.InitVelocityConstraints(step)
        }
        for (i = 0; i < step.velocityIterations; ++i) {
            for (j = 0; j < this.m_jointCount; ++j) {
                joint = this.m_joints[j];
                joint.SolveVelocityConstraints(step)
            }
            contactSolver.SolveVelocityConstraints()
        }
        for (i = 0; i < this.m_jointCount; ++i) {
            joint = this.m_joints[i];
            joint.FinalizeVelocityConstraints()
        }
        contactSolver.FinalizeVelocityConstraints();
        for (i = 0; i < this.m_bodyCount; ++i) {
            b = this.m_bodies[i];
            if (b.GetType() == b2Body.b2_staticBody) continue;
            var translationX = step.dt * b.m_linearVelocity.x;
            var translationY = step.dt * b.m_linearVelocity.y;
            if (translationX * translationX + translationY * translationY > b2Settings.b2_maxTranslationSquared) {
                b.m_linearVelocity.Normalize();
                b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * step.inv_dt;
                b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * step.inv_dt
            }
            var rotation = step.dt * b.m_angularVelocity;
            if (rotation * rotation > b2Settings.b2_maxRotationSquared) {
                if (b.m_angularVelocity < 0) {
                    b.m_angularVelocity = -b2Settings.b2_maxRotation * step.inv_dt
                } else {
                    b.m_angularVelocity = b2Settings.b2_maxRotation * step.inv_dt
                }
            }
            b.m_sweep.c0.SetV(b.m_sweep.c);
            b.m_sweep.a0 = b.m_sweep.a;
            b.m_sweep.c.x += step.dt * b.m_linearVelocity.x;
            b.m_sweep.c.y += step.dt * b.m_linearVelocity.y;
            b.m_sweep.a += step.dt * b.m_angularVelocity;
            b.SynchronizeTransform()
        }
        for (i = 0; i < step.positionIterations; ++i) {
            var contactsOkay = contactSolver.SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
            var jointsOkay = true;
            for (j = 0; j < this.m_jointCount; ++j) {
                joint = this.m_joints[j];
                var jointOkay = joint.SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
                jointsOkay = jointsOkay && jointOkay
            }
            if (contactsOkay && jointsOkay) {
                break
            }
        }
        this.Report(contactSolver.m_constraints);
        if (allowSleep) {
            var minSleepTime = Number.MAX_VALUE;
            var linTolSqr = b2Settings.b2_linearSleepTolerance * b2Settings.b2_linearSleepTolerance;
            var angTolSqr = b2Settings.b2_angularSleepTolerance * b2Settings.b2_angularSleepTolerance;
            for (i = 0; i < this.m_bodyCount; ++i) {
                b = this.m_bodies[i];
                if (b.GetType() == b2Body.b2_staticBody) {
                    continue
                }
                if ((b.m_flags & b2Body.e_allowSleepFlag) == 0) {
                    b.m_sleepTime = 0;
                    minSleepTime = 0
                }
                if ((b.m_flags & b2Body.e_allowSleepFlag) == 0 || b.m_angularVelocity * b.m_angularVelocity > angTolSqr || b2Math.Dot(b.m_linearVelocity, b.m_linearVelocity) > linTolSqr) {
                    b.m_sleepTime = 0;
                    minSleepTime = 0
                } else {
                    b.m_sleepTime += step.dt;
                    minSleepTime = b2Math.Min(minSleepTime, b.m_sleepTime)
                }
            }
            if (minSleepTime >= b2Settings.b2_timeToSleep) {
                for (i = 0; i < this.m_bodyCount; ++i) {
                    b = this.m_bodies[i];
                    b.SetAwake(false)
                }
            }
        }
    };
    b2Island.prototype.SolveTOI = function(subStep) {
        var i = 0;
        var j = 0;
        this.m_contactSolver.Initialize(subStep, this.m_contacts, this.m_contactCount, this.m_allocator);
        var contactSolver = this.m_contactSolver;
        for (i = 0; i < this.m_jointCount; ++i) {
            this.m_joints[i].InitVelocityConstraints(subStep)
        }
        for (i = 0; i < subStep.velocityIterations; ++i) {
            contactSolver.SolveVelocityConstraints();
            for (j = 0; j < this.m_jointCount; ++j) {
                this.m_joints[j].SolveVelocityConstraints(subStep)
            }
        }
        for (i = 0; i < this.m_bodyCount; ++i) {
            var b = this.m_bodies[i];
            if (b.GetType() == b2Body.b2_staticBody) continue;
            var translationX = subStep.dt * b.m_linearVelocity.x;
            var translationY = subStep.dt * b.m_linearVelocity.y;
            if (translationX * translationX + translationY * translationY > b2Settings.b2_maxTranslationSquared) {
                b.m_linearVelocity.Normalize();
                b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * subStep.inv_dt;
                b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * subStep.inv_dt
            }
            var rotation = subStep.dt * b.m_angularVelocity;
            if (rotation * rotation > b2Settings.b2_maxRotationSquared) {
                if (b.m_angularVelocity < 0) {
                    b.m_angularVelocity = -b2Settings.b2_maxRotation * subStep.inv_dt
                } else {
                    b.m_angularVelocity = b2Settings.b2_maxRotation * subStep.inv_dt
                }
            }
            b.m_sweep.c0.SetV(b.m_sweep.c);
            b.m_sweep.a0 = b.m_sweep.a;
            b.m_sweep.c.x += subStep.dt * b.m_linearVelocity.x;
            b.m_sweep.c.y += subStep.dt * b.m_linearVelocity.y;
            b.m_sweep.a += subStep.dt * b.m_angularVelocity;
            b.SynchronizeTransform()
        }
        var k_toiBaumgarte = .75;
        for (i = 0; i < subStep.positionIterations; ++i) {
            var contactsOkay = contactSolver.SolvePositionConstraints(k_toiBaumgarte);
            var jointsOkay = true;
            for (j = 0; j < this.m_jointCount; ++j) {
                var jointOkay = this.m_joints[j].SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
                jointsOkay = jointsOkay && jointOkay
            }
            if (contactsOkay && jointsOkay) {
                break
            }
        }
        this.Report(contactSolver.m_constraints)
    };
    b2Island.prototype.Report = function(constraints) {
        if (this.m_listener == null) {
            return
        }
        for (var i = 0; i < this.m_contactCount; ++i) {
            var c = this.m_contacts[i];
            var cc = constraints[i];
            for (var j = 0; j < cc.pointCount; ++j) {
                b2Island.s_impulse.normalImpulses[j] = cc.points[j].normalImpulse;
                b2Island.s_impulse.tangentImpulses[j] = cc.points[j].tangentImpulse
            }
            this.m_listener.PostSolve(c, b2Island.s_impulse)
        }
    };
    b2Island.prototype.AddBody = function(body) {
        body.m_islandIndex = this.m_bodyCount;
        this.m_bodies[this.m_bodyCount++] = body
    };
    b2Island.prototype.AddContact = function(contact) {
        this.m_contacts[this.m_contactCount++] = contact
    };
    b2Island.prototype.AddJoint = function(joint) {
        this.m_joints[this.m_jointCount++] = joint
    };
    b2Island.prototype.m_allocator = null;
    b2Island.prototype.m_listener = null;
    b2Island.prototype.m_contactSolver = null;
    b2Island.prototype.m_bodies = null;
    b2Island.prototype.m_contacts = null;
    b2Island.prototype.m_joints = null;
    b2Island.prototype.m_bodyCount = 0;
    b2Island.prototype.m_jointCount = 0;
    b2Island.prototype.m_contactCount = 0;
    b2Island.prototype.m_bodyCapacity = 0;
    b2Island.prototype.m_contactCapacity = 0;
    b2Island.prototype.m_jointCapacity = 0;
    var b2PolyAndEdgeContact = function() {
        b2Contact.prototype.__varz.call(this);
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    extend(b2PolyAndEdgeContact.prototype, b2Contact.prototype);
    b2PolyAndEdgeContact.prototype._super = b2Contact.prototype;
    b2PolyAndEdgeContact.prototype.__constructor = function() {
        this._super.__constructor.apply(this, arguments)
    };
    b2PolyAndEdgeContact.prototype.__varz = function() {};
    b2PolyAndEdgeContact.Create = function(allocator) {
        return new b2PolyAndEdgeContact
    };
    b2PolyAndEdgeContact.Destroy = function(contact, allocator) {};
    b2PolyAndEdgeContact.prototype.Evaluate = function() {
        var bA = this.m_fixtureA.GetBody();
        var bB = this.m_fixtureB.GetBody();
        this.b2CollidePolyAndEdge(this.m_manifold, this.m_fixtureA.GetShape(), bA.m_xf, this.m_fixtureB.GetShape(), bB.m_xf)
    };
    b2PolyAndEdgeContact.prototype.b2CollidePolyAndEdge = function(manifold, polygon, xf1, edge, xf2) {};
    b2PolyAndEdgeContact.prototype.Reset = function(fixtureA, fixtureB) {
        this._super.Reset.apply(this, [fixtureA, fixtureB]);
        b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_polygonShape);
        b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_edgeShape)
    };
    var b2Collision = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2Collision.prototype.__constructor = function() {};
    b2Collision.prototype.__varz = function() {};
    b2Collision.MakeClipPointVector = function() {
        var r = new Array(2);
        r[0] = new ClipVertex;
        r[1] = new ClipVertex;
        return r
    };
    b2Collision.ClipSegmentToLine = function(vOut, vIn, normal, offset) {
        var cv;
        var numOut = 0;
        cv = vIn[0];
        var vIn0 = cv.v;
        cv = vIn[1];
        var vIn1 = cv.v;
        var distance0 = normal.x * vIn0.x + normal.y * vIn0.y - offset;
        var distance1 = normal.x * vIn1.x + normal.y * vIn1.y - offset;
        if (distance0 <= 0) vOut[numOut++].Set(vIn[0]);
        if (distance1 <= 0) vOut[numOut++].Set(vIn[1]);
        if (distance0 * distance1 < 0) {
            var interp = distance0 / (distance0 - distance1);
            cv = vOut[numOut];
            var tVec = cv.v;
            tVec.x = vIn0.x + interp * (vIn1.x - vIn0.x);
            tVec.y = vIn0.y + interp * (vIn1.y - vIn0.y);
            cv = vOut[numOut];
            var cv2;
            if (distance0 > 0) {
                cv2 = vIn[0];
                cv.id = cv2.id
            } else {
                cv2 = vIn[1];
                cv.id = cv2.id
            }++numOut
        }
        return numOut
    };
    b2Collision.EdgeSeparation = function(poly1, xf1, edge1, poly2, xf2) {
        var count1 = poly1.m_vertexCount;
        var vertices1 = poly1.m_vertices;
        var normals1 = poly1.m_normals;
        var count2 = poly2.m_vertexCount;
        var vertices2 = poly2.m_vertices;
        var tMat;
        var tVec;
        tMat = xf1.R;
        tVec = normals1[edge1];
        var normal1WorldX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
        var normal1WorldY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
        tMat = xf2.R;
        var normal1X = tMat.col1.x * normal1WorldX + tMat.col1.y * normal1WorldY;
        var normal1Y = tMat.col2.x * normal1WorldX + tMat.col2.y * normal1WorldY;
        var index = 0;
        var minDot = Number.MAX_VALUE;
        for (var i = 0; i < count2; ++i) {
            tVec = vertices2[i];
            var dot = tVec.x * normal1X + tVec.y * normal1Y;
            if (dot < minDot) {
                minDot = dot;
                index = i
            }
        }
        tVec = vertices1[edge1];
        tMat = xf1.R;
        var v1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        var v1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        tVec = vertices2[index];
        tMat = xf2.R;
        var v2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        var v2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        v2X -= v1X;
        v2Y -= v1Y;
        var separation = v2X * normal1WorldX + v2Y * normal1WorldY;
        return separation
    };
    b2Collision.FindMaxSeparation = function(edgeIndex, poly1, xf1, poly2, xf2) {
        var count1 = poly1.m_vertexCount;
        var normals1 = poly1.m_normals;
        var tVec;
        var tMat;
        tMat = xf2.R;
        tVec = poly2.m_centroid;
        var dX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        var dY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        tMat = xf1.R;
        tVec = poly1.m_centroid;
        dX -= xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        dY -= xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        var dLocal1X = dX * xf1.R.col1.x + dY * xf1.R.col1.y;
        var dLocal1Y = dX * xf1.R.col2.x + dY * xf1.R.col2.y;
        var edge = 0;
        var maxDot = -Number.MAX_VALUE;
        for (var i = 0; i < count1; ++i) {
            tVec = normals1[i];
            var dot = tVec.x * dLocal1X + tVec.y * dLocal1Y;
            if (dot > maxDot) {
                maxDot = dot;
                edge = i
            }
        }
        var s = b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
        var prevEdge = edge - 1 >= 0 ? edge - 1 : count1 - 1;
        var sPrev = b2Collision.EdgeSeparation(poly1, xf1, prevEdge, poly2, xf2);
        var nextEdge = edge + 1 < count1 ? edge + 1 : 0;
        var sNext = b2Collision.EdgeSeparation(poly1, xf1, nextEdge, poly2, xf2);
        var bestEdge = 0;
        var bestSeparation;
        var increment = 0;
        if (sPrev > s && sPrev > sNext) {
            increment = -1;
            bestEdge = prevEdge;
            bestSeparation = sPrev
        } else if (sNext > s) {
            increment = 1;
            bestEdge = nextEdge;
            bestSeparation = sNext
        } else {
            edgeIndex[0] = edge;
            return s
        }
        while (true) {
            if (increment == -1) edge = bestEdge - 1 >= 0 ? bestEdge - 1 : count1 - 1;
            else edge = bestEdge + 1 < count1 ? bestEdge + 1 : 0;
            s = b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
            if (s > bestSeparation) {
                bestEdge = edge;
                bestSeparation = s
            } else {
                break
            }
        }
        edgeIndex[0] = bestEdge;
        return bestSeparation
    };
    b2Collision.FindIncidentEdge = function(c, poly1, xf1, edge1, poly2, xf2) {
        var count1 = poly1.m_vertexCount;
        var normals1 = poly1.m_normals;
        var count2 = poly2.m_vertexCount;
        var vertices2 = poly2.m_vertices;
        var normals2 = poly2.m_normals;
        var tMat;
        var tVec;
        tMat = xf1.R;
        tVec = normals1[edge1];
        var normal1X = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
        var normal1Y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
        tMat = xf2.R;
        var tX = tMat.col1.x * normal1X + tMat.col1.y * normal1Y;
        normal1Y = tMat.col2.x * normal1X + tMat.col2.y * normal1Y;
        normal1X = tX;
        var index = 0;
        var minDot = Number.MAX_VALUE;
        for (var i = 0; i < count2; ++i) {
            tVec = normals2[i];
            var dot = normal1X * tVec.x + normal1Y * tVec.y;
            if (dot < minDot) {
                minDot = dot;
                index = i
            }
        }
        var tClip;
        var i1 = index;
        var i2 = i1 + 1 < count2 ? i1 + 1 : 0;
        tClip = c[0];
        tVec = vertices2[i1];
        tMat = xf2.R;
        tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        tClip.id.features.referenceEdge = edge1;
        tClip.id.features.incidentEdge = i1;
        tClip.id.features.incidentVertex = 0;
        tClip = c[1];
        tVec = vertices2[i2];
        tMat = xf2.R;
        tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        tClip.id.features.referenceEdge = edge1;
        tClip.id.features.incidentEdge = i2;
        tClip.id.features.incidentVertex = 1
    };
    b2Collision.CollidePolygons = function(manifold, polyA, xfA, polyB, xfB) {
        var cv;
        manifold.m_pointCount = 0;
        var totalRadius = polyA.m_radius + polyB.m_radius;
        var edgeA = 0;
        b2Collision.s_edgeAO[0] = edgeA;
        var separationA = b2Collision.FindMaxSeparation(b2Collision.s_edgeAO, polyA, xfA, polyB, xfB);
        edgeA = b2Collision.s_edgeAO[0];
        if (separationA > totalRadius) return;
        var edgeB = 0;
        b2Collision.s_edgeBO[0] = edgeB;
        var separationB = b2Collision.FindMaxSeparation(b2Collision.s_edgeBO, polyB, xfB, polyA, xfA);
        edgeB = b2Collision.s_edgeBO[0];
        if (separationB > totalRadius) return;
        var poly1;
        var poly2;
        var xf1;
        var xf2;
        var edge1 = 0;
        var flip = 0;
        var k_relativeTol = .98;
        var k_absoluteTol = .001;
        var tMat;
        if (separationB > k_relativeTol * separationA + k_absoluteTol) {
            poly1 = polyB;
            poly2 = polyA;
            xf1 = xfB;
            xf2 = xfA;
            edge1 = edgeB;
            manifold.m_type = b2Manifold.e_faceB;
            flip = 1
        } else {
            poly1 = polyA;
            poly2 = polyB;
            xf1 = xfA;
            xf2 = xfB;
            edge1 = edgeA;
            manifold.m_type = b2Manifold.e_faceA;
            flip = 0
        }
        var incidentEdge = b2Collision.s_incidentEdge;
        b2Collision.FindIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);
        var count1 = poly1.m_vertexCount;
        var vertices1 = poly1.m_vertices;
        var local_v11 = vertices1[edge1];
        var local_v12;
        if (edge1 + 1 < count1) {
            local_v12 = vertices1[parseInt(edge1 + 1)]
        } else {
            local_v12 = vertices1[0]
        }
        var localTangent = b2Collision.s_localTangent;
        localTangent.Set(local_v12.x - local_v11.x, local_v12.y - local_v11.y);
        localTangent.Normalize();
        var localNormal = b2Collision.s_localNormal;
        localNormal.x = localTangent.y;
        localNormal.y = -localTangent.x;
        var planePoint = b2Collision.s_planePoint;
        planePoint.Set(.5 * (local_v11.x + local_v12.x), .5 * (local_v11.y + local_v12.y));
        var tangent = b2Collision.s_tangent;
        tMat = xf1.R;
        tangent.x = tMat.col1.x * localTangent.x + tMat.col2.x * localTangent.y;
        tangent.y = tMat.col1.y * localTangent.x + tMat.col2.y * localTangent.y;
        var tangent2 = b2Collision.s_tangent2;
        tangent2.x = -tangent.x;
        tangent2.y = -tangent.y;
        var normal = b2Collision.s_normal;
        normal.x = tangent.y;
        normal.y = -tangent.x;
        var v11 = b2Collision.s_v11;
        var v12 = b2Collision.s_v12;
        v11.x = xf1.position.x + (tMat.col1.x * local_v11.x + tMat.col2.x * local_v11.y);
        v11.y = xf1.position.y + (tMat.col1.y * local_v11.x + tMat.col2.y * local_v11.y);
        v12.x = xf1.position.x + (tMat.col1.x * local_v12.x + tMat.col2.x * local_v12.y);
        v12.y = xf1.position.y + (tMat.col1.y * local_v12.x + tMat.col2.y * local_v12.y);
        var frontOffset = normal.x * v11.x + normal.y * v11.y;
        var sideOffset1 = -tangent.x * v11.x - tangent.y * v11.y + totalRadius;
        var sideOffset2 = tangent.x * v12.x + tangent.y * v12.y + totalRadius;
        var clipPoints1 = b2Collision.s_clipPoints1;
        var clipPoints2 = b2Collision.s_clipPoints2;
        var np = 0;
        np = b2Collision.ClipSegmentToLine(clipPoints1, incidentEdge, tangent2, sideOffset1);
        if (np < 2) return;
        np = b2Collision.ClipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2);
        if (np < 2) return;
        manifold.m_localPlaneNormal.SetV(localNormal);
        manifold.m_localPoint.SetV(planePoint);
        var pointCount = 0;
        for (var i = 0; i < b2Settings.b2_maxManifoldPoints; ++i) {
            cv = clipPoints2[i];
            var separation = normal.x * cv.v.x + normal.y * cv.v.y - frontOffset;
            if (separation <= totalRadius) {
                var cp = manifold.m_points[pointCount];
                tMat = xf2.R;
                var tX = cv.v.x - xf2.position.x;
                var tY = cv.v.y - xf2.position.y;
                cp.m_localPoint.x = tX * tMat.col1.x + tY * tMat.col1.y;
                cp.m_localPoint.y = tX * tMat.col2.x + tY * tMat.col2.y;
                cp.m_id.Set(cv.id);
                cp.m_id.features.flip = flip;
                ++pointCount
            }
        }
        manifold.m_pointCount = pointCount
    };
    b2Collision.CollideCircles = function(manifold, circle1, xf1, circle2, xf2) {
        manifold.m_pointCount = 0;
        var tMat;
        var tVec;
        tMat = xf1.R;
        tVec = circle1.m_p;
        var p1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        var p1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        tMat = xf2.R;
        tVec = circle2.m_p;
        var p2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        var p2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        var dX = p2X - p1X;
        var dY = p2Y - p1Y;
        var distSqr = dX * dX + dY * dY;
        var radius = circle1.m_radius + circle2.m_radius;
        if (distSqr > radius * radius) {
            return
        }
        manifold.m_type = b2Manifold.e_circles;
        manifold.m_localPoint.SetV(circle1.m_p);
        manifold.m_localPlaneNormal.SetZero();
        manifold.m_pointCount = 1;
        manifold.m_points[0].m_localPoint.SetV(circle2.m_p);
        manifold.m_points[0].m_id.key = 0
    };
    b2Collision.CollidePolygonAndCircle = function(manifold, polygon, xf1, circle, xf2) {
        manifold.m_pointCount = 0;
        var tPoint;
        var dX;
        var dY;
        var positionX;
        var positionY;
        var tVec;
        var tMat;
        tMat = xf2.R;
        tVec = circle.m_p;
        var cX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        var cY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        dX = cX - xf1.position.x;
        dY = cY - xf1.position.y;
        tMat = xf1.R;
        var cLocalX = dX * tMat.col1.x + dY * tMat.col1.y;
        var cLocalY = dX * tMat.col2.x + dY * tMat.col2.y;
        var dist;
        var normalIndex = 0;
        var separation = -Number.MAX_VALUE;
        var radius = polygon.m_radius + circle.m_radius;
        var vertexCount = polygon.m_vertexCount;
        var vertices = polygon.m_vertices;
        var normals = polygon.m_normals;
        for (var i = 0; i < vertexCount; ++i) {
            tVec = vertices[i];
            dX = cLocalX - tVec.x;
            dY = cLocalY - tVec.y;
            tVec = normals[i];
            var s = tVec.x * dX + tVec.y * dY;
            if (s > radius) {
                return
            }
            if (s > separation) {
                separation = s;
                normalIndex = i
            }
        }
        var vertIndex1 = normalIndex;
        var vertIndex2 = vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0;
        var v1 = vertices[vertIndex1];
        var v2 = vertices[vertIndex2];
        if (separation < Number.MIN_VALUE) {
            manifold.m_pointCount = 1;
            manifold.m_type = b2Manifold.e_faceA;
            manifold.m_localPlaneNormal.SetV(normals[normalIndex]);
            manifold.m_localPoint.x = .5 * (v1.x + v2.x);
            manifold.m_localPoint.y = .5 * (v1.y + v2.y);
            manifold.m_points[0].m_localPoint.SetV(circle.m_p);
            manifold.m_points[0].m_id.key = 0;
            return
        }
        var u1 = (cLocalX - v1.x) * (v2.x - v1.x) + (cLocalY - v1.y) * (v2.y - v1.y);
        var u2 = (cLocalX - v2.x) * (v1.x - v2.x) + (cLocalY - v2.y) * (v1.y - v2.y);
        if (u1 <= 0) {
            if ((cLocalX - v1.x) * (cLocalX - v1.x) + (cLocalY - v1.y) * (cLocalY - v1.y) > radius * radius) return;
            manifold.m_pointCount = 1;
            manifold.m_type = b2Manifold.e_faceA;
            manifold.m_localPlaneNormal.x = cLocalX - v1.x;
            manifold.m_localPlaneNormal.y = cLocalY - v1.y;
            manifold.m_localPlaneNormal.Normalize();
            manifold.m_localPoint.SetV(v1);
            manifold.m_points[0].m_localPoint.SetV(circle.m_p);
            manifold.m_points[0].m_id.key = 0
        } else if (u2 <= 0) {
            if ((cLocalX - v2.x) * (cLocalX - v2.x) + (cLocalY - v2.y) * (cLocalY - v2.y) > radius * radius) return;
            manifold.m_pointCount = 1;
            manifold.m_type = b2Manifold.e_faceA;
            manifold.m_localPlaneNormal.x = cLocalX - v2.x;
            manifold.m_localPlaneNormal.y = cLocalY - v2.y;
            manifold.m_localPlaneNormal.Normalize();
            manifold.m_localPoint.SetV(v2);
            manifold.m_points[0].m_localPoint.SetV(circle.m_p);
            manifold.m_points[0].m_id.key = 0
        } else {
            var faceCenterX = .5 * (v1.x + v2.x);
            var faceCenterY = .5 * (v1.y + v2.y);
            separation = (cLocalX - faceCenterX) * normals[vertIndex1].x + (cLocalY - faceCenterY) * normals[vertIndex1].y;
            if (separation > radius) return;
            manifold.m_pointCount = 1;
            manifold.m_type = b2Manifold.e_faceA;
            manifold.m_localPlaneNormal.x = normals[vertIndex1].x;
            manifold.m_localPlaneNormal.y = normals[vertIndex1].y;
            manifold.m_localPlaneNormal.Normalize();
            manifold.m_localPoint.Set(faceCenterX, faceCenterY);
            manifold.m_points[0].m_localPoint.SetV(circle.m_p);
            manifold.m_points[0].m_id.key = 0
        }
    };
    b2Collision.TestOverlap = function(a, b) {
        var t1 = b.lowerBound;
        var t2 = a.upperBound;
        var d1X = t1.x - t2.x;
        var d1Y = t1.y - t2.y;
        t1 = a.lowerBound;
        t2 = b.upperBound;
        var d2X = t1.x - t2.x;
        var d2Y = t1.y - t2.y;
        if (d1X > 0 || d1Y > 0) return false;
        if (d2X > 0 || d2Y > 0) return false;
        return true
    };
    b2Collision.b2_nullFeature = 255;
    b2Collision.s_incidentEdge = b2Collision.MakeClipPointVector();
    b2Collision.s_clipPoints1 = b2Collision.MakeClipPointVector();
    b2Collision.s_clipPoints2 = b2Collision.MakeClipPointVector();
    b2Collision.s_edgeAO = new Array(1);
    b2Collision.s_edgeBO = new Array(1);
    b2Collision.s_localTangent = new b2Vec2;
    b2Collision.s_localNormal = new b2Vec2;
    b2Collision.s_planePoint = new b2Vec2;
    b2Collision.s_normal = new b2Vec2;
    b2Collision.s_tangent = new b2Vec2;
    b2Collision.s_tangent2 = new b2Vec2;
    b2Collision.s_v11 = new b2Vec2;
    b2Collision.s_v12 = new b2Vec2;
    b2Collision.b2CollidePolyTempVec = new b2Vec2;
    var b2PolyAndCircleContact = function() {
        b2Contact.prototype.__varz.call(this);
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    extend(b2PolyAndCircleContact.prototype, b2Contact.prototype);
    b2PolyAndCircleContact.prototype._super = b2Contact.prototype;
    b2PolyAndCircleContact.prototype.__constructor = function() {
        this._super.__constructor.apply(this, arguments)
    };
    b2PolyAndCircleContact.prototype.__varz = function() {};
    b2PolyAndCircleContact.Create = function(allocator) {
        return new b2PolyAndCircleContact
    };
    b2PolyAndCircleContact.Destroy = function(contact, allocator) {};
    b2PolyAndCircleContact.prototype.Evaluate = function() {
        var bA = this.m_fixtureA.m_body;
        var bB = this.m_fixtureB.m_body;
        b2Collision.CollidePolygonAndCircle(this.m_manifold, this.m_fixtureA.GetShape(), bA.m_xf, this.m_fixtureB.GetShape(), bB.m_xf)
    };
    b2PolyAndCircleContact.prototype.Reset = function(fixtureA, fixtureB) {
        this._super.Reset.apply(this, [fixtureA, fixtureB]);
        b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_polygonShape);
        b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_circleShape)
    };
    var b2ContactPoint = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2ContactPoint.prototype.__constructor = function() {};
    b2ContactPoint.prototype.__varz = function() {
        this.position = new b2Vec2;
        this.velocity = new b2Vec2;
        this.normal = new b2Vec2;
        this.id = new b2ContactID
    };
    b2ContactPoint.prototype.shape1 = null;
    b2ContactPoint.prototype.shape2 = null;
    b2ContactPoint.prototype.position = new b2Vec2;
    b2ContactPoint.prototype.velocity = new b2Vec2;
    b2ContactPoint.prototype.normal = new b2Vec2;
    b2ContactPoint.prototype.separation = null;
    b2ContactPoint.prototype.friction = null;
    b2ContactPoint.prototype.restitution = null;
    b2ContactPoint.prototype.id = new b2ContactID;
    var b2CircleContact = function() {
        b2Contact.prototype.__varz.call(this);
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    extend(b2CircleContact.prototype, b2Contact.prototype);
    b2CircleContact.prototype._super = b2Contact.prototype;
    b2CircleContact.prototype.__constructor = function() {
        this._super.__constructor.apply(this, arguments)
    };
    b2CircleContact.prototype.__varz = function() {};
    b2CircleContact.Create = function(allocator) {
        return new b2CircleContact
    };
    b2CircleContact.Destroy = function(contact, allocator) {};
    b2CircleContact.prototype.Evaluate = function() {
        var bA = this.m_fixtureA.GetBody();
        var bB = this.m_fixtureB.GetBody();
        b2Collision.CollideCircles(this.m_manifold, this.m_fixtureA.GetShape(), bA.m_xf, this.m_fixtureB.GetShape(), bB.m_xf)
    };
    b2CircleContact.prototype.Reset = function(fixtureA, fixtureB) {
        this._super.Reset.apply(this, [fixtureA, fixtureB])
    };
    var b2EdgeAndCircleContact = function() {
        b2Contact.prototype.__varz.call(this);
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    extend(b2EdgeAndCircleContact.prototype, b2Contact.prototype);
    b2EdgeAndCircleContact.prototype._super = b2Contact.prototype;
    b2EdgeAndCircleContact.prototype.__constructor = function() {
        this._super.__constructor.apply(this, arguments)
    };
    b2EdgeAndCircleContact.prototype.__varz = function() {};
    b2EdgeAndCircleContact.Create = function(allocator) {
        return new b2EdgeAndCircleContact
    };
    b2EdgeAndCircleContact.Destroy = function(contact, allocator) {};
    b2EdgeAndCircleContact.prototype.Evaluate = function() {
        var bA = this.m_fixtureA.GetBody();
        var bB = this.m_fixtureB.GetBody();
        this.b2CollideEdgeAndCircle(this.m_manifold, this.m_fixtureA.GetShape(), bA.m_xf, this.m_fixtureB.GetShape(), bB.m_xf)
    };
    b2EdgeAndCircleContact.prototype.b2CollideEdgeAndCircle = function(manifold, edge, xf1, circle, xf2) {};
    b2EdgeAndCircleContact.prototype.Reset = function(fixtureA, fixtureB) {
        this._super.Reset.apply(this, [fixtureA, fixtureB])
    };
    var b2ContactManager = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2ContactManager.prototype.__constructor = function() {
        this.m_world = null;
        this.m_contactCount = 0;
        this.m_contactFilter = b2ContactFilter.b2_defaultFilter;
        this.m_contactListener = b2ContactListener.b2_defaultListener;
        this.m_contactFactory = new b2ContactFactory(this.m_allocator);
        this.m_broadPhase = new b2DynamicTreeBroadPhase
    };
    b2ContactManager.prototype.__varz = function() {};
    b2ContactManager.s_evalCP = new b2ContactPoint;
    b2ContactManager.prototype.AddPair = function(proxyUserDataA, proxyUserDataB) {
        var fixtureA = proxyUserDataA;
        var fixtureB = proxyUserDataB;
        var bodyA = fixtureA.GetBody();
        var bodyB = fixtureB.GetBody();
        if (bodyA == bodyB) return;
        var edge = bodyB.GetContactList();
        while (edge) {
            if (edge.other == bodyA) {
                var fA = edge.contact.GetFixtureA();
                var fB = edge.contact.GetFixtureB();
                if (fA == fixtureA && fB == fixtureB) return;
                if (fA == fixtureB && fB == fixtureA) return
            }
            edge = edge.next
        }
        if (bodyB.ShouldCollide(bodyA) == false) {
            return
        }
        if (this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) == false) {
            return
        }
        var c = this.m_contactFactory.Create(fixtureA, fixtureB);
        fixtureA = c.GetFixtureA();
        fixtureB = c.GetFixtureB();
        bodyA = fixtureA.m_body;
        bodyB = fixtureB.m_body;
        c.m_prev = null;
        c.m_next = this.m_world.m_contactList;
        if (this.m_world.m_contactList != null) {
            this.m_world.m_contactList.m_prev = c
        }
        this.m_world.m_contactList = c;
        c.m_nodeA.contact = c;
        c.m_nodeA.other = bodyB;
        c.m_nodeA.prev = null;
        c.m_nodeA.next = bodyA.m_contactList;
        if (bodyA.m_contactList != null) {
            bodyA.m_contactList.prev = c.m_nodeA
        }
        bodyA.m_contactList = c.m_nodeA;
        c.m_nodeB.contact = c;
        c.m_nodeB.other = bodyA;
        c.m_nodeB.prev = null;
        c.m_nodeB.next = bodyB.m_contactList;
        if (bodyB.m_contactList != null) {
            bodyB.m_contactList.prev = c.m_nodeB
        }
        bodyB.m_contactList = c.m_nodeB;
        ++this.m_world.m_contactCount;
        return
    };
    b2ContactManager.prototype.FindNewContacts = function() {
        var that = this;
        this.m_broadPhase.UpdatePairs(function(a, b) {
            return that.AddPair(a, b)
        })
    };
    b2ContactManager.prototype.Destroy = function(c) {
        var fixtureA = c.GetFixtureA();
        var fixtureB = c.GetFixtureB();
        var bodyA = fixtureA.GetBody();
        var bodyB = fixtureB.GetBody();
        if (c.IsTouching()) {
            this.m_contactListener.EndContact(c)
        }
        if (c.m_prev) {
            c.m_prev.m_next = c.m_next
        }
        if (c.m_next) {
            c.m_next.m_prev = c.m_prev
        }
        if (c == this.m_world.m_contactList) {
            this.m_world.m_contactList = c.m_next
        }
        if (c.m_nodeA.prev) {
            c.m_nodeA.prev.next = c.m_nodeA.next
        }
        if (c.m_nodeA.next) {
            c.m_nodeA.next.prev = c.m_nodeA.prev
        }
        if (c.m_nodeA == bodyA.m_contactList) {
            bodyA.m_contactList = c.m_nodeA.next
        }
        if (c.m_nodeB.prev) {
            c.m_nodeB.prev.next = c.m_nodeB.next
        }
        if (c.m_nodeB.next) {
            c.m_nodeB.next.prev = c.m_nodeB.prev
        }
        if (c.m_nodeB == bodyB.m_contactList) {
            bodyB.m_contactList = c.m_nodeB.next
        }
        this.m_contactFactory.Destroy(c);
        --this.m_contactCount
    };
    b2ContactManager.prototype.Collide = function() {
        var c = this.m_world.m_contactList;
        while (c) {
            if (!(c.m_fixtureA.m_body.m_flags & b2Body.e_awakeFlag) && !(c.m_fixtureB.m_body.m_flags & b2Body.e_awakeFlag)) {
                c = c.m_next;
                continue
            }
            var fixtureA = c.GetFixtureA();
            var fixtureB = c.GetFixtureB();
            var bodyA = fixtureA.GetBody();
            var bodyB = fixtureB.GetBody();
            if (c.m_flags & b2Contact.e_filterFlag) {
                if (bodyB.ShouldCollide(bodyA) == false) {
                    var cNuke = c;
                    c = cNuke.GetNext();
                    this.Destroy(cNuke);
                    continue
                }
                if (this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) == false) {
                    cNuke = c;
                    c = cNuke.GetNext();
                    this.Destroy(cNuke);
                    continue
                }
                c.m_flags &= ~b2Contact.e_filterFlag
            }
            var proxyA = fixtureA.m_proxy;
            var proxyB = fixtureB.m_proxy;
            var overlap = this.m_broadPhase.TestOverlap(proxyA, proxyB);
            if (overlap == false) {
                cNuke = c;
                c = cNuke.GetNext();
                this.Destroy(cNuke);
                continue
            }
            c.Update(this.m_contactListener);
            c = c.GetNext()
        }
    };
    b2ContactManager.prototype.m_world = null;
    b2ContactManager.prototype.m_broadPhase = null;
    b2ContactManager.prototype.m_contactList = null;
    b2ContactManager.prototype.m_contactCount = 0;
    b2ContactManager.prototype.m_contactFilter = null;
    b2ContactManager.prototype.m_contactListener = null;
    b2ContactManager.prototype.m_contactFactory = null;
    b2ContactManager.prototype.m_allocator = null;
    var b2World = function() {
        this.__varz();
        this.__constructor.apply(this, arguments)
    };
    b2World.prototype.__constructor = function(gravity, doSleep) {
        this.m_destructionListener = null;
        this.m_debugDraw = null;
        this.m_bodyList = null;
        this.m_bodyListActive = null;
        this.m_contactList = null;
        this.m_jointList = null;
        this.m_controllerList = null;
        this.m_bodyCount = 0;
        this.m_bodyCountActive = 0;
        this.m_contactCount = 0;
        this.m_jointCount = 0;
        this.m_controllerCount = 0;
        b2World.m_warmStarting = true;
        b2World.m_continuousPhysics = true;
        this.m_allowSleep = doSleep;
        this.m_gravity = gravity;
        this.m_inv_dt0 = 0;
        this.m_contactManager.m_world = this;
        var bd = new b2BodyDef;
        this.m_groundBody = this.CreateBody(bd)
    };
    b2World.prototype.__varz = function() {
        this.s_stack = new Array;
        this.m_contactManager = new b2ContactManager;
        this.m_contactSolver = new b2ContactSolver;
        this.m_island = new b2Island
    };
    b2World.s_timestep2 = new b2TimeStep;
    b2World.s_backupA = new b2Sweep;
    b2World.s_backupB = new b2Sweep;
    b2World.s_timestep = new b2TimeStep;
    b2World.s_queue = new Array;
    b2World.e_newFixture = 1;
    b2World.e_locked = 2;
    b2World.s_xf = new b2Transform;
    b2World.s_jointColor = new b2Color(.5, .8, .8);
    b2World.m_warmStarting = null;
    b2World.m_continuousPhysics = null;
    b2World.prototype.Solve = function(step) {
        var b;
        for (var controller = this.m_controllerList; controller; controller = controller.m_next) {
            controller.Step(step)
        }
        var island = this.m_island;
        island.Initialize(this.m_bodyCount, this.m_contactCount, this.m_jointCount, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
        for (b = this.m_bodyList; b; b = b.m_next) {
            b.m_flags &= ~b2Body.e_islandFlag;
            if (b.m_type == b2Body.b2_staticBody) {
                b.m_flags &= ~b2Body.e_awakeFlag
            }
        }
        for (var c = this.m_contactList; c; c = c.m_next) {
            c.m_flags &= ~b2Contact.e_islandFlag
        }
        for (var j = this.m_jointList; j; j = j.m_next) {
            j.m_islandFlag = false
        }
        var stackSize = this.m_bodyCount;
        var stack = this.s_stack;
        for (var seed = this.m_bodyListActive; seed; seed = seed.m_nextActive) {
            if (seed.m_flags & b2Body.e_islandFlag) {
                continue
            }
            if (seed.IsAwake() == false || seed.IsActive() == false) {
                continue
            }
            island.Clear();
            var stackCount = 0;
            stack[stackCount++] = seed;
            seed.m_flags |= b2Body.e_islandFlag;
            while (stackCount > 0) {
                b = stack[--stackCount];
                island.AddBody(b);
                if (b.IsAwake() == false) {
                    b.SetAwake(true)
                }
                if (b.GetType() == b2Body.b2_staticBody) {
                    continue
                }
                var other;
                for (var ce = b.m_contactList; ce; ce = ce.next) {
                    if (ce.contact.m_flags & b2Contact.e_islandFlag) {
                        continue
                    }
                    if (ce.contact.IsSensor() == true || ce.contact.IsEnabled() == false || ce.contact.IsTouching() == false) {
                        continue
                    }
                    island.AddContact(ce.contact);
                    ce.contact.m_flags |= b2Contact.e_islandFlag;
                    other = ce.other;
                    if (other.m_flags & b2Body.e_islandFlag) {
                        continue
                    }
                    stack[stackCount++] = other;
                    other.m_flags |= b2Body.e_islandFlag
                }
                for (var jn = b.m_jointList; jn; jn = jn.next) {
                    if (jn.joint.m_islandFlag == true) {
                        continue
                    }
                    other = jn.other;
                    if (other.IsActive() == false) {
                        continue
                    }
                    island.AddJoint(jn.joint);
                    jn.joint.m_islandFlag = true;
                    if (other.m_flags & b2Body.e_islandFlag) {
                        continue
                    }
                    stack[stackCount++] = other;
                    other.m_flags |= b2Body.e_islandFlag
                }
            }
            island.Solve(step, this.m_gravity, this.m_allowSleep);
            for (var i = 0; i < island.m_bodyCount; ++i) {
                b = island.m_bodies[i];
                if (b.GetType() == b2Body.b2_staticBody) {
                    b.m_flags &= ~b2Body.e_islandFlag
                }
            }
        }
        for (i = 0; i < stack.length; ++i) {
            if (!stack[i]) break;
            stack[i] = null
        }
        for (b = this.m_bodyListActive; b; b = b.m_nextActive) {
            if (b.IsAwake() == false || b.IsActive() == false) {
                continue
            }
            b.SynchronizeFixtures()
        }
        this.m_contactManager.FindNewContacts()
    };
    b2World.prototype.SolveTOI = function(step) {
        var b;
        var fA;
        var fB;
        var bA;
        var bB;
        var cEdge;
        var j;
        var island = this.m_island;
        island.Initialize(this.m_bodyCount, b2Settings.b2_maxTOIContactsPerIsland, b2Settings.b2_maxTOIJointsPerIsland, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
        var queue = b2World.s_queue;
        for (b = this.m_bodyList; b; b = b.m_next) {
            b.m_flags &= ~b2Body.e_islandFlag;
            b.m_sweep.t0 = 0
        }
        var c;
        for (c = this.m_contactList; c; c = c.m_next) {
            c.m_flags &= ~(b2Contact.e_toiFlag | b2Contact.e_islandFlag)
        }
        for (j = this.m_jointList; j; j = j.m_next) {
            j.m_islandFlag = false
        }
        for (;;) {
            var minContact = null;
            var minTOI = 1;
            for (c = this.m_contactList; c; c = c.m_next) {
                if (c.IsSensor() == true || c.IsEnabled() == false || c.IsContinuous() == false) {
                    continue
                }
                var toi = 1;
                if (c.m_flags & b2Contact.e_toiFlag) {
                    toi = c.m_toi
                } else {
                    fA = c.m_fixtureA;
                    fB = c.m_fixtureB;
                    bA = fA.m_body;
                    bB = fB.m_body;
                    if ((bA.GetType() != b2Body.b2_dynamicBody || bA.IsAwake() == false) && (bB.GetType() != b2Body.b2_dynamicBody || bB.IsAwake() == false)) {
                        continue
                    }
                    var t0 = bA.m_sweep.t0;
                    if (bA.m_sweep.t0 < bB.m_sweep.t0) {
                        t0 = bB.m_sweep.t0;
                        bA.m_sweep.Advance(t0)
                    } else if (bB.m_sweep.t0 < bA.m_sweep.t0) {
                        t0 = bA.m_sweep.t0;
                        bB.m_sweep.Advance(t0)
                    }
                    toi = c.ComputeTOI(bA.m_sweep, bB.m_sweep);
                    b2Settings.b2Assert(0 <= toi && toi <= 1);
                    if (toi > 0 && toi < 1) {
                        toi = (1 - toi) * t0 + toi;
                        if (toi > 1) toi = 1
                    }
                    c.m_toi = toi;
                    c.m_flags |= b2Contact.e_toiFlag
                }
                if (Number.MIN_VALUE < toi && toi < minTOI) {
                    minContact = c;
                    minTOI = toi
                }
            }
            if (minContact == null || 1 - 100 * Number.MIN_VALUE < minTOI) {
                break
            }
            fA = minContact.m_fixtureA;
            fB = minContact.m_fixtureB;
            bA = fA.m_body;
            bB = fB.m_body;
            b2World.s_backupA.Set(bA.m_sweep);
            b2World.s_backupB.Set(bB.m_sweep);
            bA.Advance(minTOI);
            bB.Advance(minTOI);
            minContact.Update(this.m_contactManager.m_contactListener);
            minContact.m_flags &= ~b2Contact.e_toiFlag;
            if (minContact.IsSensor() == true || minContact.IsEnabled() == false) {
                bA.m_sweep.Set(b2World.s_backupA);
                bB.m_sweep.Set(b2World.s_backupB);
                bA.SynchronizeTransform();
                bB.SynchronizeTransform();
                continue
            }
            if (minContact.IsTouching() == false) {
                continue
            }
            var seed = bA;
            if (seed.GetType() != b2Body.b2_dynamicBody) {
                seed = bB
            }
            island.Clear();
            var queueStart = 0;
            var queueSize = 0;
            queue[queueStart + queueSize++] = seed;
            seed.m_flags |= b2Body.e_islandFlag;
            while (queueSize > 0) {
                b = queue[queueStart++];
                --queueSize;
                island.AddBody(b);
                if (b.IsAwake() == false) {
                    b.SetAwake(true)
                }
                if (b.GetType() != b2Body.b2_dynamicBody) {
                    continue
                }
                for (cEdge = b.m_contactList; cEdge; cEdge = cEdge.next) {
                    if (island.m_contactCount == island.m_contactCapacity) {
                        break
                    }
                    if (cEdge.contact.m_flags & b2Contact.e_islandFlag) {
                        continue
                    }
                    if (cEdge.contact.IsSensor() == true || cEdge.contact.IsEnabled() == false || cEdge.contact.IsTouching() == false) {
                        continue
                    }
                    island.AddContact(cEdge.contact);
                    cEdge.contact.m_flags |= b2Contact.e_islandFlag;
                    var other = cEdge.other;
                    if (other.m_flags & b2Body.e_islandFlag) {
                        continue
                    }
                    if (other.GetType() != b2Body.b2_staticBody) {
                        other.Advance(minTOI);
                        other.SetAwake(true)
                    }
                    queue[queueStart + queueSize] = other;
                    ++queueSize;
                    other.m_flags |= b2Body.e_islandFlag
                }
                for (var jEdge = b.m_jointList; jEdge; jEdge = jEdge.next) {
                    if (island.m_jointCount == island.m_jointCapacity) continue;
                    if (jEdge.joint.m_islandFlag == true) continue;
                    other = jEdge.other;
                    if (other.IsActive() == false) {
                        continue
                    }
                    island.AddJoint(jEdge.joint);
                    jEdge.joint.m_islandFlag = true;
                    if (other.m_flags & b2Body.e_islandFlag) continue;
                    if (other.GetType() != b2Body.b2_staticBody) {
                        other.Advance(minTOI);
                        other.SetAwake(true)
                    }
                    queue[queueStart + queueSize] = other;
                    ++queueSize;
                    other.m_flags |= b2Body.e_islandFlag
                }
            }
            var subStep = b2World.s_timestep;
            subStep.warmStarting = false;
            subStep.dt = (1 - minTOI) * step.dt;
            subStep.inv_dt = 1 / subStep.dt;
            subStep.dtRatio = 0;
            subStep.velocityIterations = step.velocityIterations;
            subStep.positionIterations = step.positionIterations;
            island.SolveTOI(subStep);
            var i = 0;
            for (i = 0; i < island.m_bodyCount; ++i) {
                b = island.m_bodies[i];
                b.m_flags &= ~b2Body.e_islandFlag;
                if (b.IsAwake() == false) {
                    continue
                }
                if (b.GetType() != b2Body.b2_dynamicBody) {
                    continue
                }
                b.SynchronizeFixtures();
                for (cEdge = b.m_contactList; cEdge; cEdge = cEdge.next) {
                    cEdge.contact.m_flags &= ~b2Contact.e_toiFlag
                }
            }
            for (i = 0; i < island.m_contactCount; ++i) {
                c = island.m_contacts[i];
                c.m_flags &= ~(b2Contact.e_toiFlag | b2Contact.e_islandFlag)
            }
            for (i = 0; i < island.m_jointCount; ++i) {
                j = island.m_joints[i];
                j.m_islandFlag = false
            }
            this.m_contactManager.FindNewContacts()
        }
    };
    b2World.prototype.DrawJoint = function(joint) {
        var b1 = joint.GetBodyA();
        var b2 = joint.GetBodyB();
        var xf1 = b1.m_xf;
        var xf2 = b2.m_xf;
        var x1 = xf1.position;
        var x2 = xf2.position;
        var p1 = joint.GetAnchorA();
        var p2 = joint.GetAnchorB();
        var color = b2World.s_jointColor;
        switch (joint.m_type) {
            case b2Joint.e_distanceJoint:
                this.m_debugDraw.DrawSegment(p1, p2, color);
                break;
            case b2Joint.e_pulleyJoint:
                {
                    var pulley = joint;
                    var s1 = pulley.GetGroundAnchorA();
                    var s2 = pulley.GetGroundAnchorB();this.m_debugDraw.DrawSegment(s1, p1, color);this.m_debugDraw.DrawSegment(s2, p2, color);this.m_debugDraw.DrawSegment(s1, s2, color)
                }
                break;
            case b2Joint.e_mouseJoint:
                this.m_debugDraw.DrawSegment(p1, p2, color);
                break;
            default:
                if (b1 != this.m_groundBody) this.m_debugDraw.DrawSegment(x1, p1, color);
                this.m_debugDraw.DrawSegment(p1, p2, color);
                if (b2 != this.m_groundBody) this.m_debugDraw.DrawSegment(x2, p2, color)
        }
    };
    b2World.prototype.DrawShape = function(shape, xf, color) {
        switch (shape.m_type) {
            case b2Shape.e_circleShape:
                {
                    var circle = shape;
                    var center = b2Math.MulX(xf, circle.m_p);
                    var radius = circle.m_radius;
                    var axis = xf.R.col1;this.m_debugDraw.DrawSolidCircle(center, radius, axis, color)
                }
                break;
            case b2Shape.e_polygonShape:
                {
                    var i = 0;
                    var poly = shape;
                    var vertexCount = poly.GetVertexCount();
                    var localVertices = poly.GetVertices();
                    var vertices = new Array(vertexCount);
                    for (i = 0; i < vertexCount; ++i) {
                        vertices[i] = b2Math.MulX(xf, localVertices[i])
                    }
                    this.m_debugDraw.DrawSolidPolygon(vertices, vertexCount, color)
                }
                break;
            case b2Shape.e_edgeShape:
                {
                    var edge = shape;this.m_debugDraw.DrawSegment(b2Math.MulX(xf, edge.GetVertex1()), b2Math.MulX(xf, edge.GetVertex2()), color)
                }
                break
        }
    };
    b2World.prototype.SetDestructionListener = function(listener) {
        this.m_destructionListener = listener
    };
    b2World.prototype.SetContactFilter = function(filter) {
        this.m_contactManager.m_contactFilter = filter
    };
    b2World.prototype.SetContactListener = function(listener) {
        this.m_contactManager.m_contactListener = listener
    };
    b2World.prototype.SetDebugDraw = function(debugDraw) {
        this.m_debugDraw = debugDraw
    };
    b2World.prototype.SetBroadPhase = function(broadPhase) {
        var oldBroadPhase = this.m_contactManager.m_broadPhase;
        this.m_contactManager.m_broadPhase = broadPhase;
        for (var b = this.m_bodyList; b; b = b.m_next) {
            for (var f = b.m_fixtureList; f; f = f.m_next) {
                f.m_proxy = broadPhase.CreateProxy(oldBroadPhase.GetFatAABB(f.m_proxy), f)
            }
        }
    };
    b2World.prototype.Validate = function() {
        this.m_contactManager.m_broadPhase.Validate()
    };
    b2World.prototype.GetProxyCount = function() {
        return this.m_contactManager.m_broadPhase.GetProxyCount()
    };
    b2World.prototype.CreateBody = function(def) {
        if (this.IsLocked() == true) {
            return null
        }
        var b = new b2Body(def, this);
        b.m_prev = null;
        b.m_next = this.m_bodyList;
        if (this.m_bodyList) {
            this.m_bodyList.m_prev = b
        }
        this.m_bodyList = b;
        ++this.m_bodyCount;
        if (def.type == b2Body.b2_dynamicBody) {
            b.m_prevActive = null;
            b.m_nextActive = this.m_bodyListActive;
            if (this.m_bodyListActive) {
                this.m_bodyListActive.m_prevActive = b
            }
            this.m_bodyListActive = b;
            ++this.m_bodyCountActive
        }
        return b
    };
    b2World.prototype.DestroyBody = function(b) {
        if (this.IsLocked() == true) {
            return
        }
        var jn = b.m_jointList;
        while (jn) {
            var jn0 = jn;
            jn = jn.next;
            if (this.m_destructionListener) {
                this.m_destructionListener.SayGoodbyeJoint(jn0.joint)
            }
            this.DestroyJoint(jn0.joint)
        }
        var coe = b.m_controllerList;
        while (coe) {
            var coe0 = coe;
            coe = coe.nextController;
            coe0.controller.RemoveBody(b)
        }
        var ce = b.m_contactList;
        while (ce) {
            var ce0 = ce;
            ce = ce.next;
            this.m_contactManager.Destroy(ce0.contact)
        }
        b.m_contactList = null;
        var f = b.m_fixtureList;
        while (f) {
            var f0 = f;
            f = f.m_next;
            if (this.m_destructionListener) {
                this.m_destructionListener.SayGoodbyeFixture(f0)
            }
            f0.DestroyProxy(this.m_contactManager.m_broadPhase);
            f0.Destroy()
        }
        b.m_fixtureList = null;
        b.m_fixtureCount = 0;
        if (b.m_prev) {
            b.m_prev.m_next = b.m_next
        }
        if (b.m_next) {
            b.m_next.m_prev = b.m_prev
        }
        if (b == this.m_bodyList) {
            this.m_bodyList = b.m_next
        }--this.m_bodyCount;
        if (b.GetType() === Physics.B2Body.b2_dynamicBody) {
            if (b.m_prevActive) {
                b.m_prevActive.m_nextActive = b.m_nextActive
            }
            if (b.m_nextActive) {
                b.m_nextActive.m_prevActive = b.m_prevActive
            }
            if (b == this.m_bodyListActive) {
                this.m_bodyListActive = b.m_nextActive
            }--this.m_bodyCountActive
        }
    };
    b2World.prototype.CreateJoint = function(def) {
        var j = b2Joint.Create(def, null);
        j.m_prev = null;
        j.m_next = this.m_jointList;
        if (this.m_jointList) {
            this.m_jointList.m_prev = j
        }
        this.m_jointList = j;
        ++this.m_jointCount;
        j.m_edgeA.joint = j;
        j.m_edgeA.other = j.m_bodyB;
        j.m_edgeA.prev = null;
        j.m_edgeA.next = j.m_bodyA.m_jointList;
        if (j.m_bodyA.m_jointList) j.m_bodyA.m_jointList.prev = j.m_edgeA;
        j.m_bodyA.m_jointList = j.m_edgeA;
        j.m_edgeB.joint = j;
        j.m_edgeB.other = j.m_bodyA;
        j.m_edgeB.prev = null;
        j.m_edgeB.next = j.m_bodyB.m_jointList;
        if (j.m_bodyB.m_jointList) j.m_bodyB.m_jointList.prev = j.m_edgeB;
        j.m_bodyB.m_jointList = j.m_edgeB;
        var bodyA = def.bodyA;
        var bodyB = def.bodyB;
        if (def.collideConnected == false) {
            var edge = bodyB.GetContactList();
            while (edge) {
                if (edge.other == bodyA) {
                    edge.contact.FlagForFiltering()
                }
                edge = edge.next
            }
        }
        return j
    };
    b2World.prototype.DestroyJoint = function(j) {
        var collideConnected = j.m_collideConnected;
        if (j.m_prev) {
            j.m_prev.m_next = j.m_next
        }
        if (j.m_next) {
            j.m_next.m_prev = j.m_prev
        }
        if (j == this.m_jointList) {
            this.m_jointList = j.m_next
        }
        var bodyA = j.m_bodyA;
        var bodyB = j.m_bodyB;
        bodyA.SetAwake(true);
        bodyB.SetAwake(true);
        if (j.m_edgeA.prev) {
            j.m_edgeA.prev.next = j.m_edgeA.next
        }
        if (j.m_edgeA.next) {
            j.m_edgeA.next.prev = j.m_edgeA.prev
        }
        if (j.m_edgeA == bodyA.m_jointList) {
            bodyA.m_jointList = j.m_edgeA.next
        }
        j.m_edgeA.prev = null;
        j.m_edgeA.next = null;
        if (j.m_edgeB.prev) {
            j.m_edgeB.prev.next = j.m_edgeB.next
        }
        if (j.m_edgeB.next) {
            j.m_edgeB.next.prev = j.m_edgeB.prev
        }
        if (j.m_edgeB == bodyB.m_jointList) {
            bodyB.m_jointList = j.m_edgeB.next
        }
        j.m_edgeB.prev = null;
        j.m_edgeB.next = null;
        b2Joint.Destroy(j, null);
        --this.m_jointCount;
        if (collideConnected == false) {
            var edge = bodyB.GetContactList();
            while (edge) {
                if (edge.other == bodyA) {
                    edge.contact.FlagForFiltering()
                }
                edge = edge.next
            }
        }
    };
    b2World.prototype.AddController = function(c) {
        c.m_next = this.m_controllerList;
        c.m_prev = null;
        this.m_controllerList = c;
        c.m_world = this;
        this.m_controllerCount++;
        return c
    };
    b2World.prototype.RemoveController = function(c) {
        if (c.m_prev) c.m_prev.m_next = c.m_next;
        if (c.m_next) c.m_next.m_prev = c.m_prev;
        if (this.m_controllerList == c) this.m_controllerList = c.m_next;
        this.m_controllerCount--
    };
    b2World.prototype.CreateController = function(controller) {
        if (controller.m_world != this) throw new Error("Controller can only be a member of one world");
        controller.m_next = this.m_controllerList;
        controller.m_prev = null;
        if (this.m_controllerList) this.m_controllerList.m_prev = controller;
        this.m_controllerList = controller;
        ++this.m_controllerCount;
        controller.m_world = this;
        return controller
    };
    b2World.prototype.DestroyController = function(controller) {
        controller.Clear();
        if (controller.m_next) controller.m_next.m_prev = controller.m_prev;
        if (controller.m_prev) controller.m_prev.m_next = controller.m_next;
        if (controller == this.m_controllerList) this.m_controllerList = controller.m_next;
        --this.m_controllerCount
    };
    b2World.prototype.SetWarmStarting = function(flag) {
        b2World.m_warmStarting = flag
    };
    b2World.prototype.SetContinuousPhysics = function(flag) {
        b2World.m_continuousPhysics = flag
    };
    b2World.prototype.GetBodyCount = function() {
        return this.m_bodyCount
    };
    b2World.prototype.GetJointCount = function() {
        return this.m_jointCount
    };
    b2World.prototype.GetContactCount = function() {
        return this.m_contactCount
    };
    b2World.prototype.SetGravity = function(gravity) {
        this.m_gravity = gravity
    };
    b2World.prototype.GetGravity = function() {
        return this.m_gravity
    };
    b2World.prototype.GetGroundBody = function() {
        return this.m_groundBody
    };
    b2World.prototype.Step = function(dt, velocityIterations, positionIterations) {
        if (this.m_flags & b2World.e_newFixture) {
            this.m_contactManager.FindNewContacts();
            this.m_flags &= ~b2World.e_newFixture
        }
        this.m_flags |= b2World.e_locked;
        var step = b2World.s_timestep2;
        step.dt = dt;
        step.velocityIterations = velocityIterations;
        step.positionIterations = positionIterations;
        if (dt > 0) {
            step.inv_dt = 1 / dt
        } else {
            step.inv_dt = 0
        }
        step.dtRatio = this.m_inv_dt0 * dt;
        step.warmStarting = b2World.m_warmStarting;
        this.m_contactManager.Collide();
        if (step.dt > 0) {
            this.Solve(step)
        }
        if (b2World.m_continuousPhysics && step.dt > 0) {
            this.SolveTOI(step)
        }
        if (step.dt > 0) {
            this.m_inv_dt0 = step.inv_dt
        }
        this.m_flags &= ~b2World.e_locked
    };
    b2World.prototype.ClearForces = function() {
        for (var body = this.m_bodyListActive; body; body = body.m_nextActive) {
            body.m_force.SetZero();
            body.m_torque = 0
        }
    };
    b2World.prototype.DrawDebugData = function() {
        if (this.m_debugDraw == null) {
            return
        }
        this.m_debugDraw.Clear();
        var flags = this.m_debugDraw.GetFlags();
        var i = 0;
        var b;
        var f;
        var s;
        var j;
        var bp;
        var invQ = new b2Vec2;
        var x1 = new b2Vec2;
        var x2 = new b2Vec2;
        var xf;
        var b1 = new b2AABB;
        var b2 = new b2AABB;
        var vs = [new b2Vec2, new b2Vec2, new b2Vec2, new b2Vec2];
        var color = new b2Color(0, 0, 0);
        if (flags & b2DebugDraw.e_shapeBit) {
            for (b = this.m_bodyList; b; b = b.m_next) {
                xf = b.m_xf;
                for (f = b.GetFixtureList(); f; f = f.m_next) {
                    s = f.GetShape();
                    if (b.IsActive() == false) {
                        color.Set(.5, .5, .3);
                        this.DrawShape(s, xf, color)
                    } else if (b.GetType() == b2Body.b2_staticBody) {
                        color.Set(.5, .9, .5);
                        this.DrawShape(s, xf, color)
                    } else if (b.GetType() == b2Body.b2_kinematicBody) {
                        color.Set(.5, .5, .9);
                        this.DrawShape(s, xf, color)
                    } else if (b.IsAwake() == false) {
                        color.Set(.6, .6, .6);
                        this.DrawShape(s, xf, color)
                    } else {
                        color.Set(.9, .7, .7);
                        this.DrawShape(s, xf, color)
                    }
                }
            }
        }
        if (flags & b2DebugDraw.e_jointBit) {
            for (j = this.m_jointList; j; j = j.m_next) {
                this.DrawJoint(j)
            }
        }
        if (flags & b2DebugDraw.e_controllerBit) {
            for (var c = this.m_controllerList; c; c = c.m_next) {
                c.Draw(this.m_debugDraw)
            }
        }
        if (flags & b2DebugDraw.e_pairBit) {
            color.Set(.3, .9, .9);
            for (var contact = this.m_contactManager.m_contactList; contact; contact = contact.GetNext()) {
                var fixtureA = contact.GetFixtureA();
                var fixtureB = contact.GetFixtureB();
                var cA = fixtureA.GetAABB().GetCenter();
                var cB = fixtureB.GetAABB().GetCenter();
                this.m_debugDraw.DrawSegment(cA, cB, color)
            }
        }
        if (flags & b2DebugDraw.e_aabbBit) {
            bp = this.m_contactManager.m_broadPhase;
            vs = [new b2Vec2, new b2Vec2, new b2Vec2, new b2Vec2];
            for (b = this.m_bodyList; b; b = b.GetNext()) {
                if (b.IsActive() == false) {
                    continue
                }
                for (f = b.GetFixtureList(); f; f = f.GetNext()) {
                    var aabb = bp.GetFatAABB(f.m_proxy);
                    vs[0].Set(aabb.lowerBound.x, aabb.lowerBound.y);
                    vs[1].Set(aabb.upperBound.x, aabb.lowerBound.y);
                    vs[2].Set(aabb.upperBound.x, aabb.upperBound.y);
                    vs[3].Set(aabb.lowerBound.x, aabb.upperBound.y);
                    this.m_debugDraw.DrawPolygon(vs, 4, color)
                }
            }
        }
        if (flags & b2DebugDraw.e_centerOfMassBit) {
            for (b = this.m_bodyList; b; b = b.m_next) {
                xf = b2World.s_xf;
                xf.R = b.m_xf.R;
                xf.position = b.GetWorldCenter();
                this.m_debugDraw.DrawTransform(xf)
            }
        }
    };
    b2World.prototype.QueryAABB = function(callback, aabb) {
        var broadPhase = this.m_contactManager.m_broadPhase;

        function WorldQueryWrapper(proxy) {
            return callback(broadPhase.GetUserData(proxy))
        }
        broadPhase.Query(WorldQueryWrapper, aabb)
    };
    b2World.prototype.QueryShape = function(callback, shape, transform) {
        if (transform == null) {
            transform = new b2Transform;
            transform.SetIdentity()
        }
        var broadPhase = this.m_contactManager.m_broadPhase;

        function WorldQueryWrapper(proxy) {
            var fixture = broadPhase.GetUserData(proxy);
            if (b2Shape.TestOverlap(shape, transform, fixture.GetShape(), fixture.GetBody().GetTransform())) return callback(fixture);
            return true
        }
        var aabb = new b2AABB;
        shape.ComputeAABB(aabb, transform);
        broadPhase.Query(WorldQueryWrapper, aabb)
    };
    b2World.prototype.QueryPoint = function(callback, p) {
        var broadPhase = this.m_contactManager.m_broadPhase;

        function WorldQueryWrapper(proxy) {
            var fixture = broadPhase.GetUserData(proxy);
            if (fixture.TestPoint(p)) return callback(fixture);
            return true
        }
        var aabb = new b2AABB;
        aabb.lowerBound.Set(p.x - b2Settings.b2_linearSlop, p.y - b2Settings.b2_linearSlop);
        aabb.upperBound.Set(p.x + b2Settings.b2_linearSlop, p.y + b2Settings.b2_linearSlop);
        broadPhase.Query(WorldQueryWrapper, aabb)
    };
    b2World.prototype.RayCast = function(callback, point1, point2) {
        var broadPhase = this.m_contactManager.m_broadPhase;
        var output = new b2RayCastOutput;

        function RayCastWrapper(input, proxy) {
            var userData = broadPhase.GetUserData(proxy);
            var fixture = userData;
            var hit = fixture.RayCast(output, input);
            if (hit) {
                var fraction = output.fraction;
                var point = new b2Vec2((1 - fraction) * point1.x + fraction * point2.x, (1 - fraction) * point1.y + fraction * point2.y);
                return callback(fixture, point, output.normal, fraction)
            }
            return input.maxFraction
        }
        var input = new b2RayCastInput(point1, point2);
        broadPhase.RayCast(RayCastWrapper, input)
    };
    b2World.prototype.RayCastOne = function(point1, point2) {
        var result;

        function RayCastOneWrapper(fixture, point, normal, fraction) {
            result = fixture;
            return fraction
        }
        this.RayCast(RayCastOneWrapper, point1, point2);
        return result
    };
    b2World.prototype.RayCastAll = function(point1, point2) {
        var result = new Array;

        function RayCastAllWrapper(fixture, point, normal, fraction) {
            result[result.length] = fixture;
            return 1
        }
        this.RayCast(RayCastAllWrapper, point1, point2);
        return result
    };
    b2World.prototype.GetBodyList = function() {
        return this.m_bodyList
    };
    b2World.prototype.GetJointList = function() {
        return this.m_jointList
    };
    b2World.prototype.GetContactList = function() {
        return this.m_contactList
    };
    b2World.prototype.IsLocked = function() {
        return (this.m_flags & b2World.e_locked) > 0
    };
    b2World.prototype.s_stack = new Array;
    b2World.prototype.m_flags = 0;
    b2World.prototype.m_contactManager = new b2ContactManager;
    b2World.prototype.m_contactSolver = new b2ContactSolver;
    b2World.prototype.m_island = new b2Island;
    b2World.prototype.m_bodyList = null;
    b2World.prototype.m_jointList = null;
    b2World.prototype.m_contactList = null;
    b2World.prototype.m_bodyCount = 0;
    b2World.prototype.m_contactCount = 0;
    b2World.prototype.m_jointCount = 0;
    b2World.prototype.m_controllerList = null;
    b2World.prototype.m_controllerCount = 0;
    b2World.prototype.m_gravity = null;
    b2World.prototype.m_allowSleep = null;
    b2World.prototype.m_groundBody = null;
    b2World.prototype.m_destructionListener = null;
    b2World.prototype.m_debugDraw = null;
    b2World.prototype.m_inv_dt0 = null;

    function Editor() {}
    Editor.prototype = {
        editorState: {
            Free: 0,
            Selection: 1,
            MovingEntity: 2,
            DrawGroupBox: 3,
            Rotation: 4,
            Scaling: 5,
            SetAttributes: 6,
            SetCollision: 7,
            ConfirmLoad: 8,
            FindParent: 9,
            ConfirmGrpCpy: 10,
            ConfirmBrushDel: 11,
            ConfirmObjDel: 12,
            ConfirmNewLevel: 13,
            FreeformScale: 14,
            ConfirmFile: 15,
            Rollback: 16,
            ConfirmClear: 17,
            ConfirmDelLayer: 18,
            PaletteAdd: 19,
            SetDefaults: 20,
            ObjectProperties: 21,
            CategoryProperties: 22,
            ConfirmMissingObjectSave: 23,
            ConfirmMissingObjectSaveAs: 24
        },
        AutosaveSecs: 50,
        SaveFile: "",
        LoadFile: "",
        SettingsFile: "assets/Settings.json",
        LastLoadedFile: "",
        SetIsActive: function SetIsActiveFn(Active) {
            if (this.State > this.editorState.Selection && !Active) {
                return
            }
            this.Active = Active;
            if (!this.Game.IsPaused) {
                if (this.GeneralFunctions.CameraPosition.x !== 0 && this.GeneralFunctions.CameraPosition.y !== 0) {
                    this.Camera.SetPosition(this.GeneralFunctions.CameraPosition.x, this.GeneralFunctions.CameraPosition.y);
                    this.Camera.SetZoom(this.GeneralFunctions.CameraZoom)
                } else {
                    this.GeneralFunctions.CameraPosition = this.Camera.GetPosition();
                    this.GeneralFunctions.CameraZoom = this.Camera.GetZoom()
                }
            }
            var i = 0;
            for (i = 0; i < this.UIItems.length; i += 1) {
                this.UIItems[i].EnableAll(Active)
            }
            this.Attributes.EnableAll(false);
            this.Defaults.EnableAll(false);
            this.Confirmation.EnableAll(false);
            this.LoadSave.EnableAll(false);
            this.Rollback.EnableAll(false);
            this.AddToPalette.EnableAll(false);
            this.DropDownObjectUI.EnableAll(false);
            this.DropDownCategoryUI.EnableAll(false);
            this.ObjectProperties.EnableAll(false);
            this.CategoryProperties.EnableAll(false);
            for (i = 0; i < this.UIPalettes.length; i += 1) {
                this.UIPalettes[i].Close()
            }
            this.CurrentLayer = this.LastUsedLayer === -1 ? this.World.GetPlayLayer() : this.LastUsedLayer;
            this.World.SetLayerDebug(Active);
            if (this.CurrentLayer && this.World && this.World.GetLayer(this.CurrentLayer)) {
                this.World.GetLayer(this.CurrentLayer).ShowLimitLines = Active
            }
            if (!Active && this.SelectionEntities.length > 0) {
                var k = 0;
                for (k = 0; k < this.SelectionEntities.length; k += 1) {
                    this.SelectionBackup[k] = this.SelectionEntities[k]
                }
            }
            if (this.SelectionBackup.length > 0 && Active) {
                var j = 0;
                for (j = 0; j < this.SelectionBackup.length; j += 1) {
                    this.SelectionEntities[j] = this.SelectionBackup[j]
                }
                this.State = this.editorState.Selection;
                this.SelectionBackup = []
            }
            if (!Active) {
                for (i = 0; i < this.World.GetLayerAmount(); i += 1) {
                    this.World.ShowLayer(i, true)
                }
                this.GeneralFunctions.TogglePickingMode(this, true)
            }
            for (i = 0; i < this.GeneralFunctions.HiddenObjectIndices.length; i += 1) {
                this.ObjectPaletteBox.LimitObjectSelection(this.GeneralFunctions.HiddenObjectIndices[i], Active);
                this.ObjectPaletteBox.HideObjectSelection(this.GeneralFunctions.HiddenObjectIndices[i], this)
            }
            this.Saving = false
        },
        CanILeave: function GetIsActiveFn() {
            if (this.LayerPaletteBox.IsOpen) {
                if (this.LayerFunctions.LayerName.isSuperFocused || this.LayerFunctions.LayerSpeedX.isSuperFocused || this.LayerFunctions.LayerSpeedY.isSuperFocused) {
                    return false
                }
            }
            return this.State < this.editorState.MovingEntity
        },
        GetIsActive: function GetIsActiveFn() {
            return this.Active
        },
        ViewportChanged: function ViewportChangedFn() {
            var i = 0;
            for (i = 0; i < this.UIItems.length; i += 1) {
                this.UIItems[i].ResizeUI()
            }
            this.LayerTextBox.MoveTo(0, JamSystem.RenderManager.GetScreenHeight() - 30);
            for (i = 0; i < this.World.GetLayerAmount(); i += 1) {
                var XPos = JamSystem.RenderManager.GetScreenWidth() / 2 - 130 - 20 * (this.World.GetLayerAmount() - 1 - i);
                var YPos = JamSystem.RenderManager.GetScreenHeight() - 20;
                this.CheckBox[i].MoveTo(XPos, YPos)
            }
        },
        UpdateEditorBasics: function UpdateEditorBasicsFn(TimeDelta, X, Y) {
            var i = 0,
                Entities = [];
            var Key = JamSystem.InputManager.GetKeyValue();
            if (Key !== undefined) {
                if (Key.charCodeAt(0) === 44) {
                    var PrevLayer = this.CurrentLayer;
                    while (1) {
                        PrevLayer -= 1;
                        if (PrevLayer > -1) {
                            if (this.World.IsLayerActive(PrevLayer)) {
                                break
                            }
                        } else {
                            return
                        }
                    }
                    var SHFTDWN = JamSystem.InputManager.GetKeyHeld(300) || JamSystem.InputManager.GetKeyHeld(301);
                    if (SHFTDWN && this.State === this.editorState.Selection) {
                        this.ActionFunctions.ChangeEntityLayer(this, PrevLayer)
                    }
                    var CTRLDWN = JamSystem.InputManager.GetKeyHeld(302) || JamSystem.InputManager.GetKeyHeld(303);
                    if (CTRLDWN && this.State === this.editorState.Selection) {
                        Entities = [];
                        this.GeneralFunctions.CopyEntityGroup(this, Entities, this.SelectionEntities, true, true);
                        for (i = 0; i < Entities.length; i += 1) {
                            this.World.GetLayer(PrevLayer).AddEntity(Entities[i]);
                            this.SelectionEntities[i] = Entities[i]
                        }
                        this.UndoActions.AddToUndo(this, this.UndoActions.UndoType.EntityPlaceMod, Entities)
                    }
                    this.LayerFunctions.ModifyLayer(this, PrevLayer, SHFTDWN || CTRLDWN);
                    this.LayerInfoText.SetText("FARTHER");
                    this.LayerInfoText.SetIsVisible(true)
                }
                if (Key.charCodeAt(0) === 46) {
                    var NextLayer = this.CurrentLayer;
                    while (1) {
                        NextLayer += 1;
                        if (NextLayer < this.World.GetLayerAmount()) {
                            if (this.World.IsLayerActive(NextLayer)) {
                                break
                            }
                        } else {
                            return
                        }
                    }
                    var SHFTUP = JamSystem.InputManager.GetKeyHeld(300) || JamSystem.InputManager.GetKeyHeld(301);
                    if (SHFTUP && this.State === this.editorState.Selection) {
                        this.ActionFunctions.ChangeEntityLayer(this, NextLayer)
                    }
                    var CTRLUP = JamSystem.InputManager.GetKeyHeld(302) || JamSystem.InputManager.GetKeyHeld(303);
                    if (CTRLUP && this.State === this.editorState.Selection) {
                        Entities = [];
                        this.GeneralFunctions.CopyEntityGroup(this, Entities, this.SelectionEntities, true, true);
                        for (i = 0; i < Entities.length; i += 1) {
                            this.World.GetLayer(NextLayer).AddEntity(Entities[i]);
                            this.SelectionEntities[i] = Entities[i]
                        }
                        this.UndoActions.AddToUndo(this, this.UndoActions.UndoType.EntityPlaceMod, Entities)
                    }
                    this.LayerFunctions.ModifyLayer(this, NextLayer, SHFTUP || CTRLUP);
                    this.LayerInfoText.SetText("CLOSER");
                    this.LayerInfoText.SetIsVisible(true);
                    this.LayerInfoTextAlpha = 1
                }
                if (!JamSystem.InputManager.GetKeyHeld(302) && !JamSystem.InputManager.GetKeyHeld(303) && (Key.charCodeAt(0) === 67 || Key.charCodeAt(0) === 99)) {
                    this.World.ToggleCollisionDisplay()
                }
                if (!JamSystem.InputManager.GetKeyHeld(302) && !JamSystem.InputManager.GetKeyHeld(303) && (Key.charCodeAt(0) === 79 || Key.charCodeAt(0) === 111)) {
                    this.World.AutoSortActive();
                    this.World.Optimise()
                }
                if (JamSystem.InputManager.GetKeyHeld(302) || JamSystem.InputManager.GetKeyHeld(303)) {
                    if (!JamSystem.InputManager.GetKeyHeld(300) && !JamSystem.InputManager.GetKeyHeld(301)) {
                        if (Key.charCodeAt(0) === 111 || Key.charCodeAt(0) === 79) {
                            this.GeneralFunctions.TogglePickingMode(this, true);
                            if (this.UndoActions.UndoActions.length > 0 || this.GeneralFunctions.LayerChanged) {
                                this.ConfirmationBox.SetTitleBar("\n\n\n\n\nWARNING\n\nYOU HAVE UNSAVED CHANGES!\n\nDO YOU WISH TO SAVE FIRST?");
                                this.Confirmation.EnableAll(true);
                                this.ConfirmationBox.isSuperFocused = true;
                                this.State = this.editorState.ConfirmLoad
                            } else {
                                var BestFileToUse = this.LoadFile;
                                if (SettingsFileManager.FileToLoad) {
                                    BestFileToUse = SettingsFileManager.FileToLoad
                                }
                                if (this.LastLoadedFile) {
                                    BestFileToUse = this.LastLoadedFile
                                }
                                this.LoadSaveBox.ChangeType(UIFileBox.LoadingType, BestFileToUse);
                                this.LoadSave.EnableAll(true);
                                this.LoadSaveBox.isSuperFocused = true;
                                this.State = this.editorState.ConfirmFile
                            }
                        }
                    } else {
                        if (Key.charCodeAt(0) === 111 || Key.charCodeAt(0) === 79) {
                            this.GeneralFunctions.TogglePickingMode(this, true);
                            this.AddToPalette.EnableAll(true);
                            this.AddToPaletteBox.isSuperFocused = true;
                            this.State = this.editorState.PaletteAdd
                        }
                    }
                }
                if (this.State !== this.editorState.Scaling) {
                    if ((JamSystem.InputManager.GetKeyHeld(302) || JamSystem.InputManager.GetKeyHeld(303)) && (!JamSystem.InputManager.GetKeyHeld(300) && !JamSystem.InputManager.GetKeyHeld(301)) && (Key.charCodeAt(0) === 115 || Key.charCodeAt(0) === 83)) {
                        if (!this.GeneralFunctions.CheckObjectsMissingFromPalette(this)) {
                            this.GeneralFunctions.SaveGame(this)
                        } else {
                            this.ConfirmationBox.SetTitleBar("\n\n\n\nTHERE ARE OBJECTS IN WORLD WITHOUT PALETTE REFERENCES!\n\n" + this.GeneralFunctions.MissingPaletteRefs + "\n\nARE YOU SURE YOU WISH TO SAVE? (REMOVES OBJECTS)");
                            this.Confirmation.EnableAll(true);
                            this.ConfirmationBox.isSuperFocused = true;
                            this.State = this.editorState.ConfirmMissingObjectSave
                        }
                    }
                    if ((JamSystem.InputManager.GetKeyHeld(302) || JamSystem.InputManager.GetKeyHeld(303)) && (JamSystem.InputManager.GetKeyHeld(300) || JamSystem.InputManager.GetKeyHeld(301)) && (Key.charCodeAt(0) === 115 || Key.charCodeAt(0) === 83)) {
                        if (!this.GeneralFunctions.CheckObjectsMissingFromPalette(this)) {
                            this.LoadSaveBox.ChangeType(UIFileBox.SavingType, this.LoadFile);
                            this.LoadSave.EnableAll(true);
                            this.LoadSaveBox.isSuperFocused = true;
                            this.State = this.editorState.ConfirmFile
                        } else {
                            this.ConfirmationBox.SetTitleBar("\n\n\n\nTHERE ARE OBJECTS IN WORLD WITHOUT PALETTE REFERENCES!\n\n" + this.GeneralFunctions.MissingPaletteRefs + "\n\nARE YOU SURE YOU WISH TO SAVE AS? [REMOVES OBJECTS]");
                            this.Confirmation.EnableAll(true);
                            this.ConfirmationBox.isSuperFocused = true;
                            this.State = this.editorState.ConfirmMissingObjectSaveAs
                        }
                    }
                }
                if ((JamSystem.InputManager.GetKeyHeld(302) || JamSystem.InputManager.GetKeyHeld(303)) && (Key.charCodeAt(0) === 110 || Key.charCodeAt(0) === 78)) {
                    this.LayerFunctions.WipeLayerPaletteBox(this);
                    this.LayerPaletteBox.Close();
                    var CurrentTime = new Date;
                    var CurrHours = CurrentTime.getHours();
                    if (CurrHours < 10) {
                        CurrHours = "0" + CurrHours
                    }
                    var CurrMins = CurrentTime.getMinutes();
                    if (CurrMins < 10) {
                        CurrMins = "0" + CurrMins
                    }
                    var BaseName = "Editor_Generated_NewLevel_" + CurrHours + "." + CurrMins;
                    this.LoadSaveBox.ChangeType(UIFileBox.NewType, BaseName);
                    this.LoadSave.EnableAll(true);
                    this.LoadSaveBox.isSuperFocused = true;
                    this.State = this.editorState.ConfirmNewLevel
                }
            }
            if (JamSystem.InputManager.GetKeyPressed(404)) {
                this.ShowCurrentLayerOnly = !this.ShowCurrentLayerOnly
            }
            this.GeneralFunctions.CheckCameraDrag(this, X, Y);
            this.GeneralFunctions.Zoom(this, TimeDelta)
        },
        UpdateEditorGenericAnytime: function UpdateEditorAnytimeFn(TimeDelta, X, Y) {
            var Key = JamSystem.InputManager.GetKeyValue();
            if (Key !== undefined) {
                if (Key.charCodeAt(0) === 80 || Key.charCodeAt(0) === 112) {
                    if (this.Picking && this.BrushEntities.length === 0) {
                        return
                    }
                    this.GeneralFunctions.TogglePickingMode(this)
                }
                if ((JamSystem.InputManager.GetKeyHeld(302) || JamSystem.InputManager.GetKeyHeld(303)) && (Key.charCodeAt(0) === 107 || Key.charCodeAt(0) === 75)) {
                    this.ConfirmationBox.SetTitleBar("\n\n\n\n\nWARNING\n\nYOU HAVE UNSAVED CHANGES!\n\nREALLY CLEAR THE LAYER?");
                    this.Confirmation.EnableAll(true);
                    this.ConfirmationBox.isSuperFocused = true;
                    this.State = this.editorState.ConfirmClear;
                    this.GeneralFunctions.HandleSavingChecks(this, 0, true)
                }
                if ((JamSystem.InputManager.GetKeyHeld(302) || JamSystem.InputManager.GetKeyHeld(303)) && (Key.charCodeAt(0) === 113 || Key.charCodeAt(0) === 81)) {
                    var TypeID = EntityTypeManager.GetPlayerTypeID();
                    var LocalCoords = this.World.GetLayer(this.CurrentLayer).TransformScreenToLocal(X, Y);
                    var PlayerEnt = this.World.GetAllEntitiesOfType(TypeID);
                    if (PlayerEnt.length) {
                        this.SelectedFunctions.CleanSelection(this);
                        this.SelectionEntities[0] = PlayerEnt[0];
                        this.UndoActions.AddToUndo(this, this.UndoActions.UndoType.SelectedEntityMod, this.SelectionEntities);
                        PlayerEnt[0].StartX = LocalCoords.x;
                        PlayerEnt[0].StartY = LocalCoords.y;
                        PlayerEnt[0].Layer.UpdateEntity(PlayerEnt[0]);
                        this.SelectedFunctions.CleanSelection(this);
                        this.GeneralFunctions.CameraPosition = new Vector2(LocalCoords.x, LocalCoords.y);
                        this.GeneralFunctions.CameraZoom = this.Camera.GetZoom()
                    }
                }
                if (!JamSystem.InputManager.GetKeyHeld(302) && !JamSystem.InputManager.GetKeyHeld(303) && (Key.charCodeAt(0) === 113 || Key.charCodeAt(0) === 81)) {
                    this.SelectedFunctions.AllowSingleMultiLayerSelection = false;
                    this.SelectedFunctions.AllowMultiLayerSelection = !this.SelectedFunctions.AllowMultiLayerSelection;
                    this.SelectedFunctions.CleanSelection(this)
                }
                if (!JamSystem.InputManager.GetKeyHeld(302) && !JamSystem.InputManager.GetKeyHeld(303) && (Key.charCodeAt(0) === 116 || Key.charCodeAt(0) === 84)) {
                    this.SelectedFunctions.AllowMultiLayerSelection = false;
                    this.SelectedFunctions.AllowSingleMultiLayerSelection = !this.SelectedFunctions.AllowSingleMultiLayerSelection;
                    this.SelectedFunctions.CleanSelection(this)
                }
                if ((JamSystem.InputManager.GetKeyHeld(302) || JamSystem.InputManager.GetKeyHeld(303)) && (!JamSystem.InputManager.GetKeyHeld(300) && !JamSystem.InputManager.GetKeyHeld(301)) && (Key.charCodeAt(0) === 66 || Key.charCodeAt(0) === 98)) {
                    this.BrushFunctions.SaveBrush(this)
                }
                if ((Key.charCodeAt(0) === 66 || Key.charCodeAt(0) === 98) && (!JamSystem.InputManager.GetKeyHeld(302) && !JamSystem.InputManager.GetKeyHeld(303)) && (!JamSystem.InputManager.GetKeyHeld(300) && !JamSystem.InputManager.GetKeyHeld(301))) {
                    this.World.GetLayer(this.CurrentLayer).ToggleBucketLines()
                }
                if ((JamSystem.InputManager.GetKeyHeld(302) || JamSystem.InputManager.GetKeyHeld(303)) && (!JamSystem.InputManager.GetKeyHeld(300) && !JamSystem.InputManager.GetKeyHeld(301)) && (Key.charCodeAt(0) === 71 || Key.charCodeAt(0) === 103)) {
                    var GridLines = this.World.GetLayer(this.CurrentLayer).ShowGridLines;
                    this.World.GetLayer(this.CurrentLayer).ShowGridLines = !GridLines
                }
                if ((JamSystem.InputManager.GetKeyHeld(302) || JamSystem.InputManager.GetKeyHeld(303)) && (JamSystem.InputManager.GetKeyHeld(300) || JamSystem.InputManager.GetKeyHeld(301)) && (Key.charCodeAt(0) === 71 || Key.charCodeAt(0) === 103)) {
                    var LimitLines = this.World.GetLayer(this.CurrentLayer).ShowLimitLines;
                    this.World.GetLayer(this.CurrentLayer).ShowLimitLines = !LimitLines
                }
                if (!JamSystem.InputManager.GetKeyHeld(302) && !JamSystem.InputManager.GetKeyHeld(303) && (!JamSystem.InputManager.GetKeyHeld(300) && !JamSystem.InputManager.GetKeyHeld(301)) && (Key.charCodeAt(0) === 76 || Key.charCodeAt(0) === 108)) {
                    var i = 0,
                        LayerAmount = this.World.GetLayerAmount();
                    for (i = 0; i < LayerAmount; i += 1) {
                        var GroupLines = this.World.GetLayer(i).ShowChildrenLines;
                        this.World.GetLayer(i).ShowChildrenLines = !GroupLines
                    }
                }
                if ((JamSystem.InputManager.GetKeyHeld(302) || JamSystem.InputManager.GetKeyHeld(303)) && (!JamSystem.InputManager.GetKeyHeld(300) && !JamSystem.InputManager.GetKeyHeld(301)) && (Key.charCodeAt(0) === 90 || Key.charCodeAt(0) === 122)) {
                    this.UndoActions.Undo(this)
                }
                if ((JamSystem.InputManager.GetKeyHeld(302) || JamSystem.InputManager.GetKeyHeld(303)) && (!JamSystem.InputManager.GetKeyHeld(300) && !JamSystem.InputManager.GetKeyHeld(301)) && (Key.charCodeAt(0) === 89 || Key.charCodeAt(0) === 121)) {
                    this.UndoActions.Redo(this)
                }
            }
            this.GeneralFunctions.MoveLayerContentsHold(this);
            this.GeneralFunctions.MoveLayerContentsOnce(this);
            if (JamSystem.InputManager.GetKeyHeld(302) || JamSystem.InputManager.GetKeyHeld(303)) {
                if (JamSystem.InputManager.GetKeyPressed(403) || JamSystem.InputManager.GetKeyPressed(633)) {
                    if (this.World.GetLayerAmount() > 1) {
                        this.GeneralFunctions.LayerToDelete = this.CurrentLayer;
                        this.ConfirmationBox.SetTitleBar("\n\n\n\n\nWARNING\n\nYOU HAVE UNSAVED CHANGES!\n\nREALLY DELETE THIS LAYER?");
                        this.Confirmation.EnableAll(true);
                        this.ConfirmationBox.isSuperFocused = true;
                        this.State = this.editorState.ConfirmDelLayer;
                        this.GeneralFunctions.HandleSavingChecks(this, 0, true)
                    }
                }
            }
            if (JamSystem.InputManager.GetKeyHeld(509)) {
                this.AttachmentFunctions.AttachmentMode = true;
                this.AttachmentFunctions.DisplayAttachmentLines(this)
            } else {
                this.AttachmentFunctions.AttachmentMode = false;
                this.AttachmentFunctions.StopAttachmentLines(this)
            }
            this.GeneralFunctions.CheckPaletteRightClick(this, X, Y);
            this.GeneralFunctions.CheckCollisionBoxClose(this)
        },
        UpdateEditorPicking: function UpdateEditorPickFn(TimeDelta, X, Y) {
            if (!this.Picking || !this.World.GetLayer(this.CurrentLayer).IsVisible) {
                return
            }
            this.ActionFunctions.CheckSelectedForRotation(this, this.SelectionEntities, X, Y);
            this.ScaleFunctions.FreeformScale(this, X, Y, this.SelectionEntities);
            this.SelectedFunctions.CheckHoverOverEntity(this, X, Y);
            this.AttributesFunctions.CheckForRightClick(this, X, Y);
            this.DefaultsFunctions.HandleChangesInDefaults(this, X, Y);
            this.SelectedFunctions.CheckForSelection(this, X, Y);
            this.SelectedFunctions.CheckForMovement(this, X, Y);
            if (this.State !== this.editorState.Selection) {
                return
            }
            var Key = JamSystem.InputManager.GetKeyValue();
            if (Key !== undefined) {
                if (Key.charCodeAt(0) === 70 || Key.charCodeAt(0) === 102) {
                    this.ActionFunctions.FlipEntities(this, this.SelectionEntities)
                }
                if (Key.charCodeAt(0) === 77 || Key.charCodeAt(0) === 109) {
                    this.ActionFunctions.MirrorEntities(this, this.SelectionEntities)
                }
                if ((Key.charCodeAt(0) === 90 || Key.charCodeAt(0) === 122) && (!JamSystem.InputManager.GetKeyHeld(302) && !JamSystem.InputManager.GetKeyHeld(303))) {
                    this.ActionFunctions.RotateEntities90(this, this.SelectionEntities)
                }
                if ((JamSystem.InputManager.GetKeyHeld(300) || JamSystem.InputManager.GetKeyHeld(301)) && (!JamSystem.InputManager.GetKeyHeld(304) && !JamSystem.InputManager.GetKeyHeld(305)) && (Key.charCodeAt(0) === 82 || Key.charCodeAt(0) === 114)) {
                    this.ActionFunctions.ResetBrushRotation(this, this.SelectionEntities)
                }
                if ((JamSystem.InputManager.GetKeyHeld(300) || JamSystem.InputManager.GetKeyHeld(301)) && (JamSystem.InputManager.GetKeyHeld(304) || JamSystem.InputManager.GetKeyHeld(305)) && (Key.charCodeAt(0) === 82 || Key.charCodeAt(0) === 114)) {
                    this.ActionFunctions.ResetGroupBrushRotation(this, this.SelectionEntities)
                }
                if ((JamSystem.InputManager.GetKeyHeld(300) || JamSystem.InputManager.GetKeyHeld(301)) && (!JamSystem.InputManager.GetKeyHeld(302) && !JamSystem.InputManager.GetKeyHeld(303)) && (Key.charCodeAt(0) === 83 || Key.charCodeAt(0) === 115)) {
                    this.ActionFunctions.ResetBrushScale(this, this.SelectionEntities)
                }
                if ((JamSystem.InputManager.GetKeyHeld(300) || JamSystem.InputManager.GetKeyHeld(301)) && (!JamSystem.InputManager.GetKeyHeld(302) && !JamSystem.InputManager.GetKeyHeld(303)) && (Key.charCodeAt(0) === 88 || Key.charCodeAt(0) === 120)) {
                    this.ActionFunctions.ResetBrushXScale(this, this.SelectionEntities)
                }
                if ((JamSystem.InputManager.GetKeyHeld(300) || JamSystem.InputManager.GetKeyHeld(301)) && (!JamSystem.InputManager.GetKeyHeld(302) && !JamSystem.InputManager.GetKeyHeld(303)) && (Key.charCodeAt(0) === 89 || Key.charCodeAt(0) === 121)) {
                    this.ActionFunctions.ResetBrushYScale(this, this.SelectionEntities)
                }
                if ((Key.charCodeAt(0) === 67 || Key.charCodeAt(0) === 99) && (JamSystem.InputManager.GetKeyHeld(302) || JamSystem.InputManager.GetKeyHeld(303))) {
                    this.MissingEntities = [];
                    this.MissingEntities = this.GroupFunctions.FindMissingGroupLinks(this, this.SelectionEntities);
                    if (this.MissingEntities.length > 0) {
                        this.CutMode = false;
                        this.ConfirmationBox.SetTitleBar("\n\n\n\n\nWARNING\n\nYOU HAVE NOT SELECTED THE ENTIRE GROUP!\n\nDO YOU WANT TO COPY THE WHOLE GROUP?");
                        this.Confirmation.EnableAll(true);
                        this.ConfirmationBox.isSuperFocused = true;
                        this.State = this.editorState.ConfirmGrpCpy
                    } else {
                        this.BrushFunctions.CopyBrush(this, X, Y, false, true)
                    }
                }
                if ((JamSystem.InputManager.GetKeyHeld(302) || JamSystem.InputManager.GetKeyHeld(303)) && (Key.charCodeAt(0) === 88 || Key.charCodeAt(0) === 120)) {
                    this.MissingEntities = [];
                    this.MissingEntities = this.GroupFunctions.FindMissingGroupLinks(this, this.SelectionEntities);
                    if (this.MissingEntities.length > 0) {
                        this.CutMode = true;
                        this.ConfirmationBox.SetTitleBar("\n\n\n\n\nWARNING\n\nYOU HAVE NOT SELECTED THE ENTIRE GROUP!\n\nDO YOU WANT TO CUT THE WHOLE GROUP?");
                        this.Confirmation.EnableAll(true);
                        this.ConfirmationBox.isSuperFocused = true;
                        this.State = this.editorState.ConfirmGrpCpy
                    } else {
                        this.BrushFunctions.CopyBrush(this, X, Y, true, true)
                    }
                }
                if (Key.charCodeAt(0) === 61 || Key.charCodeAt(0) === 43) {
                    if (JamSystem.InputManager.GetKeyHeld(300) || JamSystem.InputManager.GetKeyHeld(301)) {
                        this.ActionFunctions.ChangeDepth(this, true, true)
                    } else {
                        this.ActionFunctions.ChangeDepth(this, true, false)
                    }
                }
                if (Key.charCodeAt(0) === 45) {
                    if (JamSystem.InputManager.GetKeyHeld(300) || JamSystem.InputManager.GetKeyHeld(301)) {
                        this.ActionFunctions.ChangeDepth(this, false, true)
                    } else {
                        this.ActionFunctions.ChangeDepth(this, false, false)
                    }
                }
                if ((Key.charCodeAt(0) === 71 || Key.charCodeAt(0) === 103) && (!JamSystem.InputManager.GetKeyHeld(300) && !JamSystem.InputManager.GetKeyHeld(301)) && (!JamSystem.InputManager.GetKeyHeld(302) && !JamSystem.InputManager.GetKeyHeld(303))) {
                    this.GroupFunctions.GroupEntities(this)
                }
                if ((Key.charCodeAt(0) === 85 || Key.charCodeAt(0) === 117) && (!JamSystem.InputManager.GetKeyHeld(300) && !JamSystem.InputManager.GetKeyHeld(301)) && (!JamSystem.InputManager.GetKeyHeld(302) && !JamSystem.InputManager.GetKeyHeld(303))) {
                    this.GroupFunctions.UngroupEntities(this)
                }
                if ((Key.charCodeAt(0) === 65 || Key.charCodeAt(0) === 97) && (!JamSystem.InputManager.GetKeyHeld(300) && !JamSystem.InputManager.GetKeyHeld(301)) && (!JamSystem.InputManager.GetKeyHeld(302) && !JamSystem.InputManager.GetKeyHeld(303))) {
                    this.AttachmentFunctions.AttachEntities(this)
                }
                if ((Key.charCodeAt(0) === 68 || Key.charCodeAt(0) === 100) && (!JamSystem.InputManager.GetKeyHeld(300) && !JamSystem.InputManager.GetKeyHeld(301)) && (!JamSystem.InputManager.GetKeyHeld(302) && !JamSystem.InputManager.GetKeyHeld(303))) {
                    this.AttachmentFunctions.DetachEntities(this)
                }
                if ((Key.charCodeAt(0) === 72 || Key.charCodeAt(0) === 104) && (!JamSystem.InputManager.GetKeyHeld(300) && !JamSystem.InputManager.GetKeyHeld(301)) && (!JamSystem.InputManager.GetKeyHeld(302) && !JamSystem.InputManager.GetKeyHeld(303))) {
                    this.SelectedFunctions.Align(this, true)
                }
                if ((Key.charCodeAt(0) === 86 || Key.charCodeAt(0) === 118) && (!JamSystem.InputManager.GetKeyHeld(300) && !JamSystem.InputManager.GetKeyHeld(301)) && (!JamSystem.InputManager.GetKeyHeld(302) && !JamSystem.InputManager.GetKeyHeld(303))) {
                    this.SelectedFunctions.Align(this, false)
                }
            }
            if (JamSystem.InputManager.GetKeyPressed(403) || JamSystem.InputManager.GetKeyPressed(633)) {
                this.SelectedFunctions.DeleteSelected(this);
                this.State = this.editorState.Free
            }
            this.ActionFunctions.CheckSelectedForArrowMove(this);
            this.ActionFunctions.FlashSelected(this, TimeDelta)
        },
        Update: function EditorUpdateFn(TimeDelta) {
            var MouseX = JamSystem.InputManager.GetMouseX();
            var MouseY = JamSystem.InputManager.GetMouseY();
            if (this.GeneralFunctions.HandleLoadingChecks(this, TimeDelta)) {
                return
            }
            if (this.GeneralFunctions.HandleSavingChecks(this, TimeDelta)) {
                return
            }
            if (this.UpdateFunctions.CheckConfirmations(this, MouseX, MouseY)) {
                return
            }
            var i = 0,
                j = 0;
            for (i = this.UIItems.length - 1; i > -1; i -= 1) {
                if (this.UIItems[i].CheckSuperCollision(MouseX, MouseY)) {
                    return
                }
            }
            for (i = this.UIItems.length - 1; i > -1; i -= 1) {
                if (this.UIItems[i].IsSuperFocused()) {
                    this.UIItems[i].Update(TimeDelta, MouseX, MouseY);
                    return
                }
            }
            for (i = 0; i < this.UIItems.length; i += 1) {
                this.UIItems[i].Update(TimeDelta, MouseX, MouseY)
            }
            this.UpdateFunctions.UpdateInfoTextBoxes(this, MouseX, MouseY, TimeDelta);
            if (this.LayerInfoText.GetIsVisible()) {
                this.LayerInfoTextAlpha -= TimeDelta;
                this.LayerInfoText.SetColour([1, 1, 1, this.LayerInfoTextAlpha]);
                if (this.LayerInfoTextAlpha <= 0) {
                    this.LayerInfoText.SetIsVisible(false)
                }
            }
            if (this.State !== this.editorState.SetAttributes && this.State !== this.editorState.SetDefaults) {
                this.UpdateEditorBasics(TimeDelta, MouseX, MouseY)
            }
            if (this.World.IsLayerActive(this.CurrentLayer)) {
                if (this.State !== this.editorState.SetAttributes && this.State !== this.editorState.SetDefaults) {
                    this.UpdateEditorGenericAnytime(TimeDelta, MouseX, MouseY)
                }
            }
            if (this.GeneralFunctions.HandleAutosaveRollback(this, MouseX, MouseY)) {
                return
            }
            if (this.ObjectPaletteBox.ForceBrushUpdate) {
                for (i = 0; i < this.ObjectPaletteBox.EntityPaletteToChange.length; i += 1) {
                    this.World.SwapPaletteIndex(this.ObjectPaletteBox.EntityPaletteToChange[i].A, this.ObjectPaletteBox.EntityPaletteToChange[i].B)
                }
                this.ObjectPaletteBox.ForceBrushUpdate = false
            }
            for (i = this.UIItems.length - 1; i > -1; i -= 1) {
                var OtherPaletteFocused = false;
                if (this.UIItems[i].Objects[0].IsMouseOver(MouseX, MouseY) && this.UIItems[i].ItemTypes[0] === UI.prototype.itemType.palette) {
                    for (j = 0; j < this.UIPalettes.length; j += 1) {
                        if (this.UIPalettes[j].IsMouseOver(MouseX, MouseY) && this.UIPalettes[j] !== this.UIItems[i].Objects[0]) {
                            OtherPaletteFocused = true
                        }
                    }
                }
                if (!OtherPaletteFocused) {
                    var CollisionType = this.UIItems[i].CheckCollision(MouseX, MouseY);
                    if (CollisionType && (this.BrushPaletteBox.BrushClicked || this.ObjectPaletteBox.BrushClicked)) {
                        this.BrushFunctions.CheckForPaletteBrushUse(this, MouseX, MouseY);
                        return
                    }
                    if (CollisionType === UI.prototype.itemType.palette) {
                        this.UIItems[i].BringToFront();
                        if (this.UIItems[i] === this.EditorLayerPalette) {
                            this.LayerFunctions.HandleLayerPaletteOpenClose(this)
                        }
                    }
                    this.LayerFunctions.HandlePaletteLayerChange(this, MouseX, MouseY);
                    if (CollisionType) {
                        return
                    }
                }
            }
            for (i = this.UIItems.length - 1; i > -1; i -= 1) {
                if (this.UIItems[i].IsFocused() || this.UIItems[i].HasSuperScrollFocus()) {
                    return
                }
            }
            this.BrushFunctions.UpdateEditorPlacing(this, TimeDelta, MouseX, MouseY);
            if (!this.World.IsLayerActive(this.CurrentLayer)) {
                return
            }
            this.UpdateEditorPicking(TimeDelta, MouseX, MouseY)
        },
        Init: function InitFn() {
            this.GeneralFunctions.TogglePickingMode(this, true);
            this.State = this.editorState.Free;
            this.CurrentLayer = 0;
            this.BrushEntities = [];
            this.SelectionEntities = [];
            this.BrushOffsetX = [];
            this.BrushOffsetY = [];
            this.SelectionOffsetX = [];
            this.SelectionOffsetY = [];
            this.StartingCoords = new Vector2;
            this.Saving = false;
            this.Loading = false;
            this.AutoSaveTimer = 0;
            this.CutMode = false;
            this.MissingEntities = [];
            this.LastUsedLayer = -1;
            this.ShowCurrentLayerOnly = false;
            this.GeneralFunctions.Init();
            this.ActionFunctions.Init();
            this.ScaleFunctions.Init();
            this.SelectedFunctions.Init();
            this.UndoActions.Init();
            this.BrushFunctions.Init();
            this.GroupFunctions.Init();
            this.UpdateFunctions.Init();
            this.AttributesFunctions.Init();
            this.DefaultsFunctions.Init();
            this.LayerFunctions.Init();
            this.AttachmentFunctions.Init();
            this.GeneralFunctions.NewLevel(this, false)
        }
    };
    Editor.Create = function EditorCreateFn(NewWorld, NewCamera, NewGame) {
        var NewObject = new Editor;
        NewObject.Active = false;
        NewObject.Camera = NewCamera;
        NewObject.World = NewWorld;
        NewObject.Game = NewGame;
        NewObject.State = NewObject.editorState.Free;
        NewObject.Picking = true;
        NewObject.CurrentLayer = 0;
        NewObject.BrushEntities = [];
        NewObject.SelectionEntities = [];
        NewObject.BrushOffsetX = [];
        NewObject.BrushOffsetY = [];
        NewObject.SelectionOffsetX = [];
        NewObject.SelectionOffsetY = [];
        NewObject.StartingCoords = new Vector2;
        NewObject.Saving = false;
        NewObject.Loading = false;
        NewObject.AutoSaveTimer = 0;
        NewObject.CutMode = false;
        NewObject.MissingEntities = [];
        NewObject.LastUsedLayer = -1;
        NewObject.ShowCurrentLayerOnly = false;
        NewObject.SelectionBackup = [];
        NewObject.ErrorTimer = 0;
        NewObject.RenderTree = JamSystem.RenderManager.CreateTree(0, 0);
        JamSystem.RenderManager.GetRoot().AddChild(NewObject.RenderTree);
        NewObject.LayerInfoText = Helpers.CreateBitmapText("CLOSER", JamSystem.RenderManager.GetScreenWidth() / 2 + 160, JamSystem.RenderManager.GetScreenHeight() - 12, EA.MiddleMiddle, "EditorFont", NewObject.RenderTree);
        NewObject.LayerInfoText.SetIsVisible(false);
        NewObject.LayerInfoTextAlpha = 1;
        NewObject.UIItems = [];
        NewObject.UIPalettes = [];
        NewObject.EditorObjectPalette = UI.Create();
        NewObject.ObjectPaletteBox = NewObject.EditorObjectPalette.AddPaletteBox("OBJECTS", [1, 1, 1, 1], 0, false, 157, true);
        NewObject.UIItems[NewObject.UIItems.length] = NewObject.EditorObjectPalette;
        NewObject.UIPalettes[NewObject.UIPalettes.length] = NewObject.ObjectPaletteBox;
        var j = 0;
        for (j = 0; j < ObjectPaletteManager.ObjectPalette.length; j += 1) {
            NewObject.ObjectPaletteBox.AddBrushByIndex(j)
        }
        NewObject.ObjectPaletteBox.Close();
        NewObject.ObjectPaletteBox.KillEmptySlots();
        NewObject.EditorBrushPalette = UI.Create();
        NewObject.BrushPaletteBox = NewObject.EditorBrushPalette.AddPaletteBox("BRUSHES", [1, 1, 0, 1], 0, true, 170);
        NewObject.UIItems[NewObject.UIItems.length] = NewObject.EditorBrushPalette;
        NewObject.UIPalettes[NewObject.UIPalettes.length] = NewObject.BrushPaletteBox;
        BrushPaletteManager.GenerateAllBrushes();
        for (j = 0; j < BrushPaletteManager.BrushPalette.length; j += 1) {
            NewObject.BrushPaletteBox.AddBrushByEntity(BrushPaletteManager.BrushPalette[j].Entities, false)
        }
        NewObject.BrushPaletteBox.Close();
        NewObject.EditorLayerPalette = UI.Create();
        NewObject.LayerPaletteBox = NewObject.EditorLayerPalette.AddPaletteBox("LAYERS", [.48, .48, .48, 1], 1, false, 230);
        NewObject.UIItems[NewObject.UIItems.length] = NewObject.EditorLayerPalette;
        NewObject.UIPalettes[NewObject.UIPalettes.length] = NewObject.LayerPaletteBox;
        NewObject.LayerPaletteBox.Close();
        NewObject.EditorPositionTextBox = UI.Create();
        NewObject.PositionTextBox = NewObject.EditorPositionTextBox.AddTextBox("", JamSystem.RenderManager.GetScreenWidth() / 2, 0, true);
        NewObject.UIItems[NewObject.UIItems.length] = NewObject.EditorPositionTextBox;
        NewObject.EditorLayerTextBox = UI.Create();
        NewObject.LayerTextBox = NewObject.EditorLayerTextBox.AddTextBox("", JamSystem.RenderManager.GetScreenWidth() / 2, JamSystem.RenderManager.GetScreenHeight() - 30, true);
        NewObject.UIItems[NewObject.UIItems.length] = NewObject.EditorLayerTextBox;
        NewObject.EditorPickingTextBox = UI.Create();
        NewObject.PickingTextBox = NewObject.EditorPickingTextBox.AddTextBox("", JamSystem.RenderManager.GetScreenWidth() / 2, 30, true);
        NewObject.UIItems[NewObject.UIItems.length] = NewObject.EditorPickingTextBox;
        NewObject.EditorEntityInfoTextBox = UI.Create();
        NewObject.EntityInfoText = NewObject.EditorEntityInfoTextBox.AddTextBox("", -200, -200);
        NewObject.UIItems[NewObject.UIItems.length] = NewObject.EditorEntityInfoTextBox;
        NewObject.ErrorTextBox = UI.Create();
        NewObject.ErrorText = NewObject.ErrorTextBox.AddTextBox("", JamSystem.RenderManager.GetScreenWidth() / 2, -200, true);
        NewObject.UIItems[NewObject.UIItems.length] = NewObject.ErrorTextBox;
        NewObject.LayerChecks = UI.Create();
        NewObject.CheckBox = [];
        NewObject.UIItems[NewObject.UIItems.length] = NewObject.LayerChecks;
        NewObject.Attributes = UI.Create();
        NewObject.AttributesBox = NewObject.Attributes.AddDialogBox();
        NewObject.AttributesBox.AddOKCancel();
        NewObject.AttributesBox.AddAutoUpdateButton("Auto-Update", "Enabling this will allow for\n auto-update of variables below");
        NewObject.NameEdit = NewObject.Attributes.AddEditBox("Name", UIEditBox.prototype.editBoxType.Normal);
        NewObject.NameEdit.SetInfoBoxText("The name of the entity");
        NewObject.PosXEdit = NewObject.Attributes.AddEditBox("Position X", UIEditBox.prototype.editBoxType.Number);
        NewObject.PosXEdit.SetInfoBoxText("The X axis position");
        NewObject.PosXEdit.ColourArray = [0, 0, 1, 1];
        NewObject.PosYEdit = NewObject.Attributes.AddEditBox("Position Y", UIEditBox.prototype.editBoxType.Number);
        NewObject.PosYEdit.SetInfoBoxText("The Y axis position");
        NewObject.PosYEdit.ColourArray = [0, 0, 1, 1];
        NewObject.ScaleXEdit = NewObject.Attributes.AddEditBox("Scale X", UIEditBox.prototype.editBoxType.Percent);
        NewObject.ScaleXEdit.SetInfoBoxText("The X axis scale");
        NewObject.ScaleXEdit.ColourArray = [0, 0, 1, 1];
        NewObject.ScaleYEdit = NewObject.Attributes.AddEditBox("Scale Y", UIEditBox.prototype.editBoxType.Percent);
        NewObject.ScaleYEdit.SetInfoBoxText("The Y axis scale");
        NewObject.ScaleYEdit.ColourArray = [0, 0, 1, 1];
        NewObject.SizeXEdit = NewObject.Attributes.AddEditBox("Size X", UIEditBox.prototype.editBoxType.Number);
        NewObject.SizeXEdit.SetInfoBoxText("The size of object in the X axis");
        NewObject.SizeXEdit.ColourArray = [0, 0, 1, 1];
        NewObject.SizeYEdit = NewObject.Attributes.AddEditBox("Size Y", UIEditBox.prototype.editBoxType.Number);
        NewObject.SizeYEdit.SetInfoBoxText("The size of object in the Y axis");
        NewObject.SizeYEdit.ColourArray = [0, 0, 1, 1];
        NewObject.RotateEdit = NewObject.Attributes.AddEditBox("Rotation", UIEditBox.prototype.editBoxType.Number);
        NewObject.RotateEdit.SetInfoBoxText("The rotation [in degrees]");
        NewObject.RotateEdit.ColourArray = [0, 0, 1, 1];
        NewObject.ColourREdit = NewObject.Attributes.AddSlider("Red", 0, 1);
        NewObject.ColourREdit.SetInfoBoxText("The colour field Red");
        NewObject.ColourREdit.ColourArray = [0, 0, 1, 1];
        NewObject.ColourGEdit = NewObject.Attributes.AddSlider("Green", 0, 1);
        NewObject.ColourGEdit.SetInfoBoxText("The colour field Green");
        NewObject.ColourGEdit.ColourArray = [0, 0, 1, 1];
        NewObject.ColourBEdit = NewObject.Attributes.AddSlider("Blue", 0, 1);
        NewObject.ColourBEdit.SetInfoBoxText("The colour field Blue");
        NewObject.ColourBEdit.ColourArray = [0, 0, 1, 1];
        NewObject.ColourAEdit = NewObject.Attributes.AddSlider("Alpha", 0, 1);
        NewObject.ColourAEdit.SetInfoBoxText("The colour field Alpha");
        NewObject.ColourAEdit.ColourArray = [0, 0, 1, 1];
        NewObject.UIItems[NewObject.UIItems.length] = NewObject.Attributes;
        NewObject.Defaults = UI.Create();
        NewObject.DefaultsBox = NewObject.Defaults.AddDialogBox();
        NewObject.DefaultsBox.AddOKCancel();
        NewObject.DefaultsBox.AddAutoUpdateButton("Update World", "Enabling this will allow for\n update of all entities in world");
        NewObject.UIItems[NewObject.UIItems.length] = NewObject.Defaults;
        NewObject.Rollback = UI.Create();
        NewObject.RollbackBox = NewObject.Rollback.AddDialogBox(undefined, undefined, 350);
        NewObject.RollbackBox.SetTitleBar("Autosave Rollback");
        NewObject.RollbackBox.AddCancel();
        NewObject.UIItems[NewObject.UIItems.length] = NewObject.Rollback;
        NewObject.RollbackButtons = [];
        NewObject.DialogTest = UI.Create();
        NewObject.CollBox = NewObject.DialogTest.AddCollisionBox("Editor_White", 1);
        NewObject.UIItems[NewObject.UIItems.length] = NewObject.DialogTest;
        NewObject.Confirmation = UI.Create();
        NewObject.ConfirmationBox = NewObject.Confirmation.AddConfirmationBox();
        NewObject.UIItems[NewObject.UIItems.length] = NewObject.Confirmation;
        NewObject.LoadSave = UI.Create();
        NewObject.LoadSaveBox = NewObject.LoadSave.AddLoadSaveBox();
        NewObject.UIItems[NewObject.UIItems.length] = NewObject.LoadSave;
        NewObject.AddToPalette = UI.Create();
        NewObject.AddToPaletteBox = NewObject.AddToPalette.AddDialogBox(undefined, undefined, undefined, 200);
        NewObject.AddToPaletteBox.AddOKCancel();
        NewObject.AddToPaletteBox.SetTitleBar("Add New Palette Object");
        NewObject.APBNameEdit = NewObject.AddToPalette.AddEditBox("Name", UIEditBox.prototype.editBoxType.Normal);
        NewObject.APBNameEdit.SetDefaultValue("ObjectName");
        NewObject.APBNameEdit.SetInfoBoxText("The name of the object");
        NewObject.APBImageEdit = NewObject.AddToPalette.AddEditBox("Image", UIEditBox.prototype.editBoxType.Normal);
        NewObject.APBImageEdit.SetDefaultValue("Coin");
        NewObject.APBImageEdit.SetInfoBoxText("The name of the image");
        var z = 0;
        NewObject.TypeArray = [];
        for (z = 0; z < EntityTypeManager.TypesRegistered.length; z += 1) {
            NewObject.TypeArray[z] = EntityTypeManager.TypesRegistered[z].Name
        }
        NewObject.APBTypeEdit = NewObject.AddToPalette.AddComboBox(NewObject.TypeArray, "Types");
        NewObject.APBTypeEdit.SetInfoBoxText("The type of object");
        NewObject.UIItems[NewObject.UIItems.length] = NewObject.AddToPalette;
        NewObject.DropDownObjectUI = UI.Create();
        NewObject.DropDownObjectBox = NewObject.DropDownObjectUI.AddDropDownBox(["Object Collision", "Object Defaults", "Object Properties", "Limit selection to this", "Disable from selection", "Hide object", "Switch with selected", "Category Up", "Category Down", "New Object before", "New Object after", "Delete Object"]);
        NewObject.UIItems[NewObject.UIItems.length] = NewObject.DropDownObjectUI;
        NewObject.DropDownCategoryUI = UI.Create();
        NewObject.DropDownCategoryBox = NewObject.DropDownCategoryUI.AddDropDownBox(["Category Properties", "New Category Above", "New Category Below", "Move Category Up", "Move Category Down", "Delete Category"]);
        NewObject.UIItems[NewObject.UIItems.length] = NewObject.DropDownCategoryUI;
        NewObject.ObjectProperties = UI.Create();
        NewObject.ObjectPropertiesBox = NewObject.ObjectProperties.AddDialogBox(undefined, undefined, undefined, 270);
        NewObject.ObjectPropertiesBox.AddOKCancel();
        NewObject.ObjectPropertiesBox.SetTitleBar("Object Properties");
        NewObject.ObjPropNameEdit = NewObject.ObjectProperties.AddEditBox("Name", UIEditBox.prototype.editBoxType.Normal);
        NewObject.ObjPropNameEdit.SetInfoBoxText("The name of the object");
        NewObject.ObjPropImageEdit = NewObject.ObjectProperties.AddEditBox("Image1", UIEditBox.prototype.editBoxType.Normal);
        NewObject.ObjPropImageEdit.SetInfoBoxText("The name of the image");
        NewObject.ObjPropImage2Edit = NewObject.ObjectProperties.AddEditBox("Image2", UIEditBox.prototype.editBoxType.Normal);
        NewObject.ObjPropImage2Edit.SetInfoBoxText("The name of the second image [type 'undefined' or 'null' or ' ' for none]");
        NewObject.ObjPropCategoryEdit = NewObject.ObjectProperties.AddEditBox("Category", UIEditBox.prototype.editBoxType.Normal);
        NewObject.ObjPropCategoryEdit.SetInfoBoxText("The category object belongs to");
        NewObject.UIItems[NewObject.UIItems.length] = NewObject.ObjectProperties;
        NewObject.CategoryProperties = UI.Create();
        NewObject.CategoryPropertiesBox = NewObject.CategoryProperties.AddDialogBox(undefined, undefined, undefined, 120);
        NewObject.CategoryPropertiesBox.AddOKCancel();
        NewObject.CategoryPropertiesBox.SetTitleBar("Category Properties");
        NewObject.CatPropNameEdit = NewObject.CategoryProperties.AddEditBox("Name", UIEditBox.prototype.editBoxType.Normal);
        NewObject.UIItems[NewObject.UIItems.length] = NewObject.CategoryProperties;
        var i = 0;
        for (i = 0; i < NewObject.UIItems.length; i += 1) {
            NewObject.UIItems[i].EnableAll(false)
        }
        NewObject.GeneralFunctions = EditorGeneralFunctions.Create();
        NewObject.SelectedFunctions = EditorSelectedFunctions.Create();
        NewObject.ActionFunctions = EditorSelectedActions.Create();
        NewObject.ScaleFunctions = EditorScaleActions.Create();
        NewObject.UndoActions = EditorUndoActions.Create();
        NewObject.BrushFunctions = EditorBrushFunctions.Create();
        NewObject.GroupFunctions = EditorGroupFunctions.Create();
        NewObject.UpdateFunctions = EditorUpdateFunctions.Create();
        NewObject.AttributesFunctions = EditorAttributesFunctions.Create();
        NewObject.DefaultsFunctions = EditorDefaultsFunctions.Create();
        NewObject.LayerFunctions = EditorLayerFunctions.Create();
        NewObject.AttachmentFunctions = EditorAttachmentFunctions.Create();
        NewObject.Init();
        return NewObject
    };

    function EditorAttachmentFunctions() {}
    EditorAttachmentFunctions.prototype = {
        AttachEntities: function AttachEntitiesFn(Editor) {
            var i = 0;
            for (i = 0; i < Editor.SelectionEntities.length; i += 1) {
                if (this.AnyAttachments(Editor, Editor.SelectionEntities[i]) !== -1) {
                    this.DetachEntities(Editor)
                }
            }
            var AttachLen = this.Attachments.length;
            this.Attachments[AttachLen] = [];
            for (i = 0; i < Editor.SelectionEntities.length; i += 1) {
                this.Attachments[AttachLen][i] = Editor.SelectionEntities[i]
            }
            Editor.ErrorText.Item.SetText("INFO: ATTACHMENTS CREATED!");
            Editor.ErrorText.Item.SetPositionY(80);
            Editor.ErrorTimer = 1
        },
        AnyAttachments: function AnyAttachmentsFn(Editor, Entity) {
            var i = 0;
            for (i = 0; i < this.Attachments.length; i += 1) {
                var Index = this.Attachments[i].indexOf(Entity);
                if (Index !== -1) {
                    return i
                }
            }
            return -1
        },
        DetachEntities: function DetachEntitiesFn(Editor) {
            var i = 0;
            for (i = 0; i < Editor.SelectionEntities.length; i += 1) {
                var Index = this.AnyAttachments(Editor, Editor.SelectionEntities[i]);
                if (Index !== -1) {
                    var Position = this.Attachments[Index].indexOf(Editor.SelectionEntities[i]);
                    this.Attachments[Index].splice(Position, 1)
                }
            }
            for (i = 0; i < this.Attachments.length; i += 1) {
                if (this.Attachments[i].length === 1 || this.Attachments[i].length === 0) {
                    this.Attachments.splice(i, 1)
                }
            }
        },
        DisplayAttachmentLines: function DisplayAttachmentLinesFn(Editor) {
            var i = 0,
                j = 0;
            if (this.AttachmentLines.length > 0) {
                var CurrLine = 0;
                for (i = 0; i < this.Attachments.length; i += 1) {
                    for (j = 0; j < this.Attachments[i].length; j += 1) {
                        if (j !== this.Attachments[i].length - 1) {
                            var ScreenCoordsA = Editor.World.GetLayer(Editor.CurrentLayer).TransformLocalToScreen(this.Attachments[i][j].StartX, this.Attachments[i][j].StartY);
                            var ScreenCoordsB = Editor.World.GetLayer(Editor.CurrentLayer).TransformLocalToScreen(this.Attachments[i][j + 1].StartX, this.Attachments[i][j + 1].StartY);
                            this.AttachmentLines[CurrLine].SetStartCoord(ScreenCoordsA.x, ScreenCoordsA.y);
                            this.AttachmentLines[CurrLine].SetEndCoord(ScreenCoordsB.x, ScreenCoordsB.y);
                            CurrLine += 1
                        }
                    }
                }
                return
            }
            for (i = 0; i < this.Attachments.length; i += 1) {
                for (j = 0; j < this.Attachments[i].length; j += 1) {
                    if (j !== this.Attachments[i].length - 1) {
                        var Line = Helpers.CreateLine(0, 0, 0, 0, [1, 0, 1, 1], JamSystem.RenderManager.GetRoot());
                        var NextLine = this.AttachmentLines.length;
                        this.AttachmentLines[NextLine] = Line;
                        var ScreenCoordsC = Editor.World.GetLayer(Editor.CurrentLayer).TransformLocalToScreen(this.Attachments[i][j].StartX, this.Attachments[i][j].StartY);
                        var ScreenCoordsD = Editor.World.GetLayer(Editor.CurrentLayer).TransformLocalToScreen(this.Attachments[i][j + 1].StartX, this.Attachments[i][j + 1].StartY);
                        this.AttachmentLines[NextLine].SetStartCoord(ScreenCoordsC.x, ScreenCoordsC.y);
                        this.AttachmentLines[NextLine].SetEndCoord(ScreenCoordsD.x, ScreenCoordsD.y)
                    }
                }
            }
        },
        StopAttachmentLines: function StopAttachmentLinesFn(Editor) {
            if (this.AttachmentLines.length > 0) {
                while (this.AttachmentLines.length > 0) {
                    Helpers.DestroyLine(this.AttachmentLines[0]);
                    this.AttachmentLines.splice(0, 1)
                }
                return
            }
        },
        Init: function InitFn() {
            this.Attachments = [];
            this.AttachmentLines = [];
            this.AttachmentMode = false
        }
    };
    EditorAttachmentFunctions.Create = function EditorGeneralCreateFn() {
        var NewObject = new EditorAttachmentFunctions;
        NewObject.Attachments = [];
        NewObject.AttachmentLines = [];
        NewObject.AttachmentMode = false;
        return NewObject
    };

    function EditorAttributesFunctions() {}
    EditorAttributesFunctions.PositionXVariable = -10;
    EditorAttributesFunctions.PositionYVariable = -9;
    EditorAttributesFunctions.ScaleXVariable = -8;
    EditorAttributesFunctions.ScaleYVariable = -7;
    EditorAttributesFunctions.RotationVariable = -6;
    EditorAttributesFunctions.ColourRVariable = -5;
    EditorAttributesFunctions.ColourGVariable = -4;
    EditorAttributesFunctions.ColourBVariable = -3;
    EditorAttributesFunctions.ColourAVariable = -2;
    EditorAttributesFunctions.MassVariable = -1;
    EditorAttributesFunctions.prototype = {
        CheckForRightClick: function RightClickCheckFn(Editor, X, Y) {
            var i = 0,
                EntityType;
            this.HandleChangesInAttributes(Editor, X, Y);
            if (Editor.AttributesBox.IsVisible() && Editor.State === Editor.editorState.SetAttributes) {
                if (JamSystem.InputManager.GetKeyPressed(404) || JamSystem.InputManager.GetKeyPressed(622)) {
                    Editor.AttributesBox.OKPressed = true;
                    Editor.AttributesBox.SetIsVisible(false)
                }
            }
            if (Editor.GeneralFunctions.IsMouseOverPalette(Editor, X, Y)) {
                return
            }
            if (Editor.State === Editor.editorState.SetCollision || Editor.State === Editor.editorState.SetAttributes || !Editor.SelectedFunctions.HoverEntity && Editor.SelectionEntities.length === 0 || !JamSystem.InputManager.GetKeyHeld(302) && !JamSystem.InputManager.GetKeyHeld(303)) {
                return
            }
            if (JamSystem.InputManager.GetMouseButtonPressed(1)) {
                this.CreateAttributesBox(Editor, X, Y)
            }
        },
        CreateAttributesBox: function CreateAttributesBoxFn(Editor, X, Y) {
            var NewEntity = Editor.SelectedFunctions.GetEntityAt(Editor, X, Y);
            var i = 0;
            if (Editor.ObjectPaletteBox.BrushesNonSelectable() && NewEntity) {
                if (!Editor.ObjectPaletteBox.AllowSelection[NewEntity.ObjectPaletteIndex]) {
                    NewEntity = null
                }
            }
            if (NewEntity) {
                var AllowSpecificVars = true;
                var Index = Editor.SelectionEntities.indexOf(NewEntity);
                if (Index === -1) {
                    Editor.SelectedFunctions.CleanSelection(Editor);
                    Editor.SelectionEntities[0] = NewEntity
                } else {
                    for (i = 0; i < Editor.SelectionEntities.length; i += 1) {
                        if (Editor.SelectionEntities[i].TypeID !== NewEntity.TypeID) {
                            AllowSpecificVars = false
                        }
                    }
                }
                Editor.AttributesBox.SetTitleBar("Attributes: (Type " + EntityTypeManager.GetNameFromID(NewEntity.TypeID) + ")");
                if (!AllowSpecificVars) {
                    Editor.AttributesBox.SetTitleBar("Attributes: (MIXED TYPES)")
                }
                Editor.AttributesBox.CheckButtonUI.SetDefaultValue(true);
                Editor.AttributesBox.AutoUpdatePressed = true;
                Editor.NameEdit.SetDefaultValue(NewEntity.Name);
                Editor.PosXEdit.SetDefaultValue("" + NewEntity.StartX.toFixed(2));
                Editor.PosYEdit.SetDefaultValue("" + NewEntity.StartY.toFixed(2));
                Editor.ScaleXEdit.SetDefaultValue("" + NewEntity.StartScaleX.toFixed(2));
                Editor.ScaleYEdit.SetDefaultValue("" + NewEntity.StartScaleY.toFixed(2));
                Editor.SizeXEdit.SetDefaultValue("" + (NewEntity.StartScaleX * NewEntity.GetWidth()).toFixed(2));
                Editor.SizeYEdit.SetDefaultValue("" + (NewEntity.StartScaleY * NewEntity.GetHeight()).toFixed(2));
                Editor.RotateEdit.SetDefaultValue("" + Maths.RadToDeg(NewEntity.StartRotation).toFixed(2));
                var Colour = NewEntity.GetColour();
                Editor.ColourREdit.SetDefaultValue("" + Colour[0]);
                Editor.ColourGEdit.SetDefaultValue("" + Colour[1]);
                Editor.ColourBEdit.SetDefaultValue("" + Colour[2]);
                Editor.ColourAEdit.SetDefaultValue("" + Colour[3]);
                if (AllowSpecificVars) {
                    if (this.MassEdit === 0 && NewEntity.Box2DBody && NewEntity.GetIsActive()) {
                        this.MassEdit = Editor.Attributes.AddEditBox("Mass", UIEditBox.prototype.editBoxType.Number);
                        this.MassEdit.ColourArray = [0, 0, 1, 1];
                        this.MassEdit.SetDefaultValue("" + (Physics.GetBodyMass(NewEntity.Box2DBody) * 100).toFixed(2));
                        this.MassEdit.SetInfoBoxText("Mass of the dynamic entity")
                    }
                    var EntityType = EntityTypeManager.TypesRegistered[NewEntity.TypeID];
                    if (EntityType.EditableVariables) {
                        for (i = 0; i < EntityType.EditableVariables.length; i += 1) {
                            if (EntityType.EditableVariables[i].Hidden) {
                                this.EditableFields[i] = 0
                            } else {
                                var Label = EntityType.EditableVariables[i].Name;
                                var DefaultValue = NewEntity.EditableVariables[i];
                                if (EntityType.EditableVariables[i].Type === "Integer") {
                                    this.EditableFields[i] = Editor.Attributes.AddEditBox(Label, UIEditBox.prototype.editBoxType.Integer);
                                    this.EditableFields[i].SetDefaultValue("" + DefaultValue.toFixed(0))
                                }
                                if (EntityType.EditableVariables[i].Type === "Number") {
                                    this.EditableFields[i] = Editor.Attributes.AddEditBox(Label, UIEditBox.prototype.editBoxType.Number);
                                    this.EditableFields[i].SetDefaultValue("" + DefaultValue.toFixed(2))
                                }
                                if (EntityType.EditableVariables[i].Type === "Percent") {
                                    this.EditableFields[i] = Editor.Attributes.AddEditBox(Label, UIEditBox.prototype.editBoxType.Percent);
                                    this.EditableFields[i].SetDefaultValue("" + DefaultValue.toFixed(2))
                                }
                                if (EntityType.EditableVariables[i].Type === "String") {
                                    this.EditableFields[i] = Editor.Attributes.AddEditBox(Label, UIEditBox.prototype.editBoxType.Normal);
                                    this.EditableFields[i].SetDefaultValue("" + DefaultValue)
                                }
                                if (EntityType.EditableVariables[i].Type === "Boolean") {
                                    this.EditableFields[i] = Editor.Attributes.AddCheckTextBox(Label);
                                    this.EditableFields[i].SetDefaultValue(DefaultValue)
                                }
                                if (EntityType.EditableVariables[i].Type === "Slider") {
                                    var Min = parseFloat(EntityType.EditableVariables[i].Slider.Min);
                                    var Max = parseFloat(EntityType.EditableVariables[i].Slider.Max);
                                    this.EditableFields[i] = Editor.Attributes.AddSlider(Label, Min, Max);
                                    this.EditableFields[i].SetDefaultValue("" + DefaultValue)
                                }
                                if (EntityType.EditableVariables[i].Type === "Combo") {
                                    var Combo = EntityType.EditableVariables[i].Combo;
                                    this.EditableFields[i] = Editor.Attributes.AddComboBox(Combo, Label);
                                    if (DefaultValue) {
                                        this.EditableFields[i].SetDefaultValue(DefaultValue)
                                    }
                                }
                                if (EntityType.EditableVariables[i].Type === "TypeCombo") {
                                    var z = 0,
                                        TypeArray = [];
                                    for (z = 0; z < EntityTypeManager.TypesRegistered.length; z += 1) {
                                        TypeArray[z] = EntityTypeManager.TypesRegistered[z].Name
                                    }
                                    this.EditableFields[i] = Editor.Attributes.AddComboBox(TypeArray, Label);
                                    this.EditableFields[i].SetDefaultValue(NewEntity.TypeID)
                                }
                                if (EntityType.EditableVariables[i].Type === "ObjectCombo") {
                                    var j = 0,
                                        ObjectArray = [];
                                    for (j = 0; j < ObjectPaletteManager.ObjectPalette.length; j += 1) {
                                        ObjectArray[j] = ObjectPaletteManager.ObjectPalette[j].Name
                                    }
                                    this.EditableFields[i] = Editor.Attributes.AddComboBox(ObjectArray, Label);
                                    this.EditableFields[i].SetDefaultValue(NewEntity.ObjectPaletteIndex);
                                    if (DefaultValue > -1) {
                                        this.EditableFields[i].SetDefaultValue(DefaultValue)
                                    }
                                }
                                if (this.EditableFields[i] && EntityType.EditableVariables[i].Info) {
                                    this.EditableFields[i].SetInfoBoxText(EntityType.EditableVariables[i].Info)
                                }
                                if (this.EditableFields[i] && EntityType.EditableVariables[i].Shared) {
                                    this.EditableFields[i].DisableEdit(true)
                                }
                            }
                        }
                    }
                }
                this.PreviousAttributesState = Editor.State;
                Editor.Attributes.EnableAll(true);
                Editor.SelectedFunctions.CleanHoverEntity(Editor);
                this.AttributesUndoCreated = false;
                Editor.State = Editor.editorState.SetAttributes
            }
        },
        HandleChangesInAttributes: function HandleChangesInAttributesFn(Editor, X, Y) {
            if (Editor.State === Editor.editorState.SetAttributes) {
                var IsClosed = !Editor.AttributesBox.IsVisible();
                var RequiresUpdate = Editor.AttributesBox.AutoUpdatePressed;
                var i = 0;
                if (!IsClosed) {
                    Editor.AttributesBox.CheckAllForHidden()
                }
                if (IsClosed || RequiresUpdate) {
                    var EntityType = EntityTypeManager.TypesRegistered[Editor.SelectionEntities[0].TypeID];
                    if (Editor.AttributesBox.OKPressed || RequiresUpdate) {
                        var FoundChange = false;
                        if (Editor.NameEdit.CurrText !== Editor.NameEdit.DefaultText && Editor.NameEdit.CurrText) {
                            if (!this.AttributesUndoCreated) {
                                Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.SelectedEntityMod, Editor.SelectionEntities);
                                this.AttributesUndoCreated = true
                            }
                            for (i = 0; i < Editor.SelectionEntities.length; i += 1) {
                                Editor.SelectionEntities[i].Name = Editor.NameEdit.GetValue();
                                Editor.World.CheckNameUniqueness(Editor.SelectionEntities[i])
                            }
                            Editor.NameEdit.SetDefaultValue(Editor.NameEdit.GetValue());
                            FoundChange = true
                        }
                        if (Editor.PosXEdit.CurrText !== Editor.PosXEdit.DefaultText && Editor.PosXEdit.CurrText) {
                            if (!this.AttributesUndoCreated) {
                                Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.SelectedEntityMod, Editor.SelectionEntities);
                                this.AttributesUndoCreated = true
                            }
                            for (i = 0; i < Editor.SelectionEntities.length; i += 1) {
                                Editor.SelectionEntities[i].StartX = Editor.PosXEdit.GetValue();
                                Editor.SelectionEntities[i].SetEditableVariable(EditorAttributesFunctions.PositionXVariable, Editor.PosXEdit.GetValue())
                            }
                            Editor.PosXEdit.SetDefaultValue("" + Editor.PosXEdit.GetValue());
                            FoundChange = true
                        }
                        if (Editor.PosYEdit.CurrText !== Editor.PosYEdit.DefaultText && Editor.PosYEdit.CurrText) {
                            if (!this.AttributesUndoCreated) {
                                Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.SelectedEntityMod, Editor.SelectionEntities);
                                this.AttributesUndoCreated = true
                            }
                            for (i = 0; i < Editor.SelectionEntities.length; i += 1) {
                                Editor.SelectionEntities[i].StartY = Editor.PosYEdit.GetValue();
                                Editor.SelectionEntities[i].SetEditableVariable(EditorAttributesFunctions.PositionYVariable, Editor.PosYEdit.GetValue())
                            }
                            Editor.PosYEdit.SetDefaultValue("" + Editor.PosYEdit.GetValue());
                            FoundChange = true
                        }
                        if (Editor.ScaleXEdit.CurrText !== Editor.ScaleXEdit.DefaultText && Editor.ScaleXEdit.CurrText) {
                            if (Editor.ScaleXEdit.GetValue() !== 0) {
                                if (!this.AttributesUndoCreated) {
                                    Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.SelectedEntityMod, Editor.SelectionEntities);
                                    this.AttributesUndoCreated = true
                                }
                                for (i = 0; i < Editor.SelectionEntities.length; i += 1) {
                                    Editor.SelectionEntities[i].StartScaleX = Editor.ScaleXEdit.GetValue();
                                    Editor.SelectionEntities[i].SetEditableVariable(EditorAttributesFunctions.ScaleXVariable, Editor.ScaleXEdit.GetValue())
                                }
                                Editor.ScaleXEdit.SetDefaultValue("" + Editor.ScaleXEdit.GetValue());
                                Editor.SizeXEdit.SetDefaultValue("" + (Editor.ScaleXEdit.GetValue() * Editor.SelectionEntities[0].GetWidth()).toFixed(2));
                                FoundChange = true
                            }
                        }
                        if (Editor.ScaleYEdit.CurrText !== Editor.ScaleYEdit.DefaultText && Editor.ScaleYEdit.CurrText) {
                            if (Editor.ScaleYEdit.GetValue() !== 0) {
                                if (!this.AttributesUndoCreated) {
                                    Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.SelectedEntityMod, Editor.SelectionEntities);
                                    this.AttributesUndoCreated = true
                                }
                                for (i = 0; i < Editor.SelectionEntities.length; i += 1) {
                                    Editor.SelectionEntities[i].StartScaleY = Editor.ScaleYEdit.GetValue();
                                    Editor.SelectionEntities[i].SetEditableVariable(EditorAttributesFunctions.ScaleYVariable, Editor.ScaleYEdit.GetValue())
                                }
                                Editor.ScaleYEdit.SetDefaultValue("" + Editor.ScaleYEdit.GetValue());
                                Editor.SizeYEdit.SetDefaultValue("" + (Editor.ScaleYEdit.GetValue() * Editor.SelectionEntities[0].GetHeight()).toFixed(2));
                                FoundChange = true
                            }
                        }
                        if (Editor.SizeXEdit.CurrText !== Editor.SizeXEdit.DefaultText && Editor.SizeXEdit.CurrText) {
                            if (Editor.SizeXEdit.GetValue() !== 0) {
                                if (!this.AttributesUndoCreated) {
                                    Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.SelectedEntityMod, Editor.SelectionEntities);
                                    this.AttributesUndoCreated = true
                                }
                                for (i = 0; i < Editor.SelectionEntities.length; i += 1) {
                                    Editor.SelectionEntities[i].StartScaleX = Editor.SizeXEdit.GetValue() / Editor.SelectionEntities[i].GetWidth();
                                    Editor.SelectionEntities[i].SetEditableVariable(EditorAttributesFunctions.ScaleXVariable, Editor.SizeXEdit.GetValue() / Editor.SelectionEntities[i].GetWidth())
                                }
                                Editor.SizeXEdit.SetDefaultValue("" + Editor.SizeXEdit.GetValue());
                                Editor.ScaleXEdit.SetDefaultValue("" + (Editor.SizeXEdit.GetValue() / Editor.SelectionEntities[0].GetWidth()).toFixed(2));
                                FoundChange = true
                            }
                        }
                        if (Editor.SizeYEdit.CurrText !== Editor.SizeYEdit.DefaultText && Editor.SizeYEdit.CurrText) {
                            if (Editor.SizeYEdit.GetValue() !== 0) {
                                if (!this.AttributesUndoCreated) {
                                    Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.SelectedEntityMod, Editor.SelectionEntities);
                                    this.AttributesUndoCreated = true
                                }
                                for (i = 0; i < Editor.SelectionEntities.length; i += 1) {
                                    Editor.SelectionEntities[i].StartScaleY = Editor.SizeYEdit.GetValue() / Editor.SelectionEntities[i].GetHeight();
                                    Editor.SelectionEntities[i].SetEditableVariable(EditorAttributesFunctions.ScaleXVariable, Editor.SizeXEdit.GetValue() / Editor.SelectionEntities[i].GetWidth())
                                }
                                Editor.SizeYEdit.SetDefaultValue("" + Editor.SizeYEdit.GetValue());
                                Editor.ScaleYEdit.SetDefaultValue("" + (Editor.SizeYEdit.GetValue() / Editor.SelectionEntities[0].GetHeight()).toFixed(2));
                                FoundChange = true
                            }
                        }
                        if (Editor.RotateEdit.CurrText !== Editor.RotateEdit.DefaultText && Editor.RotateEdit.CurrText) {
                            if (!this.AttributesUndoCreated) {
                                Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.SelectedEntityMod, Editor.SelectionEntities);
                                this.AttributesUndoCreated = true
                            }
                            for (i = 0; i < Editor.SelectionEntities.length; i += 1) {
                                Editor.SelectionEntities[i].StartRotation = Maths.DegToRad(Editor.RotateEdit.GetValue());
                                Editor.SelectionEntities[i].SetEditableVariable(EditorAttributesFunctions.RotationVariable, Editor.RotateEdit.GetValue())
                            }
                            Editor.RotateEdit.SetDefaultValue("" + Editor.RotateEdit.GetValue());
                            FoundChange = true
                        }
                        if (Editor.ColourREdit.CurrText !== Editor.ColourREdit.DefaultText && Editor.ColourREdit.CurrText) {
                            if (!this.AttributesUndoCreated) {
                                Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.SelectedEntityMod, Editor.SelectionEntities);
                                this.AttributesUndoCreated = true
                            }
                            for (i = 0; i < Editor.SelectionEntities.length; i += 1) {
                                var Colour = Editor.SelectionEntities[i].GetColour();
                                Colour[0] = Editor.ColourREdit.GetValue();
                                Editor.SelectionEntities[i].SetColour(Colour);
                                Editor.SelectionEntities[i].SetEditableVariable(EditorAttributesFunctions.ColourRVariable, Editor.ColourREdit.GetValue())
                            }
                            Editor.ColourREdit.SetDefaultValue("" + Editor.ColourREdit.GetValue());
                            FoundChange = true
                        }
                        if (Editor.ColourGEdit.CurrText !== Editor.ColourGEdit.DefaultText && Editor.ColourGEdit.CurrText) {
                            if (!this.AttributesUndoCreated) {
                                Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.SelectedEntityMod, Editor.SelectionEntities);
                                this.AttributesUndoCreated = true
                            }
                            for (i = 0; i < Editor.SelectionEntities.length; i += 1) {
                                var Colour = Editor.SelectionEntities[i].GetColour();
                                Colour[1] = Editor.ColourGEdit.GetValue();
                                Editor.SelectionEntities[i].SetColour(Colour);
                                Editor.SelectionEntities[i].SetEditableVariable(EditorAttributesFunctions.ColourGVariable, Editor.ColourGEdit.GetValue())
                            }
                            Editor.ColourGEdit.SetDefaultValue("" + Editor.ColourGEdit.GetValue());
                            FoundChange = true
                        }
                        if (Editor.ColourBEdit.CurrText !== Editor.ColourBEdit.DefaultText && Editor.ColourBEdit.CurrText) {
                            if (!this.AttributesUndoCreated) {
                                Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.SelectedEntityMod, Editor.SelectionEntities);
                                this.AttributesUndoCreated = true
                            }
                            for (i = 0; i < Editor.SelectionEntities.length; i += 1) {
                                var Colour = Editor.SelectionEntities[i].GetColour();
                                Colour[2] = Editor.ColourBEdit.GetValue();
                                Editor.SelectionEntities[i].SetColour(Colour);
                                Editor.SelectionEntities[i].SetEditableVariable(EditorAttributesFunctions.ColourBVariable, Editor.ColourBEdit.GetValue())
                            }
                            Editor.ColourBEdit.SetDefaultValue("" + Editor.ColourBEdit.GetValue());
                            FoundChange = true
                        }
                        if (Editor.ColourAEdit.CurrText !== Editor.ColourAEdit.DefaultText && Editor.ColourAEdit.CurrText) {
                            if (!this.AttributesUndoCreated) {
                                Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.SelectedEntityMod, Editor.SelectionEntities);
                                this.AttributesUndoCreated = true
                            }
                            for (i = 0; i < Editor.SelectionEntities.length; i += 1) {
                                var Colour = Editor.SelectionEntities[i].GetColour();
                                Colour[3] = Editor.ColourAEdit.GetValue();
                                Editor.SelectionEntities[i].SetColour(Colour);
                                Editor.SelectionEntities[i].SetEditableVariable(EditorAttributesFunctions.ColourAVariable, Editor.ColourAEdit.GetValue())
                            }
                            Editor.ColourAEdit.SetDefaultValue("" + Editor.ColourAEdit.GetValue());
                            FoundChange = true
                        }
                        if (this.MassEdit) {
                            if (this.MassEdit.CurrText !== this.MassEdit.DefaultText && this.MassEdit.CurrText) {
                                if (!this.AttributesUndoCreated) {
                                    Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.SelectedEntityMod, Editor.SelectionEntities);
                                    this.AttributesUndoCreated = true
                                }
                                for (i = 0; i < Editor.SelectionEntities.length; i += 1) {
                                    Physics.SetBodyMass(Editor.SelectionEntities[i].Box2DBody, this.MassEdit.GetValue() / 100);
                                    Editor.SelectionEntities[i].SetEditableVariable(EditorAttributesFunctions.MassVariable, this.MassEdit.GetValue() / 100)
                                }
                                this.MassEdit.SetDefaultValue("" + this.MassEdit.GetValue());
                                FoundChange = true
                            }
                        }
                        if (EntityType.EditableVariables) {
                            var j = 0;
                            for (j = 0; j < EntityType.EditableVariables.length; j += 1) {
                                if (this.EditableFields[j]) {
                                    if (this.EditableFields[j].AnyChanges()) {
                                        if (!this.AttributesUndoCreated) {
                                            Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.SelectedEntityMod, Editor.SelectionEntities);
                                            this.AttributesUndoCreated = true
                                        }
                                        for (i = 0; i < Editor.SelectionEntities.length; i += 1) {
                                            Editor.SelectionEntities[i].SetEditableVariable(j, this.EditableFields[j].GetValue())
                                        }
                                        this.EditableFields[j].SetDefaultValue(this.EditableFields[j].GetValue());
                                        FoundChange = true
                                    }
                                }
                            }
                        }
                        if (FoundChange) {
                            for (i = 0; i < Editor.SelectionEntities.length; i += 1) {
                                Editor.SelectionEntities[i].Reset();
                                Editor.World.GetLayer(Editor.CurrentLayer).UpdateEntity(Editor.SelectionEntities[i])
                            }
                        }
                    }
                }
                if (IsClosed) {
                    if (Editor.AttributesBox.CancelPressed && this.AttributesUndoCreated) {
                        Editor.UndoActions.Undo(Editor)
                    }
                    Editor.AttributesBox.AutoUpdatePressed = false;
                    Editor.State = this.PreviousAttributesState;
                    if (this.MassEdit) {
                        Editor.Attributes.RemoveItem(this.MassEdit, Editor.AttributesBox);
                        this.MassEdit = 0
                    }
                    for (i = 0; i < this.EditableFields.length; i += 1) {
                        if (this.EditableFields[i]) {
                            Editor.Attributes.RemoveItem(this.EditableFields[i], Editor.AttributesBox)
                        }
                    }
                    Editor.AttributesBox.ResetBox();
                    this.EditableFields = []
                }
            }
        },
        Init: function InitFn() {
            this.MassEdit = 0;
            this.EditableFields = [];
            this.PreviousAttributesState = 0;
            this.AttributesUndoCreated = false
        }
    };
    EditorAttributesFunctions.Create = function EditorGeneralCreateFn() {
        var NewObject = new EditorAttributesFunctions;
        NewObject.MassEdit = 0;
        NewObject.EditableFields = [];
        NewObject.PreviousAttributesState = 0;
        NewObject.AttributesUndoCreated = false;
        return NewObject
    };

    function EditorDefaultsFunctions() {}
    EditorDefaultsFunctions.prototype = {
        CreateDefaultsBox: function CreateDefaultsBoxFn(Editor, X, Y, ObjectInfo) {
            if (ObjectInfo === undefined) {
                return
            }
            if (ObjectInfo.Type === undefined) {
                Debug.Log("Defaults -> Object has no type assigned");
                return
            }
            this.DefaultObjectInfo = ObjectInfo;
            var EntityType = EntityTypeManager.GetClassFromName(ObjectInfo.Type);
            if (!EntityType) {
                return
            }
            Editor.DefaultsBox.SetTitleBar("Defaults: (Type " + EntityType.Name + ")");
            var EditableDefaults = [];
            Editor.DefaultsBox.CheckButtonUI.SetDefaultValue(true);
            Editor.DefaultsBox.AutoUpdatePressed = true;
            var i = 0,
                j = 0;
            for (i = 0; i < EntityType.EditableVariables.length; i += 1) {
                if (!EntityType.EditableVariables[i].Hidden) {
                    EditableDefaults[i] = EntityType.EditableVariables[i].Default;
                    var FoundEditable = false;
                    if (ObjectInfo.Editables[i]) {
                        EditableDefaults[i] = ObjectInfo.Editables[i].Value;
                        FoundEditable = true
                    }
                    if (!FoundEditable) {
                        var NewMember = {
                            Name: EntityType.EditableVariables[i].Name,
                            Value: EntityType.EditableVariables[i].Default
                        };
                        ObjectInfo.Editables.splice(i, 0, NewMember)
                    }
                }
            }
            this.ScaleBoxX = Editor.Defaults.AddEditBox("Scale X", UIEditBox.prototype.editBoxType.Percent);
            this.ScaleBoxX.SetDefaultValue("" + ObjectInfo.Scale.x.toFixed(2));
            this.ScaleBoxX.ColourArray = [0, 0, 1, 1];
            this.ScaleBoxY = Editor.Defaults.AddEditBox("Scale Y", UIEditBox.prototype.editBoxType.Percent);
            this.ScaleBoxY.SetDefaultValue("" + ObjectInfo.Scale.y.toFixed(2));
            this.ScaleBoxY.ColourArray = [0, 0, 1, 1];
            this.RotationBox = Editor.Defaults.AddEditBox("Rotation", UIEditBox.prototype.editBoxType.Number);
            this.RotationBox.SetDefaultValue("" + Maths.RadToDeg(ObjectInfo.Rotation).toFixed(2));
            this.RotationBox.ColourArray = [0, 0, 1, 1];
            this.MassBox = Editor.Defaults.AddEditBox("Mass", UIEditBox.prototype.editBoxType.Number);
            this.MassBox.SetDefaultValue("" + (ObjectInfo.Mass * 100).toFixed(2));
            this.MassBox.ColourArray = [0, 0, 1, 1];
            this.ColoursRBox = Editor.Defaults.AddSlider("Red", 0, 1);
            this.ColoursRBox.SetDefaultValue("" + ObjectInfo.Colour[0].toFixed(2));
            this.ColoursRBox.ColourArray = [0, 0, 1, 1];
            this.ColoursGBox = Editor.Defaults.AddSlider("Green", 0, 1);
            this.ColoursGBox.SetDefaultValue("" + ObjectInfo.Colour[1].toFixed(2));
            this.ColoursGBox.ColourArray = [0, 0, 1, 1];
            this.ColoursBBox = Editor.Defaults.AddSlider("Blue", 0, 1);
            this.ColoursBBox.SetDefaultValue("" + ObjectInfo.Colour[2].toFixed(2));
            this.ColoursBBox.ColourArray = [0, 0, 1, 1];
            this.ColoursABox = Editor.Defaults.AddSlider("Alpha", 0, 1);
            this.ColoursABox.SetDefaultValue("" + ObjectInfo.Colour[3].toFixed(2));
            this.ColoursABox.ColourArray = [0, 0, 1, 1];
            for (i = 0; i < EntityType.EditableVariables.length; i += 1) {
                if (EntityType.EditableVariables[i].Hidden) {
                    this.EditableFields[i] = 0
                } else {
                    var Label = EntityType.EditableVariables[i].Name;
                    var DefaultValue = EditableDefaults[i];
                    if (EntityType.EditableVariables[i].Type === "Integer") {
                        this.EditableFields[i] = Editor.Defaults.AddEditBox(Label, UIEditBox.prototype.editBoxType.Integer);
                        this.EditableFields[i].SetDefaultValue("" + DefaultValue.toFixed(0))
                    }
                    if (EntityType.EditableVariables[i].Type === "Number") {
                        this.EditableFields[i] = Editor.Defaults.AddEditBox(Label, UIEditBox.prototype.editBoxType.Number);
                        this.EditableFields[i].SetDefaultValue("" + DefaultValue.toFixed(2))
                    }
                    if (EntityType.EditableVariables[i].Type === "String") {
                        this.EditableFields[i] = Editor.Defaults.AddEditBox(Label, UIEditBox.prototype.editBoxType.Normal);
                        this.EditableFields[i].SetDefaultValue("" + DefaultValue)
                    }
                    if (EntityType.EditableVariables[i].Type === "Boolean") {
                        this.EditableFields[i] = Editor.Defaults.AddCheckTextBox(Label);
                        this.EditableFields[i].SetDefaultValue(DefaultValue)
                    }
                    if (EntityType.EditableVariables[i].Type === "Slider") {
                        var Min = parseFloat(EntityType.EditableVariables[i].Slider.Min);
                        var Max = parseFloat(EntityType.EditableVariables[i].Slider.Max);
                        this.EditableFields[i] = Editor.Defaults.AddSlider(Label, Min, Max);
                        this.EditableFields[i].SetDefaultValue("" + DefaultValue)
                    }
                    if (EntityType.EditableVariables[i].Type === "Combo") {
                        var Combo = EntityType.EditableVariables[i].Combo;
                        this.EditableFields[i] = Editor.Defaults.AddComboBox(Combo, Label);
                        if (DefaultValue) {
                            this.EditableFields[i].SetDefaultValue(DefaultValue)
                        }
                    }
                    if (EntityType.EditableVariables[i].Type === "TypeCombo") {
                        var TypeArray = [];
                        for (j = 0; j < EntityTypeManager.TypesRegistered.length; j += 1) {
                            TypeArray[j] = EntityTypeManager.TypesRegistered[j].Name
                        }
                        this.EditableFields[i] = Editor.Defaults.AddComboBox(TypeArray, Label);
                        this.EditableFields[i].SetDefaultValue(EntityTypeManager.GetIDFromName(ObjectInfo.Type))
                    }
                    if (EntityType.EditableVariables[i].Type === "ObjectCombo") {
                        var ObjectArray = [];
                        for (j = 0; j < ObjectPaletteManager.ObjectPalette.length; j += 1) {
                            ObjectArray[j] = ObjectPaletteManager.ObjectPalette[j].Name
                        }
                        this.EditableFields[i] = Editor.Defaults.AddComboBox(ObjectArray, Label);
                        this.EditableFields[i].SetDefaultValue(ObjectPaletteManager.ObjectPalette.indexOf(ObjectInfo));
                        if (DefaultValue > -1) {
                            this.EditableFields[i].SetDefaultValue(DefaultValue)
                        }
                    }
                    if (this.EditableFields[i] && EntityType.EditableVariables[i].Info) {
                        this.EditableFields[i].SetInfoBoxText(EntityType.EditableVariables[i].Info)
                    }
                }
                if (!EntityType.EditableVariables[i].Shared) {
                    this.EditableFields[i].DisableEdit(true)
                }
            }
            Editor.Defaults.EnableAll(true);
            Editor.SelectedFunctions.CleanHoverEntity(Editor);
            this.PreviousDefaultsState = Editor.State;
            this.DefaultsUndoCreated = false;
            Editor.State = Editor.editorState.SetDefaults
        },
        HandleChangesInDefaults: function HandleChangesInDefaultsFn(Editor, X, Y) {
            if (Editor.State !== Editor.editorState.SetDefaults) {
                return
            }
            var j = 0,
                i = 0;
            if (Editor.DefaultsBox.IsVisible() && Editor.State === Editor.editorState.SetDefaults) {
                if (JamSystem.InputManager.GetKeyPressed(404) || JamSystem.InputManager.GetKeyPressed(622)) {
                    Editor.DefaultsBox.OKPressed = true;
                    Editor.DefaultsBox.SetIsVisible(false)
                }
            }
            if (Editor.State === Editor.editorState.SetDefaults) {
                if (Editor.DefaultsBox.IsVisible()) {
                    Editor.DefaultsBox.CheckAllForHidden()
                } else {
                    if (Editor.DefaultsBox.OKPressed) {
                        var AlterWorldEntities = Editor.DefaultsBox.AutoUpdatePressed;
                        var PalIndex = 0,
                            Entities = [],
                            k = 0;
                        if (AlterWorldEntities) {
                            PalIndex = ObjectPaletteManager.ObjectPalette.indexOf(this.DefaultObjectInfo);
                            var Entities = Editor.World.GetAllEntitiesOfObjectIndex(PalIndex)
                        }
                        var UndoChangesFound = false;
                        for (j = 0; j < this.EditableFields.length; j += 1) {
                            if (this.EditableFields[j]) {
                                if (this.EditableFields[j].AnyChanges()) {
                                    UndoChangesFound = true
                                }
                            }
                        }
                        if (AlterWorldEntities && (this.ScaleBoxX.AnyChanges() || this.ScaleBoxY.AnyChanges() || this.MassBox.AnyChanges() || this.RotationBox.AnyChanges() || UndoChangesFound)) {
                            Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.SelectedEntityMod, Entities)
                        }
                        var FoundChange = false;
                        if (this.ScaleBoxX.AnyChanges()) {
                            FoundChange = true;
                            this.DefaultObjectInfo.Scale.x = parseFloat(this.ScaleBoxX.GetValue().toFixed(2));
                            if (AlterWorldEntities) {
                                for (k = 0; k < Entities.length; k += 1) {
                                    Entities[k].StartScaleX = parseFloat(this.ScaleBoxX.GetValue().toFixed(2))
                                }
                            }
                        }
                        if (this.ScaleBoxY.AnyChanges()) {
                            FoundChange = true;
                            this.DefaultObjectInfo.Scale.y = parseFloat(this.ScaleBoxY.GetValue().toFixed(2));
                            if (AlterWorldEntities) {
                                for (k = 0; k < Entities.length; k += 1) {
                                    Entities[k].StartScaleY = parseFloat(this.ScaleBoxY.GetValue().toFixed(2))
                                }
                            }
                        }
                        if (this.MassBox.AnyChanges()) {
                            FoundChange = true;
                            this.DefaultObjectInfo.Mass = parseFloat(this.MassBox.GetValue().toFixed(2) / 100);
                            if (AlterWorldEntities) {
                                for (k = 0; k < Entities.length; k += 1) {
                                    Physics.SetBodyMass(Entities[k].Box2DBody, parseFloat(this.MassBox.GetValue().toFixed(2) / 100))
                                }
                            }
                        }
                        if (this.RotationBox.AnyChanges()) {
                            FoundChange = true;
                            this.DefaultObjectInfo.Rotation = parseFloat(Maths.DegToRad(this.RotationBox.GetValue().toFixed(2)));
                            if (AlterWorldEntities) {
                                for (k = 0; k < Entities.length; k += 1) {
                                    Entities[k].StartRotation = parseFloat(Maths.DegToRad(this.RotationBox.GetValue().toFixed(2)))
                                }
                            }
                        }
                        if (this.ColoursRBox.AnyChanges()) {
                            FoundChange = true;
                            this.DefaultObjectInfo.Colour[0] = parseFloat(this.ColoursRBox.GetValue().toFixed(2));
                            if (AlterWorldEntities) {
                                for (k = 0; k < Entities.length; k += 1) {
                                    var Colour = Entities[k].GetColour();
                                    Colour[0] = parseFloat(this.ColoursRBox.GetValue().toFixed(2));
                                    Entities[k].SetColour(Colour)
                                }
                            }
                        }
                        if (this.ColoursGBox.AnyChanges()) {
                            FoundChange = true;
                            this.DefaultObjectInfo.Colour[1] = parseFloat(this.ColoursGBox.GetValue().toFixed(2));
                            if (AlterWorldEntities) {
                                for (k = 0; k < Entities.length; k += 1) {
                                    var Colour = Entities[k].GetColour();
                                    Colour[1] = parseFloat(this.ColoursGBox.GetValue().toFixed(2));
                                    Entities[k].SetColour(Colour)
                                }
                            }
                        }
                        if (this.ColoursBBox.AnyChanges()) {
                            FoundChange = true;
                            this.DefaultObjectInfo.Colour[2] = parseFloat(this.ColoursBBox.GetValue().toFixed(2));
                            if (AlterWorldEntities) {
                                for (k = 0; k < Entities.length; k += 1) {
                                    var Colour = Entities[k].GetColour();
                                    Colour[2] = parseFloat(this.ColoursBBox.GetValue().toFixed(2));
                                    Entities[k].SetColour(Colour)
                                }
                            }
                        }
                        if (this.ColoursABox.AnyChanges()) {
                            FoundChange = true;
                            this.DefaultObjectInfo.Colour[3] = parseFloat(this.ColoursABox.GetValue().toFixed(2));
                            if (AlterWorldEntities) {
                                for (k = 0; k < Entities.length; k += 1) {
                                    var Colour = Entities[k].GetColour();
                                    Colour[3] = parseFloat(this.ColoursABox.GetValue().toFixed(2));
                                    Entities[k].SetColour(Colour)
                                }
                            }
                        }
                        for (j = 0; j < this.EditableFields.length; j += 1) {
                            if (this.EditableFields[j]) {
                                if (this.EditableFields[j].AnyChanges()) {
                                    for (i = 0; i < this.DefaultObjectInfo.Editables.length; i += 1) {
                                        if (this.DefaultObjectInfo.Editables[i]) {
                                            if (this.DefaultObjectInfo.Editables[i].Name === this.EditableFields[j].GetLabel()) {
                                                FoundChange = true;
                                                this.DefaultObjectInfo.Editables[i].Value = this.EditableFields[j].GetValue();
                                                if (EntityTypeManager.GetClassFromName(this.DefaultObjectInfo.Type).EditableVariables[i].Shared || AlterWorldEntities) {
                                                    PalIndex = ObjectPaletteManager.ObjectPalette.indexOf(this.DefaultObjectInfo);
                                                    Entities = Editor.World.GetAllEntitiesOfObjectIndex(PalIndex);
                                                    for (k = 0; k < Entities.length; k += 1) {
                                                        Entities[k].SetEditableVariable(i, this.EditableFields[j].GetValue())
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (FoundChange) {
                            ObjectPaletteManager.SavePalette(SettingsFileManager.ObjectPaletteFile);
                            if (Entities) {
                                for (k = 0; k < Entities.length; k += 1) {
                                    Entities[k].Reset();
                                    var Layer = Editor.World.GetLayerEntityBelongsTo(Entities[k]);
                                    Editor.World.GetLayer(Layer).UpdateEntity(Entities[k])
                                }
                            }
                        }
                    }
                    Editor.State = this.PreviousDefaultsState;
                    Editor.DefaultsBox.AutoUpdatePressed = false;
                    Editor.Defaults.RemoveItem(this.ScaleBoxX, Editor.DefaultsBox);
                    Editor.Defaults.RemoveItem(this.ScaleBoxY, Editor.DefaultsBox);
                    Editor.Defaults.RemoveItem(this.MassBox, Editor.DefaultsBox);
                    Editor.Defaults.RemoveItem(this.RotationBox, Editor.DefaultsBox);
                    Editor.Defaults.RemoveItem(this.ColoursRBox, Editor.DefaultsBox);
                    Editor.Defaults.RemoveItem(this.ColoursGBox, Editor.DefaultsBox);
                    Editor.Defaults.RemoveItem(this.ColoursBBox, Editor.DefaultsBox);
                    Editor.Defaults.RemoveItem(this.ColoursABox, Editor.DefaultsBox);
                    this.ScaleBoxX = 0;
                    this.ScaleBoxY = 0;
                    this.MassBox = 0;
                    this.RotationBox = 0;
                    this.ColoursRBox = 0;
                    this.ColoursGBox = 0;
                    this.ColoursBBox = 0;
                    this.ColoursABox = 0;
                    for (i = 0; i < this.EditableFields.length; i += 1) {
                        if (this.EditableFields[i]) {
                            Editor.Defaults.RemoveItem(this.EditableFields[i], Editor.DefaultsBox)
                        }
                    }
                    Editor.DefaultsBox.ResetBox();
                    this.EditableFields = []
                }
            }
        },
        Init: function InitFn() {
            this.MassEdit = 0;
            this.EditableFields = [];
            this.PreviousDefaultsState = 0;
            this.DefaultObjectInfo = 0;
            this.ScaleBoxX = 0;
            this.ScaleBoxY = 0;
            this.MassBox = 0;
            this.RotationBox = 0;
            this.ColoursRBox = 0;
            this.ColoursGBox = 0;
            this.ColoursBBox = 0;
            this.ColoursABox = 0
        }
    };
    EditorDefaultsFunctions.Create = function EditorGeneralCreateFn() {
        var NewObject = new EditorDefaultsFunctions;
        NewObject.MassEdit = 0;
        NewObject.EditableFields = [];
        NewObject.PreviousDefaultsState = 0;
        NewObject.DefaultObjectInfo = 0;
        NewObject.ScaleBoxX = 0;
        NewObject.ScaleBoxY = 0;
        NewObject.MassBox = 0;
        NewObject.RotationBox = 0;
        NewObject.ColoursRBox = 0;
        NewObject.ColoursGBox = 0;
        NewObject.ColoursBBox = 0;
        NewObject.ColoursABox = 0;
        return NewObject
    };

    function EditorUpdateFunctions() {}
    EditorUpdateFunctions.prototype = {
        CheckConfirmations: function CheckConfirmFn(Editor, X, Y) {
            if (Editor.State === Editor.editorState.ConfirmLoad) {
                var Load = false;
                if (Editor.ConfirmationBox.YesPressed || JamSystem.InputManager.GetKeyPressed(404)) {
                    Editor.GeneralFunctions.SaveGame(Editor);
                    Load = true;
                    Editor.GeneralFunctions.LayerChanged = false
                }
                if (Editor.ConfirmationBox.NoPressed) {
                    Load = true
                }
                if (Editor.ConfirmationBox.CancelPressed || Load) {
                    Editor.ConfirmationBox.Reset();
                    Editor.Confirmation.EnableAll(false);
                    Editor.ConfirmationBox.isSuperFocused = false;
                    Editor.State = Editor.editorState.Free
                }
                if (Load) {
                    Editor.LoadSaveBox.ChangeType(UIFileBox.LoadingType, Editor.LoadFile);
                    Editor.LoadSave.EnableAll(true);
                    Editor.LoadSaveBox.isSuperFocused = true;
                    Editor.State = Editor.editorState.ConfirmFile;
                    return true
                }
            }
            if (Editor.State === Editor.editorState.ConfirmFile) {
                var ExitBox = false;
                if (!Editor.LoadSaveBox.FileLocationUI.isSuperFocused || Editor.LoadSaveBox.ButtonPressed) {
                    if (JamSystem.InputManager.GetKeyPressed(404) || Editor.LoadSaveBox.ButtonPressed) {
                        if (Editor.LoadSaveBox.BoxType === UIFileBox.LoadingType) {
                            Editor.LoadFile = Editor.LoadSaveBox.GetFile();
                            Editor.SaveFile = Editor.LoadSaveBox.GetFile();
                            Editor.GeneralFunctions.LoadGame(Editor)
                        }
                        if (Editor.LoadSaveBox.BoxType === UIFileBox.SavingType) {
                            Editor.SaveFile = Editor.LoadSaveBox.GetFile();
                            Editor.GeneralFunctions.SaveGame(Editor)
                        }
                        ExitBox = true
                    }
                }
                if (Editor.LoadSaveBox.CancelPressed || ExitBox) {
                    if (!WorldFileManager.Success && Editor.LoadSaveBox.CancelPressed) {
                        Editor.LoadSaveBox.CancelPressed = false;
                        return true
                    }
                    Editor.LoadSaveBox.FileLocationUI.StopEditing();
                    Editor.LoadSaveBox.Reset();
                    Editor.LoadSave.EnableAll(false);
                    Editor.LoadSaveBox.isSuperFocused = false;
                    Editor.State = Editor.editorState.Free;
                    return true
                }
            }
            if (Editor.State === Editor.editorState.ConfirmNewLevel) {
                var ExitBox = false;
                if (!Editor.LoadSaveBox.FileLocationUI.isSuperFocused || Editor.LoadSaveBox.ButtonPressed) {
                    if (JamSystem.InputManager.GetKeyPressed(404) || Editor.LoadSaveBox.ButtonPressed) {
                        Editor.GeneralFunctions.NewLevel(Editor, true, Editor.LoadSaveBox.GetFile());
                        ExitBox = true
                    }
                }
                if (Editor.LoadSaveBox.CancelPressed || ExitBox) {
                    Editor.LoadSaveBox.FileLocationUI.StopEditing();
                    Editor.LoadSaveBox.Reset();
                    Editor.LoadSave.EnableAll(false);
                    Editor.LoadSaveBox.isSuperFocused = false;
                    Editor.State = Editor.editorState.Free;
                    return true
                }
            }
            var Answered = false;
            if (Editor.State === Editor.editorState.ConfirmGrpCpy) {
                if (Editor.ConfirmationBox.YesPressed || JamSystem.InputManager.GetKeyPressed(404)) {
                    var i = 0;
                    for (i = 0; i < Editor.MissingEntities.length; i += 1) {
                        Editor.SelectionEntities[Editor.SelectionEntities.length] = Editor.MissingEntities[i]
                    }
                    Editor.BrushFunctions.CopyBrush(Editor, X, Y, Editor.CutMode, true);
                    Answered = true
                }
                if (Editor.ConfirmationBox.NoPressed) {
                    Editor.BrushFunctions.CopyBrush(Editor, X, Y, Editor.CutMode, false);
                    Answered = true
                }
                if (Editor.ConfirmationBox.CancelPressed || Answered) {
                    Editor.ConfirmationBox.Reset();
                    Editor.Confirmation.EnableAll(false);
                    Editor.ConfirmationBox.isSuperFocused = false;
                    Editor.State = Editor.editorState.Free;
                    return true
                }
            }
            if (Editor.State === Editor.editorState.FindParent) {
                Editor.GroupFunctions.UpdateLines(Editor, X, Y);
                if (JamSystem.InputManager.GetMouseButtonReleased(0)) {
                    Editor.GroupFunctions.AttachToParent(Editor, X, Y);
                    return true
                }
                if (!JamSystem.InputManager.GetKeyHeld(300) && !JamSystem.InputManager.GetKeyHeld(301)) {
                    var Key = JamSystem.InputManager.GetKeyValue();
                    if (Key !== undefined) {
                        if (Key.charCodeAt(0) !== 46 && Key.charCodeAt(0) !== 44) {
                            Editor.GroupFunctions.CancelGrouping(Editor)
                        }
                    }
                }
            }
            if (Editor.BrushPaletteBox.AllowConfirmation) {
                Editor.ConfirmationBox.SetTitleBar("\n\n\n\n\nWARNING\n\nONCE DELETED THERE IS NO UNDO!\n\nARE YOU SURE YOU WANT TO DELETE THIS BRUSH?");
                Editor.Confirmation.EnableAll(true);
                Editor.ConfirmationBox.isSuperFocused = true;
                Editor.State = Editor.editorState.ConfirmBrushDel;
                Editor.BrushPaletteBox.AllowConfirmation = false;
                Editor.GeneralFunctions.HandleSavingChecks(Editor, 0, true)
            }
            if (Editor.State === Editor.editorState.ConfirmBrushDel) {
                if (Editor.ConfirmationBox.YesPressed || JamSystem.InputManager.GetKeyPressed(404)) {
                    Editor.BrushPaletteBox.DeleteBrush(UIPalette.prototype.BrushSizeLarge);
                    Answered = true
                }
                if (Editor.ConfirmationBox.NoPressed) {
                    Answered = true
                }
                if (Editor.ConfirmationBox.CancelPressed || Answered) {
                    Editor.ConfirmationBox.Reset();
                    Editor.Confirmation.EnableAll(false);
                    Editor.ConfirmationBox.isSuperFocused = false;
                    Editor.State = Editor.editorState.Free;
                    return true
                }
            }
            if (Editor.State === Editor.editorState.ConfirmObjDel) {
                if (Editor.ConfirmationBox.YesPressed || JamSystem.InputManager.GetKeyPressed(404)) {
                    var PalIndex = Editor.ObjectPaletteBox.BrushToDelete;
                    ObjectPaletteManager.AlterComboBoxesValue(PalIndex, false);
                    Editor.ObjectPaletteBox.DeleteBrush(UIPalette.prototype.BrushSizeSmall);
                    var k = 0,
                        j = 0,
                        Entities = [];
                    for (k = 0; k < Editor.World.GetLayerAmount(); k += 1) {
                        Editor.World.GetLayer(k).GetAllEntities(Entities);
                        for (j = 0; j < Entities.length; j += 1) {
                            if (Entities[j].ObjectPaletteIndex === PalIndex) {
                                Editor.World.GetLayer(k).RemoveEntity(Entities[j])
                            }
                        }
                    }
                    Editor.World.AlterPaletteIndices(PalIndex, -1);
                    ObjectPaletteManager.ObjectPalette.splice(PalIndex, 1);
                    ObjectPaletteManager.SavePalette(SettingsFileManager.ObjectPaletteFile);
                    Answered = true
                }
                if (Editor.ConfirmationBox.NoPressed) {
                    Answered = true
                }
                if (Editor.ConfirmationBox.CancelPressed || Answered) {
                    Editor.ConfirmationBox.Reset();
                    Editor.Confirmation.EnableAll(false);
                    Editor.ConfirmationBox.isSuperFocused = false;
                    Editor.State = Editor.editorState.Free;
                    return true
                }
            }
            if (Editor.State === Editor.editorState.ConfirmClear) {
                if (Editor.ConfirmationBox.YesPressed || JamSystem.InputManager.GetKeyPressed(404)) {
                    Editor.World.ClearLayer(Editor.CurrentLayer);
                    Answered = true
                }
                if (Editor.ConfirmationBox.NoPressed) {
                    Answered = true
                }
                if (Editor.ConfirmationBox.CancelPressed || Answered) {
                    Editor.ConfirmationBox.Reset();
                    Editor.Confirmation.EnableAll(false);
                    Editor.ConfirmationBox.isSuperFocused = false;
                    Editor.State = Editor.editorState.Free;
                    return true
                }
            }
            if (Editor.State === Editor.editorState.ConfirmDelLayer) {
                if (Editor.ConfirmationBox.YesPressed || JamSystem.InputManager.GetKeyPressed(404)) {
                    Editor.LayerFunctions.ModifyLayer(Editor, 0, false);
                    Editor.LayerInfoText.SetText("FARTHER");
                    Editor.LayerInfoText.SetIsVisible(true);
                    Editor.LayerInfoTextAlpha = 1;
                    Editor.World.RemoveLayer(Editor.LayerFunctions.LayerToDelete);
                    Editor.Game.ParticleManager.Reset();
                    Editor.LayerFunctions.RedrawLayerPaletteBox(Editor);
                    Answered = true
                }
                if (Editor.ConfirmationBox.NoPressed) {
                    Answered = true
                }
                if (Editor.ConfirmationBox.CancelPressed || Answered) {
                    Editor.ConfirmationBox.Reset();
                    Editor.Confirmation.EnableAll(false);
                    Editor.ConfirmationBox.isSuperFocused = false;
                    Editor.State = Editor.editorState.Free;
                    return true
                }
            }
            if (Editor.State === Editor.editorState.PaletteAdd) {
                var AddTo = false;
                if (Editor.AddToPaletteBox.OKPressed || !Editor.AddToPalette.IsSuperFocused() && JamSystem.InputManager.GetKeyPressed(404)) {
                    var ObjSlot = ObjectPaletteManager.ObjectPalette.length;
                    ObjectPaletteManager.ObjectPalette[ObjSlot] = new ObjectPalette;
                    ObjectPaletteManager.ObjectPalette[ObjSlot].Name = Editor.APBNameEdit.GetValue();
                    ObjectPaletteManager.CheckNameExclusive(ObjSlot);
                    ObjectPaletteManager.ObjectPalette[ObjSlot].Image = Editor.APBImageEdit.GetValue();
                    ObjectPaletteManager.ObjectPalette[ObjSlot].Type = EntityTypeManager.TypesRegistered[Editor.APBTypeEdit.GetValue()].Name;
                    ObjectPaletteManager.ObjectPalette[ObjSlot].Unknown = false;
                    var ObjectCollision = new EntityCollisionData;
                    ObjectCollision.Loaded = false;
                    var TextureInfo = Helpers.GetTextureInfoFromImageName(ObjectPaletteManager.ObjectPalette[ObjSlot].Image);
                    var Frame = TextureInfo.Texture.GetFrame(TextureInfo.Frame);
                    var HalfWidth = Frame.Width / 2;
                    var HalfHeight = Frame.Height / 2;
                    ObjectCollision.Circle = false;
                    if (HalfWidth > HalfHeight) {
                        ObjectCollision.CircleRadius = HalfWidth
                    } else {
                        ObjectCollision.CircleRadius = HalfHeight
                    }
                    ObjectCollision.Density = 1;
                    ObjectCollision.Friction = .5;
                    ObjectCollision.Restitution = .2;
                    ObjectCollision.CollisionPoints = [];
                    ObjectCollision.CollisionPoints[0] = new Vector2(-HalfWidth, -HalfHeight);
                    ObjectCollision.CollisionPoints[1] = new Vector2(HalfWidth, -HalfHeight);
                    ObjectCollision.CollisionPoints[2] = new Vector2(HalfWidth, HalfHeight);
                    ObjectCollision.CollisionPoints[3] = new Vector2(-HalfWidth, HalfHeight);
                    ObjectPaletteManager.ObjectPalette[ObjSlot].Collision = ObjectCollision;
                    ObjectPaletteManager.ObjectPalette[ObjSlot].ObjectType = EntityTypeManager.GetClassFromName(ObjectPaletteManager.ObjectPalette[ObjSlot].Type);
                    Editor.ObjectPaletteBox.AddBrushByIndex(ObjSlot);
                    if (Editor.GeneralFunctions.AddObjectCategory !== -1 && Editor.GeneralFunctions.AddObjectCatPos !== -1) {
                        var CatName = Editor.ObjectPaletteBox.Categories[Editor.GeneralFunctions.AddObjectCategory].Name;
                        Editor.ObjectPaletteBox.AlterObjectCategory(CatName, ObjectPaletteManager.ObjectPalette.length - 1);
                        Editor.ObjectPaletteBox.MoveObjectInCategory(Editor.GeneralFunctions.AddObjectCategory, Editor.GeneralFunctions.AddObjectCatPos, ObjectPaletteManager.ObjectPalette.length - 1);
                        Editor.GeneralFunctions.AddObjectCategory = -1;
                        Editor.GeneralFunctions.AddObjectCatPos = -1
                    }
                    ObjectPaletteManager.SavePalette(SettingsFileManager.ObjectPaletteFile);
                    Editor.ObjectPaletteBox.CalculatePlacement();
                    ObjectPaletteManager.AlterComboBoxesValue(ObjSlot, true);
                    AddTo = true
                }
                if (Editor.AddToPaletteBox.CancelPressed || AddTo) {
                    Editor.AddToPalette.EnableAll(false);
                    Editor.AddToPaletteBox.isSuperFocused = false;
                    Editor.State = Editor.editorState.Free;
                    Editor.AddToPaletteBox.ResetBox()
                }
            }
            if (Editor.State === Editor.editorState.ObjectProperties) {
                var CloseBox = false,
                    SaveFile = false;
                if (Editor.ObjectPropertiesBox.OKPressed || !Editor.ObjectProperties.IsSuperFocused() && JamSystem.InputManager.GetKeyPressed(404)) {
                    if (Editor.ObjPropNameEdit.AnyChanges()) {
                        ObjectPaletteManager.ObjectPalette[Editor.GeneralFunctions.PalIndex].Alias = Editor.ObjPropNameEdit.GetValue();
                        SaveFile = true
                    }
                    if (Editor.ObjPropImageEdit.AnyChanges()) {
                        ObjectPaletteManager.ObjectPalette[Editor.GeneralFunctions.PalIndex].Image = Editor.ObjPropImageEdit.GetValue();
                        SaveFile = true;
                        Editor.ObjectPaletteBox.UpdateBrushInfo(Editor.GeneralFunctions.PalIndex)
                    }
                    if (Editor.ObjPropImage2Edit.AnyChanges()) {
                        var Value = Editor.ObjPropImage2Edit.GetValue();
                        if (Value === "undefined" || Value === " " || Value === "" || Value === "null") {
                            ObjectPaletteManager.ObjectPalette[Editor.GeneralFunctions.PalIndex].Image2 = undefined;
                            SaveFile = true
                        } else {
                            ObjectPaletteManager.ObjectPalette[Editor.GeneralFunctions.PalIndex].Image2 = Value;
                            SaveFile = true;
                            Editor.ObjectPaletteBox.UpdateBrushInfo(Editor.GeneralFunctions.PalIndex)
                        }
                    }
                    if (Editor.GeneralFunctions.ObjPropTypeCombo.AnyChanges()) {
                        ObjectPaletteManager.ObjectPalette[Editor.GeneralFunctions.PalIndex].Type = EntityTypeManager.TypesRegistered[Editor.GeneralFunctions.ObjPropTypeCombo.GetValue()].Name;
                        ObjectPaletteManager.ObjectPalette[Editor.GeneralFunctions.PalIndex].ObjectType = EntityTypeManager.GetClassFromName(ObjectPaletteManager.ObjectPalette[Editor.GeneralFunctions.PalIndex].Type);
                        SaveFile = true
                    }
                    if (Editor.ObjPropCategoryEdit.AnyChanges()) {
                        Editor.ObjectPaletteBox.AlterObjectCategory(Editor.ObjPropCategoryEdit.GetValue(), Editor.GeneralFunctions.PalIndex);
                        SaveFile = true
                    }
                    if (Editor.GeneralFunctions.ObjPropCategoryCombo.AnyChanges()) {
                        var CategoryName = Editor.ObjectPaletteBox.Categories[Editor.GeneralFunctions.ObjPropCategoryCombo.GetValue()].Name;
                        Editor.ObjectPaletteBox.AlterObjectCategory(CategoryName, Editor.GeneralFunctions.PalIndex);
                        SaveFile = true
                    }
                    if (SaveFile) {
                        ObjectPaletteManager.SavePalette(SettingsFileManager.ObjectPaletteFile)
                    }
                    CloseBox = true
                }
                if (Editor.ObjectPropertiesBox.CancelPressed || CloseBox) {
                    Editor.ObjectProperties.RemoveItem(Editor.GeneralFunctions.ObjPropCategoryCombo, Editor.ObjectPropertiesBox);
                    Editor.GeneralFunctions.ObjPropCategoryCombo = 0;
                    Editor.ObjectProperties.RemoveItem(Editor.GeneralFunctions.ObjPropTypeCombo, Editor.ObjectPropertiesBox);
                    Editor.GeneralFunctions.ObjPropTypeCombo = 0;
                    Editor.ObjectProperties.EnableAll(false);
                    Editor.ObjectPropertiesBox.isSuperFocused = false;
                    Editor.State = Editor.editorState.Free;
                    Editor.ObjectPropertiesBox.ResetBox()
                }
            }
            if (Editor.State === Editor.editorState.CategoryProperties) {
                var CloseCategory = false;
                if (Editor.CategoryPropertiesBox.OKPressed || !Editor.CategoryProperties.IsSuperFocused() && JamSystem.InputManager.GetKeyPressed(404)) {
                    if (Editor.CatPropNameEdit.AnyChanges()) {
                        ObjectPaletteManager.ObjectCategory[Editor.GeneralFunctions.CategoryIndex].Name = Editor.CatPropNameEdit.GetValue();
                        Editor.ObjectPaletteBox.Categories[Editor.GeneralFunctions.CategoryIndex].Name = Editor.CatPropNameEdit.GetValue();
                        Editor.ObjectPaletteBox.Categories[Editor.GeneralFunctions.CategoryIndex].UI.Item.SetText(Editor.CatPropNameEdit.GetValue());
                        Editor.ObjectPaletteBox.Categories[Editor.GeneralFunctions.CategoryIndex].UI.RescaleTextBox();
                        Editor.ObjectPaletteBox.CalculatePlacement();
                        ObjectPaletteManager.SavePalette(SettingsFileManager.ObjectPaletteFile)
                    }
                    CloseCategory = true
                }
                if (Editor.CategoryPropertiesBox.CancelPressed || CloseCategory) {
                    Editor.CategoryProperties.EnableAll(false);
                    Editor.CategoryPropertiesBox.isSuperFocused = false;
                    Editor.State = Editor.editorState.Free;
                    Editor.CategoryPropertiesBox.ResetBox()
                }
            }
            if (Editor.State === Editor.editorState.ConfirmMissingObjectSave || Editor.State === Editor.editorState.ConfirmMissingObjectSaveAs) {
                if (Editor.ConfirmationBox.YesPressed || JamSystem.InputManager.GetKeyPressed(404)) {
                    if (Editor.State === Editor.editorState.ConfirmMissingObjectSave) {
                        Editor.GeneralFunctions.SaveGame(Editor);
                        Answered = true
                    }
                    if (Editor.State === Editor.editorState.ConfirmMissingObjectSaveAs) {
                        Editor.ConfirmationBox.Reset();
                        Editor.Confirmation.EnableAll(false);
                        Editor.ConfirmationBox.isSuperFocused = false;
                        Editor.LoadSaveBox.ChangeType(UIFileBox.SavingType, Editor.LoadFile);
                        Editor.LoadSave.EnableAll(true);
                        Editor.LoadSaveBox.isSuperFocused = true;
                        Editor.State = Editor.editorState.ConfirmFile
                    }
                }
                if (Editor.ConfirmationBox.NoPressed) {
                    Answered = true
                }
                if (Editor.ConfirmationBox.CancelPressed || Answered) {
                    Editor.ConfirmationBox.Reset();
                    Editor.Confirmation.EnableAll(false);
                    Editor.ConfirmationBox.isSuperFocused = false;
                    Editor.State = Editor.editorState.Free;
                    return true
                }
            }
            return false
        },
        UpdateInfoTextBoxes: function UpdateTextBoxesFn(Editor, X, Y, TimeDelta) {
            if (Editor.State === Editor.editorState.Selection || Editor.State === Editor.editorState.Scaling || Editor.State === Editor.editorState.Rotation || Editor.State === Editor.editorState.FreeformScale) {
                if (Editor.SelectionEntities[0]) {
                    Editor.PositionTextBox.Item.SetText("[Entity] X:" + Editor.SelectionEntities[0].StartX.toFixed(2) + " Y:" + Editor.SelectionEntities[0].StartY.toFixed(2) + "  Sx:" + Editor.SelectionEntities[0].StartScaleX.toFixed(2) + " Sy:" + Editor.SelectionEntities[0].StartScaleY.toFixed(2) + "  Px:" + (Editor.SelectionEntities[0].StartScaleX * Editor.SelectionEntities[0].GetWidth()).toFixed(2) + " Py:" + (Editor.SelectionEntities[0].StartScaleY * Editor.SelectionEntities[0].GetHeight()).toFixed(2) + "  R:" + Maths.RadToDeg(Editor.SelectionEntities[0].StartRotation).toFixed(2))
                }
            } else {
                var LocalCoords = Editor.World.GetLayer(Editor.CurrentLayer).TransformScreenToLocal(X, Y);
                Editor.PositionTextBox.Item.SetText("X:" + LocalCoords.x.toFixed(2) + "  Y:" + LocalCoords.y.toFixed(2) + " [Undo " + Editor.UndoActions.UndoActions.length + "][ Redo " + Editor.UndoActions.RedoActions.length + "]")
            }
            Editor.PickingTextBox.Item.SetText(Editor.Picking ? "PICKING" : "PLACING");
            if (Editor.State === Editor.editorState.Rotation) {
                Editor.PickingTextBox.Item.SetText("ROTATING")
            }
            if (Editor.State === Editor.editorState.Scaling) {
                Editor.PickingTextBox.Item.SetText("SCALING")
            }
            if (Editor.State === Editor.editorState.FreeformScale) {
                Editor.PickingTextBox.Item.SetText("FREEFORM SCALE")
            }
            if (Editor.ObjectPaletteBox.BrushesNonSelectable()) {
                Editor.PickingTextBox.Item.SetText("LIMITED SELECTION");
                Editor.PickingTextBox.BackingItem.SetColour([0, 1, 0, 1])
            } else if (Editor.SelectedFunctions.AllowMultiLayerSelection) {
                Editor.PickingTextBox.Item.SetText("MULTI-LAYER (DRAG BOX) SELECTION");
                Editor.PickingTextBox.BackingItem.SetColour([0, 1, 1, 1])
            } else if (Editor.SelectedFunctions.AllowSingleMultiLayerSelection) {
                Editor.PickingTextBox.Item.SetText("MULTI-LAYER (SINGLE) SELECTION");
                Editor.PickingTextBox.BackingItem.SetColour([0, 1, 1, 1])
            } else {
                Editor.PickingTextBox.BackingItem.SetColour([.411, .411, .411, 1])
            }
            Editor.LayerTextBox.Item.SetText(Editor.CurrentLayer + 1 + ": " + Editor.World.GetLayer(Editor.CurrentLayer).Name);
            var i = 0,
                XPos = 0,
                YPos = 0,
                j = 0;
            if (!Editor.ShowCurrentLayerOnly) {
                for (i = 0; i < Editor.World.GetLayerAmount(); i += 1) {
                    if (Editor.CheckBox[i] === undefined) {
                        continue
                    }
                    if (Editor.CheckBox[i].Enabled) {
                        Editor.World.ShowLayer(i, true);
                        if (i === Editor.CurrentLayer) {
                            if (this.RedCrossLine[0]) {
                                Helpers.DestroyLine(this.RedCrossLine[0]);
                                Helpers.DestroyLine(this.RedCrossLine[1]);
                                this.RedCrossLine = []
                            }
                        }
                    } else {
                        Editor.World.ShowLayer(i, false);
                        if (i === Editor.CurrentLayer) {
                            Editor.PickingTextBox.Item.SetText("WARNING - CURRENT LAYER IS HIDDEN");
                            Editor.PickingTextBox.BackingItem.SetColour([0, 0, 1, 1]);
                            if (!this.RedCrossLine[0]) {
                                this.RedCrossLine[0] = Helpers.CreateLine(0, 0, JamSystem.RenderManager.GetScreenWidth(), JamSystem.RenderManager.GetScreenHeight(), [1, 0, 0, 1], Editor.RenderTree);
                                this.RedCrossLine[1] = Helpers.CreateLine(0, JamSystem.RenderManager.GetScreenHeight(), JamSystem.RenderManager.GetScreenWidth(), 0, [1, 0, 0, 1], Editor.RenderTree)
                            }
                        }
                    }
                }
            } else {
                Editor.PickingTextBox.Item.SetText("ONLY SHOWING CURRENT LAYER");
                Editor.PickingTextBox.BackingItem.SetColour([0, 1, 1, 1]);
                for (i = 0; i < Editor.World.GetLayerAmount(); i += 1) {
                    if (Editor.CurrentLayer !== i) {
                        Editor.World.ShowLayer(i, false)
                    } else {
                        Editor.World.ShowLayer(i, true)
                    }
                }
            }
            while (Editor.LayerChecks.Objects.length < Editor.World.GetLayerAmount()) {
                i = Editor.LayerChecks.Objects.length;
                XPos = JamSystem.RenderManager.GetScreenWidth() / 2 - 120 - 20 * (Editor.World.GetLayerAmount() - 1 - i);
                YPos = JamSystem.RenderManager.GetScreenHeight() - 20;
                Editor.CheckBox[i] = Editor.LayerChecks.AddCheckBox(XPos, YPos);
                for (j = 0; j < Editor.World.GetLayerAmount(); j += 1) {
                    XPos = JamSystem.RenderManager.GetScreenWidth() / 2 - 120 - 20 * (Editor.World.GetLayerAmount() - 1 - j);
                    YPos = JamSystem.RenderManager.GetScreenHeight() - 20;
                    if (Editor.CheckBox[j]) {
                        Editor.CheckBox[j].Item.SetPosition(XPos, YPos)
                    }
                }
            }
            while (Editor.LayerChecks.Objects.length > Editor.World.GetLayerAmount()) {
                Editor.LayerChecks.RemoveItem(Editor.LayerChecks.Objects[Editor.LayerChecks.Objects.length - 1]);
                Editor.CheckBox[Editor.CheckBox.length - 1] = undefined;
                for (j = 0; j < Editor.World.GetLayerAmount(); j += 1) {
                    XPos = JamSystem.RenderManager.GetScreenWidth() / 2 - 120 - 20 * (Editor.World.GetLayerAmount() - 1 - j);
                    YPos = JamSystem.RenderManager.GetScreenHeight() - 20;
                    Editor.CheckBox[j].Item.SetPosition(XPos, YPos)
                }
            }
            if (Editor.ErrorTimer > 0) {
                Editor.ErrorTimer -= TimeDelta;
                if (Editor.ErrorTimer <= 0) {
                    Editor.ErrorTimer = 0;
                    Editor.ErrorText.Item.SetPosition(-200, -200)
                }
            }
        },
        Init: function InitFn() {
            this.RedCrossLine = []
        }
    };
    EditorUpdateFunctions.Create = function EditorGeneralCreateFn() {
        var NewObject = new EditorUpdateFunctions;
        NewObject.RedCrossLine = [];
        return NewObject
    };

    function EditorGroupFunctions() {}
    EditorGroupFunctions.prototype = {
        GroupEntities: function GroupEntsFn(Editor) {
            var i = 0;
            for (i = 0; i < Editor.SelectionEntities.length; i += 1) {
                Editor.SelectionEntities[i].SetEditorColour([1, 0, 0, 1]);
                var Line = Helpers.CreateLine(0, 0, 0, 0, [1, 1, 1, 1], JamSystem.RenderManager.GetRoot());
                this.GroupLines[i] = Line
            }
            Editor.State = Editor.editorState.FindParent
        },
        UpdateLines: function UpdateLinesFn(Editor, X, Y) {
            var i = 0;
            for (i = 0; i < Editor.SelectionEntities.length; i += 1) {
                var ScreenCoords = Editor.World.GetLayer(Editor.CurrentLayer).TransformLocalToScreen(Editor.SelectionEntities[i].StartX, Editor.SelectionEntities[i].StartY);
                this.GroupLines[i].SetStartCoord(ScreenCoords.x, ScreenCoords.y);
                this.GroupLines[i].SetEndCoord(X, Y)
            }
        },
        UngroupEntities: function UngroupEntsFn(Editor, EntityArray) {
            if (EntityArray === undefined) {
                EntityArray = Editor.SelectionEntities
            }
            var i = 0,
                j = 0;
            for (i = 0; i < EntityArray.length; i += 1) {
                var Parents = Editor.World.FindEntityParents(EntityArray[i]);
                for (j = 0; j < Parents.length; j += 1) {
                    Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.EntityGroupMod, Parents[j]);
                    Parents[j].RemoveChild(EntityArray[i])
                }
                if (EntityArray[i].Children) {
                    Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.EntityGroupMod, EntityArray[i]);
                    while (EntityArray[i].Children.length > 0) {
                        EntityArray[i].RemoveChild(EntityArray[i].Children[0])
                    }
                }
            }
            this.CancelGrouping(Editor)
        },
        AttachToParent: function GroupEntsToParentFn(Editor, X, Y) {
            var NewEntity = Editor.SelectedFunctions.GetEntityAt(Editor, X, Y);
            var i = 0;
            if (NewEntity) {
                if (this.CheckRecursiveDoubleGroupings(Editor, NewEntity)) {
                    Editor.ErrorText.Item.SetText("ERROR: RECURSIVE GROUPING!");
                    Editor.ErrorText.Item.SetPositionY(80);
                    Editor.ErrorTimer = 2;
                    return
                }
                var Info = ObjectPaletteManager.ObjectPalette[NewEntity.ObjectPaletteIndex];
                var EntityType = EntityTypeManager.GetClassFromName(Info.Type);
                var EntityTypeID = EntityTypeManager.TypesRegistered.indexOf(EntityType);
                var TypeName = EntityTypeManager.GetNameFromID(EntityTypeID);
                if (TypeName === "PersonGroup") {
                    var EveryoneIsPerson = true;
                    for (i = 0; i < Editor.SelectionEntities.length; i += 1) {
                        Info = ObjectPaletteManager.ObjectPalette[Editor.SelectionEntities[i].ObjectPaletteIndex];
                        EntityType = EntityTypeManager.GetClassFromName(Info.Type);
                        EntityTypeID = EntityTypeManager.TypesRegistered.indexOf(EntityType);
                        TypeName = EntityTypeManager.GetNameFromID(EntityTypeID);
                        if (TypeName !== "Person") {
                            EveryoneIsPerson = false;
                            break
                        }
                    }
                    if (!EveryoneIsPerson) {
                        this.CancelGrouping(Editor);
                        return
                    }
                }
                Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.EntityGroupMod, NewEntity);
                for (i = 0; i < Editor.SelectionEntities.length; i += 1) {
                    NewEntity.AddChild(Editor.SelectionEntities[i]);
                    Editor.World.NameEntityUniquely(Editor.SelectionEntities[i])
                }
            }
            this.CancelGrouping(Editor)
        },
        CancelGrouping: function CancelGroupEntsFn(Editor) {
            Editor.SelectedFunctions.CleanSelection(Editor);
            Editor.SelectionEntities = [];
            var i = 0;
            while (this.GroupLines.length > 0) {
                Helpers.DestroyLine(this.GroupLines[0]);
                this.GroupLines.splice(0, 1)
            }
            Editor.State = Editor.editorState.Free
        },
        AddChildrenEntities: function AddChildDetailFn(Editor, NewEntities, CopyEntities) {
            var i = 0,
                j = 0;
            for (i = 0; i < CopyEntities.length; i += 1) {
                if (CopyEntities[i].Children) {
                    for (j = 0; j < CopyEntities.length; j += 1) {
                        var Index = CopyEntities[i].Children.indexOf(CopyEntities[j]);
                        if (Index !== -1) {
                            NewEntities[i].AddChild(NewEntities[j])
                        }
                    }
                }
            }
        },
        FindMissingGroupLinks: function MissingGroupLinkFn(Editor, Entities) {
            var i = 0,
                j = 0,
                Index = 0;
            var MissingEntities = [];
            for (i = 0; i < Entities.length; i += 1) {
                this.FindMissingChildren(Editor, Entities[i], Entities, MissingEntities);
                this.FindMissingParents(Editor, Entities[i], Entities, MissingEntities)
            }
            return MissingEntities
        },
        FindMissingChildren: function MissingChildLinkFn(Editor, Entity, Entities, AdditionalEntities) {
            if (Entity.Children) {
                var i = 0,
                    Index = 0,
                    Index2 = 0;
                for (i = 0; i < Entity.Children.length; i += 1) {
                    Index = Entities.indexOf(Entity.Children[i]);
                    Index2 = AdditionalEntities.indexOf(Entity.Children[i]);
                    if (Index === -1 && Index2 === -1) {
                        AdditionalEntities[AdditionalEntities.length] = Entity.Children[i];
                        this.FindMissingChildren(Editor, Entity.Children[i], Entities, AdditionalEntities);
                        this.FindMissingParents(Editor, Entity.Children[i], Entities, AdditionalEntities)
                    }
                }
            }
        },
        FindMissingParents: function MissingParentLinkFn(Editor, Entity, Entities, AdditionalEntities) {
            var Parents = Editor.World.FindEntityParents(Entity);
            if (Parents.length > 0) {
                var j = 0,
                    Index = 0,
                    Index2 = 0;
                for (j = 0; j < Parents.length; j += 1) {
                    Index = Entities.indexOf(Parents[j]);
                    Index2 = AdditionalEntities.indexOf(Parents[j]);
                    if (Index === -1 && Index2 === -1) {
                        AdditionalEntities[AdditionalEntities.length] = Parents[j];
                        this.FindMissingChildren(Editor, Parents[j], Entities, AdditionalEntities);
                        this.FindMissingParents(Editor, Parents[j], Entities, AdditionalEntities)
                    }
                }
            }
        },
        CheckRecursiveDoubleGroupings: function CheckRecursiveDoubleGroupingsFn(Editor, NewParent) {
            var i = 0,
                j = 0,
                Index = 0;
            if (NewParent.Children) {
                for (j = 0; j < Editor.SelectionEntities.length; j += 1) {
                    Index = NewParent.Children.indexOf(Editor.SelectionEntities[j]);
                    if (Index !== -1) {
                        return true
                    }
                }
            }
            for (j = 0; j < Editor.SelectionEntities.length; j += 1) {
                if (Editor.SelectionEntities[j].Children) {
                    Index = Editor.SelectionEntities[j].Children.indexOf(NewParent);
                    if (Index !== -1) {
                        return true
                    }
                }
            }
            var Parents = Editor.World.FindEntityParents(NewParent);
            if (Parents) {
                for (i = 0; i < Parents.length; i += 1) {
                    if (this.CheckRecursiveDoubleGroupings(Editor, Parents[i])) {
                        return true
                    }
                }
            }
            return false
        },
        Init: function InitFn() {
            this.GroupLines = []
        }
    };
    EditorGroupFunctions.Create = function EditorGeneralCreateFn() {
        var NewObject = new EditorGroupFunctions;
        NewObject.GroupLines = [];
        return NewObject
    };

    function EditorBrushFunctions() {}
    EditorBrushFunctions.prototype = {
        UpdateEditorPlacing: function UpdateEditorPlaceFn(Editor, TimeDelta, X, Y) {
            var i = 0,
                j = 0,
                k = 0,
                SectionX = 0,
                SectionY = 0;
            if (!Editor.Picking) {
                var Key = JamSystem.InputManager.GetKeyValue();
                if (Key !== undefined) {
                    if (Key.charCodeAt(0) === 70 || Key.charCodeAt(0) === 102) {
                        Editor.ActionFunctions.FlipEntities(Editor, Editor.BrushEntities)
                    }
                    if (Key.charCodeAt(0) === 77 || Key.charCodeAt(0) === 109) {
                        Editor.ActionFunctions.MirrorEntities(Editor, Editor.BrushEntities)
                    }
                    if ((Key.charCodeAt(0) === 90 || Key.charCodeAt(0) === 122) && (!JamSystem.InputManager.GetKeyHeld(302) && !JamSystem.InputManager.GetKeyHeld(303))) {
                        Editor.ActionFunctions.RotateEntities90(Editor, Editor.BrushEntities)
                    }
                    if ((JamSystem.InputManager.GetKeyHeld(300) || JamSystem.InputManager.GetKeyHeld(301)) && (Key.charCodeAt(0) === 82 || Key.charCodeAt(0) === 114)) {
                        Editor.ActionFunctions.ResetBrushRotation(Editor, Editor.BrushEntities)
                    }
                    if ((JamSystem.InputManager.GetKeyHeld(300) || JamSystem.InputManager.GetKeyHeld(301)) && (!JamSystem.InputManager.GetKeyHeld(302) && !JamSystem.InputManager.GetKeyHeld(303)) && (Key.charCodeAt(0) === 83 || Key.charCodeAt(0) === 115)) {
                        Editor.ActionFunctions.ResetBrushScale(Editor, Editor.BrushEntities)
                    }
                    if ((JamSystem.InputManager.GetKeyHeld(300) || JamSystem.InputManager.GetKeyHeld(301)) && (!JamSystem.InputManager.GetKeyHeld(302) && !JamSystem.InputManager.GetKeyHeld(303)) && (Key.charCodeAt(0) === 88 || Key.charCodeAt(0) === 120)) {
                        Editor.ActionFunctions.ResetBrushXScale(Editor, Editor.BrushEntities)
                    }
                    if ((JamSystem.InputManager.GetKeyHeld(300) || JamSystem.InputManager.GetKeyHeld(301)) && (!JamSystem.InputManager.GetKeyHeld(302) && !JamSystem.InputManager.GetKeyHeld(303)) && (Key.charCodeAt(0) === 89 || Key.charCodeAt(0) === 121)) {
                        Editor.ActionFunctions.ResetBrushYScale(Editor, Editor.BrushEntities)
                    }
                }
                if (Editor.ActionFunctions.CheckSelectedForRotation(Editor, Editor.BrushEntities, X, Y)) {
                    return
                }
                if (Editor.ScaleFunctions.FreeformScale(Editor, X, Y, Editor.BrushEntities)) {
                    return
                }
                var Layer = Editor.World.GetLayer(Editor.CurrentLayer);
                if (Layer.ShowGridLines) {
                    SectionX = Layer.Width / Layer.GridSpace;
                    SectionY = Layer.Height / Layer.GridSpace
                }
                for (i = 0; i < Editor.BrushEntities.length; i += 1) {
                    var Coords = Editor.World.GetLayer(Editor.CurrentLayer).TransformScreenToLocal(X, Y);
                    if (Layer.ShowGridLines) {
                        var PosX = Math.floor(Coords.x / Layer.Width * SectionX) * Layer.GridSpace + .5 * Layer.GridSpace;
                        var PosY = Math.floor(Coords.y / Layer.Height * SectionY) * Layer.GridSpace + .5 * Layer.GridSpace;
                        Coords.x = PosX + this.GridOffset.x;
                        Coords.y = PosY + this.GridOffset.y
                    }
                    Editor.BrushEntities[i].StartX = Coords.x - Editor.BrushOffsetX[i];
                    Editor.BrushEntities[i].StartY = Coords.y - Editor.BrushOffsetY[i];
                    Editor.BrushEntities[i].Reset();
                    Editor.World.GetLayer(Editor.CurrentLayer).UpdateEntity(Editor.BrushEntities[i]);
                    Editor.BrushEntities[i].ShowEditMode(true)
                }
                if (!Editor.World.IsLayerActive(Editor.CurrentLayer)) {
                    return
                }
                if (JamSystem.InputManager.GetMouseButtonReleased(0)) {
                    if (Editor.GeneralFunctions.IsMouseOverPalette(Editor, X, Y)) {
                        return
                    }
                    var Entities = [];
                    for (i = 0; i < Editor.BrushEntities.length; i += 1) {
                        var DesiredColour = Editor.BrushEntities[i].GetColour();
                        var ValueColourR = DesiredColour[0];
                        var ValueColourG = DesiredColour[1];
                        var ValueColourB = DesiredColour[2];
                        var ValueColourA = 1;
                        Editor.BrushEntities[i].SetColour([ValueColourR, ValueColourG, ValueColourB, ValueColourA])
                    }
                    Editor.GeneralFunctions.CopyEntityGroup(Editor, Entities, Editor.BrushEntities, true, true);
                    for (i = 0; i < Editor.BrushEntities.length; i += 1) {
                        var CurrLayer = Editor.CurrentLayer;
                        if (Editor.SelectedFunctions.AllowMultiLayerSelection) {
                            CurrLayer = Editor.BrushEntities[i].DesiredLayer
                        }
                        Editor.World.GetLayer(CurrLayer).AddEntity(Entities[i]);
                        Entities[i].ShowEditMode(true)
                    }
                    for (i = 0; i < Entities.length; i += 1) {
                        var DesiredColour = Entities[i].GetColour();
                        var ValueColourR = DesiredColour[0];
                        var ValueColourG = DesiredColour[1];
                        var ValueColourB = DesiredColour[2];
                        var ValueColourA = .5;
                        Editor.BrushEntities[i].SetColour([ValueColourR, ValueColourG, ValueColourB, ValueColourA])
                    }
                    Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.EntityPlaceMod, Entities)
                }
            }
        },
        RemoveBrushFromLayer: function RemoveBrushLayerFn(Editor) {
            Editor.ObjectPaletteBox.ResetBrush();
            Editor.BrushPaletteBox.ResetBrush();
            var i = 0;
            for (i = 0; i < Editor.BrushEntities.length; i += 1) {
                if (Editor.BrushEntities[i]) {
                    Editor.World.GetLayer(Editor.CurrentLayer).RemoveEntity(Editor.BrushEntities[i]);
                    Editor.BrushEntities[i].Delete()
                }
            }
        },
        AddBrushToLayer: function AddBrushLayerFn(Editor) {
            var i = 0;
            for (i = 0; i < Editor.BrushEntities.length; i += 1) {
                Editor.World.GetLayer(Editor.CurrentLayer).AddEntity(Editor.BrushEntities[i]);
                Editor.BrushEntities[i].Sprite.SetColour([1, 1, 1, .5])
            }
            if (Editor.BrushEntities.length === 1) {
                Editor.BrushOffsetX[0] = 0;
                Editor.BrushOffsetY[0] = 0
            }
        },
        SaveBrush: function SaveBrushFn(Editor) {
            var Entities = [];
            Editor.GeneralFunctions.CopyEntityGroup(Editor, Entities, Editor.BrushEntities, true, true);
            if (Entities) {
                Editor.BrushPaletteBox.AddBrushByEntity(Entities, true)
            }
        },
        CopyBrush: function CopyBrushFn(Editor, X, Y, CutMode, CopyGroupings) {
            this.RemoveBrushFromLayer(Editor);
            Editor.BrushEntities = [];
            Editor.GeneralFunctions.CopyEntityGroup(Editor, Editor.BrushEntities, Editor.SelectionEntities, CopyGroupings, false);
            this.LastCopyGroup = CopyGroupings;
            Editor.ActionFunctions.CalculateCentreSelected(Editor, Editor.SelectionEntities);
            var Centre = Editor.ActionFunctions.CentreSelected;
            var i = 0;
            for (i = 0; i < Editor.SelectionEntities.length; i += 1) {
                Editor.BrushOffsetX[i] = Centre.x - Editor.SelectionEntities[i].StartX;
                Editor.BrushOffsetY[i] = Centre.y - Editor.SelectionEntities[i].StartY
            }
            var Layer = Editor.World.GetLayer(Editor.CurrentLayer);
            if (Layer.ShowGridLines) {
                var SectionX = Layer.Width / Layer.GridSpace;
                var SectionY = Layer.Height / Layer.GridSpace;
                var GridSquareCentreX = Math.floor(Editor.SelectionEntities[0].StartX / Layer.Width * SectionX) * Layer.GridSpace + .5 * Layer.GridSpace;
                var GridSquareCentreY = Math.floor(Editor.SelectionEntities[0].StartY / Layer.Height * SectionY) * Layer.GridSpace + .5 * Layer.GridSpace;
                this.GridOffset.x = Centre.x - GridSquareCentreX;
                this.GridOffset.y = Centre.y - GridSquareCentreY
            }
            if (CutMode) {
                Editor.SelectedFunctions.DeleteSelected(Editor)
            } else {
                for (i = 0; i < Editor.BrushEntities.length; i += 1) {
                    Editor.BrushEntities[i].Name = ""
                }
            }
            Editor.GeneralFunctions.TogglePickingMode(Editor, false)
        },
        CheckForPaletteBrushUse: function CheckForPaletteBrushUseFn(Editor, X, Y) {
            if (Editor.State !== Editor.editorState.SetAttributes && Editor.State !== Editor.editorState.SetDefaults) {
                this.WipeBrushEntities(Editor);
                var BrushClicked = Editor.ObjectPaletteBox.GetBrushClicked(Editor.BrushEntities, Editor);
                if (BrushClicked) {
                    Editor.BrushPaletteBox.ResetBrush()
                }
                if (!BrushClicked) {
                    BrushClicked = Editor.BrushPaletteBox.GetBrushClicked(Editor.BrushEntities, Editor);
                    Editor.ObjectPaletteBox.ResetBrush()
                }
                if (BrushClicked) {
                    if (Editor.SelectionEntities.length > 0 && (JamSystem.InputManager.GetKeyHeld(300) || JamSystem.InputManager.GetKeyHeld(301))) {
                        this.SwapSelectionWithPaletteBrush(Editor, Editor.ObjectPaletteBox.BrushIndex)
                    } else {
                        Editor.GeneralFunctions.TogglePickingMode(Editor, false)
                    }
                }
            } else {
                Editor.ObjectPaletteBox.ResetBrush();
                Editor.BrushPaletteBox.ResetBrush()
            }
        },
        WipeBrushEntities: function WipeBrushEntitiesFn(Editor) {
            if (Editor.State !== Editor.editorState.SetAttributes && Editor.State !== Editor.editorState.SetDefaults) {
                var i = 0;
                for (i = 0; i < Editor.BrushEntities.length; i += 1) {
                    if (Editor.BrushEntities[i]) {
                        Editor.World.GetLayer(Editor.CurrentLayer).RemoveEntity(Editor.BrushEntities[i]);
                        Editor.BrushEntities[i].Delete()
                    }
                }
            }
            Editor.BrushEntities = [];
            Editor.BrushOffsetX[0] = 0;
            Editor.BrushOffsetY[0] = 0;
            this.GridOffset.x = 0;
            this.GridOffset.y = 0
        },
        SwapSelectionWithPaletteBrush: function SwapSelectionWithPaletteBrushFn(Editor, BrushIndex) {
            if (Editor.SelectionEntities.length > 0) {
                this.WipeBrushEntities(Editor);
                Editor.ObjectPaletteBox.BrushIndex = BrushIndex;
                Editor.ObjectPaletteBox.BrushClicked = true;
                Editor.ObjectPaletteBox.GetBrushClicked(Editor.BrushEntities, Editor);
                Editor.BrushPaletteBox.ResetBrush();
                var k = 0,
                    AllowCollisionChanges = true,
                    ComparisonIndex = Editor.SelectionEntities[0].ObjectPaletteIndex;
                for (k = 0; k < Editor.SelectionEntities.length; k += 1) {
                    if (Editor.SelectionEntities[k].ObjectPaletteIndex !== ComparisonIndex) {
                        AllowCollisionChanges = false
                    }
                }
                var Entities = [],
                    TotalEntities = [],
                    i = 0;
                for (i = 0; i < Editor.SelectionEntities.length; i += 1) {
                    Editor.GeneralFunctions.CopyEntityGroup(Editor, Entities, Editor.BrushEntities, true, true);
                    Entities[0].StartX = Editor.SelectionEntities[i].StartX;
                    Entities[0].StartY = Editor.SelectionEntities[i].StartY;
                    if (Editor.SelectionEntities[i].Box2DBody && Entities[0].Box2DBody) {
                        var OriginalMass = Physics.GetBodyMass(Editor.SelectionEntities[i].Box2DBody);
                        Physics.SetBodyMass(Entities[0].Box2DBody, OriginalMass)
                    }
                    var TrueWidth = Editor.SelectionEntities[i].StartScaleX * Editor.SelectionEntities[i].GetWidth();
                    var TrueHeight = Editor.SelectionEntities[i].StartScaleY * Editor.SelectionEntities[i].GetHeight();
                    Entities[0].StartScaleX = TrueWidth / Entities[0].GetWidth();
                    Entities[0].StartScaleY = TrueHeight / Entities[0].GetHeight();
                    Entities[0].StartRotation = Editor.SelectionEntities[i].StartRotation;
                    if (Entities[0].Sprite) {
                        Entities[0].Sprite.ScaleX = Entities[0].StartScaleX;
                        Entities[0].Sprite.ScaleY = Entities[0].StartScaleY
                    } else {
                        Entities[0].SpriteList.SetScale(Entities[0].SpriteListIndex, Entities[0].StartScaleX, Entities[0].StartScaleY)
                    }
                    var ObjectPaletteIndex = Editor.SelectionEntities[i].ObjectPaletteIndex;
                    if (AllowCollisionChanges) {
                        var CollData = ObjectPaletteManager.ObjectPalette[ObjectPaletteIndex].Collision;
                        var j = 0;
                        var CollisionData = new EntityCollisionData;
                        CollisionData.Loaded = true;
                        CollisionData.Circle = CollData.Circle;
                        CollisionData.CircleRadius = CollData.CircleRadius;
                        CollisionData.Density = CollData.Density;
                        CollisionData.Friction = CollData.Friction;
                        CollisionData.Restitution = CollData.Restitution;
                        CollisionData.CollisionPoints = [];
                        var ImageName = ObjectPaletteManager.ObjectPalette[ObjectPaletteIndex].Image;
                        var FrameInfo = Helpers.GetTextureInfoFromImageName(ImageName);
                        var OldWidth = FrameInfo.Texture.GetFrame(FrameInfo.Frame).Width;
                        var OldHeight = FrameInfo.Texture.GetFrame(FrameInfo.Frame).Height;
                        var ImageName = ObjectPaletteManager.ObjectPalette[BrushIndex].Image;
                        var FrameInfo = Helpers.GetTextureInfoFromImageName(ImageName);
                        var NewWidth = FrameInfo.Texture.GetFrame(FrameInfo.Frame).Width;
                        var NewHeight = FrameInfo.Texture.GetFrame(FrameInfo.Frame).Height;
                        var WidthRatio = NewWidth / OldWidth;
                        var HeightRatio = NewHeight / OldHeight;
                        for (j = 0; j < CollData.CollisionPoints.length; j += 1) {
                            var PointX = CollData.CollisionPoints[j].x * WidthRatio;
                            var PointY = CollData.CollisionPoints[j].y * HeightRatio;
                            CollisionData.CollisionPoints[j] = new Vector2;
                            CollisionData.CollisionPoints[j].x = PointX;
                            CollisionData.CollisionPoints[j].y = PointY
                        }
                        var BrushPalIndex = Entities[0].ObjectPaletteIndex;
                        ObjectPaletteManager.ObjectPalette[BrushPalIndex].Collision = CollisionData
                    }
                    ObjectPaletteManager.ObjectPalette[BrushPalIndex].Image2 = ObjectPaletteManager.ObjectPalette[ObjectPaletteIndex].Image2;
                    var DesiredColour = Editor.SelectionEntities[i].GetColour();
                    var ValueColourR = DesiredColour[0];
                    var ValueColourG = DesiredColour[1];
                    var ValueColourB = DesiredColour[2];
                    var ValueColourA = DesiredColour[3];
                    Entities[0].SetColour([ValueColourR, ValueColourG, ValueColourB, ValueColourA]);
                    Entities[0].Reset();
                    Entity.UpdateCollision(Entities[0]);
                    Editor.World.GetLayer(Editor.CurrentLayer).AddEntity(Entities[0]);
                    TotalEntities[i] = Entities[0]
                }
                ObjectPaletteManager.SavePalette(SettingsFileManager.ObjectPaletteFile);
                Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.EntitySwapMod, TotalEntities);
                for (i = 0; i < Editor.SelectionEntities.length; i += 1) {
                    var j = 0,
                        Parents = [];
                    if (Editor.SelectionEntities[i].Children) {
                        for (j = 0; j < Editor.SelectionEntities[i].Children.length; j += 1) {
                            TotalEntities[i].AddChild(Editor.SelectionEntities[i].Children[j])
                        }
                        for (j = 0; j < TotalEntities[i].Children.length; j += 1) {
                            Editor.SelectionEntities[i].RemoveChild(Editor.SelectionEntities[i].Children[j])
                        }
                    }
                    Parents = Editor.World.FindEntityParents(Editor.SelectionEntities[i]);
                    if (Parents) {
                        for (j = 0; j < Parents.length; j += 1) {
                            var Position = Parents[j].Children.indexOf(Editor.SelectionEntities[i]);
                            Parents[j].Children[Position] = TotalEntities[i]
                        }
                    }
                }
                Editor.SelectedFunctions.DeleteSelected(Editor, false);
                Editor.SelectedFunctions.CleanSelection(Editor);
                Editor.GeneralFunctions.TogglePickingMode(Editor, true);
                for (i = 0; i < Entities.length; i += 1) {
                    Editor.SelectionEntities[i] = Entities[i]
                }
                Editor.State = Editor.editorState.Selection
            }
        },
        Init: function InitFn() {
            this.LastCopyGroup = false;
            this.GridOffset = new Vector2(0, 0)
        }
    };
    EditorBrushFunctions.Create = function EditorGeneralCreateFn() {
        var NewObject = new EditorBrushFunctions;
        NewObject.LastCopyGroup = false;
        NewObject.GridOffset = new Vector2(0, 0);
        return NewObject
    };

    function EditorLayerFunctions() {}
    EditorLayerFunctions.prototype = {
        ModifyLayer: function ModifyLayerFn(Editor, NextLayer, KeepSelection) {
            if (Editor.LayerPaletteBox.IsOpen) {
                this.LayerSelectButtons[this.EditingLayer].SetButtonColour(UIButton.prototype.Colour);
                this.LayerSelectButtons[NextLayer].Clicked = false;
                this.EditingLayer = NextLayer;
                this.LayerSelectButtons[NextLayer].SetButtonColour(UIButton.prototype.SelectedColour);
                var LayerInfo = Editor.World.GetLayer(this.EditingLayer);
                this.LayerName.SetDefaultValue(LayerInfo.Name);
                this.LayerSpeedX.SetDefaultValue("" + LayerInfo.MovementScale.x.toFixed(2));
                this.LayerSpeedY.SetDefaultValue("" + LayerInfo.MovementScale.y.toFixed(2))
            }
            var Layer = Editor.World.GetLayer(Editor.CurrentLayer);
            if (!KeepSelection) {
                if (Editor.State !== Editor.editorState.FindParent) {
                    Editor.SelectedFunctions.CleanSelection(Editor)
                }
            }
            Editor.BrushFunctions.RemoveBrushFromLayer(Editor);
            var GridLines = Layer.ShowGridLines;
            if (GridLines) {
                Layer.ShowGridLines = false
            }
            var BucketLines = Layer.ShowBucketLines;
            if (BucketLines) {
                Layer.ToggleBucketLines()
            }
            var LimitLines = Layer.ShowLimitLines;
            if (LimitLines) {
                Layer.ShowLimitLines = false
            }
            Editor.CurrentLayer = NextLayer;
            Editor.LastUsedLayer = Editor.CurrentLayer;
            Layer = Editor.World.GetLayer(Editor.CurrentLayer);
            if (!Editor.Picking) {
                Editor.BrushFunctions.RemoveBrushFromLayer(Editor)
            }
            if (GridLines) {
                Layer.ShowGridLines = true
            }
            if (BucketLines) {
                Layer.ToggleBucketLines()
            }
            if (LimitLines) {
                Layer.ShowLimitLines = true
            }
        },
        HandleLayerPaletteOpenClose: function HandleLayerPaletteOpenCloseFn(Editor) {
            if (Editor.LayerPaletteBox.IsOpen) {
                this.RedrawLayerPaletteBox(Editor)
            }
            if (!Editor.LayerPaletteBox.IsOpen) {
                this.WipeLayerPaletteBox(Editor);
                Editor.LayerPaletteBox.Close();
                Editor.ShowCurrentLayerOnly = false
            }
        },
        WipeLayerPaletteBox: function WipeLayerPaletteBoxFn(Editor) {
            var j = 0,
                Len = this.LayerPaletteItems.length;
            for (j = 0; j < Len; j += 1) {
                Editor.EditorLayerPalette.RemoveItem(this.LayerPaletteItems[j], Editor.LayerPaletteBox)
            }
            if (Len > 0) {
                Editor.LayerPaletteBox.NextItemPosition.y -= 45;
                for (j = 0; j < Editor.World.GetLayerAmount() + 1; j += 1) {
                    var FoundSpace = false;
                    if (this.LayerPlus[j]) {
                        Editor.LayerPaletteBox.NextItemPosition.y += UIBase.prototype.BoxSpacing;
                        FoundSpace = true
                    }
                    if (this.LayerArrowsDown[j]) {
                        Editor.LayerPaletteBox.NextItemPosition.y += UIBase.prototype.BoxSpacing;
                        FoundSpace = true
                    }
                    if (this.LayerArrowsUp[j]) {
                        Editor.LayerPaletteBox.NextItemPosition.y += UIBase.prototype.BoxSpacing;
                        FoundSpace = true
                    }
                    if (this.LayerDivides[j]) {
                        Editor.LayerPaletteBox.NextItemPosition.y += UIBase.prototype.BoxSpacing;
                        FoundSpace = true
                    }
                    if (FoundSpace) {
                        Editor.LayerPaletteBox.NextItemPosition.y -= 15
                    }
                }
            }
            this.LayerPaletteItems = [];
            this.LayerSelectButtons = [];
            this.LayerPlus = [];
            this.LayerArrowsDown = [];
            this.LayerArrowsUp = [];
            this.LayerDivides = []
        },
        RedrawLayerPaletteBox: function RedrawLayerPaletteBoxFn(Editor) {
            this.WipeLayerPaletteBox(Editor);
            var t = 0,
                LayerInfo;
            this.EditingLayer = Editor.CurrentLayer;
            Editor.ShowCurrentLayerOnly = true;
            Editor.LayerPaletteBox.NextItemPosition.y += 10;
            this.LayerPaletteItems[this.LayerPaletteItems.length] = Editor.EditorLayerPalette.AddTextBox("Layers:");
            for (t = 0; t < Editor.World.GetLayerAmount(); t += 1) {
                LayerInfo = Editor.World.GetLayer(t);
                var TextSelect = Editor.EditorLayerPalette.AddButton(LayerInfo.Name);
                if (t === this.EditingLayer) {
                    TextSelect.SetButtonColour(UIButton.prototype.SelectedColour)
                }
                TextSelect.ShiftBy(50);
                this.LayerPaletteItems[this.LayerPaletteItems.length] = TextSelect;
                this.LayerSelectButtons[this.LayerSelectButtons.length] = TextSelect;
                if (t !== 0) {
                    var UpArrow = Editor.EditorLayerPalette.AddButton("Editor_Arrow_Up", true, Editor.LayerPaletteBox.NextItemPosition.x, Editor.LayerPaletteBox.NextItemPosition.y - 34);
                    this.LayerPaletteItems[this.LayerPaletteItems.length] = UpArrow;
                    this.LayerArrowsUp[this.LayerArrowsUp.length] = UpArrow
                }
                if (t !== Editor.World.GetLayerAmount() - 1) {
                    var DownArrow = Editor.EditorLayerPalette.AddButton("Editor_Arrow", true, Editor.LayerPaletteBox.NextItemPosition.x + 20, Editor.LayerPaletteBox.NextItemPosition.y - 34);
                    this.LayerPaletteItems[this.LayerPaletteItems.length] = DownArrow;
                    this.LayerArrowsDown[this.LayerArrowsDown.length] = DownArrow
                }
                var PlusPosition = TextSelect.Item.GetText().length * 11 + Editor.LayerPaletteBox.NextItemPosition.x + 60;
                var Plus = Editor.EditorLayerPalette.AddButton("Editor_Plus", true, PlusPosition + 20, Editor.LayerPaletteBox.NextItemPosition.y - 34);
                this.LayerPaletteItems[this.LayerPaletteItems.length] = Plus;
                this.LayerPlus[this.LayerPlus.length] = Plus;
                if (t !== Editor.World.GetLayerAmount() - 1) {
                    var Divide = Editor.EditorLayerPalette.AddButton("Editor_White", true, Editor.LayerPaletteBox.NextItemPosition.x, Editor.LayerPaletteBox.NextItemPosition.y);
                    this.LayerPaletteItems[this.LayerPaletteItems.length] = Divide;
                    this.LayerDivides[this.LayerDivides.length] = Divide;
                    Divide.Item.SetScale(190, 2)
                }
                Editor.LayerPaletteBox.NextItemPosition.y += 15
            }
            LayerInfo = Editor.World.GetLayer(this.EditingLayer);
            Editor.LayerPaletteBox.NextItemPosition.y += 20;
            var PropertyHead = Editor.EditorLayerPalette.AddTextBox("Properties:");
            this.LayerPaletteItems[this.LayerPaletteItems.length] = PropertyHead;
            this.LayerProperties = PropertyHead;
            var Divider = Editor.EditorLayerPalette.AddButton("Editor_White", true, Editor.LayerPaletteBox.NextItemPosition.x, Editor.LayerPaletteBox.NextItemPosition.y);
            this.LayerPaletteItems[this.LayerPaletteItems.length] = Divider;
            this.LayerDivides[this.LayerDivides.length] = Divider;
            Divider.Item.SetScale(190, 2);
            Editor.LayerPaletteBox.NextItemPosition.y += 15;
            var NameEdit = Editor.EditorLayerPalette.AddEditBox("Name", UIEditBox.prototype.editBoxType.Normal, 97);
            NameEdit.SetDefaultValue(LayerInfo.Name);
            this.LayerPaletteItems[this.LayerPaletteItems.length] = NameEdit;
            this.LayerName = NameEdit;
            var SpeedEditX = Editor.EditorLayerPalette.AddEditBox("Speed X", UIEditBox.prototype.editBoxType.Number, 97);
            SpeedEditX.SetDefaultValue("" + LayerInfo.MovementScale.x.toFixed(2));
            this.LayerPaletteItems[this.LayerPaletteItems.length] = SpeedEditX;
            this.LayerSpeedX = SpeedEditX;
            var SpeedEditY = Editor.EditorLayerPalette.AddEditBox("Speed Y", UIEditBox.prototype.editBoxType.Number, 97);
            SpeedEditY.SetDefaultValue("" + LayerInfo.MovementScale.y.toFixed(2));
            this.LayerPaletteItems[this.LayerPaletteItems.length] = SpeedEditY;
            this.LayerSpeedY = SpeedEditY;
            if (Editor.World.GetLayerAmount() > 1) {
                var MergeButton = Editor.EditorLayerPalette.AddButton("Merge with Next");
                this.LayerPaletteItems[this.LayerPaletteItems.length] = MergeButton;
                this.LayerMerge = MergeButton
            }
            var ClearButton = Editor.EditorLayerPalette.AddButton("Clear Layer");
            this.LayerPaletteItems[this.LayerPaletteItems.length] = ClearButton;
            this.LayerClear = ClearButton;
            var DeleteButton = Editor.EditorLayerPalette.AddButton("Delete Layer");
            this.LayerPaletteItems[this.LayerPaletteItems.length] = DeleteButton;
            this.LayerDelete = DeleteButton
        },
        HandlePaletteLayerChange: function HandlePaletteLayerChangeFn(Editor, X, Y) {
            if (!Editor.LayerPaletteBox.IsOpen || this.LayerName === 0) {
                return
            }
            var CurrLayer = Editor.World.GetLayer(this.EditingLayer);
            var NextLayer = Editor.World.GetLayer(this.EditingLayer + 1);
            var ForceUpdate = false;
            var j = 0;
            if (this.LayerName.CurrText !== this.LayerName.DefaultText && this.LayerName.CurrText) {
                CurrLayer.Name = this.LayerName.GetValue();
                ForceUpdate = true
            }
            if (this.LayerSpeedX.CurrText !== this.LayerSpeedX.DefaultText && this.LayerSpeedX.CurrText) {
                CurrLayer.MovementScale.x = this.LayerSpeedX.GetValue();
                ForceUpdate = true
            }
            if (this.LayerSpeedY.CurrText !== this.LayerSpeedY.DefaultText && this.LayerSpeedY.CurrText) {
                CurrLayer.MovementScale.y = this.LayerSpeedY.GetValue();
                ForceUpdate = true
            }
            if (this.LayerMerge.Clicked) {
                if (Editor.World.GetLayerAmount() - 1 !== Editor.CurrentLayer && CurrLayer.StaticLayer === NextLayer.StaticLayer) {
                    var Entities = [],
                        NextEntities = [];
                    CurrLayer.GetAllEntities(Entities);
                    NextLayer.GetAllEntities(NextEntities);
                    var EntityAmount = Entities.length;
                    var NextEntityAmount = NextEntities.length;
                    var HighestDepth = 0;
                    for (j = 0; j < EntityAmount; j += 1) {
                        if (Entities[j].Depth > HighestDepth) {
                            HighestDepth = Entities[j].Depth
                        }
                    }
                    for (j = 0; j < NextEntityAmount; j += 1) {
                        NextEntities[j].Depth += HighestDepth
                    }
                    for (j = 0; j < EntityAmount; j += 1) {
                        CurrLayer.RemoveEntity(Entities[j]);
                        NextLayer.AddEntity(Entities[j])
                    }
                    Editor.World.RemoveLayer(this.EditingLayer);
                    Editor.Game.ParticleManager.Reset();
                    ForceUpdate = true
                }
                this.LayerMerge.Clicked = false
            }
            if (this.LayerClear.Clicked) {
                Editor.ConfirmationBox.SetTitleBar("\n\n\n\n\nWARNING\n\nYOU HAVE UNSAVED CHANGES!\n\nREALLY CLEAR THE LAYER?");
                Editor.Confirmation.EnableAll(true);
                Editor.ConfirmationBox.isSuperFocused = true;
                Editor.State = Editor.editorState.ConfirmClear;
                Editor.GeneralFunctions.HandleSavingChecks(Editor, 0, true);
                this.LayerClear.Clicked = false
            }
            if (this.LayerDelete.Clicked) {
                if (Editor.World.GetLayerAmount() > 1) {
                    this.LayerToDelete = this.EditingLayer;
                    Editor.ConfirmationBox.SetTitleBar("\n\n\n\n\nWARNING\n\nYOU HAVE UNSAVED CHANGES!\n\nREALLY DELETE THIS LAYER?");
                    Editor.Confirmation.EnableAll(true);
                    Editor.ConfirmationBox.isSuperFocused = true;
                    Editor.State = Editor.editorState.ConfirmDelLayer;
                    Editor.GeneralFunctions.HandleSavingChecks(Editor, 0, true)
                }
                this.LayerDelete.Clicked = false
            }
            var Index = 0;
            for (j = 0; j < this.LayerArrowsUp.length; j += 1) {
                if (this.LayerArrowsUp[j].Clicked) {
                    Index = j + 1;
                    Editor.World.CopyLayer(Index, Index - 1);
                    Editor.World.RemoveLayer(Index + 1);
                    ForceUpdate = true;
                    this.LayerArrowsUp[j].Clicked = false
                }
            }
            for (j = 0; j < this.LayerArrowsDown.length; j += 1) {
                if (this.LayerArrowsDown[j].Clicked) {
                    Index = j;
                    Editor.World.CopyLayer(Index, Index + 2);
                    Editor.World.RemoveLayer(Index);
                    ForceUpdate = true;
                    this.LayerArrowsDown[j].Clicked = false
                }
            }
            for (j = 0; j < this.LayerPlus.length; j += 1) {
                if (this.LayerPlus[j].Clicked) {
                    var LayerZero = Editor.World.GetLayer(0);
                    Editor.World.AddLayer(LayerZero.MovementScale, LayerZero.BucketWidth, LayerZero.BucketHeight, LayerZero.StaticLayer);
                    Editor.World.CopyLayer(Editor.World.GetLayerAmount() - 1, j + 1);
                    Editor.World.RemoveLayer(Editor.World.GetLayerAmount() - 1);
                    ForceUpdate = true;
                    this.LayerPlus[j].Clicked = false;
                    Editor.World.Optimise()
                }
            }
            var i = 0;
            for (i = 0; i < this.LayerSelectButtons.length; i += 1) {
                if (this.LayerSelectButtons[i].Clicked) {
                    Editor.LayerInfoText.SetText(i > this.EditingLayer ? "CLOSER" : "FARTHER");
                    Editor.LayerInfoText.SetIsVisible(true);
                    Editor.LayerInfoTextAlpha = 1;
                    this.ModifyLayer(Editor, i, false)
                }
            }
            if (ForceUpdate) {
                this.LayerChanged = true;
                this.RedrawLayerPaletteBox(Editor)
            }
        },
        Init: function InitFn() {
            this.EditingLayer = 0;
            this.LayerPaletteItems = [];
            this.LayerSelectButtons = [];
            this.LayerProperties = 0;
            this.LayerName = 0;
            this.LayerSpeedX = 0;
            this.LayerSpeedY = 0;
            this.LayerMerge = 0;
            this.LayerClear = 0;
            this.LayerDelete = 0;
            this.LayerToDelete = 0;
            this.LayerArrowsUp = [];
            this.LayerArrowsDown = [];
            this.LayerPlus = [];
            this.LayerDivides = [];
            this.LayerChanged = false
        }
    };
    EditorLayerFunctions.Create = function EditorGeneralCreateFn() {
        var NewObject = new EditorLayerFunctions;
        NewObject.EditingLayer = 0;
        NewObject.LayerPaletteItems = [];
        NewObject.LayerSelectButtons = [];
        NewObject.LayerProperties = 0;
        NewObject.LayerName = 0;
        NewObject.LayerSpeedX = 0;
        NewObject.LayerSpeedY = 0;
        NewObject.LayerMerge = 0;
        NewObject.LayerClear = 0;
        NewObject.LayerDelete = 0;
        NewObject.LayerToDelete = 0;
        NewObject.LayerArrowsUp = [];
        NewObject.LayerArrowsDown = [];
        NewObject.LayerPlus = [];
        NewObject.LayerDivides = [];
        NewObject.LayerChanged = false;
        return NewObject
    };

    function EditorGeneralFunctions() {}
    EditorGeneralFunctions.prototype = {
        TogglePickingMode: function TogglePickedFn(Editor, ForcePicked) {
            if (ForcePicked === undefined) {
                Editor.Picking = !Editor.Picking
            } else {
                Editor.Picking = ForcePicked
            }
            if (Editor.Picking) {
                Editor.BrushFunctions.RemoveBrushFromLayer(Editor)
            } else {
                Editor.BrushFunctions.AddBrushToLayer(Editor)
            }
            Editor.SelectedFunctions.CleanSelection(Editor);
            Editor.SelectedFunctions.CleanHoverEntity(Editor)
        },
        CheckPaletteRightClick: function CheckPaletteRightClickFn(Editor, X, Y) {
            if (Editor.ObjectPaletteBox.IsMouseOver(X, Y) && Editor.State !== Editor.editorState.DrawGroupBox && Editor.State !== Editor.editorState.SetAttributes && Editor.State !== Editor.editorState.SetDefaults) {
                if (JamSystem.InputManager.GetMouseButtonReleased(1)) {
                    this.CategoryIndex = Editor.ObjectPaletteBox.CheckCategoryCollision(X, Y);
                    if (this.CategoryIndex !== -1) {
                        this.TogglePickingMode(Editor, true);
                        Editor.DropDownCategoryUI.EnableAll(true);
                        Editor.DropDownCategoryUI.BringToFront();
                        Editor.DropDownCategoryBox.SetDefaultValue(-1);
                        Editor.DropDownCategoryBox.MoveTo(X, Y);
                        Editor.DropDownCategoryBox.isSuperFocused = true;
                        Editor.ObjectPaletteBox.TextBoxUI.SetIsVisible(false);
                        return
                    }
                    this.PalIndex = Editor.ObjectPaletteBox.CheckRightClickCollision(X, Y);
                    if (this.PalIndex !== -1) {
                        this.TogglePickingMode(Editor, true);
                        Editor.DropDownObjectUI.EnableAll(true);
                        Editor.DropDownObjectUI.BringToFront();
                        Editor.DropDownObjectBox.SetDefaultValue(-1);
                        Editor.DropDownObjectBox.MoveTo(X, Y);
                        Editor.DropDownObjectBox.isSuperFocused = true;
                        Editor.ObjectPaletteBox.TextBoxUI.SetIsVisible(false);
                        return
                    }
                }
            }
            if (Editor.DropDownCategoryBox.AnyChanges()) {
                switch (Editor.DropDownCategoryBox.GetValue()) {
                    case 0:
                        Editor.CatPropNameEdit.SetDefaultValue(ObjectPaletteManager.ObjectCategory[this.CategoryIndex].Name);
                        Editor.CategoryProperties.EnableAll(true);
                        Editor.CategoryPropertiesBox.isSuperFocused = true;
                        Editor.State = Editor.editorState.CategoryProperties;
                        break;
                    case 1:
                        if (this.CategoryIndex !== 0) {
                            Editor.ObjectPaletteBox.AddCategory("New", this.CategoryIndex);
                            Editor.ObjectPaletteBox.CalculatePlacement();
                            ObjectPaletteManager.SavePalette(SettingsFileManager.ObjectPaletteFile)
                        }
                        break;
                    case 2:
                        Editor.ObjectPaletteBox.AddCategory("New", this.CategoryIndex + 1);
                        Editor.ObjectPaletteBox.CalculatePlacement();
                        ObjectPaletteManager.SavePalette(SettingsFileManager.ObjectPaletteFile);
                        break;
                    case 3:
                        Editor.ObjectPaletteBox.MoveCategory(this.CategoryIndex, this.CategoryIndex - 1);
                        break;
                    case 4:
                        if (this.CategoryIndex !== 0) {
                            Editor.ObjectPaletteBox.MoveCategory(this.CategoryIndex, this.CategoryIndex + 1)
                        }
                        break;
                    case 5:
                        Editor.ObjectPaletteBox.RemoveCategory(this.CategoryIndex);
                        break;
                    default:
                        Debug.Log("Drop down box - UNKNOWN SELECTION");
                        break
                }
            }
            if (Editor.DropDownObjectBox.AnyChanges()) {
                switch (Editor.DropDownObjectBox.GetValue()) {
                    case 0:
                        this.TogglePickingMode(Editor, true);
                        var CollData = ObjectPaletteManager.ObjectPalette[this.PalIndex].Collision;
                        Editor.CollBox.ShowBox(true, ObjectPaletteManager.ObjectPalette[this.PalIndex], CollData);
                        Editor.State = Editor.editorState.SetCollision;
                        break;
                    case 1:
                        var BrushInfo = ObjectPaletteManager.ObjectPalette[this.PalIndex];
                        this.TogglePickingMode(Editor, true);
                        Editor.DefaultsFunctions.CreateDefaultsBox(Editor, X, Y, BrushInfo);
                        break;
                    case 2:
                        var Info = ObjectPaletteManager.ObjectPalette[this.PalIndex];
                        if (Info.Alias) {
                            Editor.ObjPropNameEdit.SetDefaultValue(Info.Alias)
                        } else {
                            Editor.ObjPropNameEdit.SetDefaultValue(Info.Name)
                        }
                        Editor.ObjPropImageEdit.SetDefaultValue(Info.Image);
                        Editor.ObjPropImage2Edit.SetDefaultValue(Info.Image2);
                        var EntityType = EntityTypeManager.GetClassFromName(Info.Type);
                        Editor.ObjPropCategoryEdit.SetDefaultValue(Editor.ObjectPaletteBox.GetCategoryNameFromObjectIndex(this.PalIndex));
                        var CurrCategoryIndex = Editor.ObjectPaletteBox.GetCategoryIndexFromObjectIndex(this.PalIndex);
                        var i = 0,
                            Categories = [];
                        for (i = 0; i < Editor.ObjectPaletteBox.Categories.length; i += 1) {
                            Categories[i] = Editor.ObjectPaletteBox.Categories[i].Name
                        }
                        this.ObjPropCategoryCombo = Editor.ObjectProperties.AddComboBox(Categories, "Category");
                        this.ObjPropCategoryCombo.SetDefaultValue(CurrCategoryIndex);
                        this.ObjPropCategoryCombo.SetInfoBoxText("Lookup a Category");
                        this.ObjPropTypeCombo = Editor.ObjectProperties.AddComboBox(Editor.TypeArray, "Types");
                        this.ObjPropTypeCombo.SetDefaultValue(EntityTypeManager.TypesRegistered.indexOf(EntityType));
                        this.ObjPropTypeCombo.SetInfoBoxText("Lookup for Type");
                        Editor.ObjectProperties.EnableAll(true);
                        Editor.ObjectPropertiesBox.isSuperFocused = true;
                        Editor.State = Editor.editorState.ObjectProperties;
                        break;
                    case 3:
                        Editor.ObjectPaletteBox.LimitObjectSelection(this.PalIndex, false);
                        break;
                    case 4:
                        Editor.ObjectPaletteBox.LimitObjectSelection(this.PalIndex, true);
                        break;
                    case 5:
                        Editor.ObjectPaletteBox.LimitObjectSelection(this.PalIndex, true);
                        Editor.ObjectPaletteBox.HideObjectSelection(this.PalIndex, Editor);
                        if (Editor.ObjectPaletteBox.IsObjectHidden(this.PalIndex)) {
                            this.HiddenObjectIndices[this.HiddenObjectIndices.length] = this.PalIndex
                        } else {
                            var HiddenIndex = this.HiddenObjectIndices.indexOf(this.PalIndex);
                            this.HiddenObjectIndices.splice(HiddenIndex, 1)
                        }
                        break;
                    case 6:
                        Editor.BrushFunctions.SwapSelectionWithPaletteBrush(Editor, this.PalIndex);
                        break;
                    case 7:
                        var CurrCategory = Editor.ObjectPaletteBox.GetCategoryIndexFromObjectIndex(this.PalIndex);
                        if (CurrCategory > 0) {
                            CurrCategory -= 1
                        } else {
                            break
                        }
                        Editor.ObjectPaletteBox.AlterObjectCategory(Editor.ObjectPaletteBox.Categories[CurrCategory].Name, this.PalIndex);
                        break;
                    case 8:
                        var CurrCategoryDown = Editor.ObjectPaletteBox.GetCategoryIndexFromObjectIndex(this.PalIndex);
                        if (CurrCategoryDown < Editor.ObjectPaletteBox.Categories.length - 1) {
                            CurrCategoryDown += 1
                        } else {
                            break
                        }
                        Editor.ObjectPaletteBox.AlterObjectCategory(Editor.ObjectPaletteBox.Categories[CurrCategoryDown].Name, this.PalIndex);
                        break;
                    case 9:
                        Editor.GeneralFunctions.TogglePickingMode(Editor, true);
                        Editor.AddToPalette.EnableAll(true);
                        Editor.AddToPaletteBox.isSuperFocused = true;
                        Editor.State = Editor.editorState.PaletteAdd;
                        this.AddObjectCatPos = Editor.ObjectPaletteBox.GetCategoryPositionFromObjectIndex(this.PalIndex);
                        this.AddObjectCategory = Editor.ObjectPaletteBox.GetCategoryIndexFromObjectIndex(this.PalIndex);
                        break;
                    case 10:
                        Editor.GeneralFunctions.TogglePickingMode(Editor, true);
                        Editor.AddToPalette.EnableAll(true);
                        Editor.AddToPaletteBox.isSuperFocused = true;
                        Editor.State = Editor.editorState.PaletteAdd;
                        this.AddObjectCatPos = Editor.ObjectPaletteBox.GetCategoryPositionFromObjectIndex(this.PalIndex) + 1;
                        this.AddObjectCategory = Editor.ObjectPaletteBox.GetCategoryIndexFromObjectIndex(this.PalIndex);
                        break;
                    case 11:
                        this.TogglePickingMode(Editor, true);
                        Editor.ObjectPaletteBox.BrushToDelete = this.PalIndex;
                        Editor.ConfirmationBox.SetTitleBar("\n\n\n\n\nWARNING!\n\nTHERE IS NO UNDO FOR THIS!\nDELETING OBJECT WILL REMOVE ALL INSTANCES FROM SCENE\nARE YOU SURE YOU WANT TO DELETE THIS OBJECT?");
                        Editor.Confirmation.EnableAll(true);
                        Editor.ConfirmationBox.isSuperFocused = true;
                        Editor.State = Editor.editorState.ConfirmObjDel;
                        Editor.BrushPaletteBox.AllowConfirmation = false;
                        this.HandleSavingChecks(Editor, 0, true);
                        break;
                    default:
                        Debug.Log("Drop down box - UNKNOWN SELECTION");
                        break
                }
            }
        },
        CheckCollisionBoxClose: function CheckCollBoxFn(Editor) {
            if (Editor.CollBox.FinalCollisionPoints.length > 0 || Editor.CollBox.InfoChanged) {
                var PaletteIndex = ObjectPaletteManager.ObjectPalette.indexOf(Editor.CollBox.BrushInfo);
                if (PaletteIndex === -1) {
                    Editor.CollBox.FinalCollisionPoints = [];
                    Editor.CollBox.InfoChanged = false;
                    Editor.CollBox.BrushInfo = 0;
                    Editor.State = Editor.editorState.Free;
                    return
                }
                var CollisionData = new EntityCollisionData;
                CollisionData.Loaded = true;
                CollisionData.Circle = !Editor.CollBox.PolyMode;
                CollisionData.CircleRadius = Editor.CollBox.Radius;
                CollisionData.Density = Editor.CollBox.Density;
                CollisionData.Friction = Editor.CollBox.Friction;
                CollisionData.Restitution = Editor.CollBox.Restitution;
                if (Editor.CollBox.FinalCollisionPoints.length > 0) {
                    CollisionData.CollisionPoints = Editor.CollBox.FinalCollisionPoints
                } else {
                    CollisionData.CollisionPoints = ObjectPaletteManager.ObjectPalette[PaletteIndex].Collision.CollisionPoints
                }
                ObjectPaletteManager.ObjectPalette[PaletteIndex].Collision = CollisionData;
                Editor.World.UpdateEntityCollision(PaletteIndex, CollisionData);
                ObjectPaletteManager.SavePalette(SettingsFileManager.ObjectPaletteFile);
                Editor.CollBox.FinalCollisionPoints = [];
                Editor.CollBox.InfoChanged = false;
                Editor.CollBox.BrushInfo = 0;
                Editor.State = Editor.editorState.Free
            }
            if (!Editor.CollBox.IsVisible() && Editor.State === Editor.editorState.SetCollision) {
                Editor.State = Editor.editorState.Free
            }
        },
        CheckCameraDrag: function CheckCamDragFn(Editor, X, Y) {
            if (Editor.GeneralFunctions.IsMouseOverPalette(Editor, X, Y)) {
                return
            }
            if (!this.CameraDrag) {
                if (JamSystem.InputManager.GetMouseButtonHeld(1)) {
                    this.CameraDrag = true;
                    Editor.StartingCoords.x = Editor.Camera.GetPosition().x + X / Editor.Camera.GetAdjustedZoom();
                    Editor.StartingCoords.y = Editor.Camera.GetPosition().y + Y / Editor.Camera.GetAdjustedZoom()
                }
            } else {
                if (!JamSystem.InputManager.GetMouseButtonHeld(1)) {
                    this.CameraDrag = false
                } else {
                    var CameraX = Editor.StartingCoords.x - X / Editor.Camera.GetAdjustedZoom();
                    var CameraY = Editor.StartingCoords.y - Y / Editor.Camera.GetAdjustedZoom();
                    Editor.Camera.SetPosition(CameraX, CameraY);
                    this.CameraPosition = new Vector2(CameraX, CameraY)
                }
            }
            Editor.World.GetLayer(Editor.CurrentLayer).CameraMove.x = Editor.Camera.GetPosition().x;
            Editor.World.GetLayer(Editor.CurrentLayer).CameraMove.y = Editor.Camera.GetPosition().y
        },
        MoveLayerContentsHold: function MoveLayerHoldFn(Editor) {
            if (!Editor.World.GetLayer(Editor.CurrentLayer).IsVisible) {
                return
            }
            if (!JamSystem.InputManager.GetKeyHeld(300) && !JamSystem.InputManager.GetKeyHeld(301) && (JamSystem.InputManager.GetKeyHeld(302) || JamSystem.InputManager.GetKeyHeld(303))) {
                var Layer = Editor.World.GetLayer(Editor.CurrentLayer);
                var Shift = 0;
                if (JamSystem.InputManager.GetKeyHeld(202)) {
                    Shift = new Vector2(0, -8);
                    Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.LayerPositionMod, Shift);
                    Layer.ShiftLayerContents(Shift)
                }
                if (JamSystem.InputManager.GetKeyHeld(200)) {
                    Shift = new Vector2(-8, 0);
                    Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.LayerPositionMod, Shift);
                    Layer.ShiftLayerContents(Shift)
                }
                if (JamSystem.InputManager.GetKeyHeld(203)) {
                    Shift = new Vector2(0, 8);
                    Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.LayerPositionMod, Shift);
                    Layer.ShiftLayerContents(Shift)
                }
                if (JamSystem.InputManager.GetKeyHeld(201)) {
                    Shift = new Vector2(8, 0);
                    Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.LayerPositionMod, Shift);
                    Layer.ShiftLayerContents(Shift)
                }
            }
        },
        MoveLayerContentsOnce: function MoveLayerOnceFn(Editor) {
            if (!Editor.World.GetLayer(Editor.CurrentLayer).IsVisible) {
                return
            }
            if ((JamSystem.InputManager.GetKeyHeld(300) || JamSystem.InputManager.GetKeyHeld(301)) && (JamSystem.InputManager.GetKeyHeld(302) || JamSystem.InputManager.GetKeyHeld(303))) {
                var Layer = Editor.World.GetLayer(Editor.CurrentLayer);
                var Shift = 0;
                if (JamSystem.InputManager.GetKeyPressed(202)) {
                    Shift = new Vector2(0, -1);
                    Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.LayerPositionMod, Shift);
                    Layer.ShiftLayerContents(Shift)
                }
                if (JamSystem.InputManager.GetKeyPressed(200)) {
                    Shift = new Vector2(-1, 0);
                    Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.LayerPositionMod, Shift);
                    Layer.ShiftLayerContents(Shift)
                }
                if (JamSystem.InputManager.GetKeyPressed(203)) {
                    Shift = new Vector2(0, 1);
                    Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.LayerPositionMod, Shift);
                    Layer.ShiftLayerContents(Shift)
                }
                if (JamSystem.InputManager.GetKeyPressed(201)) {
                    Shift = new Vector2(1, 0);
                    Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.LayerPositionMod, Shift);
                    Layer.ShiftLayerContents(Shift)
                }
            }
        },
        Zoom: function ZoomFn(Editor, TimeDelta) {
            var i = 0;
            for (i = Editor.UIItems.length - 1; i > -1; i -= 1) {
                if (Editor.UIItems[i].HasScrollFocus()) {
                    return
                }
            }
            if (Editor.State !== Editor.editorState.MovingEntity) {
                var ZoomLevel = 1.02;
                if (JamSystem.InputManager.GetKeyHeld(300) || JamSystem.InputManager.GetKeyHeld(301) || JamSystem.InputManager.GetKeyHeld(304) || JamSystem.InputManager.GetKeyHeld(305) || JamSystem.InputManager.GetKeyHeld(302) || JamSystem.InputManager.GetKeyHeld(303)) {
                    ZoomLevel = 1.15
                }
                this.MouseWheelVel += JamSystem.InputManager.GetMouseZ();
                if (JamSystem.InputManager.GetMouseZ() !== 0) {
                    if (JamSystem.InputManager.GetMouseZ() > 0) {
                        this.ZoomInDirection = true
                    }
                    if (JamSystem.InputManager.GetMouseZ() < 0) {
                        this.ZoomInDirection = false
                    }
                }
                var MouseZDelta = this.MouseWheelVel;
                if (MouseZDelta > 0) {
                    Editor.Camera.SetZoom(Editor.Camera.GetZoom() * ZoomLevel);
                    this.CameraZoom = Editor.Camera.GetZoom() * ZoomLevel
                }
                if (MouseZDelta < 0) {
                    Editor.Camera.SetZoom(Editor.Camera.GetZoom() / ZoomLevel);
                    this.CameraZoom = Editor.Camera.GetZoom() / ZoomLevel
                }
                Editor.World.GetLayer(Editor.CurrentLayer).Zoom = Editor.Camera.GetZoom();
                var Cursor, Camera;
                if (JamSystem.InputManager.GetMouseX() !== this.LastMousePosition.x) {
                    Cursor = Editor.World.GetLayer(Editor.CurrentLayer).TransformScreenToLocal(JamSystem.InputManager.GetMouseX(), JamSystem.InputManager.GetMouseY());
                    Camera = new Vector2(Editor.Camera.GetPosition().x, Editor.Camera.GetPosition().y);
                    this.StartDiff.x = Cursor.x - Camera.x;
                    this.LastMousePosition.x = JamSystem.InputManager.GetMouseX()
                }
                if (JamSystem.InputManager.GetMouseY() !== this.LastMousePosition.y) {
                    Cursor = Editor.World.GetLayer(Editor.CurrentLayer).TransformScreenToLocal(JamSystem.InputManager.GetMouseX(), JamSystem.InputManager.GetMouseY());
                    Camera = new Vector2(Editor.Camera.GetPosition().x, Editor.Camera.GetPosition().y);
                    this.StartDiff.y = Cursor.y - Camera.y;
                    this.LastMousePosition.y = JamSystem.InputManager.GetMouseY()
                }
                if (this.MouseWheelVel > 0) {
                    Camera = new Vector2(Editor.Camera.GetPosition().x, Editor.Camera.GetPosition().y);
                    var Modifier = ZoomLevel === 1.15 ? 7.8 : 1.2;
                    Camera.x += this.StartDiff.x * TimeDelta * Modifier;
                    Camera.y += this.StartDiff.y * TimeDelta * Modifier;
                    Editor.Camera.SetPosition(Camera.x, Camera.y);
                    this.CameraPosition = new Vector2(Camera.x, Camera.y);
                    Editor.World.GetLayer(Editor.CurrentLayer).CameraMove.x = Editor.Camera.GetPosition().x;
                    Editor.World.GetLayer(Editor.CurrentLayer).CameraMove.y = Editor.Camera.GetPosition().y
                }
                if (this.ZoomInDirection) {
                    if (this.MouseWheelVel > 0) {
                        this.MouseWheelVel -= this.MouseWheelVel * TimeDelta * 30
                    }
                    if (this.MouseWheelVel < .025) {
                        this.MouseWheelVel = 0;
                        this.LastMousePosition = new Vector2
                    }
                } else {
                    if (this.MouseWheelVel < 0) {
                        this.MouseWheelVel -= this.MouseWheelVel * TimeDelta * 30
                    }
                    if (this.MouseWheelVel > -.025) {
                        this.MouseWheelVel = 0;
                        this.LastMousePosition = new Vector2
                    }
                }
            }
        },
        HandleLoadingChecks: function HandleLoadingChecksFn(Editor, TimeDelta) {
            if (Editor.Loading) {
                Editor.PickingTextBox.Item.SetText("LOADING");
                Editor.PickingTextBox.BackingItem.SetColour([1, 0, 1, 1]);
                if (Editor.Game.IsLoadFinished) {
                    if (!Editor.Game.IsLoadSuccess) {
                        Editor.Loading = false;
                        Editor.LoadSaveBox.ChangeType(UIFileBox.LoadingType, Editor.LoadFile);
                        Editor.LoadSave.EnableAll(true);
                        Editor.LoadSaveBox.isSuperFocused = true;
                        Editor.State = Editor.editorState.ConfirmFile;
                        return false
                    } else {
                        SettingsFileManager.Save(Editor.LoadFile, Editor.SettingsFile);
                        Editor.SetIsActive(true);
                        Editor.Loading = false;
                        var TypeID = EntityTypeManager.GetPlayerTypeID();
                        var PlayerEnt = Editor.World.GetAllEntitiesOfType(TypeID);
                        if (PlayerEnt) {
                            this.CameraPosition = new Vector2(PlayerEnt.StartX, PlayerEnt.StartY);
                            Editor.Camera.SetPosition(this.CameraPosition.x, this.CameraPosition.y)
                        }
                    }
                }
                return true
            }
            return false
        },
        HandleSavingChecks: function HandleSavingChecksFn(Editor, TimeDelta, Force) {
            Editor.AutoSaveTimer += TimeDelta;
            if (Editor.AutoSaveTimer > Editor.AutosaveSecs || Force) {
                var CurrentTime = new Date;
                var AYear = CurrentTime.getFullYear() + ".";
                var AMonth = CurrentTime.getMonth() + 1 + ".";
                if (AMonth < 10) {
                    AMonth = "0" + AMonth
                }
                var ADate = CurrentTime.getDate();
                if (ADate < 10) {
                    ADate = "0" + ADate
                }
                var AHours = CurrentTime.getHours();
                if (AHours < 10) {
                    AHours = "0" + AHours
                }
                var AMins = CurrentTime.getMinutes();
                if (AMins < 10) {
                    AMins = "0" + AMins
                }
                var ATime = AHours + "." + AMins;
                this.Autosaves[this.Autosaves.length] = "Autosaves/Autosave " + AYear + AMonth + ADate + " " + ATime + ".json";
                this.SaveGame(Editor, "Autosaves/Autosave " + AYear + AMonth + ADate + " " + ATime + ".json");
                Editor.AutoSaveTimer = 0
            }
            if (Editor.Saving) {
                Editor.PickingTextBox.Item.SetText("SAVING");
                Editor.PickingTextBox.BackingItem.SetColour([1, 0, 0, 1]);
                Editor.PickingTextBox.RescaleTextBox();
                Editor.PickingTextBox.AlignCentre();
                if (WorldFileManager.GetIsReady() && ObjectPaletteManager.GetIsReady()) {
                    Editor.PickingTextBox.Item.SetText("SAVED");
                    Editor.PickingTextBox.RescaleTextBox();
                    Editor.PickingTextBox.AlignCentre();
                    Editor.AutoSaveTimer = 0
                }
                if (this.SavedTimer > .3 && !WorldFileManager.Success) {
                    Editor.PickingTextBox.Update(TimeDelta);
                    Editor.PickingTextBox.BackingItem.SetColour([1, 1, 0, 1]);
                    Editor.PickingTextBox.Item.SetText("PROBLEM SAVING");
                    Editor.PickingTextBox.RescaleTextBox();
                    Editor.PickingTextBox.AlignCentre()
                }
                this.SavedTimer += TimeDelta;
                if (this.SavedTimer > .3 && WorldFileManager.GetIsReady() && WorldFileManager.Success) {
                    Editor.Saving = false;
                    this.SavedTimer = 0;
                    Editor.PickingTextBox.BackingItem.SetColour([.411, .411, .411, 1])
                }
                return true
            }
            return false
        },
        HandleAutosaveRollback: function HandleAutoSavingChecksFn(Editor, X, Y) {
            var i = 0;
            if (Editor.State === Editor.editorState.Rollback) {
                if (Editor.RollbackBox.IsVisible()) {
                    for (i = Editor.RollbackButtons.length - 1; i > -1; i -= 1) {
                        if (Editor.RollbackButtons[i].Clicked) {
                            this.LoadGame(Editor, this.Autosaves[i]);
                            Editor.Rollback.EnableAll(false);
                            return true
                        }
                    }
                }
                if (!Editor.RollbackBox.IsVisible()) {
                    for (i = 0; i < Editor.RollbackButtons.length; i += 1) {
                        Editor.Rollback.RemoveItem(Editor.RollbackButtons[i], Editor.RollbackBox)
                    }
                    Editor.State = Editor.editorState.Free;
                    Editor.RollbackBox.ResetBox();
                    Editor.RollbackButtons = []
                }
            }
            if (!Editor.RollbackBox.IsVisible() && Editor.State === Editor.editorState.Free) {
                if (JamSystem.InputManager.GetKeyHeld(302) || JamSystem.InputManager.GetKeyHeld(303)) {
                    var Key = JamSystem.InputManager.GetKeyValue();
                    if (Key !== undefined) {
                        if (Key.charCodeAt(0) === 87 || Key.charCodeAt(0) === 119) {
                            var CurrentTime = new Date;
                            var CurrHours = CurrentTime.getHours();
                            if (CurrHours < 10) {
                                CurrHours = "0" + CurrHours
                            }
                            var CurrMins = CurrentTime.getMinutes();
                            if (CurrMins < 10) {
                                CurrMins = "0" + CurrMins
                            }
                            for (i = this.Autosaves.length - 1; i > -1; i -= 1) {
                                var Text = this.Autosaves[i];
                                Text = Text.slice(19);
                                Text = Text.slice(0, 16);
                                var Time = Text.slice(11);
                                var Hour = Time.slice(0, 2);
                                var Min = Time.slice(3);
                                var DiffHours = CurrHours - Hour;
                                var DiffMins = CurrMins - Min;
                                if (DiffHours >= 1 && DiffMins < 0) {
                                    DiffHours -= 1;
                                    DiffMins = 60 - Min + parseFloat(CurrMins);
                                    DiffHours += parseInt(DiffMins / 60, 10);
                                    DiffMins -= parseInt(DiffMins / 60, 10) * 60
                                }
                                Text = DiffHours + " Hours, " + DiffMins + " Minutes ago (" + Time + ")";
                                if (DiffHours === 0) {
                                    Text = DiffMins + " Minutes ago (" + Time + ")"
                                }
                                if (DiffMins === 1) {
                                    Text = "1 Minute ago (" + Time + ")"
                                }
                                if (DiffMins === 0) {
                                    Text = "Less than a minute ago (" + Time + ")"
                                }
                                Editor.RollbackButtons[i] = Editor.Rollback.AddButton(Text)
                            }
                            Editor.State = Editor.editorState.Rollback;
                            Editor.Rollback.EnableAll(true)
                        }
                        Editor.SelectedFunctions.CleanHoverEntity(Editor);
                        return true
                    }
                }
            }
        },
        SaveGame: function SaveGameFn(Editor, File) {
            var k = 0,
                j = 0,
                Entities = [];
            for (k = 0; k < Editor.World.GetLayerAmount(); k += 1) {
                Editor.World.GetLayer(k).GetAllEntities(Entities);
                for (j = 0; j < Entities.length; j += 1) {
                    Entities[j].Selected = false
                }
            }
            var i = 0;
            for (i = 0; i < Editor.SelectionEntities.length; i += 1) {
                Editor.SelectionEntities[i].Selected = true
            }
            var TruePickMode = Editor.Picking;
            if (!TruePickMode) {
                this.TogglePickingMode(Editor, true)
            }
            if (File === undefined) {
                File = Editor.SaveFile
            }
            WorldFileManager.Save(Editor.World, File);
            if (!TruePickMode) {
                this.TogglePickingMode(Editor, false)
            }
            Editor.Saving = true
        },
        LoadGame: function LoadGameFn(Editor, File) {
            if (File === undefined) {
                File = Editor.LoadFile
            }
            Editor.Game.Load(File);
            Editor.Loading = true;
            Editor.LastLoadedFile = File
        },
        SortDepth: function SortDepthFuncFn(a, b) {
            return a.Depth - b.Depth
        },
        CopyEntityGroup: function CopyBrushFn(Editor, NewEntities, CopyEntities, CopyGroup, Rename) {
            if (CopyGroup === undefined) {
                CopyGroup = Editor.BrushFunctions.LastCopyGroup
            }
            if (Rename === undefined) {
                Rename = Editor.BrushFunctions.LastCopyGroup
            }
            CopyEntities.sort(Editor.GeneralFunctions.SortDepth);
            var i = 0;
            for (i = 0; i < CopyEntities.length; i += 1) {
                NewEntities[i] = Entity.Clone(CopyEntities[i]);
                Entity.Copy(NewEntities[i], CopyEntities[i]);
                if (CopyEntities[i].Box2DBody) {
                    Physics.SetBodyMass(NewEntities[i].Box2DBody, Physics.GetBodyMass(CopyEntities[i].Box2DBody))
                }
                NewEntities[i].StartRotation = CopyEntities[i].StartRotation;
                NewEntities[i].StartScaleX = CopyEntities[i].StartScaleX;
                NewEntities[i].StartScaleY = CopyEntities[i].StartScaleY;
                NewEntities[i].Name = CopyEntities[i].Name;
                NewEntities[i].DesiredLayer = CopyEntities[i].DesiredLayer;
                var DesiredColour = CopyEntities[i].GetColour();
                var ValueColourR = DesiredColour[0];
                var ValueColourG = DesiredColour[1];
                var ValueColourB = DesiredColour[2];
                var ValueColourA = DesiredColour[3];
                NewEntities[i].SetColour([ValueColourR, ValueColourG, ValueColourB, ValueColourA]);
                Editor.World.GetLayer(Editor.CurrentLayer).AddEntity(NewEntities[i]);
                if (Rename) {
                    var Parents = Editor.World.FindEntityParents(CopyEntities[i]);
                    if (Parents.length > 0) {
                        Editor.World.NameEntityUniquely(NewEntities[i])
                    }
                }
            }
            if (CopyGroup) {
                Editor.GroupFunctions.AddChildrenEntities(Editor, NewEntities, CopyEntities)
            }
            for (i = 0; i < NewEntities.length; i += 1) {
                Editor.World.GetLayer(Editor.CurrentLayer).RemoveEntity(NewEntities[i])
            }
            return NewEntities
        },
        IsMouseOverPalette: function IsMouseOverPaletteFn(Editor, X, Y) {
            var i = 0;
            for (i = 0; i < Editor.UIPalettes.length; i += 1) {
                if (Editor.UIPalettes[i].IsMouseOver(X, Y)) {
                    return true
                }
            }
            return false
        },
        NewLevel: function NewLevelFn(Editor, AllowSave, DesiredLevelName) {
            var PlayLayer = Editor.World.GetLayer(Editor.World.PlayLayer);
            if (!PlayLayer) {
                Editor.World.GetLayer(0)
            }
            var i = 0;
            if (Editor.World.GetLayer(0)) {
                this.HandleSavingChecks(Editor, 0, true);
                Editor.LayerFunctions.ModifyLayer(Editor, 0, true);
                var Entities = Editor.World.GetAllEntitiesOfType(EntityTypeManager.GetPlayerTypeID());
                Entities[0].Layer.RemoveEntity(Entities[0]);
                for (i = Editor.World.GetLayerAmount() - 1; i > -1; i -= 1) {
                    Editor.World.ClearLayer(i);
                    Editor.World.RemoveLayer(i)
                }
                Editor.World.AddLayer(PlayLayer.MovementScale, PlayLayer.BucketWidth, PlayLayer.BucketHeight, PlayLayer.StaticLayer);
                if (Entities[0]) {
                    Editor.World.GetLayer(Editor.CurrentLayer).AddEntity(Entities[0])
                }
            } else {
                Editor.World.AddLayer(new Vector2(1, 1), 1280, 960, false);
                var PlayerIndex = 0;
                for (i = 0; i < ObjectPaletteManager.ObjectPalette.length; i += 1) {
                    if (ObjectPaletteManager.ObjectPalette[i].ObjectType) {
                        if (ObjectPaletteManager.ObjectPalette[i].ObjectType.TypeID) {
                            if (ObjectPaletteManager.ObjectPalette[i].ObjectType.TypeID === EntityTypeManager.GetPlayerTypeID()) {
                                PlayerIndex = i;
                                break
                            }
                        }
                    }
                }
                var NewEntity = WorldFileManager.CreateEntity(0, 0, 0, 1, 1, null, PlayerIndex, 0);
                Editor.World.GetLayer(Editor.CurrentLayer).AddEntity(NewEntity)
            }
            Editor.World.Optimise();
            var CurrentTime = new Date;
            var CurrHours = CurrentTime.getHours();
            if (CurrHours < 10) {
                CurrHours = "0" + CurrHours
            }
            var CurrMins = CurrentTime.getMinutes();
            if (CurrMins < 10) {
                CurrMins = "0" + CurrMins
            }
            var BaseName = "NewLevel_" + CurrHours + "." + CurrMins;
            if (!DesiredLevelName) {
                DesiredLevelName = BaseName
            }
            Editor.LoadFile = "assets/Levels/" + DesiredLevelName + ".json";
            Editor.SaveFile = "assets/Levels/" + DesiredLevelName + ".json";
            if (AllowSave) {
                SettingsFileManager.Save(Editor.LoadFile, Editor.SettingsFile);
                this.SaveGame(Editor);
                if (GlobalMain.CreateNewUserCallback) {
                    GlobalMain.CreateNewUserCallback(Editor.World, DesiredLevelName)
                }
            }
        },
        CheckObjectsMissingFromPalette: function CheckObjectsMissingFromPaletteFn(Editor) {
            var EntityArray = [];
            this.MissingPaletteRefs = "";
            var i = 0;
            for (i = 0; i < Editor.World.GetLayerAmount(); i += 1) {
                Editor.World.Layers[i].GetAllEntities(EntityArray)
            }
            var Found = false;
            for (i = 0; i < EntityArray.length; i += 1) {
                var EntityInfo = ObjectPaletteManager.ObjectPalette[EntityArray[i].ObjectPaletteIndex];
                if (EntityInfo === undefined && EntityArray[i].Loaded) {
                    this.MissingPaletteRefs += " (Entity, " + EntityArray[i].StartX + ", " + EntityArray[i].StartY + ")";
                    Found = true
                }
            }
            return Found
        },
        Init: function InitFn() {
            this.CameraDrag = false;
            this.Autosaves = [];
            this.LastMousePosition = new Vector2;
            this.StartDiff = new Vector2;
            this.MouseWheelVel = 0;
            this.ZoomInDirection = false;
            this.PalIndex = -1;
            this.CategoryIndex = -1;
            this.AddObjectCatPos = -1;
            this.AddObjectCategory = -1;
            this.ObjPropCategoryCombo = 0;
            this.ObjPropTypeCombo = 0;
            this.CameraZoom = 0;
            this.CameraPosition = new Vector2(0, 0);
            this.HiddenObjectIndices = [];
            this.MissingPaletteRefs = ""
        }
    };
    EditorGeneralFunctions.Create = function EditorGeneralCreateFn() {
        var NewObject = new EditorGeneralFunctions;
        NewObject.CameraDrag = false;
        NewObject.Autosaves = [];
        NewObject.LastMousePosition = new Vector2;
        NewObject.StartDiff = new Vector2;
        NewObject.MouseWheelVel = 0;
        NewObject.ZoomInDirection = false;
        NewObject.PalIndex = -1;
        NewObject.CategoryIndex = -1;
        NewObject.AddObjectCatPos = -1;
        NewObject.AddObjectCategory = -1;
        NewObject.ObjPropCategoryCombo = 0;
        NewObject.ObjPropTypeCombo = 0;
        NewObject.SavedTimer = 0;
        NewObject.CameraZoom = 0;
        NewObject.CameraPosition = new Vector2;
        NewObject.HiddenObjectIndices = [];
        NewObject.MissingPaletteRefs = "";
        return NewObject
    };

    function EditorSelectedFunctions() {}
    EditorSelectedFunctions.prototype = {
        CleanHoverEntity: function CleanHoverFn(Editor) {
            if (this.HoverEntity) {
                this.HoverEntity.ResetEditorColour();
                this.HoverEntity = 0;
                Editor.EntityInfoText.Item.SetText("");
                Editor.EntityInfoText.Item.SetPosition(-200, -200);
                Editor.ObjectPaletteBox.QuickShowBrush(-1, false)
            }
        },
        CleanSelection: function CleanSelectedFn(Editor) {
            var i = 0;
            for (i = 0; i < Editor.SelectionEntities.length; i += 1) {
                if (Editor.SelectionEntities[i]) {
                    Editor.SelectionEntities[i].ResetEditorColour();
                    Editor.SelectionEntities[i] = 0
                }
            }
            Editor.ObjectPaletteBox.QuickShowBrush(-1, true);
            Editor.SelectionEntities = [];
            Editor.State = Editor.editorState.Free
        },
        CheckHoverOverEntity: function CheckHoverOverFn(Editor, X, Y) {
            if (Editor.GeneralFunctions.IsMouseOverPalette(Editor, X, Y) || Editor.State === Editor.editorState.SetAttributes || Editor.State === Editor.editorState.SetDefaults) {
                this.CleanHoverEntity(Editor);
                return
            }
            var TempEntity = this.GetEntityAt(Editor, X, Y);
            if (Editor.State === Editor.editorState.MovingEntity) {
                this.CleanHoverEntity(Editor);
                return
            }
            if (TempEntity && this.HoverEntity && TempEntity !== this.HoverEntity) {
                this.CleanHoverEntity(Editor)
            }
            if (!TempEntity && this.HoverEntity !== 0) {
                this.CleanHoverEntity(Editor)
            }
            if (TempEntity) {
                this.HoverEntity = TempEntity;
                var EntityInfo = ObjectPaletteManager.ObjectPalette[TempEntity.ObjectPaletteIndex];
                var Text = "";
                if (TempEntity.Name) {
                    Text += TempEntity.Name
                } else {
                    if (EntityInfo) {
                        if (EntityInfo.Alias) {
                            Text += EntityInfo.Alias
                        } else {
                            Text += EntityInfo.Name
                        }
                    }
                    if (EntityInfo === undefined) {
                        Text += "Unknown Item"
                    }
                }
                var Parents = Editor.World.FindEntityParents(TempEntity);
                if (Parents.length > 0) {
                    var j = 0;
                    for (j = 0; j < Parents.length; j += 1) {
                        Text += " (Group " + Parents[j].Name + ")(" + (Parents[j].Children.indexOf(TempEntity) + 1) + " of " + Parents[j].Children.length + ")"
                    }
                }
                if (TempEntity.Children) {
                    Text += " (" + TempEntity.Children.length + ")"
                }
                Editor.EntityInfoText.Item.SetText(Text);
                if (EntityInfo) {
                    Editor.ObjectPaletteBox.QuickShowBrush(TempEntity.ObjectPaletteIndex, false)
                }
                Editor.EntityInfoText.Item.SetPosition(X, Y);
                this.HoverEntity.SetEditorColour([.6, .6, .6, 1])
            }
        },
        FindEntitiesWithinBox: function FindEntFn(Editor, X, Y) {
            if (!JamSystem.InputManager.GetKeyHeld(302) && !JamSystem.InputManager.GetKeyHeld(303)) {
                Editor.SelectionEntities = []
            }
            var Layer = Editor.World.GetLayer(Editor.CurrentLayer);
            var EndLocalCoords = Layer.TransformScreenToLocal(X, Y);
            var StartLocalCoords = Layer.TransformScreenToLocal(this.SelectionBoxCoords.x, this.SelectionBoxCoords.y);
            var Temp = 0;
            if (StartLocalCoords.x > EndLocalCoords.x) {
                Temp = EndLocalCoords.x;
                EndLocalCoords.x = StartLocalCoords.x;
                StartLocalCoords.x = Temp
            }
            if (StartLocalCoords.y > EndLocalCoords.y) {
                Temp = EndLocalCoords.y;
                EndLocalCoords.y = StartLocalCoords.y;
                StartLocalCoords.y = Temp
            }
            var NewEntities = [],
                i = 0;
            this.MultiLayers = [];
            var EntityObject = {};
            EntityObject.Entities = [];
            EntityObject.Layers = [];
            if (this.AllowMultiLayerSelection) {
                Editor.World.GetEntitiesInBox(StartLocalCoords, EndLocalCoords, EntityObject)
            } else {
                Editor.World.GetLayer(Editor.CurrentLayer).GetEntitiesInBox(StartLocalCoords, EndLocalCoords, EntityObject)
            }
            NewEntities = EntityObject.Entities;
            for (i = 0; i < NewEntities.length; i += 1) {
                NewEntities[i].DesiredLayer = EntityObject.Layers[i]
            }
            var Remove = [];
            if (!JamSystem.InputManager.GetKeyHeld(302) && !JamSystem.InputManager.GetKeyHeld(303)) {
                Editor.SelectionEntities = NewEntities
            } else {
                for (i = 0; i < NewEntities.length; i += 1) {
                    var NewIndex = Editor.SelectionEntities.indexOf(NewEntities[i]);
                    if (NewIndex === -1) {
                        if (JamSystem.InputManager.GetKeyHeld(302) || JamSystem.InputManager.GetKeyHeld(303)) {
                            Editor.SelectionEntities[Editor.SelectionEntities.length] = NewEntities[i]
                        }
                    }
                }
            }
            for (i = 0; i < Editor.SelectionEntities.length; i += 1) {
                if (Editor.ObjectPaletteBox.BrushesNonSelectable() && Editor.SelectionEntities[i]) {
                    if (!Editor.ObjectPaletteBox.AllowSelection[Editor.SelectionEntities[i].ObjectPaletteIndex]) {
                        Remove[i] = Editor.SelectionEntities[i]
                    }
                }
            }
            var OriginalLength = Editor.SelectionEntities.length;
            for (i = 0; i < OriginalLength; i += 1) {
                if (Remove[i] !== undefined) {
                    var Index = Editor.SelectionEntities.indexOf(Remove[i]);
                    Editor.SelectionEntities.splice(Index, 1);
                    this.MultiLayers.splice(Index, 1)
                }
            }
        },
        StartDragSelectionBox: function StartDragBoxFn(Editor, X, Y) {
            if (Editor.GeneralFunctions.IsMouseOverPalette(Editor, X, Y)) {
                return
            }
            this.SelectionBoxCoords.x = X;
            this.SelectionBoxCoords.y = Y;
            Editor.State = Editor.editorState.DrawGroupBox;
            this.DragBox.SetIsVisible(true);
            this.DragBox.SetPosition(X, Y)
        },
        UpdateDragSelectionBox: function UpdateDragBoxFn(Editor, X, Y) {
            if (Editor.State !== Editor.editorState.DrawGroupBox || Editor.GeneralFunctions.IsMouseOverPalette(Editor, X, Y)) {
                return
            }
            if (Math.abs(X - this.SelectionBoxCoords.x) < 10 && Math.abs(Y - this.SelectionBoxCoords.y) < 10) {
                return
            }
            this.DragBox.SetScaleX((X - this.SelectionBoxCoords.x) / this.DragBox.GetWidth());
            this.DragBox.SetScaleY((Y - this.SelectionBoxCoords.y) / this.DragBox.GetHeight());
            var k = 0;
            for (k = 0; k < Editor.SelectionEntities.length; k += 1) {
                Editor.SelectionEntities[k].ResetEditorColour();
                Editor.ObjectPaletteBox.QuickShowBrush(-1, true)
            }
            this.FindEntitiesWithinBox(Editor, X, Y);
            for (k = 0; k < Editor.SelectionEntities.length; k += 1) {
                Editor.SelectionEntities[k].SetEditorColour([.6, .6, .6, 1]);
                Editor.ObjectPaletteBox.QuickShowBrush(Editor.SelectionEntities[k].ObjectPaletteIndex, true)
            }
        },
        EndDragSelectionBox: function EndDragBoxFn(Editor, X, Y) {
            if (Editor.State !== Editor.editorState.DrawGroupBox) {
                return
            }
            if (Math.abs(X - this.SelectionBoxCoords.x) > 10 || Math.abs(Y - this.SelectionBoxCoords.y) > 10) {
                this.FindEntitiesWithinBox(Editor, X, Y)
            }
            if (Editor.SelectionEntities.length > 0) {
                this.CleanHoverEntity(Editor);
                Editor.State = Editor.editorState.Selection
            } else {
                Editor.State = Editor.editorState.Free
            }
            this.SelectionBoxCoords.x = 0;
            this.SelectionBoxCoords.y = 0;
            this.DragBox.SetScaleX(0);
            this.DragBox.SetScaleY(0);
            this.DragBox.SetIsVisible(false)
        },
        CalculateGridOffset: function CalcGridOffset(Editor) {
            Editor.SelectionOffsetX = [];
            Editor.SelectionOffsetY = [];
            var k = 0;
            var LocalCoords = Editor.World.GetLayer(Editor.CurrentLayer).TransformScreenToLocal(JamSystem.InputManager.GetMouseX(), JamSystem.InputManager.GetMouseY());
            for (k = 0; k < Editor.SelectionEntities.length; k += 1) {
                Editor.SelectionOffsetX[k] = LocalCoords.x - Editor.SelectionEntities[k].StartX;
                Editor.SelectionOffsetY[k] = LocalCoords.y - Editor.SelectionEntities[k].StartY
            }
            var Layer = Editor.World.GetLayer(Editor.CurrentLayer);
            this.GridOffset = new Vector2(0, 0);
            if (Layer.ShowGridLines) {
                var SectionX = Layer.Width / Layer.GridSpace;
                var SectionY = Layer.Height / Layer.GridSpace;
                var GridSquareCentreX = Math.floor(LocalCoords.x / Layer.Width * SectionX) * Layer.GridSpace + .5 * Layer.GridSpace;
                var GridSquareCentreY = Math.floor(LocalCoords.y / Layer.Height * SectionY) * Layer.GridSpace + .5 * Layer.GridSpace;
                this.GridOffset.x = LocalCoords.x - GridSquareCentreX;
                this.GridOffset.y = LocalCoords.y - GridSquareCentreY
            }
        },
        GetEntityAt: function GetEntityAtFn(Editor, X, Y) {
            var NewEntities = [];
            if (!this.AllowSingleMultiLayerSelection) {
                NewEntities = Editor.World.GetEntityAt(Editor.CurrentLayer, X, Y, true)
            }
            while (this.AllowSingleMultiLayerSelection && NewEntities.length === 0) {
                for (i = Editor.World.GetLayerAmount() - 1; i > -1; i -= 1) {
                    NewEntities = Editor.World.GetEntityAt(i, X, Y, true);
                    if (NewEntities.length !== 0) {
                        break
                    }
                }
                break
            }
            var i = 0,
                NewEntity = null;
            for (i = 0; i < NewEntities.length; i += 1) {
                if (NewEntities[i]) {
                    if (Editor.ObjectPaletteBox.BrushesNonSelectable()) {
                        if (!Editor.ObjectPaletteBox.AllowSelection[NewEntities[i].ObjectPaletteIndex]) {
                            continue
                        }
                    }
                    if (NewEntity === null) {
                        NewEntity = NewEntities[i];
                        continue
                    }
                    if (NewEntity === null || NewEntity.Depth < NewEntities[i].Depth) {
                        NewEntity = NewEntities[i]
                    }
                }
            }
            return NewEntity
        },
        SelectEntity: function SelectSingleEntFn(Editor, Element, X, Y) {
            var LocalCoords = Editor.World.GetLayer(Editor.CurrentLayer).TransformScreenToLocal(X, Y);
            this.LastMoveCoords = LocalCoords;
            Editor.ObjectPaletteBox.QuickShowBrush(Editor.SelectionEntities[Element].ObjectPaletteIndex, true);
            Editor.State = Editor.editorState.Selection
        },
        CheckForSelection: function SelectEntFn(Editor, X, Y) {
            if (Editor.GeneralFunctions.IsMouseOverPalette(Editor, X, Y)) {
                return
            }
            var CtrlPressed = JamSystem.InputManager.GetKeyHeld(302) || JamSystem.InputManager.GetKeyHeld(303);
            var ShftPressed = JamSystem.InputManager.GetKeyHeld(300) || JamSystem.InputManager.GetKeyHeld(301);
            var i = 0,
                j = 0,
                k = 0;
            var NewEntity = this.GetEntityAt(Editor, X, Y);
            if (!NewEntity) {
                if (JamSystem.InputManager.GetMouseButtonPressed(0)) {
                    if (ShftPressed) {
                        return
                    }
                    if (Editor.State === Editor.editorState.Selection && !CtrlPressed) {
                        var EntFound = false;
                        for (i = Editor.World.GetLayerAmount() - 1; i > -1; i -= 1) {
                            NewEntity = Editor.World.GetEntityAt(i, X, Y);
                            if (NewEntity && Editor.SelectionEntities.indexOf(NewEntity) === -1) {
                                break
                            }
                            if (NewEntity && Editor.SelectionEntities.indexOf(NewEntity) !== -1) {
                                EntFound = true;
                                break
                            }
                        }
                        if (!EntFound) {
                            this.CleanSelection(Editor)
                        }
                    }
                    if (Editor.State === Editor.editorState.Free || Editor.State === Editor.editorState.Selection && CtrlPressed) {
                        this.StartDragSelectionBox(Editor, X, Y)
                    }
                }
            }
            if (NewEntity && !ShftPressed) {
                if (JamSystem.InputManager.GetMouseButtonPressed(0)) {
                    if (Editor.State === Editor.editorState.Selection) {
                        var Index = Editor.SelectionEntities.indexOf(NewEntity);
                        if (Index !== -1) {
                            for (i = 0; i < Editor.SelectionEntities.length; i += 1) {
                                Editor.SelectionEntities[i].ResetEditorColour()
                            }
                            if (CtrlPressed) {
                                Editor.SelectionEntities.splice(Index, 1)
                            }
                        } else {
                            if (CtrlPressed) {
                                var NextElement = Editor.SelectionEntities.length;
                                Editor.SelectionEntities[NextElement] = NewEntity;
                                this.SelectEntity(Editor, NextElement, X, Y)
                            } else {
                                this.CleanSelection(Editor)
                            }
                        }
                    }
                    if (JamSystem.InputManager.GetKeyHeld(304) || JamSystem.InputManager.GetKeyHeld(305)) {
                        if (Editor.State !== Editor.editorState.Free && Editor.State !== Editor.editorState.Selection) {
                            return
                        }
                        var Entities = [];
                        if (Editor.SelectionEntities.length === 0) {
                            this.CleanSelection(Editor);
                            Editor.SelectionEntities[0] = NewEntity
                        }
                        Editor.GeneralFunctions.CopyEntityGroup(Editor, Entities, Editor.SelectionEntities, true, true);
                        this.CleanSelection(Editor);
                        for (i = 0; i < Entities.length; i += 1) {
                            Editor.World.GetLayer(Editor.CurrentLayer).AddEntity(Entities[i])
                        }
                        for (i = 0; i < Entities.length; i += 1) {
                            Editor.SelectionEntities[i] = Entities[i]
                        }
                        var Coords = Editor.World.GetLayer(Editor.CurrentLayer).TransformScreenToLocal(X, Y);
                        this.LastMoveCoords = Coords;
                        Editor.State = Editor.editorState.Selection;
                        Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.EntityPlaceMod, Entities);
                        return
                    }
                    if (Editor.State === Editor.editorState.Free && !ShftPressed) {
                        Editor.SelectionEntities[0] = NewEntity;
                        this.SelectEntity(Editor, 0, X, Y)
                    }
                    if (Editor.AttachmentFunctions.AttachmentMode) {
                        var Selection = Editor.SelectionEntities.length;
                        for (i = 0; i < Selection; i += 1) {
                            var AttachIndex = Editor.AttachmentFunctions.AnyAttachments(Editor, Editor.SelectionEntities[i]);
                            if (AttachIndex !== -1) {
                                for (k = 0; k < Editor.AttachmentFunctions.Attachments[AttachIndex].length; k += 1) {
                                    var SelectionIndex = Editor.SelectionEntities.length;
                                    var AttachEntity = Editor.AttachmentFunctions.Attachments[AttachIndex][k];
                                    if (AttachEntity !== Editor.SelectionEntities[i]) {
                                        Editor.SelectionEntities[SelectionIndex] = AttachEntity;
                                        Editor.ObjectPaletteBox.QuickShowBrush(AttachEntity.ObjectPaletteIndex, true)
                                    }
                                }
                            }
                            Editor.SelectionEntities[i].ResetEditorColour()
                        }
                    }
                }
            }
        },
        MoveEntities: function MoveEntFn(Editor, Entity, X, Y, Coords) {
            if (Editor.GeneralFunctions.IsMouseOverPalette(Editor, X, Y)) {
                return
            }
            var ShftPressed = JamSystem.InputManager.GetKeyHeld(300) || JamSystem.InputManager.GetKeyHeld(301);
            var Layer = Editor.World.GetLayer(Editor.CurrentLayer);
            if (Layer.ShowGridLines) {
                if (Entity === 0) {
                    var SectionX = Layer.Width / Layer.GridSpace;
                    var SectionY = Layer.Height / Layer.GridSpace;
                    var PosX = Math.floor(Coords.x / Layer.Width * SectionX) * Layer.GridSpace + .5 * Layer.GridSpace;
                    var PosY = Math.floor(Coords.y / Layer.Height * SectionY) * Layer.GridSpace + .5 * Layer.GridSpace;
                    Coords.x = PosX + this.GridOffset.x;
                    Coords.y = PosY + this.GridOffset.y
                }
            }
            if (ShftPressed && !this.DirectionLock.y && !this.DirectionLock.x) {
                if (Math.abs(this.LastMoveCoords.x - Coords.x) > Math.abs(this.LastMoveCoords.y - Coords.y)) {
                    this.DirectionLock.x = true
                }
                if (Math.abs(this.LastMoveCoords.y - Coords.y) > Math.abs(this.LastMoveCoords.x - Coords.x)) {
                    this.DirectionLock.y = true
                }
            }
            if (!this.DirectionLock.y) {
                Editor.SelectionEntities[Entity].StartX = Coords.x - Editor.SelectionOffsetX[Entity]
            }
            if (!this.DirectionLock.x) {
                Editor.SelectionEntities[Entity].StartY = Coords.y - Editor.SelectionOffsetY[Entity]
            }
            Editor.SelectionEntities[Entity].Reset();
            var EntityLayer = Editor.World.GetEntityLayer(Editor.SelectionEntities[Entity]);
            Editor.World.GetLayer(EntityLayer).UpdateEntity(Editor.SelectionEntities[Entity])
        },
        CheckForMovement: function SelectMoveFn(Editor, X, Y) {
            if (Editor.GeneralFunctions.IsMouseOverPalette(Editor, X, Y)) {
                return
            }
            var CtrlPressed = JamSystem.InputManager.GetKeyHeld(302) || JamSystem.InputManager.GetKeyHeld(303);
            var ShftPressed = JamSystem.InputManager.GetKeyHeld(300) || JamSystem.InputManager.GetKeyHeld(301);
            if (JamSystem.InputManager.GetMouseButtonHeld(0)) {
                if ((Editor.State === Editor.editorState.Selection || Editor.State === Editor.editorState.MovingEntity || Editor.State === Editor.editorState.Free && ShftPressed) && !CtrlPressed) {
                    var Coords = Editor.World.GetLayer(Editor.CurrentLayer).TransformScreenToLocal(X, Y);
                    if (Coords.x !== this.LastMoveCoords.x || Coords.y !== this.LastMoveCoords.y) {
                        if (ShftPressed && (Editor.State === Editor.editorState.Free || Editor.State === Editor.editorState.Selection && Editor.SelectionEntities.length === 1)) {
                            var NewEntity = this.GetEntityAt(Editor, X, Y);
                            if (NewEntity) {
                                this.CleanSelection(Editor);
                                Editor.SelectionEntities[0] = NewEntity
                            } else {
                                return
                            }
                        }
                        if (Editor.State === Editor.editorState.Selection || Editor.State === Editor.editorState.Free) {
                            if (!JamSystem.InputManager.GetKeyHeld(304) && !JamSystem.InputManager.GetKeyHeld(305)) {
                                Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.SelectedEntityMod, Editor.SelectionEntities)
                            }
                            this.CalculateGridOffset(Editor);
                            Editor.State = Editor.editorState.MovingEntity
                        } else {
                            var i = 0;
                            for (i = 0; i < Editor.SelectionEntities.length; i += 1) {
                                this.MoveEntities(Editor, i, X, Y, Coords)
                            }
                        }
                        this.LastMoveCoords.x = Coords.x;
                        this.LastMoveCoords.y = Coords.y
                    }
                }
                if (Editor.State === Editor.editorState.DrawGroupBox) {
                    this.UpdateDragSelectionBox(Editor, X, Y)
                }
            } else {
                if (Editor.State === Editor.editorState.MovingEntity) {
                    Editor.State = Editor.editorState.Selection;
                    this.DirectionLock.x = false;
                    this.DirectionLock.y = false
                }
                if (Editor.State === Editor.editorState.DrawGroupBox) {
                    this.EndDragSelectionBox(Editor, X, Y)
                }
            }
        },
        DeleteSelected: function DeleteSelectedFn(Editor, Undo) {
            if (Undo === undefined || Undo === true) {
                Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.EntityDeleteMod)
            }
            var j = 0;
            for (i = 0; i < Editor.SelectionEntities.length; i += 1) {
                var Parents = Editor.World.FindEntityParents(Editor.SelectionEntities[i]);
                for (j = 0; j < Parents.length; j += 1) {
                    Parents[j].RemoveChild(Editor.SelectionEntities[i])
                }
                if (Editor.SelectionEntities[i].Children) {
                    while (Editor.SelectionEntities[i].Children.length > 0) {
                        Editor.SelectionEntities[i].RemoveChild(Editor.SelectionEntities[i].Children[0])
                    }
                }
            }
            var i = 0;
            for (i = 0; i < Editor.SelectionEntities.length; i += 1) {
                Editor.World.GetLayer(Editor.CurrentLayer).RemoveEntity(Editor.SelectionEntities[i]);
                Editor.SelectionEntities[i].Delete()
            }
            this.CleanSelection(Editor)
        },
        Align: function AlignFn(Editor, Horizontal) {
            Editor.ActionFunctions.CalculateCentreSelected(Editor, Editor.SelectionEntities);
            var Centre = Editor.ActionFunctions.CentreSelected;
            Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.SelectedEntityMod, Editor.SelectionEntities);
            var i = 0;
            for (i = 0; i < Editor.SelectionEntities.length; i += 1) {
                if (!Horizontal) {
                    Editor.SelectionEntities[i].StartX = Centre.x
                }
                if (Horizontal) {
                    Editor.SelectionEntities[i].StartY = Centre.y
                }
                Editor.SelectionEntities[i].Reset();
                Editor.World.GetLayer(Editor.CurrentLayer).UpdateEntity(Editor.SelectionEntities[i])
            }
        },
        Init: function InitFn() {
            this.HoverEntity = 0;
            this.TrueEntityColour = 0;
            this.SelectionBoxCoords = new Vector2;
            this.DirectionLock = new Vector2;
            this.DragBox.SetIsVisible(false);
            this.LastMoveCoords = new Vector2;
            this.GridOffset = new Vector2;
            this.AllowMultiLayerSelection = false;
            this.AllowSingleMultiLayerSelection = false;
            this.MultiLayers = []
        }
    };
    EditorSelectedFunctions.Create = function EditorGeneralCreateFn() {
        var NewObject = new EditorSelectedFunctions;
        NewObject.HoverEntity = 0;
        NewObject.SelectionBoxCoords = new Vector2;
        NewObject.DirectionLock = new Vector2;
        NewObject.DragBox = Helpers.CreateSprite(0, 0, EA.TopLeft, "Editor_White", JamSystem.RenderManager.GetRoot());
        NewObject.DragBox.SetColour([1, 1, 1, .3]);
        NewObject.DragBox.SetIsVisible(false);
        NewObject.LastMoveCoords = new Vector2;
        NewObject.GridOffset = new Vector2;
        NewObject.AllowMultiLayerSelection = false;
        NewObject.AllowSingleMultiLayerSelection = false;
        NewObject.MultiLayers = [];
        return NewObject
    };

    function EditorSelectedActions() {}
    EditorSelectedActions.prototype = {
        CalculateCentreSelected: function CalcCentreSelectedFn(Editor, Entities) {
            var left = 9999999,
                right = -9999999,
                top = 9999999,
                bottom = -9999999,
                i = 0;
            if (Entities.length === 1) {
                this.CentreSelected.x = Entities[0].StartX;
                this.CentreSelected.y = Entities[0].StartY
            }
            for (i = 0; i < Entities.length; i += 1) {
                var X = Entities[i].StartX;
                var Y = Entities[i].StartY;
                if (X < left) {
                    left = X
                }
                if (X > right) {
                    right = X
                }
                if (Y < top) {
                    top = Y
                }
                if (Y > bottom) {
                    bottom = Y
                }
            }
            this.CentreSelected.x = (left + right) * .5;
            this.CentreSelected.y = (top + bottom) * .5
        },
        CheckSelectedForRotation: function CheckRotationFn(Editor, Entities, X, Y) {
            if (JamSystem.InputManager.GetKeyHeld(17) && (!JamSystem.InputManager.GetKeyHeld(300) && !JamSystem.InputManager.GetKeyHeld(301))) {
                var LocalCoords, i;
                if ((Editor.State === Editor.editorState.Selection || !Editor.Picking) && Editor.State !== Editor.editorState.Rotation) {
                    Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.SelectedEntityMod, Entities);
                    this.CalculateCentreSelected(Editor, Entities);
                    LocalCoords = Editor.World.GetLayer(Editor.CurrentLayer).TransformScreenToLocal(X, Y);
                    var InitialY = LocalCoords.y - this.CentreSelected.y;
                    var InitialX = LocalCoords.x - this.CentreSelected.x;
                    this.LastMeasurement = Math.atan2(InitialY, InitialX);
                    if (this.RotationGroupEntities !== Entities && this.RotationCarbonCopy !== Entities) {
                        this.RotationCarbonCopy = Entities;
                        Editor.GeneralFunctions.CopyEntityGroup(Editor, this.RotationGroupEntities, Entities, true, true)
                    }
                    Editor.State = Editor.editorState.Rotation
                }
                if (Editor.State === Editor.editorState.Rotation) {
                    LocalCoords = Editor.World.GetLayer(Editor.CurrentLayer).TransformScreenToLocal(X, Y);
                    var NewY = LocalCoords.y - this.CentreSelected.y;
                    var NewX = LocalCoords.x - this.CentreSelected.x;
                    var NewAngle = Math.atan2(NewY, NewX);
                    var Angle = NewAngle - this.LastMeasurement;
                    for (i = 0; i < Entities.length; i += 1) {
                        Entities[i].StartRotation += Angle;
                        if (Entities[i].StartRotation > 2 * Math.PI) {
                            Entities[i].StartRotation -= 2 * Math.PI
                        }
                        if (Entities[i].StartRotation < 0) {
                            Entities[i].StartRotation = 2 * Math.PI + Entities[i].StartRotation
                        }
                        Entities[i].Reset();
                        Editor.World.GetLayer(Editor.CurrentLayer).UpdateEntity(Entities[i])
                    }
                    this.LastMeasurement = NewAngle;
                    if (JamSystem.InputManager.GetKeyHeld(304) || JamSystem.InputManager.GetKeyHeld(305)) {
                        var Rotation = new Vector2;
                        var FinalPosition = new Vector2;
                        var Offset = new Vector2;
                        var DiffAngle = Angle;
                        Rotation.x = Math.cos(DiffAngle);
                        Rotation.y = Math.sin(DiffAngle);
                        for (i = 0; i < Entities.length; i += 1) {
                            Offset.x = Entities[i].StartX - this.CentreSelected.x;
                            Offset.y = Entities[i].StartY - this.CentreSelected.y;
                            FinalPosition.x = Offset.x * Rotation.x - Offset.y * Rotation.y;
                            FinalPosition.y = Offset.x * Rotation.y + Offset.y * Rotation.x;
                            Entities[i].StartX = FinalPosition.x + this.CentreSelected.x;
                            Entities[i].StartY = FinalPosition.y + this.CentreSelected.y;
                            Entities[i].Reset();
                            Editor.World.GetLayer(Editor.CurrentLayer).UpdateEntity(Entities[i]);
                            if (Entities === Editor.BrushEntities) {
                                Editor.BrushOffsetX[i] = -Offset.x;
                                Editor.BrushOffsetY[i] = -Offset.y
                            }
                        }
                    }
                    return true
                }
            } else {
                if (Editor.State === Editor.editorState.Rotation) {
                    if (Editor.Picking) {
                        Editor.State = Editor.editorState.Selection
                    } else {
                        Editor.State = Editor.editorState.Free
                    }
                }
                return false
            }
        },
        FlipEntities: function FlipEntsFn(Editor, Entities) {
            Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.SelectedEntityMod, Entities);
            var i = 0,
                Rotation = [];
            for (i = 0; i < Entities.length; i += 1) {
                Rotation[i] = Entities[i].StartRotation;
                Entities[i].StartRotation = 0;
                Entities[i].StartScaleY = -Entities[i].StartScaleY;
                Entities[i].StartRotation = -Rotation[i];
                if (Entities[i].StartRotation < 0) {
                    Entities[i].StartRotation = Math.PI * 2 + Entities[i].StartRotation
                }
                Entities[i].Reset();
                Editor.World.GetLayer(Editor.CurrentLayer).UpdateEntity(Entities[i])
            }
            if (JamSystem.InputManager.GetKeyHeld(304) || JamSystem.InputManager.GetKeyHeld(305)) {
                var Offset = new Vector2;
                this.CalculateCentreSelected(Editor, Entities);
                for (i = 0; i < Entities.length; i += 1) {
                    Offset.y = this.CentreSelected.y - Entities[i].StartY;
                    Entities[i].StartY = this.CentreSelected.y + Offset.y;
                    Entities[i].Reset();
                    Editor.World.GetLayer(Editor.CurrentLayer).UpdateEntity(Entities[i]);
                    Editor.BrushOffsetY[i] = -Offset.y
                }
                Editor.SelectedFunctions.CalculateGridOffset(Editor)
            }
        },
        MirrorEntities: function MirrorEntsFn(Editor, Entities) {
            Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.SelectedEntityMod, Entities);
            var i = 0,
                Rotation = [];
            for (i = 0; i < Entities.length; i += 1) {
                Rotation[i] = Entities[i].StartRotation;
                Entities[i].StartRotation = 0;
                Entities[i].StartScaleX = -Entities[i].StartScaleX;
                Entities[i].StartRotation = -Rotation[i];
                if (Entities[i].StartRotation < 0) {
                    Entities[i].StartRotation = Math.PI * 2 + Entities[i].StartRotation
                }
                Entities[i].Reset();
                Editor.World.GetLayer(Editor.CurrentLayer).UpdateEntity(Entities[i])
            }
            if (JamSystem.InputManager.GetKeyHeld(304) || JamSystem.InputManager.GetKeyHeld(305)) {
                var Offset = new Vector2;
                this.CalculateCentreSelected(Editor, Entities);
                for (i = 0; i < Entities.length; i += 1) {
                    Offset.x = this.CentreSelected.x - Entities[i].StartX;
                    Entities[i].StartX = this.CentreSelected.x + Offset.x;
                    Entities[i].Reset();
                    Editor.World.GetLayer(Editor.CurrentLayer).UpdateEntity(Entities[i]);
                    Editor.BrushOffsetX[i] = -Offset.x
                }
            }
            Editor.SelectedFunctions.CalculateGridOffset(Editor)
        },
        RotateEntities90: function Rotate90EntsFn(Editor, Entities) {
            Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.SelectedEntityMod, Entities);
            var i = 0;
            for (i = 0; i < Entities.length; i += 1) {
                Entities[i].StartRotation += Math.PI * .5;
                if (Entities[i].StartRotation > 2 * Math.PI) {
                    Entities[i].StartRotation = Entities[i].StartRotation - 2 * Math.PI
                }
                if (Entities[i].StartRotation < 0) {
                    Entities[i].StartRotation = 2 * Math.PI + Entities[i].StartRotation
                }
                Entities[i].Reset();
                Editor.World.GetLayer(Editor.CurrentLayer).UpdateEntity(Entities[i])
            }
            if (JamSystem.InputManager.GetKeyHeld(304) || JamSystem.InputManager.GetKeyHeld(305)) {
                var Offset = new Vector2;
                this.CalculateCentreSelected(Editor, Entities);
                for (i = 0; i < Entities.length; i += 1) {
                    Offset.x = Entities[i].StartX - this.CentreSelected.x;
                    Offset.y = Entities[i].StartY - this.CentreSelected.y;
                    Entities[i].StartX = -Offset.y + this.CentreSelected.x;
                    Entities[i].StartY = Offset.x + this.CentreSelected.y;
                    Entities[i].Reset();
                    Editor.World.GetLayer(Editor.CurrentLayer).UpdateEntity(Entities[i]);
                    Editor.BrushOffsetX[i] = Offset.y;
                    Editor.BrushOffsetY[i] = -Offset.x
                }
            }
            Editor.SelectedFunctions.CalculateGridOffset(Editor)
        },
        ResetBrushRotation: function ResetBrushRotFn(Editor, Entities) {
            Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.SelectedEntityMod, Entities);
            var i = 0;
            for (i = 0; i < Entities.length; i += 1) {
                Entities[i].StartRotation = 0;
                Entities[i].Reset();
                Editor.World.GetLayer(Editor.CurrentLayer).UpdateEntity(Entities[i])
            }
        },
        ResetGroupBrushRotation: function ResetGroupBrushRotationFn(Editor, Entities) {
            Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.SelectedEntityMod, Entities);
            var i = 0;
            for (i = 0; i < Entities.length; i += 1) {
                Entities[i].StartX = this.RotationGroupEntities[i].StartX;
                Entities[i].StartY = this.RotationGroupEntities[i].StartY;
                Entities[i].StartRotation = this.RotationGroupEntities[i].StartRotation;
                Entities[i].Reset();
                Editor.World.GetLayer(Editor.CurrentLayer).UpdateEntity(Entities[i])
            }
        },
        ResetBrushScale: function ResetBrushScaleFn(Editor, Entities) {
            Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.SelectedEntityMod, Entities);
            var i = 0;
            for (i = 0; i < Entities.length; i += 1) {
                Entities[i].StartScaleX = 1;
                Entities[i].StartScaleY = 1;
                Entities[i].Reset();
                Editor.World.GetLayer(Editor.CurrentLayer).UpdateEntity(Entities[i])
            }
        },
        ResetBrushXScale: function ResetBrushXScaleFn(Editor, Entities) {
            Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.SelectedEntityMod, Entities);
            var i = 0;
            for (i = 0; i < Entities.length; i += 1) {
                Entities[i].StartScaleX = 1;
                Entities[i].Reset();
                Editor.World.GetLayer(Editor.CurrentLayer).UpdateEntity(Entities[i])
            }
        },
        ResetBrushYScale: function ResetBrushYScaleFn(Editor, Entities) {
            Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.SelectedEntityMod, Entities);
            var i = 0;
            for (i = 0; i < Entities.length; i += 1) {
                Entities[i].StartScaleY = 1;
                Entities[i].Reset();
                Editor.World.GetLayer(Editor.CurrentLayer).UpdateEntity(Entities[i])
            }
        },
        MoveSelectedEntities: function MoveEntFn(Editor, X, Y) {
            Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.SelectedEntityMod, Editor.SelectionEntities);
            for (var i = 0; i < Editor.SelectionEntities.length; i += 1) {
                if (Editor.SelectionEntities[i]) {
                    Editor.SelectionEntities[i].StartX += X;
                    Editor.SelectionEntities[i].StartY += Y;
                    Editor.SelectionEntities[i].Reset();
                    Editor.World.GetLayer(Editor.CurrentLayer).UpdateEntity(Editor.SelectionEntities[i])
                }
            }
        },
        CheckSelectedForArrowMove: function CheckSelectArrowFn(Editor) {
            if ((JamSystem.InputManager.GetKeyHeld(300) || JamSystem.InputManager.GetKeyHeld(301)) && (!JamSystem.InputManager.GetKeyHeld(302) && !JamSystem.InputManager.GetKeyHeld(303))) {
                if (JamSystem.InputManager.GetKeyPressed(202)) {
                    this.MoveSelectedEntities(Editor, 0, -5)
                }
                if (JamSystem.InputManager.GetKeyPressed(200)) {
                    this.MoveSelectedEntities(Editor, -5, 0)
                }
                if (JamSystem.InputManager.GetKeyPressed(203)) {
                    this.MoveSelectedEntities(Editor, 0, 5)
                }
                if (JamSystem.InputManager.GetKeyPressed(201)) {
                    this.MoveSelectedEntities(Editor, 5, 0)
                }
            }
            if (!JamSystem.InputManager.GetKeyHeld(300) && !JamSystem.InputManager.GetKeyHeld(301) && (!JamSystem.InputManager.GetKeyHeld(302) && !JamSystem.InputManager.GetKeyHeld(303))) {
                if (JamSystem.InputManager.GetKeyPressed(202)) {
                    this.MoveSelectedEntities(Editor, 0, -1)
                }
                if (JamSystem.InputManager.GetKeyPressed(200)) {
                    this.MoveSelectedEntities(Editor, -1, 0)
                }
                if (JamSystem.InputManager.GetKeyPressed(203)) {
                    this.MoveSelectedEntities(Editor, 0, 1)
                }
                if (JamSystem.InputManager.GetKeyPressed(201)) {
                    this.MoveSelectedEntities(Editor, 1, 0)
                }
            }
        },
        FlashSelected: function FlashEntsFn(Editor, TimeDelta) {
            if (Editor.State === Editor.editorState.FindParent) {
                return
            }
            this.AlphaTimer += TimeDelta;
            if (this.AlphaTimer > .12) {
                this.EntityAlpha = !this.EntityAlpha;
                this.AlphaTimer = 0
            }
            var j = 0;
            for (j = 0; j < Editor.SelectionEntities.length; j += 1) {
                if (this.EntityAlpha) {
                    Editor.SelectionEntities[j].SetEditorColour([0, 0, 0, 1])
                } else {
                    Editor.SelectionEntities[j].ResetEditorColour()
                }
            }
        },
        ChangeDepth: function AlterDepthFn(Editor, Forward, ToEnd) {
            var Params = [!Forward, !ToEnd];
            Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.EntityDepthMod, Params);
            var Layer = Editor.World.GetLayer(Editor.CurrentLayer);
            var i = 0;
            for (i = 0; i < Editor.SelectionEntities.length; i += 1) {
                Layer.ChangeEntityDepth(Editor.SelectionEntities[i], Forward, ToEnd)
            }
        },
        ChangeEntityLayer: function ChangeEntityLayerFn(Editor, NewLayer) {
            Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.EntityDeleteMod);
            var i = 0;
            for (i = 0; i < Editor.SelectionEntities.length; i += 1) {
                Editor.World.GetLayer(Editor.CurrentLayer).RemoveEntity(Editor.SelectionEntities[i]);
                Editor.SelectionEntities[i].Delete()
            }
            for (i = 0; i < Editor.SelectionEntities.length; i += 1) {
                Editor.World.GetLayer(NewLayer).AddEntity(Editor.SelectionEntities[i]);
                Editor.SelectionEntities[i].UnDelete()
            }
            var OriginalLayer = Editor.CurrentLayer;
            Editor.CurrentLayer = NewLayer;
            Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.EntityPlaceMod, Editor.SelectionEntities);
            Editor.CurrentLayer = OriginalLayer
        },
        Init: function InitFn() {
            this.EntityAlpha = 1;
            this.AlphaTimer = 0;
            this.CentreSelected = new Vector2;
            this.LastMeasurement = 0;
            this.RotationGroupEntities = [];
            this.RotationCarbonCopy = []
        }
    };
    EditorSelectedActions.Create = function EditorGeneralCreateFn() {
        var NewObject = new EditorSelectedActions;
        NewObject.EntityAlpha = 1;
        NewObject.AlphaTimer = 0;
        NewObject.CentreSelected = new Vector2;
        NewObject.LastMeasurement = 0;
        NewObject.RotationGroupEntities = [];
        NewObject.RotationCarbonCopy = [];
        NewObject.FlashingColours = [];
        return NewObject
    };

    function EditorScaleActions() {}
    EditorScaleActions.prototype = {
        RotatePoint: function RotatePointFn(Centre, Point, Angle) {
            var CosAlpha = Math.cos(Angle);
            var SinAlpha = Math.sin(Angle);
            var LocalX = Point.x - Centre.x;
            var LocalY = Point.y - Centre.y;
            Point.x = LocalX * CosAlpha - LocalY * SinAlpha + Centre.x;
            Point.y = LocalX * SinAlpha + LocalY * CosAlpha + Centre.y;
            return Point
        },
        FreeformScale: function FreeformScaleFn(Editor, X, Y, Entities) {
            if (Entities.length === 0) {
                return
            }
            if (JamSystem.InputManager.GetKeyHeld(302) || JamSystem.InputManager.GetKeyHeld(303)) {
                return
            }
            if (JamSystem.InputManager.GetKeyHeld(300) || JamSystem.InputManager.GetKeyHeld(301)) {
                return
            }
            var Freeform = false;
            var Proportion = false;
            var XScale = false;
            var YScale = false;
            if (JamSystem.InputManager.GetKeyHeld(402) || JamSystem.InputManager.GetKeyHeld(18) || JamSystem.InputManager.GetKeyHeld(23) || JamSystem.InputManager.GetKeyHeld(24)) {
                Freeform = JamSystem.InputManager.GetKeyHeld(402);
                Proportion = JamSystem.InputManager.GetKeyHeld(18);
                XScale = JamSystem.InputManager.GetKeyHeld(23);
                YScale = JamSystem.InputManager.GetKeyHeld(24);
                if (Freeform && !Editor.Picking) {
                    return false
                }
                if (Freeform && Entities.length > 1) {
                    return false
                }
                var i = 0,
                    LocalCoords = 0,
                    Centre;
                var TrueWidth = Entities[0].GetWidth() * Entities[0].StartScaleX;
                var TrueHeight = Entities[0].GetHeight() * Entities[0].StartScaleY;
                var PercentX = TrueWidth * .1;
                var PercentY = TrueHeight * .1;
                var TopLeft = new Vector2(Entities[i].StartX - TrueWidth / 2, Entities[i].StartY - TrueHeight / 2);
                var TopLeftInner = new Vector2(TopLeft.x + PercentX, TopLeft.y + PercentY);
                var BottomRight = new Vector2(Entities[i].StartX + TrueWidth / 2, Entities[i].StartY + TrueHeight / 2);
                var BottomRightInner = new Vector2(BottomRight.x - PercentX, BottomRight.y - PercentY);
                var BottomLeft = new Vector2(Entities[i].StartX - TrueWidth / 2, Entities[i].StartY + TrueHeight / 2);
                var BottomLeftInner = new Vector2(BottomLeft.x + PercentX, BottomLeft.y - PercentY);
                var TopRight = new Vector2(Entities[i].StartX + TrueWidth / 2, Entities[i].StartY - TrueHeight / 2);
                var TopRightInner = new Vector2(TopRight.x - PercentX, TopRight.y + PercentY);
                if (Editor.State === Editor.editorState.Selection || !Editor.Picking) {
                    Editor.ActionFunctions.CalculateCentreSelected(Editor, Entities);
                    if (Freeform) {
                        if (this.AllLines[0] === undefined) {
                            for (i = 0; i < 8; i += 1) {
                                var Line = Helpers.CreateLine(0, 0, 0, 0, [1, 1, 1, 1], Editor.RenderTree);
                                this.AllLines[i] = Line
                            }
                        }
                        if (this.AllLines[0] !== undefined) {
                            this.AllLines[0].SetColour([1, 1, 1, 1]);
                            this.AllLines[1].SetColour([1, 1, 1, 1]);
                            this.AllLines[2].SetColour([1, 1, 1, 1]);
                            this.AllLines[3].SetColour([1, 1, 1, 1]);
                            this.AllLines[4].SetColour([1, 1, 1, 1]);
                            this.AllLines[5].SetColour([1, 1, 1, 1]);
                            this.AllLines[6].SetColour([1, 1, 1, 1]);
                            this.AllLines[7].SetColour([1, 1, 1, 1])
                        }
                    }
                }
                if (Freeform) {
                    if (Editor.State === Editor.editorState.Selection || !Editor.Picking || Editor.State === Editor.editorState.FreeformScale) {
                        var SurroundTopLeft, SurroundBottomRight, SurroundBottomLeft, SurroundTopRight;
                        var SurroundTopLeftInner, SurroundBottomRightInner, SurroundBottomLeftInner, SurroundTopRightInner;
                        if (Entities[0].StartRotation !== 0) {
                            Centre = new Vector2(Entities[0].StartX, Entities[0].StartY);
                            SurroundTopLeft = this.RotatePoint(Centre, TopLeft, Entities[0].StartRotation);
                            SurroundBottomLeft = this.RotatePoint(Centre, BottomLeft, Entities[0].StartRotation);
                            SurroundTopRight = this.RotatePoint(Centre, TopRight, Entities[0].StartRotation);
                            SurroundBottomRight = this.RotatePoint(Centre, BottomRight, Entities[0].StartRotation);
                            SurroundTopLeftInner = this.RotatePoint(Centre, TopLeftInner, Entities[0].StartRotation);
                            SurroundBottomLeftInner = this.RotatePoint(Centre, BottomLeftInner, Entities[0].StartRotation);
                            SurroundBottomRightInner = this.RotatePoint(Centre, BottomRightInner, Entities[0].StartRotation);
                            SurroundTopRightInner = this.RotatePoint(Centre, TopRightInner, Entities[0].StartRotation)
                        }
                        SurroundTopLeft = Editor.World.GetLayer(Editor.CurrentLayer).TransformLocalToScreen(TopLeft.x, TopLeft.y);
                        SurroundBottomRight = Editor.World.GetLayer(Editor.CurrentLayer).TransformLocalToScreen(BottomRight.x, BottomRight.y);
                        SurroundBottomLeft = Editor.World.GetLayer(Editor.CurrentLayer).TransformLocalToScreen(BottomLeft.x, BottomLeft.y);
                        SurroundTopRight = Editor.World.GetLayer(Editor.CurrentLayer).TransformLocalToScreen(TopRight.x, TopRight.y);
                        SurroundTopLeftInner = Editor.World.GetLayer(Editor.CurrentLayer).TransformLocalToScreen(TopLeftInner.x, TopLeftInner.y);
                        SurroundBottomRightInner = Editor.World.GetLayer(Editor.CurrentLayer).TransformLocalToScreen(BottomRightInner.x, BottomRightInner.y);
                        SurroundBottomLeftInner = Editor.World.GetLayer(Editor.CurrentLayer).TransformLocalToScreen(BottomLeftInner.x, BottomLeftInner.y);
                        SurroundTopRightInner = Editor.World.GetLayer(Editor.CurrentLayer).TransformLocalToScreen(TopRightInner.x, TopRightInner.y);
                        this.AllLines[0].SetStartCoord(SurroundTopLeft.x, SurroundTopLeft.y);
                        this.AllLines[0].SetEndCoord(SurroundBottomLeft.x, SurroundBottomLeft.y);
                        this.AllLines[1].SetStartCoord(SurroundTopLeftInner.x, SurroundTopLeftInner.y);
                        this.AllLines[1].SetEndCoord(SurroundBottomLeftInner.x, SurroundBottomLeftInner.y);
                        this.AllLines[2].SetStartCoord(SurroundTopRight.x, SurroundTopRight.y);
                        this.AllLines[2].SetEndCoord(SurroundBottomRight.x, SurroundBottomRight.y);
                        this.AllLines[3].SetStartCoord(SurroundTopRightInner.x, SurroundTopRightInner.y);
                        this.AllLines[3].SetEndCoord(SurroundBottomRightInner.x, SurroundBottomRightInner.y);
                        this.AllLines[4].SetStartCoord(SurroundTopLeft.x, SurroundTopLeft.y);
                        this.AllLines[4].SetEndCoord(SurroundTopRight.x, SurroundTopRight.y);
                        this.AllLines[5].SetStartCoord(SurroundTopLeftInner.x, SurroundTopLeftInner.y);
                        this.AllLines[5].SetEndCoord(SurroundTopRightInner.x, SurroundTopRightInner.y);
                        this.AllLines[6].SetStartCoord(SurroundBottomLeft.x, SurroundBottomLeft.y);
                        this.AllLines[6].SetEndCoord(SurroundBottomRight.x, SurroundBottomRight.y);
                        this.AllLines[7].SetStartCoord(SurroundBottomLeftInner.x, SurroundBottomLeftInner.y);
                        this.AllLines[7].SetEndCoord(SurroundBottomRightInner.x, SurroundBottomRightInner.y);
                        this.AllLines[0].SetColour([1, 1, 1, 1]);
                        this.AllLines[1].SetColour([1, 1, 1, 1]);
                        this.AllLines[2].SetColour([1, 1, 1, 1]);
                        this.AllLines[3].SetColour([1, 1, 1, 1]);
                        this.AllLines[4].SetColour([1, 1, 1, 1]);
                        this.AllLines[5].SetColour([1, 1, 1, 1]);
                        this.AllLines[6].SetColour([1, 1, 1, 1]);
                        this.AllLines[7].SetColour([1, 1, 1, 1]);
                        switch (this.Edge) {
                            case EA.TopRight:
                                this.AllLines[2].SetColour([1, 0, 0, 1]);
                                this.AllLines[3].SetColour([1, 0, 0, 1]);
                                this.AllLines[4].SetColour([1, 0, 0, 1]);
                                this.AllLines[5].SetColour([1, 0, 0, 1]);
                                break;
                            case EA.MiddleRight:
                                this.AllLines[2].SetColour([1, 0, 0, 1]);
                                this.AllLines[3].SetColour([1, 0, 0, 1]);
                                break;
                            case EA.BottomRight:
                                this.AllLines[2].SetColour([1, 0, 0, 1]);
                                this.AllLines[3].SetColour([1, 0, 0, 1]);
                                this.AllLines[7].SetColour([1, 0, 0, 1]);
                                this.AllLines[6].SetColour([1, 0, 0, 1]);
                                break;
                            case EA.TopMiddle:
                                this.AllLines[4].SetColour([1, 0, 0, 1]);
                                this.AllLines[5].SetColour([1, 0, 0, 1]);
                                break;
                            case EA.BottomMiddle:
                                this.AllLines[7].SetColour([1, 0, 0, 1]);
                                this.AllLines[6].SetColour([1, 0, 0, 1]);
                                break;
                            case EA.TopLeft:
                                this.AllLines[0].SetColour([1, 0, 0, 1]);
                                this.AllLines[1].SetColour([1, 0, 0, 1]);
                                this.AllLines[4].SetColour([1, 0, 0, 1]);
                                this.AllLines[5].SetColour([1, 0, 0, 1]);
                                break;
                            case EA.MiddleLeft:
                                this.AllLines[0].SetColour([1, 0, 0, 1]);
                                this.AllLines[1].SetColour([1, 0, 0, 1]);
                                break;
                            case EA.BottomLeft:
                                this.AllLines[0].SetColour([1, 0, 0, 1]);
                                this.AllLines[1].SetColour([1, 0, 0, 1]);
                                this.AllLines[7].SetColour([1, 0, 0, 1]);
                                this.AllLines[6].SetColour([1, 0, 0, 1]);
                                break
                        }
                    }
                }
                if (Editor.State === Editor.editorState.Selection) {
                    LocalCoords = Editor.World.GetLayer(Editor.CurrentLayer).TransformScreenToLocal(X, Y);
                    this.Edge = -1;
                    if (Freeform) {
                        this.Edge = Entities[0].GetIsOnEdge(LocalCoords.x, LocalCoords.y)
                    } else {
                        if (LocalCoords.x > Editor.ActionFunctions.CentreSelected.x && LocalCoords.y > Editor.ActionFunctions.CentreSelected.y) {
                            this.Edge = EA.BottomRight
                        }
                        if (LocalCoords.x < Editor.ActionFunctions.CentreSelected.x && LocalCoords.y > Editor.ActionFunctions.CentreSelected.y) {
                            this.Edge = EA.BottomLeft
                        }
                        if (LocalCoords.x > Editor.ActionFunctions.CentreSelected.x && LocalCoords.y < Editor.ActionFunctions.CentreSelected.y) {
                            this.Edge = EA.TopRight
                        }
                        if (LocalCoords.x < Editor.ActionFunctions.CentreSelected.x && LocalCoords.y < Editor.ActionFunctions.CentreSelected.y) {
                            this.Edge = EA.TopLeft
                        }
                    }
                    var ChangedEdge = this.Edge;
                    if (Entities[0].StartScaleY < 0) {
                        if (this.Edge === EA.TopRight) {
                            ChangedEdge = EA.BottomRight
                        } else if (this.Edge === EA.BottomRight) {
                            ChangedEdge = EA.TopRight
                        } else if (this.Edge === EA.TopMiddle) {
                            ChangedEdge = EA.BottomMiddle
                        } else if (this.Edge === EA.BottomMiddle) {
                            ChangedEdge = EA.TopMiddle
                        } else if (this.Edge === EA.TopLeft) {
                            ChangedEdge = EA.BottomLeft
                        } else if (this.Edge === EA.BottomLeft) {
                            ChangedEdge = EA.TopLeft
                        }
                    }
                    if (Entities[0].StartScaleX < 0) {
                        if (ChangedEdge === EA.TopRight) {
                            ChangedEdge = EA.TopLeft
                        } else if (ChangedEdge === EA.MiddleRight) {
                            ChangedEdge = EA.MiddleLeft
                        } else if (ChangedEdge === EA.BottomRight) {
                            ChangedEdge = EA.BottomLeft
                        } else if (ChangedEdge === EA.TopLeft) {
                            ChangedEdge = EA.TopRight
                        } else if (ChangedEdge === EA.MiddleLeft) {
                            ChangedEdge = EA.MiddleRight
                        } else if (ChangedEdge === EA.BottomLeft) {
                            ChangedEdge = EA.BottomRight
                        }
                    }
                    switch (this.Edge) {
                        case EA.TopRight:
                            this.StartPoint.x = BottomLeft.x;
                            this.StartPoint.y = BottomLeft.y;
                            break;
                        case EA.MiddleRight:
                            this.StartPoint.x = TopLeft.x;
                            this.StartPoint.y = TopLeft.y;
                            break;
                        case EA.BottomRight:
                            this.StartPoint.x = TopLeft.x;
                            this.StartPoint.y = TopLeft.y;
                            break;
                        case EA.TopMiddle:
                            this.StartPoint.x = BottomLeft.x;
                            this.StartPoint.y = BottomLeft.y;
                            break;
                        case EA.BottomMiddle:
                            this.StartPoint.x = TopLeft.x;
                            this.StartPoint.y = TopLeft.y;
                            break;
                        case EA.TopLeft:
                            this.StartPoint.x = BottomRight.x;
                            this.StartPoint.y = BottomRight.y;
                            break;
                        case EA.MiddleLeft:
                            this.StartPoint.x = TopRight.x;
                            this.StartPoint.y = TopRight.y;
                            break;
                        case EA.BottomLeft:
                            this.StartPoint.x = TopRight.x;
                            this.StartPoint.y = TopRight.y;
                            break
                    }
                }
                if (!Editor.Picking) {
                    this.Edge = EA.BottomRight
                }
                if ((Editor.State === Editor.editorState.Selection || !Editor.Picking) && Editor.State !== Editor.editorState.FreeformScale) {
                    if (JamSystem.InputManager.GetMouseButtonPressed(0) && Freeform || !Freeform) {
                        Editor.UndoActions.AddToUndo(Editor, Editor.UndoActions.UndoType.SelectedEntityMod, Entities);
                        Editor.State = Editor.editorState.FreeformScale;
                        for (i = 0; i < Entities.length; i += 1) {
                            this.OriginalRotation[i] = Entities[i].StartRotation;
                            this.OriginallyFlipped[i] = false;
                            this.OriginallyMirrored[i] = false;
                            if (Entities[i].StartScaleY < 0) {
                                this.OriginallyFlipped[i] = true
                            }
                            if (Entities[i].StartScaleX < 0) {
                                this.OriginallyMirrored[i] = true
                            }
                            this.OffsetX[i] = Entities[i].StartX - Editor.ActionFunctions.CentreSelected.x;
                            this.OffsetY[i] = Entities[i].StartY - Editor.ActionFunctions.CentreSelected.y
                        }
                        LocalCoords = Editor.World.GetLayer(Editor.CurrentLayer).TransformScreenToLocal(X, Y);
                        this.OriginalPoint.x = LocalCoords.x;
                        this.OriginalPoint.y = LocalCoords.y;
                        this.EntityLength.x = Math.abs(Entities[0].GetWidth() * Entities[0].StartScaleX / 2);
                        this.EntityLength.y = Math.abs(Entities[0].GetHeight() * Entities[0].StartScaleY / 2);
                        for (i = 0; i < Entities.length; i += 1) {
                            this.OriginalScale[i] = new Vector2;
                            this.OriginalScale[i].x = Entities[i].StartScaleX;
                            this.OriginalScale[i].y = Entities[i].StartScaleY
                        }
                        this.ScaleDiff = new Vector2;
                        this.DeltaScale = new Vector2
                    }
                }
                if (Editor.State === Editor.editorState.FreeformScale) {
                    if (Freeform && JamSystem.InputManager.GetMouseButtonHeld(0) || !Freeform) {
                        var NewEdge = new Vector2;
                        var Scale = new Vector2;
                        LocalCoords = Editor.World.GetLayer(Editor.CurrentLayer).TransformScreenToLocal(X, Y);
                        if (Freeform) {
                            LocalCoords = this.RotatePoint(this.OriginalPoint, LocalCoords, -this.OriginalRotation[0])
                        }
                        switch (this.Edge) {
                            case EA.TopRight:
                                NewEdge.x = this.EntityLength.x + (LocalCoords.x - this.OriginalPoint.x);
                                NewEdge.y = this.EntityLength.y - (LocalCoords.y - this.OriginalPoint.y);
                                break;
                            case EA.BottomRight:
                                NewEdge.x = this.EntityLength.x + (LocalCoords.x - this.OriginalPoint.x);
                                NewEdge.y = this.EntityLength.y + (LocalCoords.y - this.OriginalPoint.y);
                                break;
                            case EA.TopLeft:
                                NewEdge.x = this.EntityLength.x - (LocalCoords.x - this.OriginalPoint.x);
                                NewEdge.y = this.EntityLength.y - (LocalCoords.y - this.OriginalPoint.y);
                                break;
                            case EA.BottomLeft:
                                NewEdge.x = this.EntityLength.x - (LocalCoords.x - this.OriginalPoint.x);
                                NewEdge.y = this.EntityLength.y + (LocalCoords.y - this.OriginalPoint.y);
                                break;
                            case EA.MiddleRight:
                                NewEdge.x = this.EntityLength.x + (LocalCoords.x - this.OriginalPoint.x);
                                NewEdge.y = this.EntityLength.y;
                                break;
                            case EA.TopMiddle:
                                NewEdge.x = this.EntityLength.x;
                                NewEdge.y = this.EntityLength.y - (LocalCoords.y - this.OriginalPoint.y);
                                break;
                            case EA.BottomMiddle:
                                NewEdge.x = this.EntityLength.x;
                                NewEdge.y = this.EntityLength.y + (LocalCoords.y - this.OriginalPoint.y);
                                break;
                            case EA.MiddleLeft:
                                NewEdge.x = this.EntityLength.x - (LocalCoords.x - this.OriginalPoint.x);
                                NewEdge.y = this.EntityLength.y;
                                break;
                            default:
                                NewEdge.x = this.EntityLength.x;
                                NewEdge.y = this.EntityLength.y;
                                break
                        }
                        var DragDifference = new Vector2;
                        var ScaleMultiplier = new Vector2;
                        if (XScale || Freeform) {
                            DragDifference.x = NewEdge.x - this.EntityLength.x;
                            ScaleMultiplier.x = DragDifference.x / Entities[0].GetWidth();
                            Scale.x = ScaleMultiplier.x * 2
                        }
                        if (YScale || Freeform) {
                            DragDifference.y = NewEdge.y - this.EntityLength.y;
                            ScaleMultiplier.y = DragDifference.y / Entities[0].GetHeight();
                            Scale.y = ScaleMultiplier.y * 2
                        }
                        if (Proportion) {
                            DragDifference.x = NewEdge.x - this.EntityLength.x;
                            ScaleMultiplier.x = DragDifference.x / this.EntityLength.x;
                            DragDifference.y = NewEdge.y - this.EntityLength.y;
                            ScaleMultiplier.y = DragDifference.y / this.EntityLength.y;
                            Scale.x = ScaleMultiplier.x * 2;
                            Scale.y = ScaleMultiplier.y * 2;
                            var SplitScale = (Scale.x + Scale.y) / 2;
                            var OriginalWidthScale = Math.abs(Entities[0].GetWidth());
                            var OriginalHeightScale = Math.abs(Entities[0].GetHeight());
                            var CurrentWidthScale = this.EntityLength.x;
                            var CurrentHeightScale = this.EntityLength.y;
                            var RatioX = CurrentWidthScale / OriginalWidthScale;
                            var RatioY = CurrentHeightScale / OriginalHeightScale;
                            Scale.x = SplitScale * RatioX;
                            Scale.y = SplitScale * RatioY
                        }
                        if (Scale.x === 0 && Scale.y === 0) {
                            return true
                        }
                        if (Scale.x !== 1) {
                            Scale.x *= .5
                        }
                        if (Scale.y !== 1) {
                            Scale.y *= .5
                        }
                        this.ScaleDiff.x = Scale.x - this.ScaleDiff.x;
                        this.ScaleDiff.y = Scale.y - this.ScaleDiff.y;
                        this.DeltaScale.x += this.ScaleDiff.x;
                        this.DeltaScale.y += this.ScaleDiff.y;
                        Entities[0].StartRotation = 0;
                        var Addition = new Vector2(this.DeltaScale.x, this.DeltaScale.y);
                        if (Proportion || XScale || YScale) {
                            if (this.OriginallyMirrored[0]) {
                                Addition.x *= -1
                            }
                            if (this.OriginallyFlipped[0]) {
                                Addition.y *= -1
                            }
                        }
                        Entities[0].StartScaleX = this.OriginalScale[0].x + Addition.x;
                        Entities[0].StartScaleY = this.OriginalScale[0].y + Addition.y;
                        if (Freeform) {
                            var CurrentWidth = Entities[0].GetWidth() * Entities[0].StartScaleX;
                            var CurrentHeight = Entities[0].GetHeight() * Entities[0].StartScaleY;
                            Centre = new Vector2(0, 0);
                            switch (this.Edge) {
                                case EA.TopRight:
                                case EA.TopMiddle:
                                    Centre.x = this.StartPoint.x + CurrentWidth / 2;
                                    Centre.y = this.StartPoint.y - CurrentHeight / 2;
                                    break;
                                case EA.MiddleRight:
                                    Centre.x = this.StartPoint.x + CurrentWidth / 2;
                                    Centre.y = this.StartPoint.y + CurrentHeight / 2;
                                    break;
                                case EA.BottomRight:
                                case EA.BottomMiddle:
                                    Centre.x = this.StartPoint.x + CurrentWidth / 2;
                                    Centre.y = this.StartPoint.y + CurrentHeight / 2;
                                    break;
                                case EA.TopLeft:
                                    Centre.x = this.StartPoint.x - CurrentWidth / 2;
                                    Centre.y = this.StartPoint.y - CurrentHeight / 2;
                                    break;
                                case EA.MiddleLeft:
                                case EA.BottomLeft:
                                    Centre.x = this.StartPoint.x - CurrentWidth / 2;
                                    Centre.y = this.StartPoint.y + CurrentHeight / 2;
                                    break
                            }
                            Centre = this.RotatePoint(this.StartPoint, Centre, this.OriginalRotation[0]);
                            Entities[0].StartX = Centre.x;
                            Entities[0].StartY = Centre.y
                        }
                        Entities[0].StartRotation = this.OriginalRotation[0];
                        if (Proportion || XScale || YScale) {
                            if (JamSystem.InputManager.GetKeyHeld(304) || JamSystem.InputManager.GetKeyHeld(305)) {
                                var DeltaX = Entities[0].StartScaleX - this.OriginalScale[0].x;
                                var DeltaY = Entities[0].StartScaleY - this.OriginalScale[0].y;
                                Entities[0].StartX = Editor.ActionFunctions.CentreSelected.x + this.OffsetX[0] + this.OffsetX[0] * DeltaX / this.OriginalScale[0].x;
                                Entities[0].StartY = Editor.ActionFunctions.CentreSelected.y + this.OffsetY[0] + this.OffsetY[0] * DeltaY / this.OriginalScale[0].y
                            }
                        }
                        Entities[0].Reset();
                        Editor.World.GetLayer(Editor.CurrentLayer).UpdateEntity(Entities[0]);
                        Entity.UpdateCollision(Entities[0]);
                        this.ScaleDiff.x = Scale.x;
                        this.ScaleDiff.y = Scale.y;
                        if (Entities.length > 1) {
                            var PropPercentX = Entities[0].StartScaleX / this.OriginalScale[0].x;
                            var PropPercentY = Entities[0].StartScaleY / this.OriginalScale[0].y;
                            for (i = 0; i < Entities.length; i += 1) {
                                Entities[i].StartRotation = 0;
                                Entities[i].StartScaleX = this.OriginalScale[i].x * PropPercentX;
                                Entities[i].StartScaleY = this.OriginalScale[i].y * PropPercentY;
                                Entities[i].StartRotation = this.OriginalRotation[i];
                                if (Proportion || XScale || YScale) {
                                    if (JamSystem.InputManager.GetKeyHeld(304) || JamSystem.InputManager.GetKeyHeld(305)) {
                                        var MultiDeltaX = Entities[i].StartScaleX - this.OriginalScale[i].x;
                                        var MultiDeltaY = Entities[i].StartScaleY - this.OriginalScale[i].y;
                                        Entities[i].StartX = Editor.ActionFunctions.CentreSelected.x + this.OffsetX[i] + this.OffsetX[i] * MultiDeltaX / this.OriginalScale[i].x;
                                        Entities[i].StartY = Editor.ActionFunctions.CentreSelected.y + this.OffsetY[i] + this.OffsetY[i] * MultiDeltaY / this.OriginalScale[i].y;
                                        if (Entities === Editor.BrushEntities) {
                                            var MainCentre = Editor.ActionFunctions.CentreSelected;
                                            Editor.BrushOffsetX[i] = MainCentre.x - Entities[i].StartX;
                                            Editor.BrushOffsetY[i] = MainCentre.y - Entities[i].StartY
                                        }
                                    }
                                }
                                Entities[i].Reset();
                                Editor.World.GetLayer(Editor.CurrentLayer).UpdateEntity(Entities[i]);
                                Entity.UpdateCollision(Entities[i])
                            }
                        }
                    } else {
                        if (Freeform) {
                            Editor.State = Editor.editorState.Selection
                        }
                    }
                } else {
                    if (Editor.State === Editor.editorState.FreeformScale) {
                        if (Editor.Picking) {
                            Editor.State = Editor.editorState.Selection
                        } else {
                            Editor.State = Editor.editorState.Free
                        }
                    }
                }
                return true
            } else {
                if (this.AllLines) {
                    var j = 0,
                        MaxLines = this.AllLines.length;
                    for (j = 0; j < MaxLines; j += 1) {
                        Helpers.DestroyLine(this.AllLines[j])
                    }
                }
                this.AllLines = [];
                if (Editor.State === Editor.editorState.FreeformScale) {
                    if (!JamSystem.InputManager.GetMouseButtonHeld(0) && Freeform || !Freeform) {
                        if (Editor.Picking) {
                            Editor.State = Editor.editorState.Selection
                        } else {
                            Editor.State = Editor.editorState.Free
                        }
                    }
                }
            }
        },
        Init: function InitFn() {
            this.EntityLength = new Vector2;
            this.OriginalPoint = new Vector2;
            this.OriginalScale = [];
            this.DeltaScale = new Vector2;
            this.ScaleDiff = new Vector2;
            this.Edge = 0;
            this.StartPoint = new Vector2;
            this.OriginallyFlipped = [];
            this.OriginallyMirrored = [];
            this.OriginalRotation = [];
            this.OffsetX = [];
            this.OffsetY = [];
            this.AllLines = [];
            this.ScaleText = 0;
            if (this.ScaleText) {
                Helpers.DestroyBitmapText(this.ScaleText);
                this.ScaleText = 0
            }
            this.ScaleText = Helpers.CreateBitmapText("", 0, 0, EA.MiddleMiddle, "EditorFont", JamSystem.RenderManager.GetRoot());
            this.ScaleText.SetPosition(JamSystem.RenderManager.GetScreenWidth() / 2, 80);
            this.ScaleText.SetIsVisible(false)
        }
    };
    EditorScaleActions.Create = function EditorGeneralCreateFn() {
        var NewObject = new EditorScaleActions;
        NewObject.EntityLength = new Vector2;
        NewObject.OriginalPoint = new Vector2;
        NewObject.OriginalScale = [];
        NewObject.DeltaScale = new Vector2;
        NewObject.ScaleDiff = new Vector2;
        NewObject.Edge = 0;
        NewObject.StartPoint = new Vector2;
        NewObject.OriginallyFlipped = [];
        NewObject.OriginallyMirrored = [];
        NewObject.OriginalRotation = [];
        NewObject.OffsetX = [];
        NewObject.OffsetY = [];
        NewObject.AllLines = [];
        NewObject.ScaleText = 0;
        return NewObject
    };

    function EditorUndoActions() {}
    EditorUndoActions.TypeID = 0;
    EditorUndoActions.ReferenceEntitiesID = 1;
    EditorUndoActions.ValueEntitiesID = 2;
    EditorUndoActions.ValueLayerID = 3;
    EditorUndoActions.LayerModifierID = 1;
    EditorUndoActions.LayerID = 2;
    EditorUndoActions.DepthForwardID = 2;
    EditorUndoActions.DepthToEndID = 3;
    EditorUndoActions.DeletedEntsID = 1;
    EditorUndoActions.DeletedLayerID = 2;
    EditorUndoActions.DeletedParentPositionID = 3;
    EditorUndoActions.ChildEntitiesID = 2;
    EditorUndoActions.OldEntsID = 1;
    EditorUndoActions.NewEntsID = 4;
    EditorUndoActions.PosX = 0;
    EditorUndoActions.PosY = 1;
    EditorUndoActions.ScaleX = 2;
    EditorUndoActions.ScaleY = 3;
    EditorUndoActions.Rotation = 4;
    EditorUndoActions.Name = 5;
    EditorUndoActions.OffsetX = 6;
    EditorUndoActions.OffsetY = 7;
    EditorUndoActions.Colour = 8;
    EditorUndoActions.EditableVars = 9;
    EditorUndoActions.Mass = 10;
    EditorUndoActions.prototype = {
        UndoType: {
            SelectedEntityMod: 0,
            LayerPositionMod: 1,
            EntityDepthMod: 2,
            EntityDeleteMod: 3,
            EntityPlaceMod: 4,
            EntityGroupMod: 5,
            EntitySwapMod: 6
        },
        Undo: function UndoFn(Editor) {
            if (this.UndoActions.length === 0) {
                Debug.Log("NO UNDO ACTIONS");
                return
            }
            var LastState = this.UndoActions[this.UndoActions.length - 1];
            if (LastState[EditorUndoActions.TypeID].Value === this.UndoType.SelectedEntityMod) {
                this.RedoActions[this.RedoActions.length] = this.SnapshotSelectedEntities(Editor, LastState[EditorUndoActions.ReferenceEntitiesID].Value);
                this.RestoreEntities(Editor, LastState)
            }
            if (LastState[EditorUndoActions.TypeID].Value === this.UndoType.LayerPositionMod) {
                var Shift = new Vector2;
                Shift.x = -LastState[EditorUndoActions.LayerModifierID].Value.x;
                Shift.y = -LastState[EditorUndoActions.LayerModifierID].Value.y;
                this.RedoActions[this.RedoActions.length] = this.SnapshotLayerPosition(Editor, Shift);
                this.RestoreLayerPosition(Editor, LastState)
            }
            if (LastState[EditorUndoActions.TypeID].Value === this.UndoType.EntityDepthMod) {
                var Params = [!LastState[EditorUndoActions.DepthForwardID].Value, !LastState[EditorUndoActions.DepthToEndID].Value];
                this.RedoActions[this.RedoActions.length] = this.SnapshotDepth(Editor, Params);
                this.RestoreDepth(Editor, LastState)
            }
            if (LastState[EditorUndoActions.TypeID].Value === this.UndoType.EntityDeleteMod) {
                this.RedoActions[this.RedoActions.length] = this.SnapshotDeletedEntities(Editor, LastState);
                this.RestoreDeletedEntities(Editor, LastState, false)
            }
            if (LastState[EditorUndoActions.TypeID].Value === this.UndoType.EntityPlaceMod) {
                this.RedoActions[this.RedoActions.length] = this.SnapshotPlacingEntities(Editor, null, LastState);
                this.RestoreDeletedEntities(Editor, LastState, true)
            }
            if (LastState[EditorUndoActions.TypeID].Value === this.UndoType.EntityGroupMod) {
                this.RedoActions[this.RedoActions.length] = this.SnapshotGroupEntities(Editor, LastState[EditorUndoActions.ReferenceEntitiesID].Value);
                this.RestoreGroupEntities(Editor, LastState)
            }
            if (LastState[EditorUndoActions.TypeID].Value === this.UndoType.EntitySwapMod) {
                this.RedoActions[this.RedoActions.length] = this.SnapshotSwapEntities(Editor, LastState, false);
                this.RestoreSwapEntities(Editor, LastState)
            }
            this.UndoActions.splice(this.UndoActions.length - 1, 1)
        },
        Redo: function RedoFn(Editor) {
            if (this.RedoActions.length === 0) {
                return
            }
            var FutureState = this.RedoActions[this.RedoActions.length - 1];
            if (FutureState[EditorUndoActions.TypeID].Value === this.UndoType.SelectedEntityMod) {
                this.UndoActions[this.UndoActions.length] = this.SnapshotSelectedEntities(Editor, FutureState[EditorUndoActions.ReferenceEntitiesID].Value);
                this.RestoreEntities(Editor, FutureState)
            }
            if (FutureState[EditorUndoActions.TypeID].Value === this.UndoType.LayerPositionMod) {
                var Shift = new Vector2;
                Shift.x = -FutureState[EditorUndoActions.LayerModifierID].Value.x;
                Shift.y = -FutureState[EditorUndoActions.LayerModifierID].Value.y;
                this.UndoActions[this.UndoActions.length] = this.SnapshotLayerPosition(Editor, Shift);
                this.RestoreLayerPosition(Editor, FutureState)
            }
            if (FutureState[EditorUndoActions.TypeID].Value === this.UndoType.EntityDepthMod) {
                var Params = [!FutureState[EditorUndoActions.DepthForwardID].Value, !FutureState[EditorUndoActions.DepthToEndID].Value];
                this.UndoActions[this.UndoActions.length] = this.SnapshotDepth(Editor, Params);
                this.RestoreDepth(Editor, FutureState)
            }
            if (FutureState[EditorUndoActions.TypeID].Value === this.UndoType.EntityDeleteMod) {
                this.UndoActions[this.UndoActions.length] = this.SnapshotDeletedEntities(Editor, FutureState);
                this.RestoreDeletedEntities(Editor, FutureState, true)
            }
            if (FutureState[EditorUndoActions.TypeID].Value === this.UndoType.EntityPlaceMod) {
                this.UndoActions[this.UndoActions.length] = this.SnapshotPlacingEntities(Editor, null, FutureState);
                this.RestoreDeletedEntities(Editor, FutureState, false)
            }
            if (FutureState[EditorUndoActions.TypeID].Value === this.UndoType.EntityGroupMod) {
                this.UndoActions[this.UndoActions.length] = this.SnapshotGroupEntities(Editor, FutureState[EditorUndoActions.ReferenceEntitiesID].Value);
                this.RestoreGroupEntities(Editor, FutureState)
            }
            if (FutureState[EditorUndoActions.TypeID].Value === this.UndoType.EntitySwapMod) {
                this.UndoActions[this.UndoActions.length] = this.SnapshotSwapEntities(Editor, FutureState, false);
                this.RestoreSwapEntities(Editor, FutureState)
            }
            this.RedoActions.splice(this.RedoActions.length - 1, 1)
        },
        AddToUndo: function AddUndoFn(Editor, Type, VaArgs) {
            if (Type === undefined) {
                Debug.Assert(false, "PROBLEM! UNDO - No Type passed in!");
                return
            }
            this.RedoActions = [];
            if (Type === this.UndoType.SelectedEntityMod) {
                this.UndoActions[this.UndoActions.length] = this.SnapshotSelectedEntities(Editor, VaArgs)
            }
            if (Type === this.UndoType.LayerPositionMod) {
                this.UndoActions[this.UndoActions.length] = this.SnapshotLayerPosition(Editor, VaArgs)
            }
            if (Type === this.UndoType.EntityDepthMod) {
                this.UndoActions[this.UndoActions.length] = this.SnapshotDepth(Editor, VaArgs)
            }
            if (Type === this.UndoType.EntityDeleteMod) {
                this.UndoActions[this.UndoActions.length] = this.SnapshotDeletedEntities(Editor)
            }
            if (Type === this.UndoType.EntityPlaceMod) {
                this.UndoActions[this.UndoActions.length] = this.SnapshotPlacingEntities(Editor, VaArgs)
            }
            if (Type === this.UndoType.EntityGroupMod) {
                this.UndoActions[this.UndoActions.length] = this.SnapshotGroupEntities(Editor, VaArgs)
            }
            if (Type === this.UndoType.EntitySwapMod) {
                this.UndoActions[this.UndoActions.length] = this.SnapshotSwapEntities(Editor, VaArgs, true)
            }
        },
        SnapshotSelectedEntities: function SnapshotType1Fn(Editor, KeyEntities) {
            var EntitiesRef = [];
            var i = 0;
            for (i = 0; i < KeyEntities.length; i += 1) {
                EntitiesRef[i] = KeyEntities[i]
            }
            var Entities = [];
            for (i = 0; i < EntitiesRef.length; i += 1) {
                var Editables = [];
                var EntityType = EntityTypeManager.TypesRegistered[EntitiesRef[i].TypeID];
                if (EntityType.EditableVariables) {
                    var j = 0;
                    for (j = 0; j < EntityType.EditableVariables.length; j += 1) {
                        Editables[j] = EntitiesRef[i].EditableVariables[j]
                    }
                }
                var Colour = [],
                    ActualColour = EntitiesRef[i].GetColour();
                Colour[0] = ActualColour[0];
                Colour[1] = ActualColour[1];
                Colour[2] = ActualColour[2];
                Colour[3] = ActualColour[3];
                var EntityDetails = [{
                    Name: "PositionX",
                    Value: EntitiesRef[i].StartX
                }, {
                    Name: "PositionY",
                    Value: EntitiesRef[i].StartY
                }, {
                    Name: "ScaleX",
                    Value: EntitiesRef[i].StartScaleX
                }, {
                    Name: "ScaleY",
                    Value: EntitiesRef[i].StartScaleY
                }, {
                    Name: "Rotation",
                    Value: EntitiesRef[i].StartRotation
                }, {
                    Name: "Name",
                    Value: EntitiesRef[i].Name
                }, {
                    Name: "OffsetX",
                    Value: Editor.BrushOffsetX[i]
                }, {
                    Name: "OffsetY",
                    Value: Editor.BrushOffsetY[i]
                }, {
                    Name: "Colour",
                    Value: Colour
                }, {
                    Name: "EditVars",
                    Value: Editables
                }];
                if (EntitiesRef[i].Box2DBody) {
                    EntityDetails[10] = {
                        Name: "Mass",
                        Value: Physics.GetBodyMass(EntitiesRef[i].Box2DBody)
                    }
                }
                Entities[i] = EntityDetails
            }
            var PreviousState = [{
                Name: "Type",
                Value: this.UndoType.SelectedEntityMod
            }, {
                Name: "ReferenceEntities",
                Value: EntitiesRef
            }, {
                Name: "ValueEntities",
                Value: Entities
            }, {
                Name: "ValueLayer",
                Value: Editor.CurrentLayer
            }];
            return PreviousState
        },
        RestoreEntities: function RestoreType1Fn(Editor, LastState) {
            var i = 0,
                j = 0;
            for (i = 0; i < LastState[EditorUndoActions.ReferenceEntitiesID].Value.length; i += 1) {
                if (LastState[EditorUndoActions.ReferenceEntitiesID].Value[i]) {
                    var EntityInfo = LastState[EditorUndoActions.ValueEntitiesID].Value[i];
                    LastState[EditorUndoActions.ReferenceEntitiesID].Value[i].StartX = EntityInfo[EditorUndoActions.PosX].Value;
                    LastState[EditorUndoActions.ReferenceEntitiesID].Value[i].StartY = EntityInfo[EditorUndoActions.PosY].Value;
                    LastState[EditorUndoActions.ReferenceEntitiesID].Value[i].StartScaleX = EntityInfo[EditorUndoActions.ScaleX].Value;
                    LastState[EditorUndoActions.ReferenceEntitiesID].Value[i].StartScaleY = EntityInfo[EditorUndoActions.ScaleY].Value;
                    LastState[EditorUndoActions.ReferenceEntitiesID].Value[i].StartRotation = EntityInfo[EditorUndoActions.Rotation].Value;
                    LastState[EditorUndoActions.ReferenceEntitiesID].Value[i].Name = EntityInfo[EditorUndoActions.Name].Value;
                    if (LastState[EditorUndoActions.ReferenceEntitiesID].Value[i].Box2DBody) {
                        Physics.SetBodyMass(LastState[EditorUndoActions.ReferenceEntitiesID].Value[i].Box2DBody, EntityInfo[EditorUndoActions.Mass].Value)
                    }
                    Editor.BrushOffsetX[i] = EntityInfo[EditorUndoActions.OffsetX].Value;
                    Editor.BrushOffsetY[i] = EntityInfo[EditorUndoActions.OffsetY].Value;
                    LastState[EditorUndoActions.ReferenceEntitiesID].Value[i].SetColour(EntityInfo[EditorUndoActions.Colour].Value);
                    if (EntityInfo[EditorUndoActions.EditableVars].Value) {
                        for (j = 0; j < EntityInfo[EditorUndoActions.EditableVars].Value.length; j += 1) {
                            LastState[EditorUndoActions.ReferenceEntitiesID].Value[i].SetEditableVariable(j, EntityInfo[EditorUndoActions.EditableVars].Value[j])
                        }
                    }
                    LastState[EditorUndoActions.ReferenceEntitiesID].Value[i].Reset();
                    var Layer = LastState[EditorUndoActions.ValueLayerID].Value;
                    Editor.World.GetLayer(Layer).UpdateEntity(LastState[EditorUndoActions.ReferenceEntitiesID].Value[i])
                }
            }
        },
        SnapshotLayerPosition: function SnapshotType2Fn(Editor, VaArgs) {
            var PreviousState = [{
                Name: "Type",
                Value: this.UndoType.LayerPositionMod
            }, {
                Name: "LayerShift",
                Value: VaArgs
            }, {
                Name: "Layer",
                Value: Editor.CurrentLayer
            }];
            return PreviousState
        },
        RestoreLayerPosition: function RestoreType2Fn(Editor, LastState) {
            Editor.CurrentLayer = LastState[EditorUndoActions.LayerID].Value;
            var Layer = Editor.World.GetLayer(Editor.CurrentLayer);
            Layer.ShiftLayerContents(LastState[EditorUndoActions.LayerModifierID].Value)
        },
        SnapshotDepth: function SnapshotType3Fn(Editor, VaArgs) {
            var EntitiesRef = [];
            var i = 0;
            for (i = 0; i < Editor.SelectionEntities.length; i += 1) {
                EntitiesRef[i] = Editor.SelectionEntities[i]
            }
            var PreviousState = [{
                Name: "Type",
                Value: this.UndoType.EntityDepthMod
            }, {
                Name: "ReferenceEntities",
                Value: EntitiesRef
            }, {
                Name: "Forward",
                Value: VaArgs[0]
            }, {
                Name: "ToEnd",
                Value: VaArgs[1]
            }];
            return PreviousState
        },
        RestoreDepth: function RestoreType3Fn(Editor, LastState) {
            var Layer = Editor.World.GetLayer(Editor.CurrentLayer);
            var i = 0;
            for (i = 0; i < LastState[EditorUndoActions.ReferenceEntitiesID].Value.length; i += 1) {
                if (LastState[EditorUndoActions.ReferenceEntitiesID].Value[i]) {
                    var Forward = LastState[EditorUndoActions.DepthForwardID].Value;
                    var ToEnd = LastState[EditorUndoActions.DepthToEndID].Value;
                    Layer.ChangeEntityDepth(LastState[EditorUndoActions.ReferenceEntitiesID].Value[i], Forward, ToEnd)
                }
            }
        },
        SnapshotDeletedEntities: function SnapshotType4Fn(Editor, LastState) {
            var Entities = [];
            var EntityParentChildPosition = [];
            var i = 0,
                j = 0,
                Parents = 0;
            for (i = 0; i < Editor.SelectionEntities.length; i += 1) {
                Entities[i] = Editor.SelectionEntities[i];
                Parents = Editor.World.FindEntityParents(Entities[i]);
                EntityParentChildPosition[i] = [];
                for (j = 0; j < Parents.length; j += 1) {
                    EntityParentChildPosition[i][j] = {
                        Parent: Parents[j],
                        Position: Parents[j].Children.indexOf(Entities[i])
                    }
                }
            }
            if (LastState) {
                for (i = 0; i < LastState[EditorUndoActions.DeletedEntsID].Value.length; i += 1) {
                    Entities[i] = LastState[EditorUndoActions.DeletedEntsID].Value[i];
                    Parents = Editor.World.FindEntityParents(LastState[EditorUndoActions.DeletedEntsID].Value[i]);
                    EntityParentChildPosition[i] = [];
                    for (j = 0; j < Parents.length; j += 1) {
                        EntityParentChildPosition[i][j] = {
                            Parent: Parents[j],
                            Position: Parents[j].Children.indexOf(LastState[EditorUndoActions.DeletedEntsID].Value[i])
                        }
                    }
                }
            }
            var PreviousState = [{
                Name: "Type",
                Value: this.UndoType.EntityDeleteMod
            }, {
                Name: "DeletedEntities",
                Value: Entities
            }, {
                Name: "Layer",
                Value: Editor.CurrentLayer
            }, {
                Name: "ParentPosition",
                Value: EntityParentChildPosition
            }];
            return PreviousState
        },
        RestoreDeletedEntities: function RestoreType4Fn(Editor, LastState, Remove) {
            var Layer = LastState[EditorUndoActions.DeletedLayerID].Value;
            var i = 0,
                j = 0;
            if (!Remove) {
                for (i = 0; i < LastState[EditorUndoActions.DeletedEntsID].Value.length; i += 1) {
                    Editor.World.GetLayer(Layer).AddEntity(LastState[EditorUndoActions.DeletedEntsID].Value[i]);
                    LastState[EditorUndoActions.DeletedEntsID].Value[i].UnDelete();
                    if (LastState[EditorUndoActions.DeletedParentPositionID]) {
                        var ParentInfo = LastState[EditorUndoActions.DeletedParentPositionID].Value;
                        for (j = 0; j < ParentInfo[i].length; j += 1) {
                            var Parent = ParentInfo[i][j].Parent;
                            var Position = ParentInfo[i][j].Position;
                            Parent.Children.splice(Position, 0, LastState[EditorUndoActions.DeletedEntsID].Value[i])
                        }
                    }
                }
            } else {
                for (i = 0; i < LastState[EditorUndoActions.DeletedEntsID].Value.length; i += 1) {
                    Editor.World.GetLayer(Layer).RemoveEntity(LastState[EditorUndoActions.DeletedEntsID].Value[i]);
                    LastState[EditorUndoActions.DeletedEntsID].Value[i].Delete()
                }
                for (i = 0; i < LastState[EditorUndoActions.DeletedEntsID].Value.length; i += 1) {
                    var Parents = Editor.World.FindEntityParents(LastState[EditorUndoActions.DeletedEntsID].Value[i]);
                    for (j = 0; j < Parents.length; j += 1) {
                        Parents[j].RemoveChild(LastState[EditorUndoActions.DeletedEntsID].Value[i])
                    }
                    if (LastState[EditorUndoActions.DeletedEntsID].Value[i].Children) {
                        while (LastState[EditorUndoActions.DeletedEntsID].Value[i].Children.length > 0) {
                            LastState[EditorUndoActions.DeletedEntsID].Value[i].RemoveChild(LastState[EditorUndoActions.DeletedEntsID].Value[i].Children[0])
                        }
                    }
                }
            }
        },
        SnapshotPlacingEntities: function SnapshotType5Fn(Editor, VaArgs, LastState) {
            var Entities = [];
            var i = 0;
            if (VaArgs !== null) {
                for (i = 0; i < VaArgs.length; i += 1) {
                    Entities[i] = VaArgs[i]
                }
            } else {
                for (i = 0; i < LastState[EditorUndoActions.DeletedEntsID].Value.length; i += 1) {
                    Entities[i] = LastState[EditorUndoActions.DeletedEntsID].Value[i]
                }
            }
            var PreviousState = [{
                Name: "Type",
                Value: this.UndoType.EntityPlaceMod
            }, {
                Name: "DeletedEntities",
                Value: Entities
            }, {
                Name: "Layer",
                Value: Editor.CurrentLayer
            }];
            return PreviousState
        },
        SnapshotGroupEntities: function SnapshotType6Fn(Editor, VaArgs) {
            var ChildArray = [];
            if (VaArgs.Children) {
                var j = 0;
                for (j = 0; j < VaArgs.Children.length; j += 1) {
                    ChildArray[j] = VaArgs.Children[j]
                }
            }
            var PreviousState = [{
                Name: "Type",
                Value: this.UndoType.EntityGroupMod
            }, {
                Name: "ReferenceEntities",
                Value: VaArgs
            }, {
                Name: "ValueEntities",
                Value: ChildArray
            }];
            return PreviousState
        },
        RestoreGroupEntities: function RestoreType6Fn(Editor, LastState) {
            var PreviousChildren = LastState[EditorUndoActions.ChildEntitiesID].Value;
            var CurrentChildren = LastState[EditorUndoActions.ReferenceEntitiesID].Value.Children;
            var PreviousChildrenAmount = 0;
            var CurrentChildrenAmount = 0;
            if (PreviousChildren) {
                PreviousChildrenAmount = PreviousChildren.length
            }
            if (CurrentChildren) {
                CurrentChildrenAmount = CurrentChildren.length
            }
            var i = 0;
            if (PreviousChildrenAmount !== 0 && CurrentChildrenAmount !== 0) {
                var FoundDifference = false;
                for (i = PreviousChildrenAmount - 1; i > -1; i -= 1) {
                    if (CurrentChildren.indexOf(PreviousChildren[i]) === -1) {
                        LastState[EditorUndoActions.ReferenceEntitiesID].Value.AddChild(PreviousChildren[i]);
                        FoundDifference = true
                    }
                }
                if (!FoundDifference) {
                    for (i = CurrentChildrenAmount - 1; i > -1; i -= 1) {
                        if (PreviousChildren.indexOf(CurrentChildren[i]) === -1) {
                            LastState[EditorUndoActions.ReferenceEntitiesID].Value.RemoveChild(CurrentChildren[i])
                        }
                    }
                }
            } else {
                if (PreviousChildrenAmount === 0 && CurrentChildrenAmount !== 0) {
                    for (i = CurrentChildrenAmount - 1; i > -1; i -= 1) {
                        LastState[EditorUndoActions.ReferenceEntitiesID].Value.RemoveChild(CurrentChildren[i])
                    }
                }
                if (PreviousChildrenAmount !== 0 && CurrentChildrenAmount === 0) {
                    for (i = PreviousChildrenAmount - 1; i > -1; i -= 1) {
                        LastState[EditorUndoActions.ReferenceEntitiesID].Value.AddChild(PreviousChildren[i])
                    }
                }
            }
        },
        SnapshotSwapEntities: function SnapshotType7Fn(Editor, VaArgs, FirstTime) {
            var OldEntities = [],
                NewEntities = [];
            var EntityParentChildPosition = [],
                Parents = [];
            var i = 0,
                j = 0;
            for (i = 0; i < Editor.SelectionEntities.length; i += 1) {
                OldEntities[i] = Editor.SelectionEntities[i];
                Parents = Editor.World.FindEntityParents(Editor.SelectionEntities[i]);
                EntityParentChildPosition[i] = [];
                for (j = 0; j < Parents.length; j += 1) {
                    EntityParentChildPosition[i][j] = {
                        Parent: Parents[j],
                        Position: Parents[j].Children.indexOf(Editor.SelectionEntities[i])
                    }
                }
            }
            for (i = 0; i < VaArgs.length; i += 1) {
                if (FirstTime) {
                    NewEntities[i] = VaArgs[i]
                }
            }
            if (VaArgs[EditorUndoActions.NewEntsID] && !FirstTime) {
                OldEntities = [];
                NewEntities = [];
                for (i = 0; i < VaArgs[EditorUndoActions.NewEntsID].Value.length; i += 1) {
                    OldEntities[i] = VaArgs[EditorUndoActions.NewEntsID].Value[i];
                    Parents = Editor.World.FindEntityParents(VaArgs[EditorUndoActions.DeletedEntsID].Value[i]);
                    EntityParentChildPosition[i] = [];
                    for (j = 0; j < Parents.length; j += 1) {
                        EntityParentChildPosition[i][j] = {
                            Parent: Parents[j],
                            Position: Parents[j].Children.indexOf(VaArgs[EditorUndoActions.DeletedEntsID].Value[i])
                        }
                    }
                }
                for (i = 0; i < VaArgs[EditorUndoActions.OldEntsID].Value.length; i += 1) {
                    NewEntities[i] = VaArgs[EditorUndoActions.OldEntsID].Value[i]
                }
            }
            var PreviousState = [{
                Name: "Type",
                Value: this.UndoType.EntitySwapMod
            }, {
                Name: "OldEntities",
                Value: OldEntities
            }, {
                Name: "Layer",
                Value: Editor.CurrentLayer
            }, {
                Name: "ParentPosition",
                Value: EntityParentChildPosition
            }, {
                Name: "NewEntities",
                Value: NewEntities
            }];
            return PreviousState
        },
        RestoreSwapEntities: function RestoreType7Fn(Editor, LastState, Remove) {
            var Layer = LastState[EditorUndoActions.DeletedLayerID].Value;
            var i = 0,
                j = 0;
            for (i = 0; i < LastState[EditorUndoActions.OldEntsID].Value.length; i += 1) {
                Editor.World.GetLayer(Layer).AddEntity(LastState[EditorUndoActions.OldEntsID].Value[i]);
                LastState[EditorUndoActions.OldEntsID].Value[i].UnDelete();
                var ParentInfo = LastState[EditorUndoActions.DeletedParentPositionID].Value;
                for (j = 0; j < ParentInfo[i].length; j += 1) {
                    var Parent = ParentInfo[i][j].Parent;
                    var Position = ParentInfo[i][j].Position;
                    Parent.Children.splice(Position, 0, LastState[EditorUndoActions.OldEntsID].Value[i])
                }
            }
            for (i = 0; i < LastState[EditorUndoActions.NewEntsID].Value.length; i += 1) {
                Editor.World.GetLayer(Layer).RemoveEntity(LastState[EditorUndoActions.NewEntsID].Value[i]);
                LastState[EditorUndoActions.NewEntsID].Value[i].Delete()
            }
        },
        Init: function InitFn() {
            this.UndoActions = [];
            this.RedoActions = []
        }
    };
    EditorUndoActions.Create = function EditorGeneralCreateFn() {
        var NewObject = new EditorUndoActions;
        NewObject.UndoActions = [];
        NewObject.RedoActions = [];
        return NewObject
    };

    function UI() {}
    UI.prototype = {
        itemType: {
            empty: 0,
            box: 1,
            textbox: 2,
            brush: 3,
            checkbox: 4,
            button: 5,
            editbox: 6,
            minimap: 7,
            collbox: 8,
            checktextbox: 9,
            okcancelbox: 10,
            combobox: 11,
            confirmbox: 12,
            palette: 13,
            loadsavebox: 14,
            slider: 15,
            dropdownbox: 16
        },
        AddDialogBox: function AddBoxFn(X, Y, Width, Height) {
            for (var i = 0; i < this.Objects.length; i += 1) {
                if (this.ItemTypes[i] === this.itemType.box) {
                    Debug.Assert(false, "AddDialogBox - You already have a dialog box in this UI Item")
                }
            }
            if (Width === undefined) {
                Width = 500
            }
            if (X === undefined) {
                X = JamSystem.RenderManager.GetScreenWidth() / 2 - Width / 2
            }
            if (Height === undefined) {
                Height = JamSystem.RenderManager.GetScreenHeight() / 2
            }
            if (Y === undefined) {
                Y = JamSystem.RenderManager.GetScreenHeight() / 2 - Height / 2
            }
            Debug.Assert(typeof X === "number" && typeof Y === "number" && typeof Width === "number" && typeof Height === "number", "PROBLEM! AddTextBox - vars do not match type!");
            var BoxUI = UIBox.Create();
            var BackingItem = BoxUI.AddDialogBox(X, Y, Width, Height, this.RootTree);
            var CurrItem = this.Objects.length;
            this.Objects[CurrItem] = BoxUI;
            this.ItemTypes[CurrItem] = this.itemType.box;
            return BoxUI
        },
        AddPaletteBox: function AddPalBoxFn(Label, Colour, Index, RHS, Width, Category) {
            for (var i = 0; i < this.Objects.length; i += 1) {
                if (this.ItemTypes[i] === this.itemType.palette) {
                    Debug.Assert(false, "AddPaletteBox - You already have a palette box in this UI Item")
                }
            }
            if (Width === undefined) {
                Width = 180
            }
            Debug.Assert(Index !== undefined && Colour !== undefined && Label !== undefined && RHS !== undefined, "PROBLEM! AddPaletteBox - undefined vars!");
            var PaletteUI = 0;
            var BackingItem = 0;
            if (Category) {
                PaletteUI = UIPaletteCategory.Create();
                BackingItem = PaletteUI.AddPalette(Label, Colour, Width, this.RootTree, Index, RHS)
            } else {
                PaletteUI = UIPalette.Create();
                BackingItem = PaletteUI.AddPalette(Label, Colour, Width, this.RootTree, Index, RHS)
            }
            var CurrItem = this.Objects.length;
            this.Objects[CurrItem] = PaletteUI;
            this.ItemTypes[CurrItem] = this.itemType.palette;
            return PaletteUI
        },
        AddConfirmationBox: function AddConfirmBoxFn() {
            var ConfirmBoxUI = UIConfirmationBox.Create();
            var BoxItem = ConfirmBoxUI.AddBox(this.RootTree);
            var CurrItem = this.Objects.length;
            this.Objects[CurrItem] = ConfirmBoxUI;
            this.ItemTypes[CurrItem] = this.itemType.confirmbox;
            return ConfirmBoxUI
        },
        AddLoadSaveBox: function AddLoadSaveBoxFn(Type) {
            var LoadSaveUI = UIFileBox.Create();
            if (!Type) {
                Type = UIFileBox.LoadingType
            }
            var BoxItem = LoadSaveUI.AddBox(Type, this.RootTree);
            var CurrItem = this.Objects.length;
            this.Objects[CurrItem] = LoadSaveUI;
            this.ItemTypes[CurrItem] = this.itemType.loadsavebox;
            return LoadSaveUI
        },
        AddTextBox: function AddTextBoxFn(Text, X, Y, CentreAlign, RHSAlign) {
            if (RHSAlign === undefined) {
                RHSAlign = false
            }
            if (CentreAlign === undefined) {
                CentreAlign = false
            }
            var TextUI = UITextBox.Create();
            var BoxUI = 0;
            if (X === undefined && Y === undefined) {
                BoxUI = this.GetBoxUI();
                X = BoxUI.NextItemPosition.x + BoxUI.Item.GetPositionX();
                Y = BoxUI.NextItemPosition.y + BoxUI.Item.GetPositionY();
                BoxUI.GenerateNextItemPosition()
            }
            Debug.Assert(typeof Text === "string" && typeof X === "number" && typeof Y === "number" && typeof RHSAlign === "boolean", "PROBLEM! UI, AddTextBox - vars do not match type!");
            TextUI.AddTextBoxItem(X, Y, Text, CentreAlign, RHSAlign, this.RootTree);
            if (BoxUI) {
                BoxUI.ObjectsAttached[BoxUI.ObjectsAttached.length] = TextUI
            }
            var CurrItem = this.Objects.length;
            this.Objects[CurrItem] = TextUI;
            this.ItemTypes[CurrItem] = this.itemType.textbox;
            return TextUI
        },
        AddCheckBox: function AddCheckBoxFn(X, Y) {
            var CheckUI = UICheckBox.Create();
            var CheckBackingItem = CheckUI.AddCheckItem(X, Y, this.RootTree);
            var CurrItem = this.Objects.length;
            this.Objects[CurrItem] = CheckUI;
            this.ItemTypes[CurrItem] = this.itemType.checkbox;
            return CheckUI
        },
        AddCheckTextBox: function AddCheckTextBoxFn(Text, X, Y) {
            var CheckTextBoxUI = UICheckTextBox.Create();
            var BoxUI = 0;
            if (X === undefined && Y === undefined) {
                BoxUI = this.GetBoxUI();
                X = BoxUI.NextItemPosition.x + BoxUI.Item.GetPositionX();
                Y = BoxUI.NextItemPosition.y + BoxUI.Item.GetPositionY();
                BoxUI.GenerateNextItemPosition()
            }
            var CheckTextItem = CheckTextBoxUI.AddCheckTextBox(Text, X, Y, this.RootTree);
            if (BoxUI) {
                BoxUI.ObjectsAttached[BoxUI.ObjectsAttached.length] = CheckTextBoxUI
            }
            var CurrItem = this.Objects.length;
            this.Objects[CurrItem] = CheckTextBoxUI;
            this.ItemTypes[CurrItem] = this.itemType.checktextbox;
            return CheckTextBoxUI
        },
        AddButton: function AddButtonFn(VaArg, IsGraphic, X, Y) {
            var ButtonUI = UIButton.Create();
            var BoxUI = this.GetBoxUI();
            if (X === undefined && Y === undefined) {
                X = BoxUI.NextItemPosition.x + BoxUI.Item.GetPositionX();
                Y = BoxUI.NextItemPosition.y + BoxUI.Item.GetPositionY();
                BoxUI.GenerateNextItemPosition()
            }
            if (IsGraphic === undefined) {
                IsGraphic = false
            }
            var ButtonItem = ButtonUI.AddButton(X, Y, VaArg, IsGraphic, this.RootTree);
            if (BoxUI) {
                BoxUI.ObjectsAttached[BoxUI.ObjectsAttached.length] = ButtonUI
            }
            var CurrItem = this.Objects.length;
            this.Objects[CurrItem] = ButtonUI;
            this.ItemTypes[CurrItem] = this.itemType.button;
            return ButtonUI
        },
        AddEditBox: function AddEditBoxFn(Label, EditType, Shift, X, Y) {
            var EditUI = UIEditBox.Create();
            var BoxUI = 0;
            if (X === undefined && Y === undefined) {
                BoxUI = this.GetBoxUI();
                X = BoxUI.NextItemPosition.x + BoxUI.Item.GetPositionX();
                Y = BoxUI.NextItemPosition.y + BoxUI.Item.GetPositionY();
                BoxUI.GenerateNextItemPosition()
            }
            if (Label === undefined) {
                Label = "No Label"
            }
            if (EditType === undefined) {
                EditType = UIEditBox.prototype.editBoxType.Normal
            }
            var EditItem = EditUI.AddEditBoxItem(X, Y, EditType, Label, Shift, this.RootTree);
            if (BoxUI) {
                BoxUI.ObjectsAttached[BoxUI.ObjectsAttached.length] = EditUI
            }
            var CurrItem = this.Objects.length;
            this.Objects[CurrItem] = EditUI;
            this.ItemTypes[CurrItem] = this.itemType.editbox;
            return EditUI
        },
        AddSlider: function AddSliderFn(Label, Min, Max, Shift, X, Y) {
            var SliderUI = UISlider.Create();
            var BoxUI = 0;
            if (X === undefined && Y === undefined) {
                BoxUI = this.GetBoxUI();
                X = BoxUI.NextItemPosition.x + BoxUI.Item.GetPositionX();
                Y = BoxUI.NextItemPosition.y + BoxUI.Item.GetPositionY();
                BoxUI.GenerateNextItemPosition()
            }
            if (Label === undefined) {
                Label = "No Label"
            }
            if (Min === undefined) {
                Min = 0
            }
            if (Max === undefined) {
                Max = 1
            }
            var SlideItem = SliderUI.AddSliderItem(X, Y, Label, Min, Max, Shift, this.RootTree);
            if (BoxUI) {
                BoxUI.ObjectsAttached[BoxUI.ObjectsAttached.length] = SliderUI
            }
            var CurrItem = this.Objects.length;
            this.Objects[CurrItem] = SliderUI;
            this.ItemTypes[CurrItem] = this.itemType.slider;
            return SliderUI
        },
        AddCollisionBox: function AddCollFn(BrushInfo) {
            var CollUI = UICollisionBox.Create();
            var CollBackingItem = CollUI.AddCollisionBox(BrushInfo, this.RootTree);
            var CurrItem = this.Objects.length;
            this.Objects[CurrItem] = CollUI;
            this.ItemTypes[CurrItem] = this.itemType.collbox;
            return CollUI
        },
        AddComboBox: function AddComboBoxFn(TextItems, Label, Shift, X, Y) {
            var ComboUI = UIComboBox.Create();
            var BoxUI = 0;
            if (X === undefined && Y === undefined) {
                BoxUI = this.GetBoxUI();
                X = BoxUI.NextItemPosition.x + BoxUI.Item.GetPositionX();
                Y = BoxUI.NextItemPosition.y + BoxUI.Item.GetPositionY();
                BoxUI.GenerateNextItemPosition()
            }
            var ComboBackingItem = ComboUI.AddComboBox(X, Y, TextItems, Label, Shift, this.RootTree);
            if (BoxUI) {
                BoxUI.ObjectsAttached[BoxUI.ObjectsAttached.length] = ComboUI
            }
            var CurrItem = this.Objects.length;
            this.Objects[CurrItem] = ComboUI;
            this.ItemTypes[CurrItem] = this.itemType.combobox;
            return ComboUI
        },
        AddDropDownBox: function AddDropDownBoxFn(TextItems, X, Y) {
            var DropUI = UIDropDownBox.Create();
            if (X === undefined && Y === undefined) {
                X = Y = 300
            }
            DropUI.AddDropBox(X, Y, TextItems, this.RootTree);
            var CurrItem = this.Objects.length;
            this.Objects[CurrItem] = DropUI;
            this.ItemTypes[CurrItem] = this.itemType.dropdownbox;
            return DropUI
        },
        GetBoxUI: function GetBoxUIFn() {
            for (var i = 0; i < this.Objects.length; i += 1) {
                if (this.ItemTypes[i] === this.itemType.box || this.ItemTypes[i] === this.itemType.palette) {
                    return this.Objects[i]
                }
            }
            Debug.Assert(false, "PROBLEM! This UI item has no base box/palette to add to")
        },
        ShiftBoxTo: function ShiftBoxFn(X, Y) {
            this.RootTree.SetPosition(X, Y)
        },
        CheckSuperCollision: function CheckCollSuperFn(X, Y) {
            var j = 0;
            for (j = this.Objects.length - 1; j > -1; j -= 1) {
                if (this.Objects[j].isSuperFocused) {
                    if (JamSystem.InputManager.GetMouseButtonReleased(0) && !this.WaitForRelease) {
                        if (this.Objects[j].CheckCollision(X, Y)) {
                            return this.ItemTypes[j]
                        }
                    }
                    if (JamSystem.InputManager.GetMouseButtonPressed(0)) {
                        if (this.ItemTypes[j] === this.itemType.collbox || this.ItemTypes[j] === this.itemType.combobox) {
                            if (this.Objects[j].CheckCollisionPressed(X, Y)) {
                                this.WaitForRelease = true;
                                return this.ItemTypes[j]
                            }
                        }
                    }
                    if (!JamSystem.InputManager.GetMouseButtonHeld(0) && this.WaitForRelease) {
                        this.WaitForRelease = false
                    }
                }
            }
        },
        CheckCollision: function CheckCollLeftFn(X, Y) {
            var i = 0,
                k = 0;
            for (k = this.Objects.length - 1; k > -1; k -= 1) {
                if (this.Objects[k].isFocused && this.Objects[k].IsMouseOver(X, Y)) {
                    if (JamSystem.InputManager.GetMouseButtonReleased(0)) {
                        if (this.Objects[k].CheckCollision(X, Y)) {
                            return this.ItemTypes[k]
                        }
                    }
                }
            }
            for (i = this.Objects.length - 1; i > -1; i -= 1) {
                if (this.Objects[i].IsVisible() && this.Objects[i].IsMouseOver(X, Y)) {
                    if (JamSystem.InputManager.GetMouseButtonReleased(0) && !this.WaitForRelease) {
                        if (this.Objects[i].CheckCollision(X, Y)) {
                            return this.ItemTypes[i]
                        }
                    }
                    if (JamSystem.InputManager.GetMouseButtonPressed(0)) {
                        if (this.ItemTypes[i] === this.itemType.box || this.ItemTypes[i] === this.itemType.palette || this.ItemTypes[i] === this.itemType.slider) {
                            if (this.Objects[i].CheckCollisionPressed(X, Y)) {
                                this.WaitForRelease = true;
                                return this.ItemTypes[i]
                            }
                        }
                    }
                    if (!JamSystem.InputManager.GetMouseButtonHeld(0) && this.WaitForRelease) {
                        this.WaitForRelease = false
                    }
                }
            }
        },
        Update: function UpdateFn(TimeDelta, MouseX, MouseY) {
            var i = 0;
            for (i = 0; i < this.Objects.length; i += 1) {
                if (this.Objects[i].isFocused) {
                    this.Objects[i].Update(TimeDelta, MouseX, MouseY);
                    return
                }
            }
            for (i = 0; i < this.Objects.length; i += 1) {
                this.Objects[i].Update(TimeDelta, MouseX, MouseY)
            }
        },
        IsSuperFocused: function SuperFocusFn() {
            for (var i = 0; i < this.Objects.length; i += 1) {
                if (this.Objects[i].isSuperFocused) {
                    return this.ItemTypes[i]
                }
            }
        },
        IsFocused: function FocusFn() {
            for (var i = 0; i < this.Objects.length; i += 1) {
                if (this.Objects[i].isFocused) {
                    return this.ItemTypes[i]
                }
            }
        },
        HasScrollFocus: function ScrollFocusFn() {
            for (var i = 0; i < this.Objects.length; i += 1) {
                if (this.Objects[i].ScrollFocus) {
                    return this.ItemTypes[i]
                }
            }
        },
        HasSuperScrollFocus: function SuperScrollFocusFn() {
            for (var i = 0; i < this.Objects.length; i += 1) {
                if (this.Objects[i].SuperScrollFocus) {
                    return this.ItemTypes[i]
                }
            }
        },
        RemoveItem: function RemoveItemFn(Item, Box) {
            if (Box !== undefined) {
                Box.RemoveNextItemPosition()
            }
            Item.RemoveItem();
            for (var i = 0; i < this.Objects.length; i += 1) {
                if (this.Objects[i] === Item) {
                    this.Objects.splice(i, 1);
                    this.ItemTypes.splice(i, 1)
                }
            }
        },
        BringToFront: function BringToFrontFn() {
            JamSystem.RenderManager.GetRoot().RemoveChild(this.RootTree);
            JamSystem.RenderManager.GetRoot().AddChild(this.RootTree)
        },
        ResizeUI: function ResizeUIFn() {
            var i = 0;
            for (i = 0; i < this.Objects.length; i += 1) {
                if (this.Objects[i]) {
                    this.Objects[i].RelocateItem()
                }
            }
        },
        EnableAll: function EnableFn(Enable) {
            for (var i = 0; i < this.Objects.length; i += 1) {
                if (this.ItemTypes[i] !== this.itemType.box) {
                    this.Objects[i].SetIsVisible(Enable)
                }
            }
            for (i = 0; i < this.Objects.length; i += 1) {
                if (this.ItemTypes[i] === this.itemType.box) {
                    this.Objects[i].SetIsVisible(Enable)
                }
            }
        }
    };
    UI.Create = function UICreateFn() {
        var NewObject = new UI;
        NewObject.RootTree = 0;
        NewObject.Objects = [];
        NewObject.ItemTypes = [];
        NewObject.RootTree = JamSystem.RenderManager.CreateTree(0, 0);
        JamSystem.RenderManager.GetRoot().AddChild(NewObject.RootTree);
        NewObject.WaitForRelease = false;
        return NewObject
    };

    function UIBox() {}
    UIBox.prototype = {};
    UIBox.AddDialogBox = function AddBoxFn(thisUI, X, Y, Width, Height, RenderTree) {
        Debug.Assert(Width !== undefined && Height !== undefined && X !== undefined && Y !== undefined && RenderTree !== undefined, "PROBLEM! AddDialogBox - missing param! Something undefined...");
        Debug.Assert(typeof X === "number" && typeof Y === "number" && typeof Width === "number" && typeof Height === "number", "PROBLEM! AddDialogBox - vars do not match type!");
        thisUI.NextItemPosition.x = 10;
        thisUI.NextItemPosition.y = 60;
        thisUI.RenderTree = RenderTree;
        var ScaleWidth = 1;
        var ScaleHeight = 1;
        thisUI.BackingItem = Helpers.CreateSprite(X, Y - 30, EA.TopLeft, "Editor_White", RenderTree);
        thisUI.BackingItem.SetColour([1, 1, 1, 1]);
        ScaleWidth = Width / thisUI.BackingItem.GetWidth();
        ScaleHeight = (Height + 62) / thisUI.BackingItem.GetHeight();
        thisUI.BackingItem.SetScale(ScaleWidth, ScaleHeight);
        thisUI.Item = Helpers.CreateSprite(X, Y, EA.TopLeft, "Editor_White", RenderTree);
        thisUI.Item.SetColour([.411, .411, .411, 1]);
        if (Width !== 0) {
            ScaleWidth = Width / thisUI.Item.GetWidth()
        }
        if (Height !== 0) {
            ScaleHeight = Height / thisUI.Item.GetHeight()
        }
        thisUI.Item.SetScale(ScaleWidth, ScaleHeight);
        thisUI.TitleBarItem = Helpers.CreateBitmapText("", X + Width / 2, Y + 25, EA.MiddleMiddle, "EditorFont", RenderTree);
        thisUI.TitleBarItem.SetColour([0, 0, 0, 1]);
        return thisUI.Item
    };
    UIBox.GenerateNextItemPosition = function GenSelectSpaceFn(thisUI) {
        thisUI.NextItemPosition.y += thisUI.BoxSpacing;
        thisUI.CheckForScrollBar()
    };
    UIBox.RemoveNextItemPosition = function RemoveSelectSpaceFn(thisUI) {
        thisUI.NextItemPosition.y -= thisUI.BoxSpacing;
        thisUI.CheckForScrollBar()
    };
    UIBox.CheckForScrollBar = function ScrollCheckFn(thisUI, ActualLength) {
        var MaxLength = thisUI.GetTrueHeight();
        if (ActualLength === undefined) {
            ActualLength = thisUI.NextItemPosition.y
        }
        if (ActualLength > MaxLength) {
            var ScrollerLength = 1 / (ActualLength / MaxLength) * thisUI.GetTrueHeight();
            var ScrollSpeed = ActualLength / MaxLength;
            if (thisUI.ScrollUI) {
                var Change = thisUI.ScrollUI.ModifyScrollBar(ScrollerLength, ScrollSpeed, MaxLength, thisUI.PaletteBox);
                if (Change !== 0 && !thisUI.IsPaletteCategory) {
                    var i = 0;
                    for (i = 0; i < thisUI.ObjectsAttached.length; i += 1) {
                        if (thisUI.ObjectsAttached[i] !== thisUI) {
                            thisUI.ObjectsAttached[i].ShiftBy(0, -Change)
                        }
                    }
                    if (thisUI.BrushPosition) {
                        thisUI.BrushPosition.y -= Change
                    }
                }
                thisUI.UpdateScroll()
            } else {
                thisUI.AddScrollBar(ScrollerLength, ScrollSpeed);
                if (thisUI.TextBoxUI) {
                    thisUI.TextBoxUI.ReattachObjects()
                }
            }
        } else {
            if (thisUI.ScrollUI) {
                var FinalDelta = thisUI.ScrollUI.ResetScrollBar(thisUI.ObjectsAttached);
                if (thisUI.BrushPosition) {
                    thisUI.BrushPosition.y += FinalDelta
                }
                thisUI.ScrollUI.DisableScrollBar();
                thisUI.ScrollUI = 0
            }
        }
    };
    UIBox.AddScrollBar = function AddScrollFn(thisUI, Length, Speed) {
        thisUI.ScrollUI = UIScrollBar.Create();
        var StartX = thisUI.GetTrueWidth() + thisUI.Item.GetPositionX();
        var ScrollBarItem = thisUI.ScrollUI.AddScrollBar(Length, Speed, StartX, thisUI.Item.GetPositionY(), thisUI.GetTrueHeight(), thisUI.RenderTree);
        if (thisUI.PaletteBox) {
            thisUI.ScrollUI.MouseWheelSpeed = 2
        }
        if (thisUI.ComboBox) {
            thisUI.ScrollUI.MouseWheelSpeed = .5
        }
    };
    UIBox.AddOKCancel = function AddButtonFn(thisUI) {
        thisUI.OKButtonUI = UIButton.Create();
        thisUI.CancelButtonUI = UIButton.Create();
        var Pos = thisUI.GetTrueWidth() / 4 + thisUI.Item.GetPositionX() - 40;
        var YPos = thisUI.GetTrueHeight() + thisUI.Item.GetPositionY() + 1;
        thisUI.OKButtonUI.AddButton(Pos, YPos, "DONE", false, thisUI.RenderTree);
        Pos = thisUI.Item.GetPositionX() + thisUI.GetTrueWidth() - thisUI.GetTrueWidth() / 4 - 58;
        thisUI.CancelButtonUI.AddButton(Pos, YPos, "CANCEL", false, thisUI.RenderTree)
    };
    UIBox.AddCancel = function AddCancelButtonFn(thisUI) {
        thisUI.CancelButtonUI = UIButton.Create();
        var Pos = thisUI.GetTrueWidth() / 4 + thisUI.Item.GetPositionX() - 40;
        var YPos = thisUI.GetTrueHeight() + thisUI.Item.GetPositionY() + 1;
        Pos = thisUI.Item.GetPositionX() + thisUI.GetTrueWidth() - thisUI.GetTrueWidth() / 4 - 58;
        thisUI.CancelButtonUI.AddButton(Pos, YPos, "CANCEL", false, thisUI.RenderTree)
    };
    UIBox.AddAutoUpdateButton = function AddAutoUpdateButtonFn(thisUI, Text, Info) {
        thisUI.CheckButtonUI = UICheckTextBox.Create();
        var Pos = thisUI.Item.GetPositionX();
        var YPos = thisUI.Item.GetPositionY() - 30;
        thisUI.CheckButtonUI.ShiftX = 150;
        thisUI.CheckButtonUI.AddCheckTextBox(Text, Pos, YPos, thisUI.RenderTree);
        thisUI.CheckButtonUI.TextBoxUI.Item.SetColour([.7, .7, .7, .5]);
        thisUI.CheckButtonUI.CheckBoxUI.Item.SetColour([.7, .7, .7, 1]);
        thisUI.CheckButtonUI.TextBoxUI.BackingItem.SetColour([1, 1, 1, 1]);
        thisUI.CheckButtonUI.SetDefaultValue(false);
        thisUI.CheckButtonUI.SetInfoBoxText(Info)
    };
    UIBox.CheckHidden = function HiddenFn(thisUI, Item) {
        var CurrItem = thisUI.ObjectsAttached[Item];
        var Top = CurrItem.GetTop();
        if (!thisUI.PaletteBox && !thisUI.ComboBox) {
            Top -= 50
        }
        var Bottom = CurrItem.GetTrueHeight() + CurrItem.GetTop();
        if (!thisUI.PaletteBox && !thisUI.ComboBox) {
            var Temp = Bottom;
            Bottom = Top + 5;
            Top = Temp
        }
        if (thisUI.ComboBox) {
            Top = Bottom
        }
        if (Bottom < thisUI.ScrollUI.Top) {
            CurrItem.SetIsVisible(false)
        }
        if (Bottom >= thisUI.ScrollUI.Top) {
            CurrItem.SetIsVisible(true)
        }
        if (Top > thisUI.ScrollUI.Bottom) {
            CurrItem.SetIsVisible(false)
        }
    };
    UIBox.CheckAllForHidden = function CheckAllForHiddenFn(thisUI) {
        var i = 0;
        for (i = 0; i < thisUI.ObjectsAttached.length; i += 1) {
            if (thisUI.ObjectsAttached[i] !== thisUI) {
                thisUI.CheckHidden(i)
            }
        }
    };
    UIBox.UpdateScroll = function UpdateScrollFn(thisUI) {
        if (thisUI.IsVisible()) {
            for (var k = 0; k < thisUI.ObjectsAttached.length; k += 1) {
                if (thisUI.ObjectsAttached[k] !== thisUI) {
                    thisUI.ObjectsAttached[k].Scroll(thisUI.ScrollUI.ScrollDelta);
                    thisUI.CheckHidden(k)
                }
            }
        }
    };
    UIBox.MoveBox = function MoveBoxFn(thisUI, MouseX, MouseY) {
        var DiffX = MouseX - thisUI.LastDragPosition.x;
        var DiffY = MouseY - thisUI.LastDragPosition.y;
        thisUI.Item.SetPosition(thisUI.Item.GetPositionX() + DiffX, thisUI.Item.GetPositionY() + DiffY);
        if (thisUI.BackingItem) {
            thisUI.BackingItem.SetPosition(thisUI.BackingItem.GetPositionX() + DiffX, thisUI.BackingItem.GetPositionY() + DiffY)
        }
        if (thisUI.ScrollUI) {
            thisUI.ScrollUI.UpdatePosition(DiffX, DiffY)
        }
        if (thisUI.OKButtonUI) {
            thisUI.OKButtonUI.UpdatePosition(DiffX, DiffY)
        }
        if (thisUI.CancelButtonUI) {
            thisUI.CancelButtonUI.UpdatePosition(DiffX, DiffY)
        }
        if (thisUI.CheckButtonUI) {
            thisUI.CheckButtonUI.UpdatePosition(DiffX, DiffY)
        }
        if (thisUI.TitleBarItem) {
            thisUI.TitleBarItem.SetPosition(thisUI.TitleBarItem.GetPositionX() + DiffX, thisUI.TitleBarItem.GetPositionY() + DiffY)
        }
        if (thisUI.ObjectsAttached) {
            for (var k = 0; k < thisUI.ObjectsAttached.length; k += 1) {
                if (thisUI.ObjectsAttached[k] !== thisUI) {
                    thisUI.ObjectsAttached[k].UpdatePosition(DiffX, DiffY)
                }
            }
        }
    };
    UIBox.SetTitleBar = function SetTitleFn(thisUI, Text) {
        thisUI.TitleText = Text
    };
    UIBox.ResetBox = function ResetBoxFn(thisUI) {
        thisUI.OKPressed = false;
        thisUI.CancelPressed = false
    };
    UIBox.ReattachObjects = function ReattachFn(thisUI) {
        thisUI.RenderTree.RemoveChild(thisUI.Item);
        thisUI.RenderTree.AddChild(thisUI.Item);
        if (thisUI.ScrollUI) {
            thisUI.ScrollUI.ReattachObjects()
        }
    };
    UIBox.Update = function UpdateFn(thisUI, TimeDelta, MouseX, MouseY) {
        if (thisUI.OKButtonUI) {
            thisUI.OKButtonUI.Update(TimeDelta, MouseX, MouseY)
        }
        if (thisUI.CancelButtonUI) {
            thisUI.CancelButtonUI.Update(TimeDelta, MouseX, MouseY)
        }
        if (thisUI.CheckButtonUI) {
            thisUI.CheckButtonUI.Update(TimeDelta, MouseX, MouseY)
        }
        if (!thisUI.IsVisible()) {
            return
        }
        if (!thisUI.isSuperFocused && thisUI.ObjectsAttached) {
            for (var k = 0; k < thisUI.ObjectsAttached.length; k += 1) {
                if (thisUI.ObjectsAttached[k].isSuperFocused) {
                    return
                }
            }
        }
        if (!JamSystem.InputManager.GetMouseButtonHeld(0)) {
            thisUI.isSuperFocused = false
        }
        if (thisUI.BackingItem && thisUI.isSuperFocused) {
            thisUI.MoveBox(MouseX, MouseY);
            thisUI.LastDragPosition.x = MouseX;
            thisUI.LastDragPosition.y = MouseY
        }
        if (thisUI.TitleBarItem) {
            if (thisUI.TitleBarItem.pszText !== thisUI.TitleText) {
                thisUI.TitleBarItem.SetText(thisUI.TitleText);
                var Pos = thisUI.Item.GetPositionX() + thisUI.GetTrueWidth() / 2;
                thisUI.TitleBarItem.SetPositionX(Pos)
            }
        }
        if (!thisUI.ComboBox) {
            thisUI.ScrollFocus = thisUI.IsMouseOver(MouseX, MouseY)
        }
        if (thisUI.ScrollUI && (thisUI.ScrollFocus || thisUI.SuperScrollFocus)) {
            thisUI.ScrollUI.Update(TimeDelta, MouseX, MouseY);
            if (thisUI.ScrollUI.ScrollDelta !== 0) {
                thisUI.UpdateScroll()
            }
        }
        if (thisUI.ScrollUI) {
            thisUI.SuperScrollFocus = thisUI.ScrollUI.Scrolling
        }
        UIBase.Update(thisUI, TimeDelta, MouseX, MouseY)
    };
    UIBox.SetIsVisible = function SetIsVisibleFn(thisUI, Visible) {
        UIBase.SetIsVisible(thisUI, Visible);
        if (thisUI.TitleBarItem) {
            thisUI.TitleBarItem.SetIsVisible(Visible)
        }
        if (thisUI.ScrollUI) {
            thisUI.ScrollUI.SetIsVisible(Visible)
        }
        thisUI.ScrollFocus = false;
        if (thisUI.OKButtonUI) {
            thisUI.OKButtonUI.SetIsVisible(Visible)
        }
        if (thisUI.CancelButtonUI) {
            thisUI.CancelButtonUI.SetIsVisible(Visible)
        }
        if (thisUI.CheckButtonUI) {
            thisUI.CheckButtonUI.SetIsVisible(Visible)
        }
        if (thisUI.ObjectsAttached) {
            for (var k = 0; k < thisUI.ObjectsAttached.length; k += 1) {
                if (thisUI.ObjectsAttached[k] !== thisUI) {
                    if (!Visible) {
                        thisUI.ObjectsAttached[k].SetIsVisible(false)
                    } else {
                        thisUI.CheckHidden(k)
                    }
                }
            }
        }
    };
    UIBox.CheckCollision = function CheckCollFn(thisUI, X, Y) {
        if (thisUI.OKButtonUI) {
            if (thisUI.OKButtonUI.CheckCollision(X, Y)) {
                thisUI.OKPressed = true;
                thisUI.SetIsVisible(false);
                return true
            }
        }
        if (thisUI.CancelButtonUI) {
            if (thisUI.CancelButtonUI.CheckCollision(X, Y)) {
                thisUI.CancelPressed = true;
                thisUI.SetIsVisible(false);
                return true
            }
        }
        if (thisUI.CheckButtonUI) {
            if (thisUI.CheckButtonUI.CheckCollision(X, Y)) {
                thisUI.AutoUpdatePressed = !thisUI.AutoUpdatePressed;
                return true
            }
        }
        var Collision = UIBase.CheckCollision(thisUI, X, Y);
        if (Collision) {
            return true
        }
        if (thisUI.BackingItem) {
            var TrueWidth = thisUI.BackingItem.GetWidth() * thisUI.BackingItem.GetScaleX();
            var TrueHeight = thisUI.BackingItem.GetHeight() * thisUI.BackingItem.GetScaleY();
            if (thisUI.BackingItem) {
                if (X >= thisUI.BackingItem.GetPositionX() && X <= TrueWidth + thisUI.BackingItem.GetPositionX() && Y >= thisUI.BackingItem.GetPositionY() && Y <= TrueHeight + thisUI.BackingItem.GetPositionY()) {
                    thisUI.LastDragPosition.x = X;
                    thisUI.LastDragPosition.y = Y;
                    thisUI.isSuperFocused = true;
                    return true
                }
            }
        }
        return false
    };
    UIBox.CheckCollisionPressed = function CheckCollPressFn(thisUI, X, Y) {
        if (thisUI.ScrollUI) {
            if (thisUI.ScrollUI.CheckCollision(X, Y, thisUI.ObjectsAttached, thisUI)) {
                thisUI.CheckAllForHidden();
                return true
            }
        }
        if (!thisUI.PaletteBox && !thisUI.ComboBox) {
            return thisUI.CheckCollision(X, Y)
        }
        return false
    };
    UIBox.UpdatePosition = function UpdatePosFn(thisUI, DeltaX, DeltaY) {
        UIBase.UpdatePosition(thisUI, DeltaX, DeltaY);
        if (thisUI.TitleBarItem) {
            thisUI.TitleBarItem.SetPosition(thisUI.TitleBarItem.GetPositionX() + DeltaX, thisUI.TitleBarItem.GetPositionY() + DeltaY)
        }
        if (thisUI.ScrollUI) {
            thisUI.ScrollUI.UpdatePosition(DeltaX, DeltaY)
        }
        for (var k = 0; k < thisUI.ObjectsAttached.length; k += 1) {
            if (thisUI.ObjectsAttached[k] !== thisUI) {
                thisUI.ObjectsAttached[k].UpdatePosition(DeltaX, DeltaY)
            }
        }
    };
    UIBox.Scroll = function ScrollFn(thisUI, Delta) {
        UIBase.Scroll(thisUI, Delta);
        if (thisUI.ScrollUI) {
            thisUI.ScrollUI.Scroll(Delta)
        }
    };
    UIBox.RelocateItem = function RelocateItemFn(thisUI) {
        var DiffX = -(thisUI.Item.GetPositionX() + thisUI.GetTrueWidth() / 2 - JamSystem.RenderManager.GetScreenWidth() / 2);
        var DiffY = -(thisUI.Item.GetPositionY() + thisUI.GetTrueHeight() / 2 - JamSystem.RenderManager.GetScreenHeight() / 2);
        if (thisUI.Item.GetPositionX() + thisUI.GetTrueWidth() / 2 === JamSystem.RenderManager.GetScreenWidth() / 2) {
            DiffX = 0
        }
        if (thisUI.Item.GetPositionY() + thisUI.GetTrueHeight() / 2 === JamSystem.RenderManager.GetScreenHeight() / 2) {
            DiffY = 0
        }
        thisUI.Item.SetPosition(thisUI.Item.GetPositionX() + DiffX, thisUI.Item.GetPositionY() + DiffY);
        if (thisUI.BackingItem) {
            thisUI.BackingItem.SetPosition(thisUI.BackingItem.GetPositionX() + DiffX, thisUI.BackingItem.GetPositionY() + DiffY)
        }
        if (thisUI.ScrollUI) {
            thisUI.ScrollUI.UpdatePosition(DiffX, DiffY)
        }
        if (thisUI.OKButtonUI) {
            thisUI.OKButtonUI.UpdatePosition(DiffX, DiffY)
        }
        if (thisUI.CancelButtonUI) {
            thisUI.CancelButtonUI.UpdatePosition(DiffX, DiffY)
        }
        if (thisUI.CheckButtonUI) {
            thisUI.CheckButtonUI.UpdatePosition(DiffX, DiffY)
        }
        if (thisUI.TitleBarItem) {
            thisUI.TitleBarItem.SetPosition(thisUI.TitleBarItem.GetPositionX() + DiffX, thisUI.TitleBarItem.GetPositionY() + DiffY)
        }
        if (thisUI.ObjectsAttached) {
            for (var k = 0; k < thisUI.ObjectsAttached.length; k += 1) {
                if (thisUI.ObjectsAttached[k] !== thisUI) {
                    thisUI.ObjectsAttached[k].UpdatePosition(DiffX, DiffY)
                }
            }
        }
    };
    UIBox.RemoveItem = function RemoveItemFn(thisUI) {
        if (thisUI.TitleBarItem) {
            Helpers.DestroyBitmapText(thisUI.TitleBarItem)
        }
        if (thisUI.BackingItem) {
            Helpers.DestroySprite(thisUI.BackingItem)
        }
        if (thisUI.Item) {
            Helpers.DestroySprite(thisUI.Item)
        }
        if (thisUI.OKButtonUI) {
            thisUI.OKButtonUI.RemoveItem()
        }
        if (thisUI.CancelButtonUI) {
            thisUI.CancelButtonUI.RemoveItem()
        }
        if (thisUI.CheckButtonUI) {
            thisUI.CheckButtonUI.RemoveItem()
        }
        if (thisUI.ScrollUI) {
            thisUI.ScrollUI.RemoveItem()
        }
        if (thisUI.ObjectsAttached) {
            for (var k = 0; k < thisUI.ObjectsAttached.length; k += 1) {
                if (thisUI.ObjectsAttached[k] !== thisUI) {
                    thisUI.ObjectsAttached[k].RemoveItem()
                }
            }
        }
    };
    UIBox.IsMouseOver = function IsMouseOverFn(thisUI, X, Y) {
        return UIBase.IsMouseOver(thisUI, X, Y)
    };
    UIBox.Create = function UICreateFn() {
        var NewObject = UIBase.Create();
        NewObject.NextItemPosition = new Vector2(10, 10);
        NewObject.ObjectsAttached = [];
        NewObject.LastDragPosition = new Vector2(0, 0);
        NewObject.OKPressed = false;
        NewObject.CancelPressed = false;
        NewObject.TitleBarItem = 0;
        NewObject.TitleText = "";
        NewObject.ComboBox = false;
        NewObject.PaletteBox = false;
        NewObject.ScrollFocus = false;
        NewObject.AutoUpdatePressed = false;
        NewObject.OKButtonUI = 0;
        NewObject.CancelButtonUI = 0;
        NewObject.CheckButtonUI = 0;
        NewObject.ScrollUI = 0;
        NewObject.AddDialogBox = function AddBoxFn(X, Y, Width, Height, RenderTree) {
            return UIBox.AddDialogBox(this, X, Y, Width, Height, RenderTree)
        };
        NewObject.GenerateNextItemPosition = function GenSelectSpaceFn() {
            UIBox.GenerateNextItemPosition(this)
        };
        NewObject.CheckForScrollBar = function ScrollCheckFn(ActualLength) {
            UIBox.CheckForScrollBar(this, ActualLength)
        };
        NewObject.AddScrollBar = function AddScrollFn(Length, Speed) {
            UIBox.AddScrollBar(this, Length, Speed)
        };
        NewObject.AddOKCancel = function AddButtonFn() {
            UIBox.AddOKCancel(this)
        };
        NewObject.AddCancel = function AddCancelButtonFn() {
            UIBox.AddCancel(this)
        };
        NewObject.AddAutoUpdateButton = function AddAutoUpdateButtonFn(Text, Info) {
            UIBox.AddAutoUpdateButton(this, Text, Info)
        };
        NewObject.CheckAllForHidden = function CheckAllForHiddenFn() {
            UIBox.CheckAllForHidden(this)
        };
        NewObject.CheckHidden = function HiddenFn(Item) {
            UIBox.CheckHidden(this, Item)
        };
        NewObject.UpdateScroll = function UpdateScrollFn() {
            UIBox.UpdateScroll(this)
        };
        NewObject.MoveBox = function MoveBoxFn(MouseX, MouseY) {
            UIBox.MoveBox(this, MouseX, MouseY)
        };
        NewObject.SetTitleBar = function SetTitleFn(Text) {
            UIBox.SetTitleBar(this, Text)
        };
        NewObject.RemoveNextItemPosition = function RemoveSelectSpaceFn() {
            UIBox.RemoveNextItemPosition(this)
        };
        NewObject.ResetBox = function ResetBoxFn() {
            UIBox.ResetBox(this)
        };
        NewObject.ReattachObjects = function ReattachFn() {
            UIBox.ReattachObjects(this)
        };
        NewObject.Update = function UpdateFn(TimeDelta, MouseX, MouseY) {
            UIBox.Update(this, TimeDelta, MouseX, MouseY)
        };
        NewObject.SetIsVisible = function SetIsVisibleFn(Visible) {
            UIBox.SetIsVisible(this, Visible)
        };
        NewObject.CheckCollision = function CheckCollFn(X, Y) {
            return UIBox.CheckCollision(this, X, Y)
        };
        NewObject.CheckCollisionPressed = function CheckCollPressFn(X, Y) {
            return UIBox.CheckCollisionPressed(this, X, Y)
        };
        NewObject.UpdatePosition = function UpdatePosFn(DeltaX, DeltaY) {
            UIBox.UpdatePosition(this, DeltaX, DeltaY)
        };
        NewObject.Scroll = function ScrollFn(Delta) {
            UIBox.Scroll(this, Delta)
        };
        NewObject.RelocateItem = function RelocateItemFn() {
            UIBox.RelocateItem(this)
        };
        NewObject.RemoveItem = function RemoveItemFn() {
            UIBox.RemoveItem(this)
        };
        NewObject.IsMouseOver = function IsMouseOverFn(X, Y) {
            return UIBox.IsMouseOver(this, X, Y)
        };
        return NewObject
    };

    function UISlider() {}
    UISlider.prototype = {};
    UISlider.AddSliderItem = function AddSliderItemFn(thisUI, X, Y, Label, Min, Max, Shift, RenderTree) {
        Debug.Assert(X !== undefined && Y !== undefined && Label !== undefined && RenderTree !== undefined, "PROBLEM! AddSliderItem - missing param! Something undefined...");
        Debug.Assert(typeof X === "number" && typeof Y === "number", "PROBLEM! AddSliderItem - vars do not match type!");
        thisUI.Min = Min;
        thisUI.Max = Max;
        if (!thisUI.Min) {
            thisUI.Min = 0
        }
        if (!thisUI.Max) {
            thisUI.Max = 1
        }
        thisUI.SliderStartPosition = new Vector2;
        thisUI.SliderStartPosition.x = X + thisUI.ShiftX;
        thisUI.SliderStartPosition.y = Y;
        if (Shift) {
            thisUI.SliderStartPosition.x += Shift
        }
        thisUI.Backing = Helpers.CreateSprite(thisUI.SliderStartPosition.x, Y, EA.TopLeft, "Editor_White", RenderTree);
        thisUI.Backing.SetScaleX(80 / thisUI.Backing.GetWidth());
        thisUI.Backing.SetScaleY(30 / thisUI.Backing.GetHeight());
        thisUI.Backing.SetColour([0, 0, 0, .1]);
        thisUI.Bar = Helpers.CreateSprite(thisUI.SliderStartPosition.x, Y, EA.TopLeft, "Editor_White", RenderTree);
        thisUI.Bar.SetScaleX(80 / thisUI.Bar.GetWidth());
        thisUI.Bar.SetScaleY(4 / thisUI.Bar.GetHeight());
        thisUI.Bar.SetPositionY(Y + 14);
        thisUI.Bar.SetColour([0, 0, 0, 1]);
        thisUI.SliderBacking = Helpers.CreateSprite(thisUI.SliderStartPosition.x, Y, EA.TopMiddle, "Editor_White", RenderTree);
        thisUI.SliderBacking.SetScaleX(12 / thisUI.SliderBacking.GetWidth());
        thisUI.SliderBacking.SetScaleY(30 / thisUI.SliderBacking.GetHeight());
        thisUI.SliderBacking.SetColour([0, 0, 0, .2]);
        thisUI.Slider = Helpers.CreateSprite(thisUI.SliderStartPosition.x, Y, EA.TopMiddle, "Editor_White", RenderTree);
        thisUI.Slider.SetScaleX(6 / thisUI.Slider.GetWidth());
        thisUI.Slider.SetScaleY(30 / thisUI.Slider.GetHeight());
        thisUI.Slider.SetColour([0, 0, 0, 1]);
        var EditPosX = thisUI.SliderStartPosition.x - X + thisUI.Bar.GetScaleX() * thisUI.Bar.GetWidth() + 20;
        UIEditBox.AddEditBoxItem(thisUI, X, Y, UIEditBox.prototype.editBoxType.Number, Label, EditPosX, RenderTree);
        UIEditBox.SetDefaultValue(thisUI, "" + Min.toFixed(0));
        return thisUI.Item
    };
    UISlider.SetDefaultValue = function SetDefaultFn(thisUI, NewText) {
        UIEditBox.SetDefaultValue(thisUI, NewText);
        var ToPercent = parseFloat(thisUI.CurrText);
        if (ToPercent > thisUI.Max) {
            ToPercent = thisUI.Max;
            thisUI.CurrText = "" + thisUI.Max
        }
        if (ToPercent < thisUI.Min) {
            ToPercent = thisUI.Min;
            thisUI.CurrText = "" + thisUI.Min
        }
        ToPercent = (ToPercent - thisUI.Min) / (thisUI.Max - thisUI.Min);
        var BoxWidth = thisUI.Bar.GetScaleX() * thisUI.Bar.GetWidth();
        var Position = thisUI.Bar.GetPositionX() + BoxWidth * ToPercent;
        thisUI.Slider.SetPositionX(Position);
        thisUI.SliderBacking.SetPositionX(Position)
    };
    UISlider.ReattachObjects = function ReattachFn(thisUI) {
        UIEditBox.ReattachObjects(thisUI)
    };
    UISlider.Update = function UpdateFn(thisUI, TimeDelta, MouseX, MouseY) {
        UIEditBox.Update(thisUI, TimeDelta, MouseX, MouseY);
        if (UIEditBox.AnyChanges(thisUI)) {
            var ToPercent = parseFloat(thisUI.CurrText);
            if (ToPercent > thisUI.Max) {
                ToPercent = thisUI.Max;
                thisUI.CurrText = "" + thisUI.Max
            }
            if (ToPercent < thisUI.Min) {
                ToPercent = thisUI.Min;
                thisUI.CurrText = "" + thisUI.Min
            }
            ToPercent = (ToPercent - thisUI.Min) / (thisUI.Max - thisUI.Min);
            var BoxWidth = thisUI.Bar.GetScaleX() * thisUI.Bar.GetWidth();
            var Position = thisUI.Bar.GetPositionX() + BoxWidth * ToPercent;
            thisUI.Slider.SetPositionX(Position);
            thisUI.SliderBacking.SetPositionX(Position)
        }
        if (JamSystem.InputManager.GetMouseButtonHeld(0)) {
            var TrueWidth = thisUI.Backing.GetScaleX() * thisUI.Backing.GetWidth();
            var TrueHeight = thisUI.Backing.GetScaleY() * thisUI.Backing.GetHeight();
            if (MouseX >= thisUI.Backing.GetPositionX() && MouseX <= TrueWidth + thisUI.Backing.GetPositionX() && MouseY >= thisUI.Backing.GetPositionY() && MouseY <= TrueHeight + thisUI.Backing.GetPositionY()) {
                if (MouseX >= thisUI.Backing.GetPositionX() && MouseX <= thisUI.Backing.GetPositionX() + TrueWidth) {
                    var Percent = (MouseX - thisUI.Backing.GetPositionX()) / TrueWidth;
                    Percent = (thisUI.Max - thisUI.Min) * Percent + thisUI.Min;
                    thisUI.CurrText = "" + Percent.toFixed(2);
                    thisUI.Item.SetText(thisUI.CurrText);
                    thisUI.Slider.SetPositionX(MouseX);
                    thisUI.SliderBacking.SetPositionX(MouseX);
                    return
                }
                if (MouseX < thisUI.Bar.GetPositionX()) {
                    thisUI.CurrText = "" + thisUI.Min.toFixed(2);
                    thisUI.Item.SetText(thisUI.CurrText);
                    thisUI.Slider.SetPositionX(thisUI.Backing.GetPositionX());
                    thisUI.SliderBacking.SetPositionX(thisUI.Backing.GetPositionX());
                    return
                }
                if (MouseX > thisUI.Bar.GetPositionX() + TrueWidth) {
                    thisUI.CurrText = "" + thisUI.Max.toFixed(2);
                    thisUI.Item.SetText(thisUI.CurrText);
                    thisUI.Slider.SetPositionX(thisUI.Backing.GetPositionX() + TrueWidth);
                    thisUI.SliderBacking.SetPositionX(thisUI.Backing.GetPositionX() + TrueWidth);
                    return
                }
            }
        }
    };
    UISlider.CheckCollision = function CheckCollFn(thisUI, X, Y) {
        var TrueWidth = thisUI.Backing.GetScaleX() * thisUI.Backing.GetWidth();
        var TrueHeight = thisUI.Backing.GetScaleY() * thisUI.Backing.GetHeight();
        if (X >= thisUI.Backing.GetPositionX() && X <= TrueWidth + thisUI.Backing.GetPositionX() && Y >= thisUI.Backing.GetPositionY() && Y <= TrueHeight + thisUI.Backing.GetPositionY()) {
            thisUI.Slider.SetPositionX(X);
            thisUI.SliderBacking.SetPositionX(X);
            return true
        }
        UIEditBox.CheckCollision(thisUI, X, Y)
    };
    UISlider.CheckCollisionPressed = function CheckCollPressFn(thisUI, X, Y) {
        return false
    };
    UISlider.SetIsVisible = function SetIsVisibleFn(thisUI, Visible) {
        thisUI.Bar.SetIsVisible(Visible);
        thisUI.Backing.SetIsVisible(Visible);
        thisUI.Slider.SetIsVisible(Visible);
        thisUI.SliderBacking.SetIsVisible(Visible);
        UIEditBox.SetIsVisible(thisUI, Visible)
    };
    UISlider.UpdatePosition = function UpdatePosFn(thisUI, DeltaX, DeltaY) {
        thisUI.Bar.SetPosition(thisUI.Bar.GetPositionX() + DeltaX, thisUI.Bar.GetPositionY() + DeltaY);
        thisUI.Backing.SetPosition(thisUI.Backing.GetPositionX() + DeltaX, thisUI.Backing.GetPositionY() + DeltaY);
        thisUI.Slider.SetPosition(thisUI.Slider.GetPositionX() + DeltaX, thisUI.Slider.GetPositionY() + DeltaY);
        thisUI.SliderBacking.SetPosition(thisUI.SliderBacking.GetPositionX() + DeltaX, thisUI.SliderBacking.GetPositionY() + DeltaY);
        UIEditBox.UpdatePosition(thisUI, DeltaX, DeltaY)
    };
    UISlider.Scroll = function ScrollFn(thisUI, Delta) {
        var NewPosition = thisUI.Bar.GetPositionY() - Delta;
        thisUI.Bar.SetPositionY(NewPosition);
        NewPosition = thisUI.Slider.GetPositionY() - Delta;
        thisUI.Slider.SetPositionY(NewPosition);
        NewPosition = thisUI.Backing.GetPositionY() - Delta;
        thisUI.Backing.SetPositionY(NewPosition);
        NewPosition = thisUI.SliderBacking.GetPositionY() - Delta;
        thisUI.SliderBacking.SetPositionY(NewPosition);
        UIEditBox.Scroll(thisUI, Delta)
    };
    UISlider.ShiftBy = function ShiftByFn(thisUI, X, Y) {
        thisUI.Bar.SetPosition(thisUI.Bar.GetPositionX() + X, thisUI.Bar.GetPositionY() + Y);
        thisUI.Backing.SetPosition(thisUI.Backing.GetPositionX() + X, thisUI.Backing.GetPositionY() + Y);
        thisUI.Slider.SetPosition(thisUI.Slider.GetPositionX() + X, thisUI.Slider.GetPositionY() + Y);
        thisUI.SliderBacking.SetPosition(thisUI.SliderBacking.GetPositionX() + X, thisUI.SliderBacking.GetPositionY() + Y);
        UIEditBox.ShiftBy(thisUI, X, Y)
    };
    UISlider.MoveTo = function MoveToFn(thisUI, X, Y) {
        if (Y === undefined) {
            Y = thisUI.Bar.GetPositionY()
        }
        thisUI.Bar.SetPosition(X + thisUI.SliderStartPosition.x, Y);
        if (Y === undefined) {
            Y = thisUI.Backing.GetPositionY()
        }
        thisUI.Backing.SetPosition(X + thisUI.SliderStartPosition.x, Y);
        if (Y === undefined) {
            Y = thisUI.Slider.GetPositionY()
        }
        thisUI.Slider.SetPosition(X + thisUI.SliderStartPosition.x, Y);
        if (Y === undefined) {
            Y = thisUI.SliderBacking.GetPositionY()
        }
        thisUI.SliderBacking.SetPosition(X + thisUI.SliderStartPosition.x, Y);
        UIEditBox.MoveTo(thisUI, X, Y)
    };
    UISlider.RemoveItem = function RemoveItemFn(thisUI) {
        Helpers.DestroySprite(thisUI.Slider);
        Helpers.DestroySprite(thisUI.Bar);
        Helpers.DestroySprite(thisUI.Backing);
        Helpers.DestroySprite(thisUI.SliderBacking);
        UIEditBox.RemoveItem(thisUI)
    };
    UISlider.IsMouseOver = function IsMouseOverFn(thisUI, X, Y) {
        var Width = thisUI.Backing.GetScaleX() * thisUI.Backing.GetWidth();
        var Height = thisUI.Backing.GetScaleY() * thisUI.Backing.GetHeight();
        var SlideWidth = thisUI.SliderBacking.GetScaleX() * thisUI.SliderBacking.GetWidth();
        var SlideHeight = thisUI.SliderBacking.GetScaleY() * thisUI.SliderBacking.GetHeight();
        var Collide = X > thisUI.Backing.GetPositionX() && X < thisUI.Backing.GetPositionX() + Width && Y > thisUI.Backing.GetPositionY() && Y < thisUI.Backing.GetPositionY() + Height || X > thisUI.SliderBacking.GetPositionX() && X < thisUI.SliderBacking.GetPositionX() + SlideWidth && Y > thisUI.SliderBacking.GetPositionY() && Y < thisUI.SliderBacking.GetPositionY() + SlideHeight;
        if (Collide) {
            return true
        }
        return UIBase.IsMouseOver(thisUI, X, Y)
    };
    UISlider.Create = function UICreateFn() {
        var NewObject = UIEditBox.Create();
        NewObject.SliderStartPosition = new Vector2;
        NewObject.Slider = 0;
        NewObject.Bar = 0;
        NewObject.Backing = 0;
        NewObject.SliderBacking = 0;
        NewObject.Min = 0;
        NewObject.Max = 1;
        NewObject.AddSliderItem = function AddSliderItemFn(X, Y, Label, Min, Max, Shift, RenderTree) {
            return UISlider.AddSliderItem(this, X, Y, Label, Min, Max, Shift, RenderTree)
        };
        NewObject.SetDefaultValue = function SetDefaultFn(NewText) {
            UISlider.SetDefaultValue(this, NewText)
        };
        NewObject.ReattachObjects = function ReattachFn() {
            UISlider.ReattachObjects(this)
        };
        NewObject.Update = function UpdateFn(TimeDelta, MouseX, MouseY) {
            UISlider.Update(this, TimeDelta, MouseX, MouseY)
        };
        NewObject.CheckCollision = function CheckCollFn(X, Y) {
            return UISlider.CheckCollision(this, X, Y)
        };
        NewObject.CheckCollisionPressed = function CheckCollPressFn(X, Y) {
            return UISlider.CheckCollisionPressed(this, X, Y)
        };
        NewObject.SetIsVisible = function SetIsVisibleFn(Visible) {
            UISlider.SetIsVisible(this, Visible)
        };
        NewObject.UpdatePosition = function UpdatePosFn(DeltaX, DeltaY) {
            UISlider.UpdatePosition(this, DeltaX, DeltaY)
        };
        NewObject.Scroll = function ScrollFn(Delta) {
            UISlider.Scroll(this, Delta)
        };
        NewObject.MoveTo = function MoveToFn(X, Y) {
            UISlider.MoveTo(this, X, Y)
        };
        NewObject.ShiftBy = function ShiftByFn(X, Y) {
            UISlider.ShiftBy(this, X, Y)
        };
        NewObject.RemoveItem = function RemoveItemFn() {
            UISlider.RemoveItem(this)
        };
        NewObject.IsMouseOver = function IsMouseOverFn(X, Y) {
            return UISlider.IsMouseOver(this, X, Y)
        };
        return NewObject
    };

    function UIConfirmationBox() {}
    UIConfirmationBox.prototype = {};
    UIConfirmationBox.AddBox = function AddBoxFn(thisUI, RenderTree) {
        Debug.Assert(RenderTree !== undefined, "PROBLEM! Add Confirmation Box - missing param! Something undefined...");
        thisUI.RenderTree = RenderTree;
        var CentreWidth = JamSystem.RenderManager.GetScreenWidth() / 2;
        var CentreHeight = JamSystem.RenderManager.GetScreenHeight() / 2;
        UIBox.AddDialogBox(thisUI, CentreWidth - CentreWidth / 4, CentreHeight - CentreHeight / 6, CentreWidth / 2, CentreHeight / 3, RenderTree);
        thisUI.YesButtonUI = UIButton.Create();
        thisUI.YesButtonUI.AddButton(CentreWidth - 110, CentreHeight + CentreHeight / 6, "YES", false, RenderTree);
        thisUI.NoButtonUI = UIButton.Create();
        thisUI.NoButtonUI.AddButton(CentreWidth - 30, CentreHeight + CentreHeight / 6, "NO", false, RenderTree);
        thisUI.CancelUI = UIButton.Create();
        thisUI.CancelUI.AddButton(CentreWidth + 40, CentreHeight + CentreHeight / 6, "CANCEL", false, RenderTree);
        return thisUI.Item
    };
    UIConfirmationBox.Resize = function ResizeFn(thisUI) {
        var ItemWidth = thisUI.TitleBarItem.GetWidth();
        var ItemHeight = thisUI.TitleBarItem.GetHeight();
        var BoxWidth = thisUI.GetTrueWidth();
        var BoxHeight = thisUI.GetTrueHeight();
        var ScaleWidth = 1;
        var ScaleHeight = 1;
        ScaleWidth = (ItemWidth + 20) / thisUI.BackingItem.GetWidth();
        ScaleHeight = (ItemHeight + 62) / thisUI.BackingItem.GetHeight();
        thisUI.BackingItem.SetScale(ScaleWidth, ScaleHeight);
        ScaleWidth = (ItemWidth + 20) / thisUI.Item.GetWidth();
        ScaleHeight = ItemHeight / thisUI.Item.GetHeight();
        thisUI.Item.SetScale(ScaleWidth, ScaleHeight);
        var X = JamSystem.RenderManager.GetScreenWidth() / 2 - thisUI.GetTrueWidth() / 2;
        var Y = JamSystem.RenderManager.GetScreenHeight() / 2 - thisUI.GetTrueHeight() / 2;
        thisUI.Item.SetPosition(X, Y);
        var pos = Y + thisUI.GetTrueHeight() / 2;
        thisUI.BackingItem.SetPosition(X, pos - thisUI.BackingItem.GetHeight() * thisUI.BackingItem.GetScaleY() / 2);
        var CentreX = thisUI.GetTrueWidth() / 2;
        thisUI.TitleBarItem.SetPosition(X + CentreX, Y + 25);
        Y += thisUI.GetTrueHeight();
        thisUI.NoButtonUI.MoveTo(X + CentreX - thisUI.NoButtonUI.GetTrueWidth() / 2 - 15, Y);
        thisUI.YesButtonUI.MoveTo(thisUI.NoButtonUI.BackingItem.GetPositionX() - 65, Y);
        thisUI.CancelUI.MoveTo(thisUI.NoButtonUI.BackingItem.GetPositionX() + thisUI.NoButtonUI.GetTrueWidth() + 10, Y)
    };
    UIConfirmationBox.Reset = function ResetFn(thisUI) {
        thisUI.YesPressed = false;
        thisUI.NoPressed = false;
        thisUI.CancelPressed = false
    };
    UIConfirmationBox.MoveBox = function MoveBoxFn(thisUI, MouseX, MouseY) {
        var DiffX = MouseX - thisUI.LastDragPosition.x;
        var DiffY = MouseY - thisUI.LastDragPosition.y;
        if (thisUI.YesButtonUI) {
            thisUI.YesButtonUI.UpdatePosition(DiffX, DiffY)
        }
        if (thisUI.NoButtonUI) {
            thisUI.NoButtonUI.UpdatePosition(DiffX, DiffY)
        }
        if (thisUI.CancelUI) {
            thisUI.CancelUI.UpdatePosition(DiffX, DiffY)
        }
        UIBox.MoveBox(thisUI, MouseX, MouseY)
    };
    UIConfirmationBox.ReattachObjects = function ReattachFn(thisUI) {
        UIBox.ReattachObjects(thisUI);
        thisUI.YesButtonUI.ReattachObjects();
        thisUI.NoButtonUI.ReattachObjects();
        thisUI.CancelUI.ReattachObjects()
    };
    UIConfirmationBox.Update = function UpdateFn(thisUI, TimeDelta, MouseX, MouseY) {
        if (!JamSystem.InputManager.GetMouseButtonHeld(0)) {
            thisUI.isFocused = false
        }
        thisUI.YesButtonUI.Update(TimeDelta, MouseX, MouseY);
        thisUI.NoButtonUI.Update(TimeDelta, MouseX, MouseY);
        thisUI.CancelUI.Update(TimeDelta, MouseX, MouseY);
        if (thisUI.BackingItem && thisUI.isFocused && !thisUI.ScrollUI.isFocused) {
            thisUI.MoveBox(MouseX, MouseY);
            thisUI.LastDragPosition.x = MouseX;
            thisUI.LastDragPosition.y = MouseY
        }
        if (thisUI.TitleBarItem) {
            if (thisUI.TitleBarItem.pszText !== thisUI.TitleText) {
                thisUI.TitleBarItem.SetText(thisUI.TitleText);
                thisUI.Resize()
            }
        }
        UIBase.Update(thisUI, TimeDelta, MouseX, MouseY)
    };
    UIConfirmationBox.SetIsVisible = function SetIsVisibleFn(thisUI, Visible) {
        UIBox.SetIsVisible(thisUI, Visible);
        thisUI.YesButtonUI.SetIsVisible(Visible);
        thisUI.NoButtonUI.SetIsVisible(Visible);
        thisUI.CancelUI.SetIsVisible(Visible)
    };
    UIConfirmationBox.CheckCollision = function CheckCollFn(thisUI, X, Y) {
        if (thisUI.YesButtonUI.CheckCollision(X, Y)) {
            thisUI.YesPressed = true;
            return true
        }
        if (thisUI.NoButtonUI.CheckCollision(X, Y)) {
            thisUI.NoPressed = true;
            return true
        }
        if (thisUI.CancelUI.CheckCollision(X, Y)) {
            thisUI.CancelPressed = true;
            return true
        }
        UIBox.CheckCollision(thisUI, X, Y);
        return false
    };
    UIConfirmationBox.UpdatePosition = function UpdatePosFn(thisUI, DeltaX, DeltaY) {
        UIBox.UpdatePosition(thisUI, DeltaX, DeltaY);
        thisUI.YesButtonUI.UpdatePosition(DeltaX, DeltaY);
        thisUI.NoButtonUI.UpdatePosition(DeltaX, DeltaY);
        thisUI.CancelUI.UpdatePosition(DeltaX, DeltaY)
    };
    UIConfirmationBox.RelocateItem = function RelocateItemFn(thisUI) {
        UIBox.RelocateItem(thisUI);
        thisUI.Resize(thisUI)
    };
    UIConfirmationBox.Create = function UICreateFn() {
        var NewObject = UIBox.Create();
        NewObject.AllowResize = false;
        NewObject.YesPressed = false;
        NewObject.NoPressed = false;
        NewObject.CancelPressed = false;
        NewObject.YesButtonUI = 0;
        NewObject.NoButtonUI = 0;
        NewObject.CancelUI = 0;
        NewObject.AddBox = function AddBoxFn(RenderTree) {
            UIConfirmationBox.AddBox(this, RenderTree)
        };
        NewObject.Resize = function ResizeFn() {
            UIConfirmationBox.Resize(this)
        };
        NewObject.Reset = function ResetFn() {
            UIConfirmationBox.Reset(this)
        };
        NewObject.MoveBox = function MoveBoxFn(MouseX, MouseY) {
            UIConfirmationBox.MoveBox(this, MouseX, MouseY)
        };
        NewObject.ReattachObjects = function ReattachFn() {
            UIConfirmationBox.ReattachObjects(this)
        };
        NewObject.Update = function UpdateFn(TimeDelta, MouseX, MouseY) {
            UIConfirmationBox.Update(this, TimeDelta, MouseX, MouseY)
        };
        NewObject.SetIsVisible = function SetIsVisibleFn(Visible) {
            UIConfirmationBox.SetIsVisible(this, Visible)
        };
        NewObject.CheckCollision = function CheckCollFn(X, Y) {
            return UIConfirmationBox.CheckCollision(this, X, Y)
        };
        NewObject.UpdatePosition = function UpdatePosFn(DeltaX, DeltaY) {
            UIConfirmationBox.UpdatePosition(this, DeltaX, DeltaY)
        };
        NewObject.RelocateItem = function RelocateItemFn() {
            UIConfirmationBox.RelocateItem(this)
        };
        return NewObject
    };

    function UITextBox() {}
    UITextBox.prototype = {};
    UITextBox.AddTextBoxItem = function AddTextItemFn(thisUI, X, Y, Text, CentreAlign, RHSAlign, RenderTree, ForceWidth) {
        Debug.Assert(RHSAlign !== undefined && Text !== undefined && X !== undefined && Y !== undefined && RenderTree !== undefined, "PROBLEM! AddTextBoxItem - missing param! Something undefined...");
        Debug.Assert(typeof X === "number" && typeof Y === "number" && typeof RHSAlign === "boolean" && typeof Text === "string", "PROBLEM! AddTextBoxItem - vars do not match type!");
        thisUI.RenderTree = RenderTree;
        thisUI.StartPosition.y = Y;
        if (Text.length < 1) {
            Text = "   "
        }
        thisUI.BackingItem = Helpers.CreateSprite(X, Y, EA.TopLeft, "Editor_White", RenderTree);
        thisUI.BackingItem.SetColour([.411, .411, .411, 1]);
        thisUI.Item = Helpers.CreateBitmapText(Text, X, Y, EA.MiddleMiddle, "EditorFont", RenderTree);
        thisUI.isRHSAlign = RHSAlign;
        if (RHSAlign) {
            thisUI.AlignRight()
        }
        thisUI.isCentreAlign = CentreAlign;
        if (CentreAlign) {
            thisUI.AlignCentre()
        }
        if (ForceWidth !== undefined) {
            thisUI.RequiredWidth = ForceWidth
        }
        return thisUI.Item
    };
    UITextBox.RescaleTextBox = function ScaleTextFn(thisUI) {
        var ItemWidth = thisUI.Item.GetWidth();
        var ItemHeight = thisUI.Item.GetHeight();
        var BestScaleX = ItemWidth / thisUI.BackingItem.GetWidth();
        var BestScaleY = ItemHeight / thisUI.BackingItem.GetHeight();
        thisUI.BackingItem.SetScale(BestScaleX + 20, BestScaleY + 14);
        thisUI.BackingItem.SetPositionY(thisUI.StartPosition.y);
        thisUI.Item.SetPosition(thisUI.BackingItem.GetPositionX() + thisUI.GetTrueWidth() / 2, thisUI.BackingItem.GetPositionY() + thisUI.GetTrueHeight() / 2);
        if (thisUI.RequiredWidth !== 0) {
            BestScaleX = thisUI.RequiredWidth / thisUI.BackingItem.GetWidth();
            thisUI.BackingItem.SetScaleX(BestScaleX)
        }
        thisUI.LastTextSize = ItemWidth
    };
    UITextBox.AlignRight = function AlignTextRightFn(thisUI) {
        var TrueBoxWidth = thisUI.GetTrueWidth();
        var XPos = JamSystem.RenderManager.GetScreenWidth() - TrueBoxWidth;
        thisUI.BackingItem.SetPositionX(XPos);
        thisUI.Item.SetPositionX(XPos + TrueBoxWidth / 2)
    };
    UITextBox.AlignCentre = function AlignTextCentreFn(thisUI) {
        var HalfBoxWidth = thisUI.GetTrueWidth() / 2;
        var XPos = JamSystem.RenderManager.GetScreenWidth() / 2 - HalfBoxWidth;
        thisUI.BackingItem.SetPositionX(XPos);
        thisUI.Item.SetPositionX(XPos + HalfBoxWidth)
    };
    UITextBox.Update = function UpdateFn(thisUI, TimeDelta, MouseX, MouseY) {
        if (thisUI.Item.GetWidth() !== thisUI.LastTextSize) {
            thisUI.RescaleTextBox()
        }
        if (thisUI.isCentreAlign) {
            thisUI.AlignCentre(thisUI)
        }
        if (thisUI.isRHSAlign) {
            thisUI.AlignRight(thisUI)
        }
        UIBase.Update(thisUI, TimeDelta, MouseX, MouseY)
    };
    UITextBox.GetTop = function TopFn(thisUI) {
        return thisUI.BackingItem.GetPositionY()
    };
    UITextBox.GetTrueWidth = function TrueWidthFn(thisUI) {
        return thisUI.BackingItem.GetWidth() * thisUI.BackingItem.GetScaleX()
    };
    UITextBox.GetTrueHeight = function TrueHeightFn(thisUI) {
        return thisUI.BackingItem.GetHeight() * thisUI.BackingItem.GetScaleY()
    };
    UITextBox.CheckCollision = function CheckCollFn(thisUI, X, Y) {
        var TrueWidth = thisUI.GetTrueWidth();
        var TrueHeight = thisUI.GetTrueHeight();
        if (X >= thisUI.BackingItem.GetPositionX() && X <= TrueWidth + thisUI.BackingItem.GetPositionX() && Y >= thisUI.BackingItem.GetPositionY() && Y <= TrueHeight + thisUI.BackingItem.GetPositionY()) {
            return true
        } else {
            return false
        }
    };
    UITextBox.MoveTo = function MoveToFn(thisUI, X, Y) {
        if (X === undefined) {
            X = thisUI.BackingItem.GetPositionX()
        }
        if (Y === undefined) {
            Y = thisUI.BackingItem.GetPositionY()
        }
        thisUI.StartPosition.x = X;
        thisUI.StartPosition.y = Y;
        if (thisUI.BackingItem) {
            thisUI.BackingItem.SetPosition(X, Y)
        }
        thisUI.RescaleTextBox()
    };
    UITextBox.ShiftBy = function ShiftByFn(thisUI, X, Y) {
        var A, B;
        if (thisUI.BackingItem) {
            A = thisUI.BackingItem.GetPositionX();
            B = thisUI.BackingItem.GetPositionY();
            thisUI.BackingItem.SetPosition(A + X, B + Y)
        }
        if (thisUI.Item) {
            A = thisUI.Item.GetPositionX();
            B = thisUI.Item.GetPositionY();
            thisUI.Item.SetPosition(A + X, B + Y)
        }
    };
    UITextBox.RemoveItem = function RemoveItemFn(thisUI) {
        Helpers.DestroyBitmapText(thisUI.Item);
        Helpers.DestroySprite(thisUI.BackingItem)
    };
    UITextBox.Create = function UICreateFn() {
        var NewObject = UIBase.Create();
        NewObject.LastTextSize = -22;
        NewObject.RequiredWidth = 0;
        NewObject.isRHSAlign = false;
        NewObject.isCentreAlign = false;
        NewObject.LastY = 0;
        NewObject.AddTextBoxItem = function AddTextItemFn(X, Y, Text, CentreAlign, RHSAlign, RenderTree, ForceWidth) {
            return UITextBox.AddTextBoxItem(this, X, Y, Text, CentreAlign, RHSAlign, RenderTree, ForceWidth)
        };
        NewObject.RescaleTextBox = function ScaleTextFn() {
            UITextBox.RescaleTextBox(this)
        };
        NewObject.AlignRight = function AlignTextFn() {
            UITextBox.AlignRight(this)
        };
        NewObject.AlignCentre = function AlignTextFn() {
            UITextBox.AlignCentre(this)
        };
        NewObject.Update = function UpdateFn(TimeDelta, MouseX, MouseY) {
            UITextBox.Update(this, TimeDelta, MouseX, MouseY)
        };
        NewObject.GetTop = function TopFn() {
            return UITextBox.GetTop(this)
        };
        NewObject.GetTrueWidth = function TrueWidthFn() {
            return UITextBox.GetTrueWidth(this)
        };
        NewObject.GetTrueHeight = function TrueHeightFn() {
            return UITextBox.GetTrueHeight(this)
        };
        NewObject.CheckCollision = function CheckCollFn(X, Y) {
            return UITextBox.CheckCollision(this, X, Y)
        };
        NewObject.MoveTo = function MoveToFn(X, Y) {
            UITextBox.MoveTo(this, X, Y)
        };
        NewObject.ShiftBy = function ShiftByFn(X, Y) {
            UITextBox.ShiftBy(this, X, Y)
        };
        NewObject.RemoveItem = function RemoveItemFn() {
            UITextBox.RemoveItem(this)
        };
        return NewObject
    };

    function UIBrush() {}
    UIBrush.prototype = {
        HoverOverColour: [0, 0, 0, 1],
        BackingColour: [1, 0, 1, 1]
    };
    UIBrush.AddBrushByIndex = function AddBrushIndexFn(thisUI, X, Y, BrushIndex, BrushSize, RenderTree) {
        Debug.Assert(X !== undefined && Y !== undefined && BrushIndex !== undefined && BrushSize !== undefined && RenderTree !== undefined, "PROBLEM! AddBrushByIndex - missing param! Something undefined...");
        Debug.Assert(typeof X === "number" && typeof Y === "number", "PROBLEM! AddBrushByIndex - vars do not match type!");
        thisUI.BrushIndex = BrushIndex;
        thisUI.BrushInfo = ObjectPaletteManager.ObjectPalette[BrushIndex];
        thisUI.BrushSize = BrushSize;
        thisUI.BackingItem = Helpers.CreateSprite(X - 3, Y - 3, EA.TopLeft, "Editor_White", RenderTree);
        var ActualScale = (thisUI.BrushSize + 6) / thisUI.BackingItem.GetHeight();
        thisUI.BackingItem.SetScale(ActualScale, ActualScale);
        thisUI.BackingItem.SetColour(UIBrush.prototype.BackingColour);
        thisUI.Item = Helpers.CreateSprite(X, Y, EA.TopLeft, thisUI.BrushInfo.Image, RenderTree);
        thisUI.RenderTree = RenderTree;
        ActualScale = 1;
        var HeightScale = thisUI.BrushSize / thisUI.Item.GetHeight();
        var WidthScale = thisUI.BrushSize / thisUI.Item.GetWidth();
        ActualScale = HeightScale < WidthScale ? HeightScale : WidthScale;
        thisUI.Item.SetScale(ActualScale, ActualScale);
        var TrueWidth = thisUI.Item.GetWidth() * ActualScale;
        var TrueHeight = thisUI.Item.GetHeight() * ActualScale;
        if (TrueWidth !== thisUI.BrushSize) {
            var HalfGraphicWidth = TrueWidth / 2;
            var CentreX = X + thisUI.BrushSize / 2;
            thisUI.Item.SetPositionX(CentreX - HalfGraphicWidth)
        }
        if (TrueHeight !== thisUI.BrushSize) {
            var HalfGraphicHeight = TrueHeight / 2;
            var CentreY = Y + thisUI.BrushSize / 2;
            thisUI.Item.SetPositionY(CentreY - HalfGraphicHeight)
        }
        thisUI.Item.SetColour([1, 1, 1, 1]);
        thisUI.TickItem = Helpers.CreateSprite(X + thisUI.BrushSize - 15, Y, EA.TopLeft, "Editor_Tick", RenderTree);
        thisUI.TickItem.SetIsVisible(false);
        thisUI.AllowTick = false;
        return thisUI.Item
    };
    UIBrush.AddBrushByEntity = function AddBrushEntityFn(thisUI, X, Y, BrushEntities, BrushSize, RenderTree) {
        Debug.Assert(X !== undefined && Y !== undefined && BrushEntities !== undefined && BrushSize !== undefined && RenderTree !== undefined, "PROBLEM! AddBrushByEntity - missing param! Something undefined...");
        Debug.Assert(typeof X === "number" && typeof Y === "number", "PROBLEM! AddBrushByEntity - vars do not match type!");
        thisUI.BrushSize = BrushSize;
        thisUI.Entities = BrushEntities;
        thisUI.RenderTree = RenderTree;
        thisUI.BackingItem = Helpers.CreateSprite(X, Y, EA.TopLeft, "Editor_White", RenderTree);
        var ActualScale = thisUI.BrushSize / thisUI.BackingItem.GetHeight();
        thisUI.BackingItem.SetScale(ActualScale, ActualScale);
        thisUI.BackingItem.SetColour(UIBrush.prototype.BackingColour);
        thisUI.EntityRenderTree = JamSystem.RenderManager.CreateTree(X, Y);
        RenderTree.AddChild(thisUI.EntityRenderTree);
        var Width = 0,
            Height = 0,
            Centre = new Vector2;
        var Returns = [{
            Name: "Width",
            Value: Width
        }, {
            Name: "Height",
            Value: Height
        }, {
            Name: "Centre",
            Value: Centre
        }];
        thisUI.FindScaleStats(thisUI.Entities, Returns);
        Width = Returns[0].Value;
        Height = Returns[1].Value;
        Centre = Returns[2].Value;
        var i = 0;
        for (i = 0; i < thisUI.Entities.length; i += 1) {
            var Sprite = thisUI.Entities[i].Sprite;
            thisUI.OffsetX[i] = Centre.x - thisUI.Entities[i].StartX;
            thisUI.OffsetY[i] = Centre.y - thisUI.Entities[i].StartY;
            thisUI.EntityRenderTree.AddChild(thisUI.Entities[i].Sprite)
        }
        var Scale = 1;
        var HeightScale = thisUI.BrushSize / Height - .01;
        var WidthScale = thisUI.BrushSize / Width - .01;
        Scale = HeightScale < WidthScale ? HeightScale : WidthScale;
        thisUI.EntityRenderTree.SetScale(Scale, Scale);
        thisUI.EntityRenderTree.SetPosition(thisUI.EntityRenderTree.GetPositionX() - Centre.x * Scale + BrushSize / 2, thisUI.EntityRenderTree.GetPositionY() - Centre.y * Scale + BrushSize / 2);
        thisUI.CrossItem = Helpers.CreateSprite(X + thisUI.BrushSize - 15, Y, EA.TopLeft, "Editor_Cross", RenderTree);
        return thisUI.BackingItem
    };
    UIBrush.FindScaleStats = function FindWidthFn(Entities, Returns) {
        var MinX = 9999999,
            MaxX = -9999999,
            MinY = 9999999,
            MaxY = -9999999,
            i = 0;
        for (i = 0; i < Entities.length; i += 1) {
            var CurrEntity = Entities[i];
            var ScaledX = CurrEntity.GetWidth() * .5 * CurrEntity.StartScaleX;
            var ScaledY = CurrEntity.GetHeight() * .5 * CurrEntity.StartScaleY;
            var Left = CurrEntity.StartX - ScaledX;
            var Right = CurrEntity.StartX + ScaledX;
            var Top = CurrEntity.StartY - ScaledY;
            var Bottom = CurrEntity.StartY + ScaledY;
            var CosAngle = Math.cos(CurrEntity.StartRotation);
            var SinAngle = Math.sin(CurrEntity.StartRotation);
            var TL = new Vector2,
                TR = new Vector2,
                BL = new Vector2,
                BR = new Vector2;
            var ShiftX = Left + (Right - Left) * .5;
            var ShiftY = Top + (Bottom - Top) * .5;
            TL.x = Left - ShiftX;
            TL.y = Top - ShiftY;
            TR.x = Right - ShiftX;
            TR.y = Top - ShiftY;
            BR.x = Right - ShiftX;
            BR.y = Bottom - ShiftY;
            BL.x = Left - ShiftX;
            BL.y = Bottom - ShiftY;
            var Rotated = new Vector2;
            Rotated.x = TL.x * CosAngle - TL.y * SinAngle;
            Rotated.y = TL.x * SinAngle + TL.y * CosAngle;
            if (Rotated.x + ShiftX < MinX) {
                MinX = Rotated.x + ShiftX
            }
            if (Rotated.x + ShiftX > MaxX) {
                MaxX = Rotated.x + ShiftX
            }
            if (Rotated.y + ShiftY < MinY) {
                MinY = Rotated.y + ShiftY
            }
            if (Rotated.y + ShiftY > MaxY) {
                MaxY = Rotated.y + ShiftY
            }
            Rotated.x = TR.x * CosAngle - TR.y * SinAngle;
            Rotated.y = TR.x * SinAngle + TR.y * CosAngle;
            if (Rotated.x + ShiftX < MinX) {
                MinX = Rotated.x + ShiftX
            }
            if (Rotated.x + ShiftX > MaxX) {
                MaxX = Rotated.x + ShiftX
            }
            if (Rotated.y + ShiftY < MinY) {
                MinY = Rotated.y + ShiftY
            }
            if (Rotated.y + ShiftY > MaxY) {
                MaxY = Rotated.y + ShiftY
            }
            Rotated.x = BR.x * CosAngle - BR.y * SinAngle;
            Rotated.y = BR.x * SinAngle + BR.y * CosAngle;
            if (Rotated.x + ShiftX < MinX) {
                MinX = Rotated.x + ShiftX
            }
            if (Rotated.x + ShiftX > MaxX) {
                MaxX = Rotated.x + ShiftX
            }
            if (Rotated.y + ShiftY < MinY) {
                MinY = Rotated.y + ShiftY
            }
            if (Rotated.y + ShiftY > MaxY) {
                MaxY = Rotated.y + ShiftY
            }
            Rotated.x = BL.x * CosAngle - BL.y * SinAngle;
            Rotated.y = BL.x * SinAngle + BL.y * CosAngle;
            if (Rotated.x + ShiftX < MinX) {
                MinX = Rotated.x + ShiftX
            }
            if (Rotated.x + ShiftX > MaxX) {
                MaxX = Rotated.x + ShiftX
            }
            if (Rotated.y + ShiftY < MinY) {
                MinY = Rotated.y + ShiftY
            }
            if (Rotated.y + ShiftY > MaxY) {
                MaxY = Rotated.y + ShiftY
            }
        }
        Returns[0].Value = MaxX - MinX;
        Returns[1].Value = MaxY - MinY;
        Returns[2].Value.x = MinX + (MaxX - MinX) * .5;
        Returns[2].Value.y = MinY + (MaxY - MinY) * .5
    };
    UIBrush.Reset = function ResetFn(thisUI) {
        thisUI.isFlashing = false;
        if (thisUI.Item) {
            thisUI.Item.SetColour([1, 1, 1, 1])
        }
        if (thisUI.BackingItem) {
            thisUI.BackingItem.SetColour(UIBrush.prototype.BackingColour)
        }
        if (thisUI.CrossItem) {
            thisUI.CrossItem.SetColour([1, 1, 1, 1])
        }
        if (thisUI.TickItem) {
            thisUI.TickItem.SetColour([1, 1, 1, 1])
        }
    };
    UIBrush.CheckRightClickCollision = function CheckCollRCFn(thisUI, X, Y) {
        var CompensateX = thisUI.RenderTree.GetPositionX();
        if (X >= thisUI.BackingItem.GetPositionX() + CompensateX && X <= thisUI.GetTrueWidth() + thisUI.BackingItem.GetPositionX() + CompensateX && Y >= thisUI.BackingItem.GetPositionY() && Y <= thisUI.GetTrueHeight() + thisUI.BackingItem.GetPositionY()) {
            return thisUI.BrushInfo
        }
        return false
    };
    UIBrush.CheckDelete = function CheckCollDeleteFn(thisUI, X, Y) {
        var CompensateX = thisUI.RenderTree.GetPositionX();
        if (thisUI.CrossItem) {
            if (X >= thisUI.CrossItem.GetPositionX() + CompensateX && X <= 15 + thisUI.CrossItem.GetPositionX() + CompensateX && Y >= thisUI.CrossItem.GetPositionY() && Y <= 15 + thisUI.CrossItem.GetPositionY()) {
                return true
            }
        }
        return false
    };
    UIBrush.ShiftBackwards = function ShuntBrushFn(thisUI, BrushSize, BrushesPerLine) {
        var Delta = BrushSize + 10;
        if (BrushSize === UIPalette.prototype.BrushSizeLarge) {
            if (thisUI.EntityRenderTree) {
                thisUI.EntityRenderTree.SetPositionY(thisUI.EntityRenderTree.GetPositionY() - Delta)
            }
            if (thisUI.CrossItem) {
                thisUI.CrossItem.SetPositionY(thisUI.CrossItem.GetPositionY() - Delta)
            }
            if (thisUI.Item) {
                thisUI.Item.SetPositionY(thisUI.Item.GetPositionY() - Delta)
            }
            thisUI.BackingItem.SetPositionY(thisUI.BackingItem.GetPositionY() - Delta)
        }
        if (BrushSize === UIPalette.prototype.BrushSizeSmall) {
            if (thisUI.BackingItem.GetPositionX() !== 7) {
                if (thisUI.Item) {
                    thisUI.Item.SetPositionX(thisUI.Item.GetPositionX() - Delta)
                }
                thisUI.BackingItem.SetPositionX(thisUI.BackingItem.GetPositionX() - Delta)
            } else {
                var NewXPos = 10 + BrushesPerLine * (BrushSize + 10);
                if (thisUI.Item) {
                    thisUI.Item.SetPositionX(NewXPos)
                }
                thisUI.BackingItem.SetPositionX(NewXPos - 3);
                if (thisUI.Item) {
                    thisUI.Item.SetPositionY(thisUI.Item.GetPositionY() - Delta)
                }
                thisUI.BackingItem.SetPositionY(thisUI.BackingItem.GetPositionY() - Delta)
            }
            thisUI.BrushIndex -= 1
        }
    };
    UIBrush.HighlightItem = function HighlightItemFn(thisUI, Highlight, Selected) {
        if (thisUI.QuickShowBrushSelected && !Selected) {
            return
        }
        thisUI.QuickShowBrushSelected = Selected;
        if (!Highlight) {
            thisUI.BackingItem.SetColour(UIBrush.prototype.BackingColour);
            thisUI.QuickShowBrushSelected = false
        }
        thisUI.isHighlighted = Highlight
    };
    UIBrush.ReplaceBrushInfo = function ReplaceBrushInfoFn(thisUI, NewBrushIndex) {
        thisUI.BrushIndex = NewBrushIndex;
        thisUI.BrushInfo = ObjectPaletteManager.ObjectPalette[NewBrushIndex];
        var TextureInfo = Helpers.GetTextureInfoFromImageName(thisUI.BrushInfo.Image);
        thisUI.Item.SetTexture(TextureInfo.Texture, TextureInfo.Frame);
        var ActualScale = 1;
        var HeightScale = thisUI.BrushSize / thisUI.Item.GetHeight();
        var WidthScale = thisUI.BrushSize / thisUI.Item.GetWidth();
        ActualScale = HeightScale < WidthScale ? HeightScale : WidthScale;
        thisUI.Item.SetScale(ActualScale, ActualScale);
        thisUI.Item.SetPositionX(thisUI.BackingItem.GetPosition().x + 3);
        thisUI.Item.SetPositionY(thisUI.BackingItem.GetPosition().y + 3);
        var TrueWidth = thisUI.Item.GetWidth() * ActualScale;
        var TrueHeight = thisUI.Item.GetHeight() * ActualScale;
        if (TrueWidth !== thisUI.BrushSize) {
            var HalfGraphicWidth = TrueWidth / 2;
            var CentreX = thisUI.BackingItem.GetPosition().x + 3 + thisUI.BrushSize / 2;
            thisUI.Item.SetPositionX(CentreX - HalfGraphicWidth)
        }
        if (TrueHeight !== thisUI.BrushSize) {
            var HalfGraphicHeight = TrueHeight / 2;
            var CentreY = thisUI.BackingItem.GetPosition().y + 3 + thisUI.BrushSize / 2;
            thisUI.Item.SetPositionY(CentreY - HalfGraphicHeight)
        }
    };
    UIBrush.Update = function UpdateFn(thisUI, TimeDelta, MouseX, MouseY) {
        if (thisUI.isFlashing || thisUI.isHighlighted) {
            thisUI.Modifier += TimeDelta;
            if (thisUI.Modifier > .12) {
                if (thisUI.FlashAmount === 1) {
                    thisUI.FlashAmount = 0
                } else {
                    thisUI.FlashAmount = 1
                }
                thisUI.Modifier = 0
            }
            if (!thisUI.isHighlighted) {
                if (thisUI.Item) {
                    thisUI.Item.SetColour([1, 1, 1, thisUI.FlashAmount])
                }
                if (thisUI.BackingItem) {
                    thisUI.BackingItem.SetColour([1, 1, 1, thisUI.FlashAmount])
                }
                if (thisUI.CrossItem) {
                    thisUI.CrossItem.SetColour([1, 1, 1, thisUI.FlashAmount])
                }
                if (thisUI.TickItem) {
                    thisUI.TickItem.SetColour([1, 1, 1, thisUI.FlashAmount])
                }
            } else {
                if (thisUI.BackingItem) {
                    thisUI.BackingItem.SetColour([thisUI.FlashAmount, thisUI.FlashAmount, thisUI.FlashAmount, 1])
                }
            }
        }
        var CompensateX = thisUI.RenderTree.GetPositionX();
        var BrushColour = thisUI.BackingItem.GetColour();
        var MouseOver = MouseX >= thisUI.BackingItem.GetPositionX() + CompensateX && MouseX <= thisUI.GetTrueWidth() + thisUI.BackingItem.GetPositionX() + CompensateX && MouseY >= thisUI.BackingItem.GetPositionY() && MouseY <= thisUI.GetTrueHeight() + thisUI.BackingItem.GetPositionY();
        if (BrushColour !== UIBrush.prototype.HoverOverColour && MouseOver) {
            thisUI.BackingItem.SetColour(UIBrush.prototype.HoverOverColour)
        }
        if (BrushColour === UIBrush.prototype.HoverOverColour && !MouseOver && !thisUI.isHighlighted) {
            thisUI.BackingItem.SetColour(UIBrush.prototype.BackingColour)
        }
        UIBase.Update(thisUI, TimeDelta, MouseX, MouseY)
    };
    UIBrush.GetTop = function TopFn(thisUI) {
        return thisUI.BackingItem.GetPositionY()
    };
    UIBrush.GetTrueWidth = function TrueWidthFn(thisUI) {
        return thisUI.BackingItem.GetWidth() * thisUI.BackingItem.GetScaleX()
    };
    UIBrush.GetTrueHeight = function TrueHeightFn(thisUI) {
        return thisUI.BackingItem.GetHeight() * thisUI.BackingItem.GetScaleY()
    };
    UIBrush.CheckCollision = function CheckCollFn(thisUI, X, Y) {
        var CompensateX = thisUI.RenderTree.GetPositionX();
        if (X >= thisUI.BackingItem.GetPositionX() + CompensateX && X <= thisUI.GetTrueWidth() + thisUI.BackingItem.GetPositionX() + CompensateX && Y >= thisUI.BackingItem.GetPositionY() && Y <= thisUI.GetTrueHeight() + thisUI.BackingItem.GetPositionY()) {
            return true
        }
        return false
    };
    UIBrush.SetIsVisible = function SetIsVisibleFn(thisUI, Visible) {
        UIBase.SetIsVisible(thisUI, Visible);
        if (thisUI.EntityRenderTree) {
            thisUI.EntityRenderTree.SetIsVisible(Visible)
        }
        if (thisUI.CrossItem) {
            thisUI.CrossItem.SetIsVisible(Visible)
        }
        if (thisUI.TickItem) {
            if (thisUI.AllowTick && thisUI.Item.GetIsVisible()) {
                thisUI.TickItem.SetIsVisible(Visible)
            }
            if (!Visible) {
                thisUI.TickItem.SetIsVisible(Visible)
            }
        }
        thisUI.Reset()
    };
    UIBrush.Scroll = function ScrollFn(thisUI, Delta) {
        UIBase.Scroll(thisUI, Delta);
        var NewPosition;
        if (thisUI.CrossItem) {
            NewPosition = thisUI.CrossItem.GetPositionY() - Delta;
            thisUI.CrossItem.SetPositionY(NewPosition)
        }
        if (thisUI.TickItem) {
            NewPosition = thisUI.TickItem.GetPositionY() - Delta;
            thisUI.TickItem.SetPositionY(NewPosition)
        }
        if (thisUI.EntityRenderTree) {
            NewPosition = thisUI.EntityRenderTree.GetPositionY() - Delta;
            thisUI.EntityRenderTree.SetPositionY(NewPosition)
        }
    };
    UIBrush.ShiftBy = function ShiftByFn(thisUI, X, Y) {
        var A, B;
        if (thisUI.EntityRenderTree) {
            A = thisUI.EntityRenderTree.GetPositionX();
            B = thisUI.EntityRenderTree.GetPositionY();
            thisUI.EntityRenderTree.SetPosition(A + X, B + Y)
        }
        if (thisUI.CrossItem) {
            A = thisUI.CrossItem.GetPositionX();
            B = thisUI.CrossItem.GetPositionY();
            thisUI.CrossItem.SetPosition(A + X, B + Y)
        }
        if (thisUI.TickItem) {
            A = thisUI.TickItem.GetPositionX();
            B = thisUI.TickItem.GetPositionY();
            thisUI.TickItem.SetPosition(A + X, B + Y)
        }
        if (thisUI.Item) {
            A = thisUI.Item.GetPositionX();
            B = thisUI.Item.GetPositionY();
            thisUI.Item.SetPosition(A + X, B + Y)
        }
        if (thisUI.BackingItem) {
            A = thisUI.BackingItem.GetPositionX();
            B = thisUI.BackingItem.GetPositionY();
            thisUI.BackingItem.SetPosition(A + X, B + Y)
        }
    };
    UIBrush.MoveTo = function MoveToFn(thisUI, X, Y) {
        if (thisUI.TickItem) {
            thisUI.TickItem.SetPosition(X + thisUI.BrushSize - 15, Y)
        }
        var XDiff = thisUI.Item.GetPositionX() - thisUI.BackingItem.GetPositionX();
        var YDiff = thisUI.Item.GetPositionY() - thisUI.BackingItem.GetPositionY();
        if (thisUI.BackingItem) {
            thisUI.BackingItem.SetPosition(X, Y)
        }
        if (thisUI.Item) {
            thisUI.Item.SetPosition(thisUI.BackingItem.GetPositionX() + XDiff, thisUI.BackingItem.GetPositionY() + YDiff)
        }
    };
    UIBrush.RemoveItem = function RemoveItemFn(thisUI) {
        if (thisUI.EntityRenderTree) {
            thisUI.RenderTree.RemoveChild(thisUI.EntityRenderTree);
            var i = 0;
            for (i = 0; i < thisUI.Entities.length; i += 1) {
                thisUI.EntityRenderTree.RemoveChild(thisUI.Entities[i].Sprite)
            }
            Helpers.DestroyTree(thisUI.EntityRenderTree)
        }
        if (thisUI.CrossItem) {
            Helpers.DestroySprite(thisUI.CrossItem)
        }
        if (thisUI.TickItem) {
            Helpers.DestroySprite(thisUI.TickItem)
        }
        if (thisUI.Item) {
            Helpers.DestroySprite(thisUI.Item)
        }
        if (thisUI.BackingItem) {
            Helpers.DestroySprite(thisUI.BackingItem)
        }
        thisUI.Entities = 0
    };
    UIBrush.Create = function UICreateFn() {
        var NewObject = UIBase.Create();
        NewObject.BrushInfo = 0;
        NewObject.BrushIndex = 0;
        NewObject.BrushSize = 0;
        NewObject.isFlashing = false;
        NewObject.isHighlighted = false;
        NewObject.QuickShowBrushSelected = false;
        NewObject.EntityRenderTree = 0;
        NewObject.OffsetX = [];
        NewObject.OffsetY = [];
        NewObject.Entities = [];
        NewObject.CrossItem = 0;
        NewObject.TickItem = 0;
        NewObject.AllowTick = false;
        NewObject.AddBrushByIndex = function AddBrushIndexFn(X, Y, BrushIndex, BrushSize, RenderTree) {
            return UIBrush.AddBrushByIndex(this, X, Y, BrushIndex, BrushSize, RenderTree)
        };
        NewObject.AddBrushByEntity = function AddBrushEntityFn(X, Y, BrushEntities, BrushSize, RenderTree) {
            return UIBrush.AddBrushByEntity(this, X, Y, BrushEntities, BrushSize, RenderTree)
        };
        NewObject.FindScaleStats = function FindWidthFn(Entities, Returns) {
            return UIBrush.FindScaleStats(Entities, Returns)
        };
        NewObject.Reset = function ResetFn() {
            UIBrush.Reset(this)
        };
        NewObject.CheckRightClickCollision = function CheckCollRCFn(X, Y) {
            return UIBrush.CheckRightClickCollision(this, X, Y)
        };
        NewObject.CheckDelete = function CheckCollDeleteFn(X, Y) {
            return UIBrush.CheckDelete(this, X, Y)
        };
        NewObject.ShiftBackwards = function ShuntBrushFn(BrushSize, BrushesPerLine) {
            UIBrush.ShiftBackwards(this, BrushSize, BrushesPerLine)
        };
        NewObject.HighlightItem = function HighlightItemFn(Highlight, Selected) {
            UIBrush.HighlightItem(this, Highlight, Selected)
        };
        NewObject.ReplaceBrushInfo = function ReplaceBrushInfoFn(NewBrushIndex) {
            UIBrush.ReplaceBrushInfo(this, NewBrushIndex)
        };
        NewObject.GetTop = function TopFn() {
            return UIBrush.GetTop(this)
        };
        NewObject.GetTrueWidth = function TrueWidthFn() {
            return UIBrush.GetTrueWidth(this)
        };
        NewObject.GetTrueHeight = function TrueHeightFn() {
            return UIBrush.GetTrueHeight(this)
        };
        NewObject.CheckCollision = function CheckCollFn(X, Y) {
            return UIBrush.CheckCollision(this, X, Y)
        };
        NewObject.Update = function UpdateFn(TimeDelta, MouseX, MouseY) {
            UIBrush.Update(this, TimeDelta, MouseX, MouseY)
        };
        NewObject.SetIsVisible = function SetIsVisibleFn(Visible) {
            UIBrush.SetIsVisible(this, Visible)
        };
        NewObject.Scroll = function ScrollFn(Delta) {
            UIBrush.Scroll(this, Delta)
        };
        NewObject.ShiftBy = function ShiftByFn(X, Y) {
            UIBrush.ShiftBy(this, X, Y)
        };
        NewObject.MoveTo = function MoveToFn(X, Y) {
            UIBrush.MoveTo(this, X, Y)
        };
        NewObject.RemoveItem = function RemoveItemFn() {
            UIBrush.RemoveItem(this)
        };
        return NewObject
    };

    function UIScrollBar() {}
    UIScrollBar.prototype = {
        Generosity: 60
    };
    UIScrollBar.AddScrollBarBacking = function AddScrollBkFn(thisUI, X, Y, EndY, RenderTree) {
        thisUI.BackingItem = Helpers.CreateSprite(X - thisUI.ScrollBarWidth, Y, EA.TopLeft, "Editor_White", RenderTree);
        thisUI.BackingItem.SetColour([0, 0, 0, 1]);
        var ScaleWidth = thisUI.ScrollBarWidth / thisUI.BackingItem.GetWidth();
        var ScaleHeight = EndY / thisUI.BackingItem.GetHeight();
        thisUI.BackingItem.SetScale(ScaleWidth, ScaleHeight);
        thisUI.Scrolling = false;
        thisUI.ScrollStart = 0;
        return thisUI.BackingItem
    };
    UIScrollBar.AddScrollBar = function AddScrollFn(thisUI, ScrollerLength, Speed, X, Y, EndY, RenderTree) {
        Debug.Assert(ScrollerLength !== undefined && Speed !== undefined && EndY !== undefined && X !== undefined && Y !== undefined && RenderTree !== undefined, "PROBLEM! AddScrollBar - missing param! Something undefined...");
        Debug.Assert(typeof X === "number" && typeof Y === "number" && typeof EndY === "number" && typeof Speed === "number" && typeof ScrollerLength === "number", "PROBLEM! AddScrollBar - vars do not match type!");
        thisUI.Top = Y;
        thisUI.Bottom = EndY + Y;
        thisUI.ScrollSpeed = Speed;
        thisUI.RenderTree = RenderTree;
        thisUI.AddScrollBarBacking(X, Y, EndY, RenderTree);
        thisUI.Item = Helpers.CreateSprite(X - thisUI.ScrollBarWidth, Y, EA.TopLeft, "Editor_White", RenderTree);
        thisUI.Item.SetColour([1, 1, 1, 1]);
        var ScaleWidth = thisUI.ScrollBarWidth / thisUI.Item.GetWidth();
        var ScrollScaleHeight = ScrollerLength / thisUI.Item.GetHeight();
        thisUI.Item.SetScale(ScaleWidth, ScrollScaleHeight);
        return thisUI.Item
    };
    UIScrollBar.ModifyScrollBar = function AddScrollModFn(thisUI, Length, Speed, BackLength, isPalette) {
        var PercentScroll = thisUI.Item.GetPositionY() / BackLength;
        var Scale = Length / thisUI.Item.GetHeight();
        thisUI.Item.SetScaleY(Scale);
        Scale = BackLength / thisUI.BackingItem.GetHeight();
        thisUI.BackingItem.SetScaleY(Scale);
        var OldSpeed = thisUI.ScrollSpeed;
        thisUI.ScrollSpeed = Speed;
        thisUI.Bottom = thisUI.BackingItem.GetPositionY() + thisUI.BackingItem.GetHeight() * thisUI.BackingItem.GetScaleY();
        var Change = thisUI.Top - thisUI.Item.GetPositionY();
        thisUI.Item.SetPositionY(thisUI.Item.GetPositionY() + Change);
        if (isPalette) {
            thisUI.Item.SetPositionY(thisUI.Item.GetPositionY() + BackLength * PercentScroll);
            var BackTrueHeight = thisUI.BackingItem.GetHeight() * thisUI.BackingItem.GetScaleY();
            var ScrollerLen = thisUI.Item.GetHeight() * thisUI.Item.GetScaleY();
            var Diff = 0;
            if (thisUI.Item.GetPositionY() + ScrollerLen > thisUI.BackingItem.GetPositionY() + BackTrueHeight) {
                var Position = thisUI.BackingItem.GetPositionY() + BackTrueHeight - ScrollerLen;
                Diff = thisUI.Item.GetPositionY() - Position;
                thisUI.Item.SetPositionY(thisUI.Item.GetPositionY() - Diff)
            }
            return (BackLength * PercentScroll - Diff) * thisUI.ScrollSpeed + Change * OldSpeed
        }
        return Change * OldSpeed
    };
    UIScrollBar.ResetScrollBar = function ResetScrollBarFn(thisUI, Objects) {
        var Change = thisUI.Top - thisUI.Item.GetPositionY();
        thisUI.Item.SetPositionY(thisUI.Item.GetPositionY() + Change);
        var i = 0;
        if (Objects) {
            for (i = 0; i < Objects.length; i += 1) {
                Objects[i].ShiftBy(0, -(Change * thisUI.ScrollSpeed))
            }
        }
        return -(Change * thisUI.ScrollSpeed)
    };
    UIScrollBar.DisableScrollBar = function DisableScrollFn(thisUI) {
        Helpers.DestroySprite(thisUI.Item);
        Helpers.DestroySprite(thisUI.BackingItem)
    };
    UIScrollBar.UpdateScrollPosition = function UpdateScrollerFn(thisUI, NewYVal) {
        var Shift = 0;
        var Delta = NewYVal - thisUI.ScrollStart;
        if (Delta === 0) {
            return 0
        }
        var NewPosition = thisUI.Item.GetPositionY() + Delta;
        var TrueScrollLength = thisUI.GetTrueHeight();
        if (NewPosition < thisUI.Top) {
            Shift = thisUI.Top - NewPosition;
            NewPosition += Shift
        }
        if (NewPosition + TrueScrollLength > thisUI.Bottom) {
            Shift = thisUI.Bottom - (TrueScrollLength + NewPosition);
            NewPosition += Shift
        }
        thisUI.Item.SetPositionY(NewPosition);
        thisUI.ScrollStart = NewYVal;
        return Delta + Shift
    };
    UIScrollBar.Update = function UpdateFn(thisUI, TimeDelta, MouseX, MouseY) {
        if (!JamSystem.InputManager.GetMouseButtonHeld(0)) {
            thisUI.Scrolling = false;
            thisUI.ScrollStart = 0;
            thisUI.isFocused = false
        }
        thisUI.ScrollDelta = 0;
        var MouseZDelta = JamSystem.InputManager.GetMouseZ();
        MouseZDelta *= thisUI.MouseWheelSpeed;
        if (thisUI.IsMouseOverGenerous(MouseX, MouseY) && thisUI.Scrolling) {
            if (JamSystem.InputManager.GetMouseLeftScreen()) {
                thisUI.Scrolling = false;
                thisUI.ScrollStart = 0;
                thisUI.isFocused = false
            }
            thisUI.isFocused = true;
            thisUI.ScrollDelta = thisUI.UpdateScrollPosition(MouseY);
            thisUI.ScrollDelta *= thisUI.ScrollSpeed;
            return
        }
        if (MouseZDelta !== 0) {
            thisUI.isFocused = true;
            MouseY = -MouseZDelta * 10;
            thisUI.ScrollDelta = thisUI.UpdateScrollPosition(MouseY);
            thisUI.ScrollDelta *= thisUI.ScrollSpeed;
            return
        }
        thisUI.isFocused = false;
        UIBase.Update(thisUI, TimeDelta, MouseX, MouseY)
    };
    UIScrollBar.CheckCollision = function CheckCollFn(thisUI, X, Y, VaArgs, Box) {
        var ScrollWidth = thisUI.Item.GetWidth() * thisUI.Item.GetScaleX();
        var ScrollHeight = thisUI.Item.GetHeight() * thisUI.Item.GetScaleY();
        if (X >= thisUI.Item.GetPositionX() && X <= ScrollWidth + thisUI.Item.GetPositionX() && Y >= thisUI.Item.GetPositionY() && Y <= ScrollHeight + thisUI.Item.GetPositionY()) {
            thisUI.Scrolling = true;
            thisUI.ScrollStart = Y;
            thisUI.isFocused = true;
            return true
        }
        var TrueWidth = thisUI.BackingItem.GetWidth() * thisUI.BackingItem.GetScaleX();
        var TrueHeight = thisUI.BackingItem.GetHeight() * thisUI.BackingItem.GetScaleY();
        if (thisUI.BackingItem) {
            if (X >= thisUI.BackingItem.GetPositionX() && X <= TrueWidth + thisUI.BackingItem.GetPositionX() && Y >= thisUI.BackingItem.GetPositionY() && Y <= TrueHeight + thisUI.BackingItem.GetPositionY()) {
                var Addition = Y - thisUI.Item.GetPositionY();
                var Position = Y;
                var ScrollerLen = thisUI.Item.GetHeight() * thisUI.Item.GetScaleY();
                if (Position + ScrollerLen > thisUI.BackingItem.GetPositionY() + TrueHeight) {
                    Position = thisUI.BackingItem.GetPositionY() + TrueHeight - ScrollerLen;
                    Addition -= Y - Position
                }
                thisUI.Item.SetPositionY(Position);
                var i = 0;
                for (i = 0; i < VaArgs.length; i += 1) {
                    if (VaArgs[i] !== Box) {
                        VaArgs[i].Scroll(Addition * thisUI.ScrollSpeed)
                    }
                }
                return true
            }
        }
        return false
    };
    UIScrollBar.UpdatePosition = function UpdatePosFn(thisUI, DeltaX, DeltaY) {
        UIBase.UpdatePosition(thisUI, DeltaX, DeltaY);
        thisUI.Top += DeltaY;
        thisUI.Bottom += DeltaY
    };
    UIScrollBar.Scroll = function ScrollFn(thisUI, Delta) {
        UIBase.Scroll(thisUI, Delta);
        thisUI.Top -= Delta;
        thisUI.Bottom -= Delta
    };
    UIScrollBar.RemoveItem = function RemoveItemFn(thisUI) {
        Helpers.DestroySprite(thisUI.BackingItem);
        Helpers.DestroySprite(thisUI.Item)
    };
    UIScrollBar.IsMouseOver = function IsMouseOverFn(thisUI, X, Y) {
        var ScrollWidth = thisUI.Item.GetWidth() * thisUI.Item.GetScaleX();
        var ScrollHeight = thisUI.Item.GetHeight() * thisUI.Item.GetScaleY();
        if (X >= thisUI.Item.GetPositionX() && X <= ScrollWidth + thisUI.Item.GetPositionX() && Y >= thisUI.Item.GetPositionY() && Y <= ScrollHeight + thisUI.Item.GetPositionY()) {
            return true
        }
        return false
    };
    UIScrollBar.IsMouseOverGenerous = function IsMouseOverGenFn(thisUI, X, Y) {
        var ScrollWidth = thisUI.Item.GetWidth() * thisUI.Item.GetScaleX();
        var ScrollHeight = thisUI.Item.GetHeight() * thisUI.Item.GetScaleY();
        var Delta = UIScrollBar.prototype.Generosity;
        if (X >= thisUI.Item.GetPositionX() - Delta && X <= ScrollWidth + thisUI.Item.GetPositionX() + Delta && Y >= thisUI.Item.GetPositionY() - Delta && Y <= ScrollHeight + thisUI.Item.GetPositionY() + Delta) {
            return true
        }
        return false
    };
    UIScrollBar.Create = function UICreateFn() {
        var NewObject = UIBase.Create();
        NewObject.ScrollSpeed = 0;
        NewObject.Top = 0;
        NewObject.Bottom = 0;
        NewObject.Scrolling = false;
        NewObject.ScrollStart = 0;
        NewObject.ScrollDelta = 0;
        NewObject.MouseWheelSpeed = 1;
        NewObject.AddScrollBarBacking = function AddScrollBkFn(X, Y, EndY, RenderTree) {
            return UIScrollBar.AddScrollBarBacking(this, X, Y, EndY, RenderTree)
        };
        NewObject.AddScrollBar = function AddScrollFn(ScrollerLength, Speed, X, Y, EndY, RenderTree) {
            return UIScrollBar.AddScrollBar(this, ScrollerLength, Speed, X, Y, EndY, RenderTree)
        };
        NewObject.ModifyScrollBar = function AddScrollModFn(Length, Speed, BackLength, isPalette) {
            return UIScrollBar.ModifyScrollBar(this, Length, Speed, BackLength, isPalette)
        };
        NewObject.UpdateScrollPosition = function UpdateScrollerFn(NewYVal) {
            return UIScrollBar.UpdateScrollPosition(this, NewYVal)
        };
        NewObject.ResetScrollBar = function ResetScrollBarFn(Objects) {
            return UIScrollBar.ResetScrollBar(this, Objects)
        };
        NewObject.DisableScrollBar = function DisableScrollFn() {
            UIScrollBar.DisableScrollBar(this)
        };
        NewObject.IsMouseOverGenerous = function IsMouseOverGenFn(X, Y) {
            return UIScrollBar.IsMouseOverGenerous(this, X, Y)
        };
        NewObject.Update = function UpdateFn(TimeDelta, MouseX, MouseY) {
            UIScrollBar.Update(this, TimeDelta, MouseX, MouseY)
        };
        NewObject.CheckCollision = function CheckCollFn(X, Y, VaArgs, Box) {
            return UIScrollBar.CheckCollision(this, X, Y, VaArgs, Box)
        };
        NewObject.UpdatePosition = function UpdatePosFn(DeltaX, DeltaY) {
            UIScrollBar.UpdatePosition(this, DeltaX, DeltaY)
        };
        NewObject.Scroll = function ScrollFn(Delta) {
            UIScrollBar.Scroll(this, Delta)
        };
        NewObject.RemoveItem = function RemoveItemFn() {
            UIScrollBar.RemoveItem(this)
        };
        NewObject.IsMouseOver = function IsMouseOverFn(X, Y) {
            return UIScrollBar.IsMouseOver(this, X, Y)
        };
        return NewObject
    };

    function UICheckBox() {}
    UICheckBox.prototype = {};
    UICheckBox.AddCheckItem = function AddCheckItemFn(thisUI, X, Y, RenderTree) {
        Debug.Assert(X !== undefined && Y !== undefined && RenderTree !== undefined, "PROBLEM! AddCheckItem - missing param! Something undefined...");
        Debug.Assert(typeof X === "number" && typeof Y === "number", "PROBLEM! AddCheckItem - vars do not match type!");
        thisUI.RenderTree = RenderTree;
        thisUI.Item = Helpers.CreateSprite(X, Y, EA.TopLeft, "Editor_Cross", RenderTree);
        var ScaleWidth = thisUI.CheckBoxSize / thisUI.Item.GetWidth();
        var ScaleHeight = thisUI.CheckBoxSize / thisUI.Item.GetHeight();
        thisUI.Item.SetScale(ScaleWidth, ScaleHeight);
        thisUI.Enabled = true;
        thisUI.SwitchGraphic(true);
        return thisUI.Item
    };
    UICheckBox.SwitchGraphic = function SwitchFn(thisUI, Enabled) {
        var psTexture = Helpers.GetTexture("EditorSprites");
        var Image = 0;
        thisUI.Enabled = Enabled;
        if (!Enabled) {
            Image = psTexture.GetFrameIndexFromName("Editor_CrossEmpty")
        } else {
            Image = psTexture.GetFrameIndexFromName("Editor_Cross")
        }
        thisUI.Item.SetTexture(psTexture, Image)
    };
    UICheckBox.CheckCollision = function CheckCollFn(thisUI, X, Y) {
        var Collision = UIBase.CheckCollision(thisUI, X, Y);
        if (Collision) {
            thisUI.SwitchGraphic(!thisUI.Enabled);
            return true
        } else {
            return false
        }
    };
    UICheckBox.RemoveItem = function RemoveItemFn(thisUI) {
        Helpers.DestroySprite(thisUI.Item)
    };
    UICheckBox.Create = function UICreateFn() {
        var NewObject = UIBase.Create();
        NewObject.Enabled = true;
        NewObject.AddCheckItem = function AddCheckItemFn(X, Y, RenderTree) {
            return UICheckBox.AddCheckItem(this, X, Y, RenderTree)
        };
        NewObject.SwitchGraphic = function SwitchFn(Enabled) {
            UICheckBox.SwitchGraphic(this, Enabled)
        };
        NewObject.CheckCollision = function CheckCollFn(X, Y) {
            return UICheckBox.CheckCollision(this, X, Y)
        };
        NewObject.RemoveItem = function RemoveItemFn() {
            UICheckBox.RemoveItem(this)
        };
        return NewObject
    };

    function UIEditBox() {}
    UIEditBox.prototype = {
        editBoxType: {
            Normal: 0,
            Number: 1,
            Integer: 2,
            Boolean: 3,
            Percent: 4
        },
        editBoxClicks: {
            None: 0,
            SelectAll: 1,
            Cursor: 2
        },
        NormalColour: [.6, 0, 0, 1],
        NumberColour: [0, .6, 0, 1],
        IntegerColour: [0, .6, .6, 1],
        BooleanColour: [.6, 0, .6, 1],
        PercentColour: [.6, .6, 0, 1]
    };
    UIEditBox.AddEditBoxItem = function AddEditItemFn(thisUI, X, Y, EditType, Label, Shift, RenderTree) {
        Debug.Assert(EditType !== undefined && X !== undefined && Y !== undefined && Label !== undefined && RenderTree !== undefined, "PROBLEM! AddEditBoxItem - missing param! Something undefined...");
        Debug.Assert(typeof X === "number" && typeof Y === "number", "PROBLEM! AddEditBoxItem - vars do not match type!");
        if (Label !== null) {
            thisUI.TextBoxUI = UITextBox.Create();
            thisUI.TextBoxUI.AddTextBoxItem(X, Y, Label, false, false, RenderTree)
        }
        if (Shift === undefined) {
            Shift = thisUI.ShiftX
        }
        thisUI.Shift = X + Shift;
        if (thisUI.TextBoxUI) {
            thisUI.Shift += thisUI.TextBoxUI.GetTrueWidth()
        }
        thisUI.BackingItem = Helpers.CreateSprite(thisUI.Shift, Y, EA.TopLeft, "Editor_White", RenderTree);
        if (EditType === UIEditBox.prototype.editBoxType.Normal) {
            thisUI.ColourArray = UIEditBox.prototype.NormalColour
        }
        if (EditType === UIEditBox.prototype.editBoxType.Number) {
            thisUI.ColourArray = UIEditBox.prototype.NumberColour
        }
        if (EditType === UIEditBox.prototype.editBoxType.Integer) {
            thisUI.ColourArray = UIEditBox.prototype.IntegerColour
        }
        if (EditType === UIEditBox.prototype.editBoxType.Boolean) {
            thisUI.ColourArray = UIEditBox.prototype.BooleanColour
        }
        if (EditType === UIEditBox.prototype.editBoxType.Percent) {
            thisUI.ColourArray = UIEditBox.prototype.PercentColour
        }
        thisUI.CurrText = thisUI.DefaultText;
        thisUI.RenderTree = RenderTree;
        thisUI.EditType = EditType;
        thisUI.Item = Helpers.CreateBitmapText(thisUI.CurrText, thisUI.Shift, Y, EA.MiddleLeft, "EditorFont", RenderTree);
        thisUI.WhiteSelectBox = Helpers.CreateSprite(thisUI.Shift, Y, EA.MiddleLeft, "Editor_White", RenderTree);
        thisUI.WhiteSelectBox.SetColour([1, 1, 1, .5]);
        thisUI.WhiteSelectBox.SetIsVisible(false);
        thisUI.BlackCursor = Helpers.CreateSprite(thisUI.Shift, Y, EA.MiddleLeft, "Editor_White", RenderTree);
        thisUI.BlackCursor.SetColour([0, 0, 0, 1]);
        thisUI.BlackCursor.SetIsVisible(false);
        if (EditType === UIEditBox.prototype.editBoxType.Percent) {
            thisUI.PercentSign = Helpers.CreateBitmapText(" %", thisUI.Shift, Y, EA.MiddleLeft, "EditorFont", RenderTree)
        }
        thisUI.RescaleEditBox();
        thisUI.BlackCursor.SetScale(3 / thisUI.BlackCursor.GetWidth(), thisUI.Item.GetHeight() + 4 / thisUI.BlackCursor.GetHeight());
        thisUI.BlackCursor.SetPosition(thisUI.Item.GetPosition().x - 3, thisUI.Item.GetPosition().y - 1);
        return thisUI.Item
    };
    UIEditBox.RescaleEditBox = function ScaleTextFn(thisUI) {
        var BestScaleX = thisUI.Item.GetWidth() / thisUI.BackingItem.GetWidth();
        var BestScaleY = thisUI.Item.GetHeight() / thisUI.BackingItem.GetHeight();
        thisUI.BackingItem.SetScale(BestScaleX + 20, BestScaleY + 14);
        thisUI.Item.SetPosition(thisUI.BackingItem.GetPositionX() + 10, thisUI.BackingItem.GetPositionY() + thisUI.GetTrueHeight() / 2);
        thisUI.WhiteSelectBox.SetScale(thisUI.Item.GetWidth() / thisUI.WhiteSelectBox.GetWidth(), thisUI.Item.GetHeight() / thisUI.WhiteSelectBox.GetHeight());
        thisUI.WhiteSelectBox.SetPosition(thisUI.Item.GetPosition().x, thisUI.Item.GetPosition().y);
        if (thisUI.EditType === UIEditBox.prototype.editBoxType.Percent) {
            var Position = thisUI.BackingItem.GetPositionX() + thisUI.BackingItem.GetWidth() * thisUI.BackingItem.GetScaleX();
            thisUI.PercentSign.SetPosition(Position, thisUI.Item.GetPosition().y)
        }
        var ExactPosition = thisUI.Item.GetSpecificWidth(thisUI.CursorStringPosition);
        thisUI.BlackCursor.SetPositionX(thisUI.Item.GetPosition().x + ExactPosition - 3);
        if (thisUI.InfoItem) {
            thisUI.InfoItem.MoveTo(thisUI.BackingItem.GetPositionX() * thisUI.BackingItem.StartScaleX + 20)
        }
    };
    UIEditBox.SetDefaultValue = function SetDefaultFn(thisUI, NewText) {
        if (NewText === "" || NewText === null) {
            NewText = "Type Here..."
        }
        NewText += "";
        if (thisUI.EditType === UIEditBox.prototype.editBoxType.Percent) {
            NewText = "" + (parseFloat(NewText) * 100).toFixed(2)
        }
        thisUI.DefaultText = NewText;
        thisUI.CurrText = thisUI.DefaultText;
        thisUI.Item.SetText(thisUI.CurrText);
        thisUI.RescaleEditBox(thisUI)
    };
    UIEditBox.GetValue = function GetFormatTextFn(thisUI) {
        if (thisUI.EditType === UIEditBox.prototype.editBoxType.Normal) {
            return thisUI.CurrText
        }
        if (thisUI.EditType === UIEditBox.prototype.editBoxType.Number) {
            return parseFloat(thisUI.CurrText)
        }
        if (thisUI.EditType === UIEditBox.prototype.editBoxType.Integer) {
            return parseInt(thisUI.CurrText, 10)
        }
        if (thisUI.EditType === UIEditBox.prototype.editBoxType.Boolean) {
            return parseInt(thisUI.CurrText, 10)
        }
        if (thisUI.EditType === UIEditBox.prototype.editBoxType.Percent) {
            return parseFloat(thisUI.CurrText) / 100
        }
        return 0
    };
    UIEditBox.AnyChanges = function AnyChangesFn(thisUI) {
        if (thisUI.CurrText !== thisUI.DefaultText && thisUI.CurrText !== undefined) {
            return true
        } else {
            return false
        }
    };
    UIEditBox.StopEditing = function StopEditingFn(thisUI) {
        if (thisUI.isSuperFocused) {
            thisUI.isSuperFocused = false;
            thisUI.ColourArray[3] = 1;
            thisUI.BackingItem.SetColour(thisUI.ColourArray);
            thisUI.ClickState = UIEditBox.prototype.editBoxClicks.None;
            thisUI.WhiteSelectBox.SetIsVisible(false);
            thisUI.BlackCursor.SetIsVisible(false)
        }
    };
    UIEditBox.DisableEdit = function DisableEditFn(thisUI, Disable) {
        thisUI.Disabled = Disable;
        if (Disable) {
            thisUI.BackingItem.SetColour([1, 1, 1, .4]);
            thisUI.Item.SetColour([1, 1, 1, .4])
        } else {
            thisUI.BackingItem.SetColour([1, 1, 1, 1]);
            thisUI.Item.SetColour([1, 1, 1, 1])
        }
    };
    UIEditBox.ReattachObjects = function ReattachFn(thisUI) {
        if (thisUI.TextBoxUI) {
            thisUI.TextBoxUI.ReattachObjects()
        }
        UIBase.ReattachObjects(thisUI)
    };
    UIEditBox.Update = function UpdateFn(thisUI, TimeDelta, MouseX, MouseY) {
        if (thisUI.IsVisible()) {
            UIBase.ShowInfoBox(thisUI, thisUI.IsMouseOver(MouseX, MouseY), thisUI.BackingItem.GetPosition())
        }
        if (!thisUI.isSuperFocused && !thisUI.Disabled) {
            var TrueWidth = thisUI.GetTrueWidth();
            var TrueHeight = thisUI.GetTrueHeight();
            if (MouseX >= thisUI.BackingItem.GetPositionX() && MouseX <= TrueWidth + thisUI.BackingItem.GetPositionX() && MouseY >= thisUI.BackingItem.GetPositionY() && MouseY <= TrueHeight + thisUI.BackingItem.GetPositionY()) {
                thisUI.ColourArray[3] = .25;
                thisUI.BackingItem.SetColour(thisUI.ColourArray)
            } else {
                thisUI.ColourArray[3] = 1;
                thisUI.BackingItem.SetColour(thisUI.ColourArray)
            }
        }
        if (thisUI.TextBoxUI) {
            thisUI.TextBoxUI.Update(TimeDelta, MouseX, MouseY)
        }
        if (thisUI.Item.GetWidth() !== thisUI.LastTextWidth) {
            if (thisUI.CurrText) {
                thisUI.RescaleEditBox()
            }
            thisUI.LastTextWidth = thisUI.Item.GetWidth()
        }
        if (thisUI.isSuperFocused) {
            var CharCode = 0,
                NewTextA = 0,
                NewTextB = 0,
                AllowKey = false;
            var i = 0,
                NumpadPress = false,
                ExactPosition = 0;
            if (JamSystem.InputManager.GetKeyPressed(404)) {
                thisUI.StopEditing()
            }
            if (thisUI.ClickState === UIEditBox.prototype.editBoxClicks.Cursor) {
                thisUI.CursorTimer += TimeDelta;
                if (thisUI.CursorTimer > .6) {
                    thisUI.CursorOn = !thisUI.CursorOn;
                    if (thisUI.CursorOn) {
                        thisUI.BlackCursor.SetColour([0, 0, 0, 1])
                    } else {
                        thisUI.BlackCursor.SetColour([0, 0, 0, 0])
                    }
                    thisUI.CursorTimer = 0
                }
                if (JamSystem.InputManager.GetKeyPressed(200)) {
                    if (thisUI.CursorStringPosition > 0) {
                        thisUI.CursorStringPosition -= 1;
                        ExactPosition = thisUI.Item.GetSpecificWidth(thisUI.CursorStringPosition);
                        thisUI.BlackCursor.SetPositionX(thisUI.Item.GetPosition().x + ExactPosition - 3)
                    }
                }
                if (JamSystem.InputManager.GetKeyPressed(201)) {
                    if (thisUI.CursorStringPosition < thisUI.CurrText.length) {
                        thisUI.CursorStringPosition += 1;
                        ExactPosition = thisUI.Item.GetSpecificWidth(thisUI.CursorStringPosition);
                        thisUI.BlackCursor.SetPositionX(thisUI.Item.GetPosition().x + ExactPosition - 3)
                    }
                }
            }
            var Key = JamSystem.InputManager.GetKeyValue();
            if (JamSystem.InputManager.GetKeyPressed(509)) {
                if (thisUI.EditType === UIEditBox.prototype.editBoxType.Normal) {
                    Key = "/";
                    thisUI.Item.SetText(thisUI.CurrText)
                }
            }
            if (Key !== undefined) {
                if (thisUI.ClickState === UIEditBox.prototype.editBoxClicks.SelectAll) {
                    thisUI.CurrText = "";
                    thisUI.WhiteSelectBox.SetIsVisible(false);
                    thisUI.BlackCursor.SetIsVisible(true);
                    thisUI.CursorStringPosition = 0;
                    thisUI.BlackCursor.SetPosition(thisUI.Item.GetPosition().x, thisUI.Item.GetPosition().y - 1);
                    thisUI.ClickState = UIEditBox.prototype.editBoxClicks.Cursor
                }
                if (Key.charCodeAt(0) === 13 || JamSystem.InputManager.GetKeyPressed(622)) {
                    thisUI.StopEditing();
                    return
                }
                if (Key.charCodeAt(0) === 8) {
                    if (thisUI.CursorStringPosition > 0) {
                        if (thisUI.ClickState === UIEditBox.prototype.editBoxClicks.Cursor) {
                            NewTextA = thisUI.CurrText.slice(0, thisUI.CursorStringPosition - 1);
                            NewTextB = thisUI.CurrText.slice(thisUI.CursorStringPosition, thisUI.CurrText.length);
                            thisUI.CurrText = NewTextA + NewTextB;
                            thisUI.CursorStringPosition -= 1;
                            ExactPosition = thisUI.Item.GetSpecificWidth(thisUI.CursorStringPosition);
                            thisUI.BlackCursor.SetPositionX(thisUI.Item.GetPosition().x + ExactPosition - 3)
                        } else {
                            thisUI.CurrText = thisUI.CurrText.slice(0, -1)
                        }
                    }
                    thisUI.Item.SetText(thisUI.CurrText);
                    return
                } else if (JamSystem.InputManager.GetKeyPressed(403) || JamSystem.InputManager.GetKeyPressed(633)) {
                    if (thisUI.CursorStringPosition < thisUI.CurrText.length) {
                        NewTextA = thisUI.CurrText.slice(0, thisUI.CursorStringPosition);
                        NewTextB = thisUI.CurrText.slice(thisUI.CursorStringPosition + 1, thisUI.CurrText.length);
                        thisUI.CurrText = NewTextA + NewTextB;
                        thisUI.Item.SetText(thisUI.CurrText);
                        return
                    }
                } else {
                    for (i = 612; i < 622; i += 1) {
                        if (JamSystem.InputManager.GetKeyPressed(i)) {
                            NumpadPress = i;
                            break
                        }
                    }
                    if (thisUI.EditType === UIEditBox.prototype.editBoxType.Normal) {
                        if (JamSystem.InputManager.GetKeyHeld(300) || JamSystem.InputManager.GetKeyHeld(301) || JamSystem.InputManager.IsCapsLockOn()) {
                            CharCode = Key.charCodeAt(0);
                            if (CharCode > 96 && CharCode < 123) {
                                CharCode -= 32;
                                Key = String.fromCharCode(CharCode);
                                AllowKey = true
                            }
                        } else {
                            if (NumpadPress) {
                                Key = NumpadPress - 612
                            }
                            AllowKey = true
                        }
                    }
                    if (thisUI.EditType === UIEditBox.prototype.editBoxType.Number || thisUI.EditType === UIEditBox.prototype.editBoxType.Percent) {
                        CharCode = Key.charCodeAt(0);
                        if (CharCode > 47 && CharCode < 58 || CharCode === 45 || CharCode === 46 || NumpadPress) {
                            if (CharCode === 46) {
                                var k = 0,
                                    FoundPoint = false;
                                for (k = 0; k < thisUI.CurrText.length; k += 1) {
                                    if (thisUI.CurrText[k] === ".") {
                                        FoundPoint = true
                                    }
                                }
                                if (!FoundPoint) {
                                    AllowKey = true
                                }
                            } else {
                                if (NumpadPress) {
                                    Key = NumpadPress - 612;
                                    AllowKey = true
                                } else {
                                    AllowKey = true
                                }
                            }
                        }
                    }
                    if (thisUI.EditType === UIEditBox.prototype.editBoxType.Integer) {
                        CharCode = Key.charCodeAt(0);
                        if (CharCode > 47 && CharCode < 58) {
                            AllowKey = true
                        }
                        if (NumpadPress) {
                            Key = NumpadPress - 612;
                            AllowKey = true
                        }
                    }
                    if (thisUI.EditType === UIEditBox.prototype.editBoxType.Boolean) {
                        CharCode = Key.charCodeAt(0);
                        if (CharCode === 48 || CharCode === 49) {
                            AllowKey = true
                        }
                    }
                }
                if (!NumpadPress && AllowKey) {
                    if (JamSystem.InputManager.GetKeyHeld(302) || JamSystem.InputManager.GetKeyHeld(303) || (JamSystem.InputManager.GetKeyHeld(304) || JamSystem.InputManager.GetKeyHeld(305))) {
                        return
                    }
                }
                if (AllowKey) {
                    NewTextA = thisUI.CurrText.slice(0, thisUI.CursorStringPosition);
                    NewTextB = thisUI.CurrText.slice(thisUI.CursorStringPosition, thisUI.CurrText.length);
                    thisUI.CursorStringPosition += 1;
                    ExactPosition = thisUI.Item.GetSpecificWidth(thisUI.CursorStringPosition);
                    thisUI.BlackCursor.SetPositionX(thisUI.Item.GetPosition().x + ExactPosition - 3);
                    if (thisUI.CursorStringPosition === 0) {
                        thisUI.CurrText = Key + NewTextB
                    } else {
                        thisUI.CurrText = NewTextA + Key + NewTextB
                    }
                }
                thisUI.Item.SetText(thisUI.CurrText)
            }
        }
        UIBase.Update(thisUI, TimeDelta, MouseX, MouseY)
    };
    UIEditBox.GetTrueWidth = function TrueWidthFn(thisUI) {
        return thisUI.BackingItem.GetWidth() * thisUI.BackingItem.GetScaleX()
    };
    UIEditBox.GetTop = function TopFn(thisUI) {
        return thisUI.BackingItem.GetPositionY()
    };
    UIEditBox.GetTrueHeight = function TrueHeightFn(thisUI) {
        return thisUI.BackingItem.GetHeight() * thisUI.BackingItem.GetScaleY()
    };
    UIEditBox.CheckCollision = function CheckCollFn(thisUI, X, Y) {
        if (thisUI.Disabled) {
            return
        }
        var TrueWidth = thisUI.GetTrueWidth();
        var TrueHeight = thisUI.GetTrueHeight();
        if (X >= thisUI.BackingItem.GetPositionX() && X <= TrueWidth + thisUI.BackingItem.GetPositionX() && Y >= thisUI.BackingItem.GetPositionY() && Y <= TrueHeight + thisUI.BackingItem.GetPositionY()) {
            thisUI.isSuperFocused = true;
            var Displacement = 0,
                Width = 0,
                ExactPosition = 0;
            if (thisUI.ClickState === UIEditBox.prototype.editBoxClicks.None) {
                thisUI.WhiteSelectBox.SetIsVisible(true);
                thisUI.ClickState = UIEditBox.prototype.editBoxClicks.SelectAll;
                return true
            }
            if (thisUI.ClickState === UIEditBox.prototype.editBoxClicks.SelectAll) {
                Width = X - thisUI.Item.GetPosition().x;
                Displacement = thisUI.Item.GetIndexFromWidth(Width);
                ExactPosition = thisUI.Item.GetSpecificWidth(Displacement);
                if (Displacement >= 0) {
                    thisUI.WhiteSelectBox.SetIsVisible(false);
                    thisUI.BlackCursor.SetIsVisible(true);
                    thisUI.CursorStringPosition = Displacement;
                    thisUI.BlackCursor.SetPosition(thisUI.Item.GetPosition().x + ExactPosition - 3, thisUI.Item.GetPosition().y - 1);
                    thisUI.ClickState = UIEditBox.prototype.editBoxClicks.Cursor
                }
                return true
            }
            if (thisUI.ClickState === UIEditBox.prototype.editBoxClicks.Cursor) {
                Width = X - thisUI.Item.GetPosition().x;
                Displacement = thisUI.Item.GetIndexFromWidth(Width);
                ExactPosition = thisUI.Item.GetSpecificWidth(Displacement);
                if (Displacement >= 0) {
                    thisUI.CursorStringPosition = Displacement;
                    thisUI.BlackCursor.SetPosition(thisUI.Item.GetPosition().x + ExactPosition - 3, thisUI.Item.GetPosition().y - 1)
                }
                return true
            }
            return true
        } else {
            thisUI.StopEditing();
            return false
        }
    };
    UIEditBox.SetIsVisible = function SetIsVisibleFn(thisUI, Visible) {
        if (thisUI.TextBoxUI) {
            thisUI.TextBoxUI.SetIsVisible(Visible)
        }
        if (thisUI.EditType === UIEditBox.prototype.editBoxType.Percent) {
            thisUI.PercentSign.SetIsVisible(Visible)
        }
        UIBase.SetIsVisible(thisUI, Visible);
        if (thisUI.ClickState === UIEditBox.prototype.editBoxClicks.SelectAll) {
            thisUI.WhiteSelectBox.SetIsVisible(Visible)
        }
        if (thisUI.ClickState === UIEditBox.prototype.editBoxClicks.Cursor) {
            thisUI.BlackCursor.SetIsVisible(Visible)
        }
        if (Visible === false) {
            thisUI.WhiteSelectBox.SetIsVisible(false);
            thisUI.BlackCursor.SetIsVisible(false);
            UIBase.ShowInfoBox(thisUI, false)
        }
    };
    UIEditBox.UpdatePosition = function UpdatePosFn(thisUI, DeltaX, DeltaY) {
        UIBase.UpdatePosition(thisUI, DeltaX, DeltaY);
        if (thisUI.TextBoxUI) {
            thisUI.TextBoxUI.UpdatePosition(DeltaX, DeltaY)
        }
        thisUI.WhiteSelectBox.SetPosition(thisUI.Item.GetPosition().x, thisUI.Item.GetPosition().y);
        if (thisUI.EditType === UIEditBox.prototype.editBoxType.Percent) {
            thisUI.PercentSign.SetPosition(thisUI.PercentSign.GetPositionX() + DeltaX, thisUI.PercentSign.GetPositionY() + DeltaY)
        }
    };
    UIEditBox.Scroll = function ScrollFn(thisUI, Delta) {
        if (thisUI.TextBoxUI) {
            thisUI.TextBoxUI.Scroll(Delta)
        }
        UIBase.Scroll(thisUI, Delta);
        thisUI.WhiteSelectBox.SetPosition(thisUI.Item.GetPosition().x, thisUI.Item.GetPosition().y);
        if (thisUI.EditType === UIEditBox.prototype.editBoxType.Percent) {
            thisUI.PercentSign.SetPositionY(thisUI.Item.GetPosition().y)
        }
    };
    UIEditBox.ShiftBy = function ShiftByFn(thisUI, X, Y) {
        if (thisUI.TextBoxUI) {
            thisUI.TextBoxUI.ShiftBy(X, Y)
        }
        var A = thisUI.Item.GetPositionX();
        var B = thisUI.Item.GetPositionY();
        thisUI.Item.SetPosition(A + X, B + Y);
        var C = thisUI.BackingItem.GetPositionX();
        var D = thisUI.BackingItem.GetPositionY();
        thisUI.BackingItem.SetPosition(C + X, D + Y)
    };
    UIEditBox.MoveTo = function MoveToFn(thisUI, X, Y) {
        if (thisUI.TextBoxUI) {
            thisUI.TextBoxUI.MoveTo(X, Y)
        }
        if (thisUI.Item) {
            if (Y === undefined) {
                Y = thisUI.Item.GetPositionY()
            }
            thisUI.Item.SetPosition(X + thisUI.ShiftX, Y)
        }
        if (thisUI.BackingItem) {
            if (Y === undefined) {
                Y = thisUI.BackingItem.GetPositionY()
            }
            thisUI.BackingItem.SetPosition(X + thisUI.ShiftX, Y)
        }
    };
    UIEditBox.RemoveItem = function RemoveItemFn(thisUI) {
        Helpers.DestroyBitmapText(thisUI.Item);
        Helpers.DestroySprite(thisUI.BackingItem);
        if (thisUI.PercentSign) {
            Helpers.DestroyBitmapText(thisUI.PercentSign)
        }
        if (thisUI.TextBoxUI) {
            thisUI.TextBoxUI.RemoveItem()
        }
    };
    UIEditBox.Create = function UICreateFn() {
        var NewObject = UIBase.Create();
        NewObject.TextBoxUI = 0;
        NewObject.EditType = false;
        NewObject.LastTextWidth = 0;
        NewObject.CurrText = "";
        NewObject.Shift = 0;
        NewObject.DefaultText = "Type Here...";
        NewObject.ClickState = 0;
        NewObject.WhiteSelectBox = 0;
        NewObject.BlackCursor = 0;
        NewObject.CursorTimer = 0;
        NewObject.CursorOn = true;
        NewObject.CursorStringPosition = 0;
        NewObject.PercentSign = 0;
        NewObject.Disabled = false;
        NewObject.AddEditBoxItem = function AddEditItemFn(X, Y, EditType, Label, Shift, RenderTree) {
            return UIEditBox.AddEditBoxItem(this, X, Y, EditType, Label, Shift, RenderTree)
        };
        NewObject.RescaleEditBox = function ScaleTextFn() {
            UIEditBox.RescaleEditBox(this)
        };
        NewObject.SetDefaultValue = function SetDefaultFn(NewText) {
            UIEditBox.SetDefaultValue(this, NewText)
        };
        NewObject.GetValue = function GetFormatTextFn() {
            return UIEditBox.GetValue(this)
        };
        NewObject.AnyChanges = function AnyChangesFn() {
            return UIEditBox.AnyChanges(this)
        };
        NewObject.StopEditing = function StopEditingFn() {
            UIEditBox.StopEditing(this)
        };
        NewObject.DisableEdit = function DisableEditFn(Disable) {
            UIEditBox.DisableEdit(this, Disable)
        };
        NewObject.ReattachObjects = function ReattachFn() {
            UIEditBox.ReattachObjects(this)
        };
        NewObject.Update = function UpdateFn(TimeDelta, MouseX, MouseY) {
            UIEditBox.Update(this, TimeDelta, MouseX, MouseY)
        };
        NewObject.GetTop = function TopFn() {
            return UIEditBox.GetTop(this)
        };
        NewObject.GetTrueWidth = function TrueWidthFn() {
            return UIEditBox.GetTrueWidth(this)
        };
        NewObject.GetTrueHeight = function TrueHeightFn() {
            return UIEditBox.GetTrueHeight(this)
        };
        NewObject.CheckCollision = function CheckCollFn(X, Y) {
            return UIEditBox.CheckCollision(this, X, Y)
        };
        NewObject.UpdatePosition = function UpdatePosFn(DeltaX, DeltaY) {
            UIEditBox.UpdatePosition(this, DeltaX, DeltaY)
        };
        NewObject.Scroll = function ScrollFn(Delta) {
            UIEditBox.Scroll(this, Delta)
        };
        NewObject.SetIsVisible = function SetIsVisibleFn(Visible) {
            UIEditBox.SetIsVisible(this, Visible)
        };
        NewObject.MoveTo = function MoveToFn(X, Y) {
            UIEditBox.MoveTo(this, X, Y)
        };
        NewObject.ShiftBy = function ShiftByFn(X, Y) {
            UIEditBox.ShiftBy(this, X, Y)
        };
        NewObject.RemoveItem = function RemoveItemFn() {
            UIEditBox.RemoveItem(this)
        };
        return NewObject
    };

    function UIButton() {}
    UIButton.prototype = {
        Colour: [0, 0, 0, 1],
        SelectedColour: [.6, .6, 0, 1]
    };
    UIButton.AddButton = function AddButtonFn(thisUI, X, Y, Text, IsGraphic, RenderTree) {
        Debug.Assert(Text !== undefined && IsGraphic !== undefined && X !== undefined && Y !== undefined && RenderTree !== undefined, "PROBLEM! AddButton - missing param! Something undefined...");
        Debug.Assert(typeof X === "number" && typeof Y === "number" && typeof Text === "string", "PROBLEM! AddButton - vars do not match type!");
        thisUI.IsGraphicButton = IsGraphic;
        thisUI.ColourArray = UIButton.prototype.Colour;
        if (!IsGraphic) {
            UITextBox.AddTextBoxItem(thisUI, X, Y, Text, false, false, RenderTree, undefined, 1)
        } else {
            thisUI.BackingItem = Helpers.CreateSprite(X, Y, EA.TopLeft, "Editor_White", RenderTree);
            thisUI.Item = Helpers.CreateSprite(X, Y, EA.TopLeft, Text, RenderTree);
            var ScaleWidth = thisUI.Item.GetWidth() / thisUI.BackingItem.GetWidth();
            var ScaleHeight = thisUI.Item.GetHeight() / thisUI.BackingItem.GetHeight();
            thisUI.BackingItem.SetScale(ScaleWidth, ScaleHeight)
        }
    };
    UIButton.SetButtonText = function SetButtonTextFn(thisUI, Text) {
        if (!thisUI.IsGraphicButton) {
            thisUI.Item.SetText(Text)
        }
    };
    UIButton.SetButtonColour = function SetButtonColourFn(thisUI, Colour) {
        thisUI.ColourArray = Colour
    };
    UIButton.GetTrueWidth = function TrueWidthFn(thisUI) {
        return thisUI.BackingItem.GetWidth() * thisUI.BackingItem.GetScaleX()
    };
    UIButton.GetTrueHeight = function TrueHeightFn(thisUI) {
        return thisUI.BackingItem.GetHeight() * thisUI.BackingItem.GetScaleY()
    };
    UIButton.CheckCollision = function CheckCollFn(thisUI, X, Y) {
        var Collision = UITextBox.CheckCollision(thisUI, X, Y);
        if (Collision) {
            thisUI.Clicked = true;
            return true
        } else {
            return false
        }
    };
    UIButton.Update = function UpdateFn(thisUI, TimeDelta, MouseX, MouseY) {
        if (!thisUI.IsGraphicButton) {
            UITextBox.Update(thisUI, TimeDelta, MouseX, MouseY)
        }
        var Collision = UITextBox.CheckCollision(thisUI, MouseX, MouseY);
        if (Collision) {
            thisUI.ColourArray[3] = .25;
            thisUI.BackingItem.SetColour(thisUI.ColourArray)
        } else {
            thisUI.ColourArray[3] = 1;
            thisUI.BackingItem.SetColour(thisUI.ColourArray)
        }
        UIBase.Update(thisUI, TimeDelta, MouseX, MouseY)
    };
    UIButton.MoveTo = function MoveToFn(thisUI, X, Y) {
        if (X === undefined) {
            X = thisUI.BackingItem.GetPositionX()
        }
        if (Y === undefined) {
            Y = thisUI.BackingItem.GetPositionY()
        }
        thisUI.StartPosition.x = X;
        thisUI.StartPosition.y = Y;
        if (thisUI.BackingItem) {
            thisUI.BackingItem.SetPosition(X, Y)
        }
        thisUI.RescaleTextBox()
    };
    UIButton.RemoveItem = function RemoveItemFn(thisUI) {
        if (thisUI.IsGraphicButton) {
            Helpers.DestroyBitmapText(thisUI.Item)
        } else {
            Helpers.DestroySprite(thisUI.Item)
        }
        Helpers.DestroySprite(thisUI.BackingItem)
    };
    UIButton.Create = function UICreateFn() {
        var NewObject = UITextBox.Create();
        NewObject.Clicked = false;
        NewObject.IsGraphicButton = false;
        NewObject.AddButton = function AddButtonFn(X, Y, Text, IsGraphic, RenderTree) {
            UIButton.AddButton(this, X, Y, Text, IsGraphic, RenderTree)
        };
        NewObject.SetButtonText = function SetButtonTextFn(Text) {
            UIButton.SetButtonText(this, Text)
        };
        NewObject.SetButtonColour = function SetButtonColourFn(Colour) {
            UIButton.SetButtonColour(this, Colour)
        };
        NewObject.GetTrueWidth = function TrueWidthFn() {
            return UIButton.GetTrueWidth(this)
        };
        NewObject.GetTrueHeight = function TrueHeightFn() {
            return UIButton.GetTrueHeight(this)
        };
        NewObject.CheckCollision = function CheckCollFn(X, Y) {
            return UIButton.CheckCollision(this, X, Y)
        };
        NewObject.Update = function UpdateFn(TimeDelta, MouseX, MouseY) {
            UIButton.Update(this, TimeDelta, MouseX, MouseY)
        };
        NewObject.MoveTo = function MoveToFn(X, Y) {
            UIButton.MoveTo(this, X, Y)
        };
        NewObject.RemoveItem = function RemoveItemFn() {
            UIButton.RemoveItem(this)
        };
        return NewObject
    };

    function UICollisionBox() {}
    UICollisionBox.prototype = {
        ImageBaseSize: 256
    };
    UICollisionBox.AddCollisionBox = function AddBoxFn(thisUI, BrushType, RenderTree) {
        Debug.Assert(BrushType !== undefined && RenderTree !== undefined, "PROBLEM! AddCollisionBox - missing param! Something undefined...");
        var CentreX = JamSystem.RenderManager.GetScreenWidth() / 2;
        var CentreY = JamSystem.RenderManager.GetScreenHeight() / 2 - 150;
        thisUI.RenderTree = RenderTree;
        var X = CentreX - 250;
        var Y = CentreY - 150;
        thisUI.BoxUI = UIBox.Create();
        thisUI.BackingItem = thisUI.BoxUI.AddDialogBox(X, Y, 500, 460, RenderTree);
        thisUI.StartPosition.x = X;
        thisUI.StartPosition.y = Y;
        thisUI.BackImage = Helpers.CreateSprite(X + 25, 0, EA.TopLeft, "Editor_White", RenderTree);
        thisUI.BackImage.SetColour([0, 0, 0, 1]);
        var ScaleWidth = UICollisionBox.prototype.ImageBaseSize / thisUI.BackImage.GetWidth();
        var ScaleHeight = UICollisionBox.prototype.ImageBaseSize / thisUI.BackImage.GetHeight();
        thisUI.BackImage.SetScale(ScaleWidth, ScaleHeight);
        thisUI.BackImage.SetPositionY(Y + 25);
        thisUI.Item = Helpers.CreateSprite(X + 25, 0, EA.TopLeft, "Editor_White", RenderTree);
        thisUI.Item.SetScale(ScaleWidth, ScaleHeight);
        thisUI.CircleItem = Helpers.CreateSprite(0, 0, EA.MidleMiddle, "Circle", RenderTree);
        thisUI.CircleItem.SetScale(2, 2);
        thisUI.CircleItem.SetPosition(thisUI.BackImage.GetPositionX() + UICollisionBox.prototype.ImageBaseSize / 2, thisUI.BackImage.GetPositionY() + UICollisionBox.prototype.ImageBaseSize / 2);
        thisUI.DoneButtonUI = UIButton.Create();
        var ButtonDone = thisUI.DoneButtonUI.AddButton(CentreX + 70, CentreY - 115, "DONE", false, RenderTree);
        thisUI.CancelButtonUI = UIButton.Create();
        var ButtonCancel = thisUI.CancelButtonUI.AddButton(CentreX + 70, CentreY - 65, "CANCEL", false, RenderTree);
        thisUI.RemoveButtonUI = UIButton.Create();
        var ButtonRemove = thisUI.RemoveButtonUI.AddButton(CentreX + 70, CentreY - 15, "REMOVE LAST", false, RenderTree);
        thisUI.ClearButtonUI = UIButton.Create();
        var ButtonClear = thisUI.ClearButtonUI.AddButton(CentreX + 70, CentreY + 35, "CLEAR ALL", false, RenderTree);
        thisUI.CheckUI = UICheckTextBox.Create();
        thisUI.CheckUI.AddCheckTextBox("POLYGON MODE?", CentreX - 180, CentreY + 140, RenderTree);
        thisUI.EditDensityUI = UIEditBox.Create();
        thisUI.EditDensityUI.AddEditBoxItem(CentreX - 180, CentreY + 180, UIEditBox.prototype.editBoxType.Number, "Density", undefined, RenderTree);
        thisUI.EditFrictionUI = UIEditBox.Create();
        thisUI.EditFrictionUI.AddEditBoxItem(CentreX - 180, CentreY + 215, UIEditBox.prototype.editBoxType.Number, "Friction", undefined, RenderTree);
        thisUI.EditRestitutionUI = UIEditBox.Create();
        thisUI.EditRestitutionUI.AddEditBoxItem(CentreX - 180, CentreY + 250, UIEditBox.prototype.editBoxType.Number, "Restitution", undefined, RenderTree);
        thisUI.CoordsTextBoxUI = UITextBox.Create();
        thisUI.CoordsTextBoxUI.AddTextBoxItem(CentreX + 60, CentreY + 100, "", false, false, RenderTree, false)
    };
    UICollisionBox.AddCollisionPoint = function AddPointFn(thisUI, X, Y) {
        var Item = Helpers.CreateSprite(X, Y, EA.MiddleMiddle, "Editor_White", thisUI.RenderTree);
        Item.SetColour([1, .5, 0, 1]);
        var ScaleWidth = 10 / Item.GetWidth();
        var ScaleHeight = 10 / Item.GetHeight();
        Item.SetScale(ScaleWidth, ScaleHeight);
        thisUI.CollPointImage[thisUI.CollPointImage.length] = Item;
        thisUI.CollisionPoints[thisUI.CollisionPoints.length] = new Vector2(X, Y);
        var PointA, PointB;
        if (thisUI.CollisionPoints.length > 1) {
            PointA = thisUI.CollisionPoints[thisUI.CollisionPoints.length - 2];
            PointB = thisUI.CollisionPoints[thisUI.CollisionPoints.length - 1];
            var Line = Helpers.CreateLine(PointA.x, PointA.y, PointB.x, PointB.y, thisUI.LineColour, thisUI.RenderTree);
            thisUI.CollPointLines[thisUI.CollPointLines.length] = Line
        }
        if (thisUI.CollisionPoints.length > 2) {
            if (thisUI.EndLine) {
                Helpers.DestroyLine(thisUI.EndLine)
            }
            PointA = thisUI.CollisionPoints[thisUI.CollisionPoints.length - 1];
            PointB = thisUI.CollisionPoints[0];
            thisUI.EndLine = Helpers.CreateLine(PointA.x, PointA.y, PointB.x, PointB.y, [1, 0, 0, .5], thisUI.RenderTree)
        }
    };
    UICollisionBox.InsertCollisionPoint = function InsertPointFn(thisUI, X, Y, AtSlot) {
        var Item = Helpers.CreateSprite(X, Y, EA.MiddleMiddle, "Editor_White", thisUI.RenderTree);
        Item.SetColour([1, .5, 0, 1]);
        var ScaleWidth = 10 / Item.GetWidth();
        var ScaleHeight = 10 / Item.GetHeight();
        Item.SetScale(ScaleWidth, ScaleHeight);
        thisUI.CollPointImage.splice(AtSlot + 1, 0, Item);
        thisUI.CollisionPoints.splice(AtSlot + 1, 0, new Vector2(X, Y));
        var PointA, PointB, Line = 0;
        if (thisUI.CollPointLines[AtSlot]) {
            Helpers.DestroyLine(thisUI.CollPointLines[AtSlot])
        }
        PointA = thisUI.CollisionPoints[AtSlot];
        PointB = thisUI.CollisionPoints[AtSlot + 1];
        Line = Helpers.CreateLine(PointA.x, PointA.y, PointB.x, PointB.y, thisUI.LineColour, thisUI.RenderTree);
        thisUI.CollPointLines[AtSlot] = Line;
        if (thisUI.CollisionPoints[AtSlot + 2]) {
            PointA = thisUI.CollisionPoints[AtSlot + 1];
            PointB = thisUI.CollisionPoints[AtSlot + 2];
            Line = Helpers.CreateLine(PointA.x, PointA.y, PointB.x, PointB.y, thisUI.LineColour, thisUI.RenderTree);
            thisUI.CollPointLines.splice(AtSlot + 1, 0, Line)
        }
        if (thisUI.CollisionPoints.length > 2) {
            if (thisUI.EndLine) {
                Helpers.DestroyLine(thisUI.EndLine)
            }
            PointA = thisUI.CollisionPoints[thisUI.CollisionPoints.length - 1];
            PointB = thisUI.CollisionPoints[0];
            thisUI.EndLine = Helpers.CreateLine(PointA.x, PointA.y, PointB.x, PointB.y, [1, 0, 0, .5], thisUI.RenderTree)
        }
    };
    UICollisionBox.ConvertCollisionPoints = function ConvertPointFn(thisUI) {
        thisUI.CompleteChain();
        for (var i = 0; i < thisUI.CollisionPoints.length - 1; i += 1) {
            thisUI.FinalCollisionPoints[i] = thisUI.CollisionPoints[i];
            thisUI.FinalCollisionPoints[i].x -= thisUI.Offset.x;
            thisUI.FinalCollisionPoints[i].y -= thisUI.Offset.y;
            thisUI.FinalCollisionPoints[i].x -= thisUI.StartPosition.x + 25;
            thisUI.FinalCollisionPoints[i].y -= thisUI.StartPosition.y + 25;
            thisUI.FinalCollisionPoints[i].x /= thisUI.Item.GetScaleX();
            thisUI.FinalCollisionPoints[i].y /= thisUI.Item.GetScaleY();
            thisUI.FinalCollisionPoints[i].x -= thisUI.Item.GetWidth() / 2;
            thisUI.FinalCollisionPoints[i].y -= thisUI.Item.GetHeight() / 2
        }
    };
    UICollisionBox.RemoveCollisionPoint = function RmvPointFn(thisUI, Point) {
        if (thisUI.CollisionPoints.length < 1) {
            return
        }
        if (Point === undefined) {
            Point = thisUI.CollisionPoints.length - 1
        }
        Helpers.DestroySprite(thisUI.CollPointImage[Point]);
        thisUI.CollPointImage.splice(Point, 1);
        thisUI.CollisionPoints.splice(Point, 1);
        if (!thisUI.CollisionPoints[Point]) {
            if (thisUI.CollPointLines.length > 0) {
                Helpers.DestroyLine(thisUI.CollPointLines[Point - 1]);
                thisUI.CollPointLines.splice(Point - 1, 1)
            }
        }
        var PointA, PointB, Line = 0;
        if (thisUI.CollisionPoints[Point]) {
            var i = 0;
            for (i = 0; i < thisUI.CollPointLines.length; i += 1) {
                Helpers.DestroyLine(thisUI.CollPointLines[i])
            }
            thisUI.CollPointLines = [];
            for (i = 0; i < thisUI.CollisionPoints.length - 1; i += 1) {
                PointA = thisUI.CollisionPoints[i];
                PointB = thisUI.CollisionPoints[i + 1];
                Line = Helpers.CreateLine(PointA.x, PointA.y, PointB.x, PointB.y, thisUI.LineColour, thisUI.RenderTree);
                thisUI.CollPointLines[thisUI.CollPointLines.length] = Line
            }
        }
        if (thisUI.CollisionPoints.length < 3) {
            if (thisUI.EndLine) {
                Helpers.DestroyLine(thisUI.EndLine)
            }
        }
        if (thisUI.CollisionPoints.length > 2) {
            if (thisUI.EndLine) {
                Helpers.DestroyLine(thisUI.EndLine)
            }
            PointA = thisUI.CollisionPoints[thisUI.CollisionPoints.length - 1];
            PointB = thisUI.CollisionPoints[0];
            thisUI.EndLine = Helpers.CreateLine(PointA.x, PointA.y, PointB.x, PointB.y, [1, 0, 0, .5], thisUI.RenderTree)
        }
    };
    UICollisionBox.CompleteChain = function CompletePointFn(thisUI) {
        if (thisUI.CollisionPoints.length < 1) {
            return
        }
        var StartX = thisUI.CollisionPoints[0].x;
        var StartY = thisUI.CollisionPoints[0].y;
        thisUI.AddCollisionPoint(StartX, StartY)
    };
    UICollisionBox.ForceVisible = function ForceVisibleFn(thisUI, Visible) {
        thisUI.Item.SetIsVisible(Visible);
        thisUI.CircleItem.SetIsVisible(Visible);
        thisUI.BackImage.SetIsVisible(Visible);
        thisUI.BoxUI.SetIsVisible(Visible);
        thisUI.DoneButtonUI.SetIsVisible(Visible);
        thisUI.ClearButtonUI.SetIsVisible(Visible);
        thisUI.CancelButtonUI.SetIsVisible(Visible);
        thisUI.RemoveButtonUI.SetIsVisible(Visible);
        thisUI.CheckUI.SetIsVisible(Visible);
        thisUI.EditDensityUI.SetIsVisible(Visible);
        thisUI.EditFrictionUI.SetIsVisible(Visible);
        thisUI.EditRestitutionUI.SetIsVisible(Visible);
        thisUI.CoordsTextBoxUI.SetIsVisible(Visible);
        var ArrLen = thisUI.CollisionPoints.length;
        for (var i = 0; i < ArrLen; i += 1) {
            thisUI.RemoveCollisionPoint()
        }
    };
    UICollisionBox.SetupPoints = function SetupPointsFn(thisUI) {
        var i = 0;
        var NewPoint = [];
        for (i = 0; i < thisUI.CollPoints.length; i += 1) {
            NewPoint[i] = new Vector2;
            NewPoint[i].x = thisUI.CollPoints[i].x;
            NewPoint[i].y = thisUI.CollPoints[i].y;
            NewPoint[i].x += thisUI.Item.GetWidth() / 2;
            NewPoint[i].y += thisUI.Item.GetHeight() / 2;
            NewPoint[i].x *= thisUI.Item.GetScaleX();
            NewPoint[i].y *= thisUI.Item.GetScaleY();
            NewPoint[i].x += thisUI.StartPosition.x + 25;
            NewPoint[i].y += thisUI.StartPosition.y + 25;
            NewPoint[i].x += thisUI.Offset.x;
            NewPoint[i].y += thisUI.Offset.y;
            thisUI.AddCollisionPoint(NewPoint[i].x, NewPoint[i].y)
        }
    };
    UICollisionBox.SetupCircle = function SetupCircleFn(thisUI) {
        thisUI.CircleItem.SetScale(1, 1);
        var MaxRadius = thisUI.Item.GetWidth() / 2;
        var Ratio = thisUI.Radius / MaxRadius;
        var Scale = 2 * Ratio;
        thisUI.CircleItem.SetScale(Scale, Scale)
    };
    UICollisionBox.ShowBox = function ShowFn(thisUI, Show, BrushInfo, Data) {
        if (BrushInfo !== undefined) {
            thisUI.BrushInfo = BrushInfo;
            var TextureInfo = Helpers.GetTextureInfoFromImageName(BrushInfo.Image);
            thisUI.Item.SetTexture(TextureInfo.Texture, TextureInfo.Frame);
            thisUI.Item.SetScale(1, 1);
            thisUI.Offset.x = 0;
            thisUI.Offset.y = 0;
            var X = thisUI.StartPosition.x;
            var Y = thisUI.StartPosition.y;
            thisUI.Item.SetPosition(thisUI.StartPosition.x, thisUI.StartPosition.y);
            var ActualScale = 1;
            var HeightScale = UICollisionBox.prototype.ImageBaseSize / thisUI.Item.GetHeight();
            var WidthScale = UICollisionBox.prototype.ImageBaseSize / thisUI.Item.GetWidth();
            ActualScale = HeightScale < WidthScale ? HeightScale : WidthScale;
            thisUI.Item.SetScale(ActualScale, ActualScale);
            var PlacementX = X + 25,
                PlacementY = Y + 25;
            var Centre = 0;
            if (WidthScale !== ActualScale) {
                var HalfWidth = thisUI.Item.GetWidth() * ActualScale * .5;
                Centre = UICollisionBox.prototype.ImageBaseSize / 2 - HalfWidth;
                PlacementX += Centre;
                thisUI.Offset.x = Centre
            }
            if (HeightScale !== ActualScale) {
                var HalfHeight = thisUI.Item.GetHeight() * ActualScale * .5;
                Centre = UICollisionBox.prototype.ImageBaseSize / 2 - HalfHeight;
                PlacementY += Centre;
                thisUI.Offset.y = Centre
            }
            thisUI.Item.SetPosition(PlacementX, PlacementY)
        }
        thisUI.ForceVisible(Show);
        thisUI.isSuperFocused = Show;
        if (Data !== undefined) {
            thisUI.PolyMode = !Data.Circle;
            thisUI.LastMode = thisUI.PolyMode;
            thisUI.Radius = Data.CircleRadius;
            thisUI.Density = Data.Density;
            thisUI.Friction = Data.Friction;
            thisUI.Restitution = Data.Restitution;
            thisUI.CollPoints = Data.CollisionPoints;
            thisUI.CheckUI.SetDefaultValue(thisUI.PolyMode);
            thisUI.EditDensityUI.SetDefaultValue("" + thisUI.Density.toFixed(2));
            thisUI.EditFrictionUI.SetDefaultValue("" + thisUI.Friction.toFixed(2));
            thisUI.EditRestitutionUI.SetDefaultValue("" + thisUI.Restitution.toFixed(2));
            if (thisUI.PolyMode) {
                thisUI.CircleItem.SetIsVisible(false);
                thisUI.SetupPoints();
                thisUI.RemoveButtonUI.SetIsVisible(true);
                thisUI.ClearButtonUI.SetIsVisible(true)
            } else {
                var ArrLen = thisUI.CollisionPoints.length;
                var i = 0;
                for (i = 0; i < ArrLen; i += 1) {
                    thisUI.RemoveCollisionPoint()
                }
                thisUI.SetupCircle();
                thisUI.RemoveButtonUI.SetIsVisible(false);
                thisUI.ClearButtonUI.SetIsVisible(false)
            }
        }
    };
    UICollisionBox.ReattachObjects = function ReattachFn(thisUI) {
        thisUI.BoxUI.ReattachObjects();
        UIBase.ReattachObjects(thisUI);
        thisUI.RenderTree.RemoveChild(thisUI.BackImage);
        thisUI.RenderTree.AddChild(thisUI.BackImage);
        thisUI.DoneButtonUI.ReattachObjects();
        thisUI.ClearButtonUI.ReattachObjects();
        thisUI.CancelButtonUI.ReattachObjects();
        thisUI.RemoveButtonUI.ReattachObjects();
        thisUI.CheckUI.ReattachObjects();
        thisUI.EditDensityUI.ReattachObjects();
        thisUI.EditFrictionUI.ReattachObjects();
        thisUI.EditRestitutionUI.ReattachObjects();
        thisUI.CoordsTextBoxUI.ReattachObjects()
    };
    UICollisionBox.Update = function UpdateFn(thisUI, TimeDelta, MouseX, MouseY) {
        if (!thisUI.Item.GetIsVisible()) {
            return
        }
        if (thisUI.DraggingPoint) {
            if (JamSystem.InputManager.GetMouseButtonHeld(0)) {
                thisUI.CollisionPoints[thisUI.DraggingPointID].x = MouseX;
                thisUI.CollisionPoints[thisUI.DraggingPointID].y = MouseY;
                thisUI.CollPointImage[thisUI.DraggingPointID].SetPosition(MouseX, MouseY);
                if (thisUI.CollPointLines[thisUI.DraggingPointID - 1]) {
                    thisUI.CollPointLines[thisUI.DraggingPointID - 1].SetEndCoord(MouseX, MouseY)
                }
                if (thisUI.CollPointLines[thisUI.DraggingPointID]) {
                    thisUI.CollPointLines[thisUI.DraggingPointID].SetStartCoord(MouseX, MouseY)
                }
                if (thisUI.CollisionPoints.length > 2) {
                    var StartPoint = thisUI.CollisionPoints[0];
                    thisUI.EndLine.SetEndCoord(StartPoint.x, StartPoint.y);
                    var LastPoint = thisUI.CollisionPoints[thisUI.CollisionPoints.length - 1];
                    thisUI.EndLine.SetStartCoord(LastPoint.x, LastPoint.y)
                }
                var PointX = MouseX;
                var PointY = MouseY;
                PointX -= thisUI.Offset.x;
                PointY -= thisUI.Offset.y;
                PointX -= thisUI.StartPosition.x + 25;
                PointY -= thisUI.StartPosition.y + 25;
                PointX /= thisUI.Item.GetScaleX();
                PointY /= thisUI.Item.GetScaleY();
                PointX = Math.floor(PointX);
                PointY = Math.floor(PointY);
                thisUI.CoordsTextBoxUI.Item.SetText("(" + PointX + "," + PointY + ")")
            } else {
                thisUI.DraggingPoint = false;
                thisUI.CoordsTextBoxUI.Item.SetText("")
            }
        }
        if (thisUI.DraggingCircle) {
            if (JamSystem.InputManager.GetMouseButtonHeld(0)) {
                var StartX = thisUI.StartPosition.x + 25;
                var StartY = thisUI.StartPosition.y + 25;
                var DeltaX = MouseX - StartX;
                var DeltaY = MouseY - StartY;
                DeltaX = Math.abs((DeltaX - 128) / 4);
                DeltaY = Math.abs((DeltaY - 128) / 4);
                var Length = DeltaX * DeltaX + DeltaY * DeltaY;
                Length = Math.sqrt(Length);
                var MaxRadius = thisUI.Item.GetWidth() / 2;
                var Ratio = Length / MaxRadius;
                var Scale = 2 * Ratio;
                if (Length <= MaxRadius) {
                    thisUI.CircleItem.SetScale(Scale, Scale);
                    thisUI.Radius = Length;
                    thisUI.InfoChanged = true
                }
            } else {
                thisUI.DraggingCircle = false
            }
        }
        thisUI.BoxUI.Update(TimeDelta, MouseX, MouseY);
        thisUI.DoneButtonUI.Update(TimeDelta, MouseX, MouseY);
        thisUI.ClearButtonUI.Update(TimeDelta, MouseX, MouseY);
        thisUI.CancelButtonUI.Update(TimeDelta, MouseX, MouseY);
        thisUI.RemoveButtonUI.Update(TimeDelta, MouseX, MouseY);
        thisUI.CheckUI.Update(TimeDelta, MouseX, MouseY);
        thisUI.EditDensityUI.Update(TimeDelta, MouseX, MouseY);
        thisUI.EditFrictionUI.Update(TimeDelta, MouseX, MouseY);
        thisUI.EditRestitutionUI.Update(TimeDelta, MouseX, MouseY);
        thisUI.CoordsTextBoxUI.Update(TimeDelta, MouseX, MouseY);
        thisUI.PolyMode = thisUI.CheckUI.GetValue();
        if (thisUI.PolyMode !== thisUI.LastMode) {
            if (thisUI.PolyMode) {
                thisUI.CircleItem.SetIsVisible(false);
                thisUI.SetupPoints();
                thisUI.RemoveButtonUI.SetIsVisible(true);
                thisUI.ClearButtonUI.SetIsVisible(true);
                thisUI.LastMode = thisUI.PolyMode
            } else {
                var ArrLen = thisUI.CollisionPoints.length;
                var i = 0;
                for (i = 0; i < ArrLen; i += 1) {
                    thisUI.RemoveCollisionPoint()
                }
                thisUI.CircleItem.SetIsVisible(true);
                thisUI.RemoveButtonUI.SetIsVisible(false);
                thisUI.ClearButtonUI.SetIsVisible(false);
                thisUI.LastMode = thisUI.PolyMode
            }
        }
        if (thisUI.EditDensityUI.AnyChanges()) {
            thisUI.Density = thisUI.EditDensityUI.GetValue();
            thisUI.InfoChanged = true
        }
        if (thisUI.EditFrictionUI.AnyChanges()) {
            thisUI.Friction = thisUI.EditFrictionUI.GetValue();
            thisUI.InfoChanged = true
        }
        if (thisUI.EditRestitutionUI.AnyChanges()) {
            thisUI.Restitution = thisUI.EditRestitutionUI.GetValue();
            thisUI.InfoChanged = true
        }
        UIBase.Update(thisUI, TimeDelta, MouseX, MouseY)
    };
    UICollisionBox.SetIsVisible = function SetIsVisibleFn(thisUI, Visible) {
        if (!Visible) {
            thisUI.ForceVisible(false);
            thisUI.isSuperFocused = false
        }
    };
    UICollisionBox.GetTop = function TopFn(thisUI) {
        return thisUI.BoxUI.GetTop()
    };
    UICollisionBox.CheckCollision = function CheckCollFn(thisUI, X, Y) {
        if (!thisUI.isSuperFocused) {
            return
        }
        var i = 0;
        if (thisUI.CollisionPoints.length > 0) {
            for (i = 0; i < thisUI.CollisionPoints.length; i += 1) {
                if (X >= thisUI.CollisionPoints[i].x - 10 && X <= 10 + thisUI.CollisionPoints[i].x && Y >= thisUI.CollisionPoints[i].y - 10 && Y <= 10 + thisUI.CollisionPoints[i].y) {
                    if (JamSystem.InputManager.GetKeyHeld(302) || JamSystem.InputManager.GetKeyHeld(303)) {
                        thisUI.InsertCollisionPoint(X + 20, Y, i)
                    } else if (JamSystem.InputManager.GetKeyHeld(300) || JamSystem.InputManager.GetKeyHeld(301)) {
                        thisUI.RemoveCollisionPoint(i)
                    }
                    return true
                }
            }
        }
        if (X >= thisUI.Item.GetPositionX() && X <= 256 + thisUI.Item.GetPositionX() && Y >= thisUI.Item.GetPositionY() && Y <= 256 + thisUI.Item.GetPositionY()) {
            if (!thisUI.PolyMode) {
                thisUI.DraggingCircle = true;
                return true
            }
        }
        var Collision = UIBase.CheckCollision(thisUI, X, Y);
        if (Collision) {
            thisUI.AddCollisionPoint(X, Y);
            return true
        }
        if (thisUI.DoneButtonUI.CheckCollision(X, Y)) {
            thisUI.ConvertCollisionPoints(thisUI);
            thisUI.EditDensityUI.isSuperFocused = false;
            thisUI.EditFrictionUI.isSuperFocused = false;
            thisUI.EditRestitutionUI.isSuperFocused = false;
            thisUI.ShowBox(false);
            return true
        }
        if (thisUI.RemoveButtonUI.CheckCollision(X, Y)) {
            thisUI.RemoveCollisionPoint();
            return true
        }
        if (thisUI.ClearButtonUI.CheckCollision(X, Y)) {
            var ArrLen = thisUI.CollisionPoints.length;
            for (i = 0; i < ArrLen; i += 1) {
                thisUI.RemoveCollisionPoint()
            }
            return true
        }
        if (thisUI.CancelButtonUI.CheckCollision(X, Y)) {
            thisUI.FinalCollisionPoints = [];
            thisUI.InfoChanged = false;
            thisUI.ShowBox(false);
            thisUI.EditDensityUI.isSuperFocused = false;
            thisUI.EditFrictionUI.isSuperFocused = false;
            thisUI.EditRestitutionUI.isSuperFocused = false;
            return true
        }
        if (thisUI.CheckUI.CheckCollision(X, Y)) {
            thisUI.InfoChanged = true;
            return true
        }
        thisUI.EditDensityUI.CheckCollision(X, Y);
        thisUI.EditFrictionUI.CheckCollision(X, Y);
        thisUI.EditRestitutionUI.CheckCollision(X, Y);
        return false
    };
    UICollisionBox.CheckCollisionPressed = function CheckCollPressFn(thisUI, X, Y) {
        if (thisUI.CollisionPoints.length > 0) {
            var i = 0;
            for (i = 0; i < thisUI.CollisionPoints.length; i += 1) {
                if (X >= thisUI.CollisionPoints[i].x - 10 && X <= 10 + thisUI.CollisionPoints[i].x && Y >= thisUI.CollisionPoints[i].y - 10 && Y <= 10 + thisUI.CollisionPoints[i].y) {
                    if (JamSystem.InputManager.GetKeyHeld(302) || JamSystem.InputManager.GetKeyHeld(303) || JamSystem.InputManager.GetKeyHeld(300) || JamSystem.InputManager.GetKeyHeld(301)) {
                        return false
                    }
                    if (!JamSystem.InputManager.GetKeyHeld(302) && !JamSystem.InputManager.GetKeyHeld(303) && (!JamSystem.InputManager.GetKeyHeld(300) && !JamSystem.InputManager.GetKeyHeld(301))) {
                        thisUI.DraggingPoint = true;
                        thisUI.DraggingPointID = i
                    }
                    return true
                }
            }
        }
        if (X >= thisUI.Item.GetPositionX() && X <= 256 + thisUI.Item.GetPositionX() && Y >= thisUI.Item.GetPositionY() && Y <= 256 + thisUI.Item.GetPositionY()) {
            if (!thisUI.PolyMode) {
                thisUI.DraggingCircle = true;
                return true
            }
        }
        return false
    };
    UICollisionBox.RelocateItem = function RelocateItemFn(thisUI) {
        var DiffX = -(thisUI.BoxUI.Item.GetPositionX() + thisUI.BoxUI.GetTrueWidth() / 2 - JamSystem.RenderManager.GetScreenWidth() / 2);
        var DiffY = -(thisUI.BoxUI.Item.GetPositionY() + thisUI.BoxUI.GetTrueHeight() / 2 - JamSystem.RenderManager.GetScreenHeight() / 2);
        if (thisUI.BoxUI.Item.GetPositionX() + thisUI.BoxUI.GetTrueWidth() / 2 === JamSystem.RenderManager.GetScreenWidth() / 2) {
            DiffX = 0
        }
        if (thisUI.BoxUI.Item.GetPositionY() + thisUI.BoxUI.GetTrueHeight() / 2 === JamSystem.RenderManager.GetScreenHeight() / 2) {
            DiffY = 0
        }
        thisUI.CircleItem.SetPosition(thisUI.CircleItem.GetPositionX() + DiffX, thisUI.CircleItem.GetPositionY() + DiffY);
        thisUI.BackImage.SetPosition(thisUI.BackImage.GetPositionX() + DiffX, thisUI.BackImage.GetPositionY() + DiffY);
        thisUI.Item.SetPosition(thisUI.Item.GetPositionX() + DiffX, thisUI.Item.GetPositionY() + DiffY);
        thisUI.StartPosition.x += DiffX;
        thisUI.StartPosition.y += DiffY;
        thisUI.BoxUI.Item.SetPosition(thisUI.BoxUI.Item.GetPositionX() + DiffX, thisUI.BoxUI.Item.GetPositionY() + DiffY);
        thisUI.BoxUI.BackingItem.SetPosition(thisUI.BoxUI.BackingItem.GetPositionX() + DiffX, thisUI.BoxUI.BackingItem.GetPositionY() + DiffY);
        if (thisUI.DoneButtonUI) {
            thisUI.DoneButtonUI.UpdatePosition(DiffX, DiffY)
        }
        if (thisUI.CancelButtonUI) {
            thisUI.CancelButtonUI.UpdatePosition(DiffX, DiffY)
        }
        if (thisUI.ClearButtonUI) {
            thisUI.ClearButtonUI.UpdatePosition(DiffX, DiffY)
        }
        if (thisUI.RemoveButtonUI) {
            thisUI.RemoveButtonUI.UpdatePosition(DiffX, DiffY)
        }
        if (thisUI.CheckUI) {
            thisUI.CheckUI.UpdatePosition(DiffX, DiffY)
        }
        if (thisUI.EditDensityUI) {
            thisUI.EditDensityUI.UpdatePosition(DiffX, DiffY)
        }
        if (thisUI.EditFrictionUI) {
            thisUI.EditFrictionUI.UpdatePosition(DiffX, DiffY)
        }
        if (thisUI.EditRestitutionUI) {
            thisUI.EditRestitutionUI.UpdatePosition(DiffX, DiffY)
        }
        if (thisUI.CoordsTextBoxUI) {
            thisUI.CoordsTextBoxUI.UpdatePosition(DiffX, DiffY)
        }
        var i = 0;
        for (i = 0; i < thisUI.CollPointImage.length; i += 1) {
            var Point = thisUI.CollPointImage[i];
            Point.SetPosition(Point.GetPositionX() + DiffX, Point.GetPositionY() + DiffY)
        }
        for (i = 0; i < thisUI.CollPointLines.length; i += 1) {
            var Line = thisUI.CollPointLines[i];
            Line.SetStartCoord(Line.x1 + DiffX, Line.y1 + DiffY);
            Line.SetEndCoord(Line.x2 + DiffX, Line.y2 + DiffY)
        }
        if (thisUI.EndLine) {
            thisUI.EndLine.SetStartCoord(thisUI.EndLine.x1 + DiffX, thisUI.EndLine.y1 + DiffY);
            thisUI.EndLine.SetEndCoord(thisUI.EndLine.x2 + DiffX, thisUI.EndLine.y2 + DiffY)
        }
    };
    UICollisionBox.Create = function UICreateFn() {
        var NewObject = UIBase.Create();
        NewObject.BackImage = 0;
        NewObject.CircleItem = 0;
        NewObject.CollPointImage = [];
        NewObject.CollisionPoints = [];
        NewObject.CollPointLines = [];
        NewObject.EndLine = 0;
        NewObject.PolyMode = true;
        NewObject.LastMode = true;
        NewObject.Radius = 0;
        NewObject.Density = 0;
        NewObject.Friction = 0;
        NewObject.Restitution = 0;
        NewObject.DraggingPoint = false;
        NewObject.DraggingPointIndex = 0;
        NewObject.DraggingCircle = false;
        NewObject.InfoChanged = false;
        NewObject.FinalCollisionPoints = [];
        NewObject.BrushInfo = 0;
        NewObject.LineColour = [1, 1, 0, 1];
        NewObject.Offset = new Vector2;
        NewObject.BoxUI = 0;
        NewObject.DoneButtonUI = 0;
        NewObject.ClearButtonUI = 0;
        NewObject.CancelButtonUI = 0;
        NewObject.RemoveButtonUI = 0;
        NewObject.CheckUI = 0;
        NewObject.EditDensityUI = 0;
        NewObject.EditFrictionUI = 0;
        NewObject.EditRestitutionUI = 0;
        NewObject.CoordsTextBoxUI = 0;
        NewObject.AddCollisionBox = function AddBoxFn(BrushType, RenderTree) {
            return UICollisionBox.AddCollisionBox(this, BrushType, RenderTree)
        };
        NewObject.AddCollisionPoint = function AddPointFn(X, Y) {
            UICollisionBox.AddCollisionPoint(this, X, Y)
        };
        NewObject.InsertCollisionPoint = function InsertPointFn(X, Y, AtSlot) {
            UICollisionBox.InsertCollisionPoint(this, X, Y, AtSlot)
        };
        NewObject.RemoveCollisionPoint = function RmvPointFn(Point) {
            UICollisionBox.RemoveCollisionPoint(this, Point)
        };
        NewObject.CompleteChain = function CompletePointFn() {
            UICollisionBox.CompleteChain(this)
        };
        NewObject.ForceVisible = function ForceVisibleFn(Visible) {
            UICollisionBox.ForceVisible(this, Visible)
        };
        NewObject.ShowBox = function ShowFn(Show, BrushInfo, Data) {
            UICollisionBox.ShowBox(this, Show, BrushInfo, Data)
        };
        NewObject.ConvertCollisionPoints = function ConvertPointFn() {
            UICollisionBox.ConvertCollisionPoints(this)
        };
        NewObject.SetupPoints = function SetupPointsFn() {
            UICollisionBox.SetupPoints(this)
        };
        NewObject.SetupCircle = function SetupCircleFn() {
            UICollisionBox.SetupCircle(this)
        };
        NewObject.ReattachObjects = function ReattachFn() {
            UICollisionBox.ReattachObjects(this)
        };
        NewObject.Update = function UpdateFn(TimeDelta, MouseX, MouseY) {
            UICollisionBox.Update(this, TimeDelta, MouseX, MouseY)
        };
        NewObject.SetIsVisible = function SetIsVisibleFn(Visible) {
            UICollisionBox.SetIsVisible(this, Visible)
        };
        NewObject.GetTop = function TopFn() {
            return UICollisionBox.GetTop(this)
        };
        NewObject.CheckCollision = function CheckCollFn(X, Y) {
            return UICollisionBox.CheckCollision(this, X, Y)
        };
        NewObject.CheckCollisionPressed = function CheckCollPressFn(X, Y) {
            return UICollisionBox.CheckCollisionPressed(this, X, Y)
        };
        NewObject.RelocateItem = function RelocateItemFn() {
            UICollisionBox.RelocateItem(this)
        };
        return NewObject
    };

    function UICheckTextBox() {}
    UICheckTextBox.prototype = {};
    UICheckTextBox.AddCheckTextBox = function AddBoxFn(thisUI, Text, X, Y, RenderTree) {
        Debug.Assert(Text !== undefined && X !== undefined && Y !== undefined && RenderTree !== undefined, "PROBLEM! AddCheckTextBox - missing param! Something undefined...");
        Debug.Assert(typeof X === "number" && typeof Y === "number" && typeof Text === "string", "PROBLEM! AddCheckTextBox - vars do not match type!");
        thisUI.RenderTree = RenderTree;
        thisUI.TextBoxUI = UITextBox.Create();
        var TextItem = thisUI.TextBoxUI.AddTextBoxItem(X, Y, Text, false, false, RenderTree);
        var Shift = X + thisUI.ShiftX + thisUI.TextBoxUI.GetTrueWidth();
        thisUI.CheckBoxUI = UICheckBox.Create();
        var CheckItem = thisUI.CheckBoxUI.AddCheckItem(Shift, Y + 7, RenderTree)
    };
    UICheckTextBox.SetDefaultValue = function SetDefaultFn(thisUI, Value) {
        thisUI.CheckBoxUI.SwitchGraphic(Value);
        thisUI.DefaultValue = Value
    };
    UICheckTextBox.GetValue = function GetFormatTextFn(thisUI) {
        return thisUI.CheckBoxUI.Enabled
    };
    UICheckTextBox.AnyChanges = function AnyChangesFn(thisUI) {
        return thisUI.CheckBoxUI.Enabled !== thisUI.DefaultValue
    };
    UICheckTextBox.DisableEdit = function DisableEditFn(thisUI, Disable) {
        thisUI.Disabled = Disable;
        if (Disable) {
            thisUI.CheckBoxUI.Item.SetColour([1, 1, 1, .4])
        } else {
            thisUI.CheckBoxUI.Item.SetColour([1, 1, 1, 1])
        }
    };
    UICheckTextBox.ReattachObjects = function ReattachFn(thisUI) {
        thisUI.CheckBoxUI.ReattachObjects();
        thisUI.TextBoxUI.ReattachObjects()
    };
    UICheckTextBox.GetTop = function TopFn(thisUI) {
        return thisUI.TextBoxUI.GetTop()
    };
    UICheckTextBox.GetTrueWidth = function TrueWidthFn(thisUI) {
        return thisUI.CheckBoxUI.GetTrueWidth()
    };
    UICheckTextBox.GetTrueHeight = function TrueHeightFn(thisUI) {
        return thisUI.TextBoxUI.GetTrueHeight()
    };
    UICheckTextBox.Update = function UpdateFn(thisUI, TimeDelta, MouseX, MouseY) {
        thisUI.CheckBoxUI.Update(TimeDelta, MouseX, MouseY);
        thisUI.TextBoxUI.Update(TimeDelta, MouseX, MouseY);
        if (thisUI.IsVisible()) {
            var Placement = thisUI.CheckBoxUI.Item.GetPosition();
            Placement.y -= 7;
            UIBase.ShowInfoBox(thisUI, thisUI.IsMouseOver(MouseX, MouseY), Placement)
        }
        UIBase.Update(thisUI, TimeDelta, MouseX, MouseY)
    };
    UICheckTextBox.SetIsVisible = function SetIsVisibleFn(thisUI, Visible) {
        thisUI.CheckBoxUI.SetIsVisible(Visible);
        thisUI.TextBoxUI.SetIsVisible(Visible);
        if (!Visible) {
            UIBase.ShowInfoBox(thisUI, false)
        }
    };
    UICheckTextBox.CheckCollision = function CheckCollFn(thisUI, X, Y) {
        if (thisUI.Disabled) {
            return
        }
        if (thisUI.CheckBoxUI.CheckCollision(X, Y)) {
            return true
        } else {
            return false
        }
    };
    UICheckTextBox.UpdatePosition = function UpdatePosFn(thisUI, DeltaX, DeltaY) {
        thisUI.CheckBoxUI.UpdatePosition(DeltaX, DeltaY);
        thisUI.TextBoxUI.UpdatePosition(DeltaX, DeltaY)
    };
    UICheckTextBox.IsVisible = function VisibleFn(thisUI, Delta) {
        return thisUI.CheckBoxUI.Item.GetIsVisible()
    };
    UICheckTextBox.Scroll = function ScrollFn(thisUI, Delta) {
        thisUI.CheckBoxUI.Scroll(Delta);
        thisUI.TextBoxUI.Scroll(Delta)
    };
    UICheckTextBox.ShiftBy = function ShiftByFn(thisUI, X, Y) {
        if (thisUI.TextBoxUI) {
            thisUI.TextBoxUI.ShiftBy(X, Y)
        }
        if (thisUI.CheckBoxUI) {
            thisUI.CheckBoxUI.ShiftBy(X, Y)
        }
    };
    UICheckTextBox.MoveTo = function MoveToFn(thisUI, X, Y) {
        if (thisUI.TextBoxUI) {
            thisUI.TextBoxUI.MoveTo(X, Y)
        }
        if (thisUI.CheckBoxUI) {
            thisUI.CheckBoxUI.MoveTo(X, Y)
        }
    };
    UICheckTextBox.RemoveItem = function RemoveItemFn(thisUI) {
        thisUI.CheckBoxUI.RemoveItem();
        thisUI.TextBoxUI.RemoveItem()
    };
    UICheckTextBox.IsMouseOver = function IsMouseOverFn(thisUI, X, Y) {
        var Width, Height;
        if (thisUI.CheckBoxUI.Item) {
            Width = thisUI.CheckBoxUI.Item.GetScaleX() * thisUI.CheckBoxUI.Item.GetWidth();
            Height = thisUI.CheckBoxUI.Item.GetScaleY() * thisUI.CheckBoxUI.Item.GetHeight();
            return X > thisUI.CheckBoxUI.Item.GetPositionX() && X < thisUI.CheckBoxUI.Item.GetPositionX() + Width && Y > thisUI.CheckBoxUI.Item.GetPositionY() && Y < thisUI.CheckBoxUI.Item.GetPositionY() + Height
        }
        return false
    };
    UICheckTextBox.Create = function UICreateFn() {
        var NewObject = new UIBase.Create;
        NewObject.DefaultValue = false;
        NewObject.CheckBoxUI = 0;
        NewObject.TextBoxUI = 0;
        NewObject.AddCheckTextBox = function AddBoxFn(Text, X, Y, RenderTree) {
            return UICheckTextBox.AddCheckTextBox(this, Text, X, Y, RenderTree)
        };
        NewObject.GetValue = function GetFormatTextFn() {
            return UICheckTextBox.GetValue(this)
        };
        NewObject.AnyChanges = function AnyChangesFn() {
            return UICheckTextBox.AnyChanges(this)
        };
        NewObject.SetDefaultValue = function SetDefaultFn(Value) {
            UICheckTextBox.SetDefaultValue(this, Value)
        };
        NewObject.DisableEdit = function DisableEditFn(Disable) {
            UICheckTextBox.DisableEdit(this, Disable)
        };
        NewObject.ReattachObjects = function ReattachFn() {
            UICheckTextBox.ReattachObjects(this)
        };
        NewObject.Update = function UpdateFn(TimeDelta, MouseX, MouseY) {
            UICheckTextBox.Update(this, TimeDelta, MouseX, MouseY)
        };
        NewObject.SetIsVisible = function SetIsVisibleFn(Visible) {
            UICheckTextBox.SetIsVisible(this, Visible)
        };
        NewObject.GetTop = function TopFn() {
            return UICheckTextBox.GetTop(this)
        };
        NewObject.GetTrueWidth = function TrueWidthFn() {
            return UICheckTextBox.GetTrueWidth(this)
        };
        NewObject.GetTrueHeight = function TrueHeightFn() {
            return UICheckTextBox.GetTrueHeight(this)
        };
        NewObject.CheckCollision = function CheckCollFn(X, Y) {
            return UICheckTextBox.CheckCollision(this, X, Y)
        };
        NewObject.UpdatePosition = function UpdatePosFn(DeltaX, DeltaY) {
            UICheckTextBox.UpdatePosition(this, DeltaX, DeltaY)
        };
        NewObject.IsVisible = function VisibleFn() {
            return UICheckTextBox.IsVisible(this)
        };
        NewObject.Scroll = function ScrollFn(Delta) {
            UICheckTextBox.Scroll(this, Delta)
        };
        NewObject.MoveTo = function MoveToFn(X, Y) {
            UICheckTextBox.MoveTo(this, X, Y)
        };
        NewObject.ShiftBy = function ShiftByFn(X, Y) {
            UICheckTextBox.ShiftBy(this, X, Y)
        };
        NewObject.RemoveItem = function RemoveItemFn() {
            UICheckTextBox.RemoveItem(this)
        };
        NewObject.IsMouseOver = function IsMouseOverFn(X, Y) {
            return UICheckTextBox.IsMouseOver(this, X, Y)
        };
        return NewObject
    };

    function UIComboBox() {}
    UIComboBox.prototype = {};
    UIComboBox.AddComboBox = function AddBoxFn(thisUI, X, Y, TextItems, Label, Shift, RenderTree) {
        Debug.Assert(TextItems !== undefined && X !== undefined && Y !== undefined && RenderTree !== undefined, "PROBLEM! AddComboBox - missing param! Something undefined...");
        Debug.Assert(typeof X === "number" && typeof Y === "number" && typeof TextItems === "object", "PROBLEM! AddComboBox - vars do not match type!");
        thisUI.RenderTree = RenderTree;
        thisUI.PrimaryType = 0;
        thisUI.LastType = 0;
        thisUI.TextBoxUI = UITextBox.Create();
        thisUI.TextBoxUI.AddTextBoxItem(X, Y, Label, false, false, RenderTree);
        if (Shift === undefined) {
            Shift = thisUI.ShiftX
        }
        Shift = X + Shift + thisUI.TextBoxUI.GetTrueWidth();
        thisUI.BoxUI = UIBox.Create();
        thisUI.BoxUI.AddDialogBox(Shift, Y + thisUI.TextBoxSpacing - 2, thisUI.UltimateWidth, 0, RenderTree);
        thisUI.BoxUI.SetIsVisible(false);
        Helpers.DestroySprite(thisUI.BoxUI.BackingItem);
        thisUI.BoxUI.BackingItem = 0;
        Helpers.DestroyBitmapText(thisUI.BoxUI.TitleBarItem);
        thisUI.BoxUI.TitleBarItem = 0;
        thisUI.BoxUI.ComboBox = true;
        thisUI.StartPosition.x = Shift;
        thisUI.StartPosition.y = Y;
        thisUI.BoxUI.NextItemPosition.x = Shift;
        thisUI.BoxUI.NextItemPosition.y = 0;
        var MaxText = TextItems.length;
        if (MaxText > thisUI.MaxItems) {
            MaxText = thisUI.MaxItems
        }
        for (var i = 0; i < TextItems.length; i += 1) {
            var MultiMainTextBoxUI = UITextBox.Create();
            var YShift = 0;
            if (i === 0) {
                YShift = -2
            }
            if (TextItems[i].length > 15) {
                TextItems[i] = TextItems[i].slice(0, 15);
                TextItems[i] += "..."
            }
            MultiMainTextBoxUI.AddTextBoxItem(Shift, Y + thisUI.TextBoxSpacing + i * (thisUI.TextBoxSpacing - YShift), TextItems[i], false, false, RenderTree, thisUI.UltimateWidth - 20, i % 2);
            var CurrItem = thisUI.TextObjects.length;
            thisUI.TextObjects[CurrItem] = MultiMainTextBoxUI;
            MultiMainTextBoxUI.SetIsVisible(false);
            thisUI.BoxUI.NextItemPosition.y += thisUI.TextBoxSpacing;
            if (i % 2 === 0) {
                MultiMainTextBoxUI.BackingItem.SetColour([1, .5, .7, 1])
            } else {
                MultiMainTextBoxUI.BackingItem.SetColour([.6, 1, 0, 1])
            }
        }
        thisUI.BoxUI.ObjectsAttached = thisUI.TextObjects;
        thisUI.MainTextBoxUI = UITextBox.Create();
        thisUI.MainTextBoxUI.AddTextBoxItem(Shift, Y, TextItems[0], false, false, RenderTree, thisUI.UltimateWidth, 2);
        thisUI.MainTextBoxUI.BackingItem.SetColour([1, .5, 0, 1]);
        thisUI.Item = Helpers.CreateSprite(0, Y, EA.TopLeft, "Editor_ArrowDown", RenderTree);
        var ScaleWidth = (thisUI.TextBoxSpacing - 2) / thisUI.Item.GetWidth();
        var ScaleHeight = (thisUI.TextBoxSpacing - 2) / thisUI.Item.GetHeight();
        thisUI.Item.SetScale(ScaleWidth, ScaleHeight);
        thisUI.Item.SetPositionX(Shift + thisUI.UltimateWidth - thisUI.Item.GetWidth() * thisUI.Item.GetScaleX());
        thisUI.BoxUI.Item.SetScaleY(MaxText * thisUI.TextBoxSpacing / thisUI.BoxUI.Item.GetHeight());
        thisUI.BoxUI.Item.SetPositionY(Y + thisUI.TextBoxSpacing);
        thisUI.BoxUI.CheckForScrollBar();
        if (thisUI.BoxUI.ScrollUI) {
            thisUI.BoxUI.ScrollUI.Top = Y + thisUI.TextBoxSpacing;
            thisUI.BoxUI.ScrollUI.SetIsVisible(false)
        }
    };
    UIComboBox.AddField = function AddFieldFn(thisUI, Text, Type) {
        var CurrElement = thisUI.TextObjects.length;
        var MultiMainTextBoxUI = UITextBox.Create();
        var TextItem = MultiMainTextBoxUI.AddTextBoxItem(thisUI.StartPosition.x, thisUI.StartPosition.y + thisUI.TextBoxSpacing + CurrElement * thisUI.TextBoxSpacing, Text, false, false, thisUI.RenderTree, thisUI.UltimateWidth - 20, CurrElement % 2);
        var LastItem = thisUI.TextObjects[thisUI.TextObjects.length - 1];
        TextItem.SetPositionY(LastItem.BackingItem.GetPositionY() + LastItem.GetTrueHeight());
        thisUI.TextObjects[CurrElement] = MultiMainTextBoxUI;
        MultiMainTextBoxUI.SetIsVisible(false);
        thisUI.BoxUI.NextItemPosition.y += thisUI.TextBoxSpacing;
        thisUI.BoxUI.CheckForScrollBar()
    };
    UIComboBox.HandleOpenClose = function HandleOpenClose(thisUI, MouseY) {
        for (var i = 0; i < thisUI.TextObjects.length; i += 1) {
            if (!thisUI.isOpen) {
                thisUI.TextObjects[i].SetIsVisible(false)
            } else {
                thisUI.TextObjects[i].SetIsVisible(true)
            }
        }
        thisUI.BoxUI.SetIsVisible(thisUI.isOpen);
        if (thisUI.isOpen) {
            thisUI.ReattachObjects()
        }
    };
    UIComboBox.SetDefaultValue = function SetDefaultFn(thisUI, Value) {
        thisUI.MainTextBoxUI.Item.SetText(thisUI.TextObjects[Value].Item.GetText());
        thisUI.LastType = thisUI.PrimaryType = Value
    };
    UIComboBox.GetValue = function GetFormatTextFn(thisUI) {
        return thisUI.PrimaryType
    };
    UIComboBox.AnyChanges = function AnyChangesFn(thisUI) {
        return thisUI.PrimaryType !== thisUI.LastType
    };
    UIComboBox.DisableEdit = function DisableEditFn(thisUI, Disable) {
        thisUI.Disabled = Disable;
        if (Disable) {
            thisUI.MainTextBoxUI.BackingItem.SetColour([1, 1, 1, .4]);
            thisUI.MainTextBoxUI.Item.SetColour([1, 1, 1, .4]);
            thisUI.Item.SetColour([1, 1, 1, .4])
        } else {
            thisUI.MainTextBoxUI.BackingItem.SetColour([1, 1, 1, 1]);
            thisUI.MainTextBoxUI.Item.SetColour([1, 1, 1, 1]);
            thisUI.Item.SetColour([1, 1, 1, 1])
        }
    };
    UIComboBox.ReattachObjects = function ReattachFn(thisUI) {
        thisUI.BoxUI.ReattachObjects();
        thisUI.TextBoxUI.ReattachObjects();
        for (var j = 0; j < thisUI.TextObjects.length; j += 1) {
            thisUI.TextObjects[j].ReattachObjects()
        }
        thisUI.MainTextBoxUI.ReattachObjects();
        UIBase.ReattachObjects(thisUI)
    };
    UIComboBox.Update = function UpdateFn(thisUI, TimeDelta, MouseX, MouseY) {
        if (thisUI.isOpen) {
            thisUI.BoxUI.ScrollFocus = thisUI.IsMouseOver(MouseX, MouseY)
        }
        if (thisUI.IsVisible()) {
            UIBase.ShowInfoBox(thisUI, thisUI.IsMouseOver(MouseX, MouseY), thisUI.Item.GetPosition())
        }
        thisUI.BoxUI.Update(TimeDelta, MouseX, MouseY);
        thisUI.TextBoxUI.Update(TimeDelta, MouseX, MouseY);
        thisUI.MainTextBoxUI.Update(TimeDelta, MouseX, MouseY);
        for (var j = 0; j < thisUI.TextObjects.length; j += 1) {
            thisUI.TextObjects[j].Update(TimeDelta, MouseX, MouseY)
        }
        UIBase.Update(thisUI, TimeDelta, MouseX, MouseY)
    };
    UIComboBox.SetIsVisible = function SetIsVisibleFn(thisUI, Visible) {
        if (!Visible) {
            for (var i = 0; i < thisUI.TextObjects.length; i += 1) {
                thisUI.TextObjects[i].SetIsVisible(false)
            }
            thisUI.BoxUI.SetIsVisible(false);
            UIBase.ShowInfoBox(thisUI, false)
        }
        thisUI.MainTextBoxUI.SetIsVisible(Visible);
        thisUI.TextBoxUI.SetIsVisible(Visible);
        UIBase.SetIsVisible(thisUI, Visible)
    };
    UIComboBox.CheckCollision = function CheckCollFn(thisUI, X, Y) {
        if (thisUI.Disabled) {
            return
        }
        var Collision = UIBase.CheckCollision(thisUI, X, Y);
        if (!Collision) {
            Collision = thisUI.MainTextBoxUI.CheckCollision(X, Y)
        }
        if (Collision) {
            thisUI.isOpen = !thisUI.isOpen;
            thisUI.isSuperFocused = !thisUI.isSuperFocused;
            thisUI.HandleOpenClose(Y);
            return true
        }
        if (!thisUI.isSuperFocused) {
            return false
        }
        for (var i = 0; i < thisUI.TextObjects.length; i += 1) {
            if (thisUI.TextObjects[i].BackingItem.GetIsVisible() !== false) {
                if (thisUI.TextObjects[i].CheckCollision(X, Y)) {
                    thisUI.MainTextBoxUI.Item.SetText(thisUI.TextObjects[i].Item.GetText());
                    thisUI.PrimaryType = i;
                    thisUI.isOpen = !thisUI.isOpen;
                    thisUI.isSuperFocused = !thisUI.isSuperFocused;
                    thisUI.HandleOpenClose(Y);
                    return true
                }
            }
        }
        if (thisUI.BoxUI.CheckCollision(X, Y)) {
            return true
        }
        if (thisUI.isOpen) {
            thisUI.isOpen = !thisUI.isOpen;
            thisUI.isSuperFocused = !thisUI.isSuperFocused;
            thisUI.HandleOpenClose(Y)
        }
        return false
    };
    UIComboBox.CheckCollisionPressed = function CheckCollPressFn(thisUI, X, Y) {
        if (!thisUI.isSuperFocused) {
            return false
        }
        return thisUI.BoxUI.CheckCollisionPressed(X, Y)
    };
    UIComboBox.UpdatePosition = function UpdatePosFn(thisUI, DeltaX, DeltaY) {
        UIBase.UpdatePosition(thisUI, DeltaX, DeltaY);
        thisUI.BoxUI.UpdatePosition(DeltaX, DeltaY);
        thisUI.TextBoxUI.UpdatePosition(DeltaX, DeltaY);
        thisUI.MainTextBoxUI.UpdatePosition(DeltaX, DeltaY)
    };
    UIComboBox.Scroll = function ScrollFn(thisUI, Delta) {
        thisUI.BoxUI.Scroll(Delta);
        thisUI.MainTextBoxUI.Scroll(Delta);
        thisUI.TextBoxUI.Scroll(Delta);
        UIBase.Scroll(thisUI, Delta);
        for (var j = 0; j < thisUI.TextObjects.length; j += 1) {
            thisUI.TextObjects[j].Scroll(Delta)
        }
    };
    UIComboBox.RemoveItem = function RemoveItemFn(thisUI) {
        Helpers.DestroySprite(thisUI.Item);
        thisUI.BoxUI.RemoveItem();
        thisUI.MainTextBoxUI.RemoveItem();
        thisUI.TextBoxUI.RemoveItem();
        for (var j = 0; j < thisUI.TextObjects.length; j += 1) {
            thisUI.TextObjects[j].RemoveItem()
        }
    };
    UIComboBox.IsMouseOver = function IsMouseOverFn(thisUI, X, Y) {
        if (thisUI.isOpen) {
            if (thisUI.BoxUI.IsMouseOver(X, Y)) {
                return true
            }
        }
        if (UIBase.IsMouseOver(thisUI, X, Y)) {
            return true
        }
        if (thisUI.MainTextBoxUI.IsMouseOver(X, Y)) {
            return true
        }
        return false
    };
    UIComboBox.Create = function UICreateFn() {
        var NewObject = UIBase.Create();
        NewObject.TextObjects = [];
        NewObject.PrimaryType = 0;
        NewObject.LastType = 0;
        NewObject.isOpen = false;
        NewObject.BoxUI = 0;
        NewObject.MainTextBoxUI = 0;
        NewObject.TextBoxUI = 0;
        NewObject.AddComboBox = function AddBoxFn(X, Y, TextItems, Label, Shift, RenderTree) {
            return UIComboBox.AddComboBox(this, X, Y, TextItems, Label, Shift, RenderTree)
        };
        NewObject.AddField = function AddFieldFn(Text, Type) {
            UIComboBox.AddField(this, Text, Type)
        };
        NewObject.HandleOpenClose = function HandleOpenClose(MouseY) {
            UIComboBox.HandleOpenClose(this, MouseY)
        };
        NewObject.GetValue = function GetFormatTextFn() {
            return UIComboBox.GetValue(this)
        };
        NewObject.AnyChanges = function AnyChangesFn() {
            return UIComboBox.AnyChanges(this)
        };
        NewObject.SetDefaultValue = function SetDefaultFn(Value) {
            UIComboBox.SetDefaultValue(this, Value)
        };
        NewObject.DisableEdit = function DisableEditFn(Disable) {
            UIComboBox.DisableEdit(this, Disable)
        };
        NewObject.ReattachObjects = function ReattachFn() {
            UIComboBox.ReattachObjects(this)
        };
        NewObject.Update = function UpdateFn(TimeDelta, MouseX, MouseY) {
            UIComboBox.Update(this, TimeDelta, MouseX, MouseY)
        };
        NewObject.SetIsVisible = function SetIsVisibleFn(Visible) {
            UIComboBox.SetIsVisible(this, Visible)
        };
        NewObject.CheckCollision = function CheckCollFn(X, Y) {
            return UIComboBox.CheckCollision(this, X, Y)
        };
        NewObject.CheckCollisionPressed = function CheckCollPressFn(X, Y) {
            return UIComboBox.CheckCollisionPressed(this, X, Y)
        };
        NewObject.UpdatePosition = function UpdatePosFn(DeltaX, DeltaY) {
            UIComboBox.UpdatePosition(this, DeltaX, DeltaY)
        };
        NewObject.Scroll = function ScrollFn(Delta) {
            UIComboBox.Scroll(this, Delta)
        };
        NewObject.RemoveItem = function RemoveItemFn() {
            UIComboBox.RemoveItem(this)
        };
        NewObject.IsMouseOver = function IsMouseOverFn(X, Y) {
            return UIComboBox.IsMouseOver(this, X, Y)
        };
        return NewObject
    };

    function UIPalette() {}
    UIPalette.prototype = {
        BrushSizeSmall: 32,
        BrushSizeLarge: 128
    };
    UIPalette.AddPalette = function AddBoxFn(thisUI, Label, Colour, Width, RenderTree, Index, RHS) {
        Debug.Assert(RenderTree !== undefined, "PROBLEM! AddPalette - missing param! Something undefined...");
        thisUI.RenderTree = RenderTree;
        thisUI.RHS = RHS;
        thisUI.PaletteWidth = Width;
        var X = 0;
        if (RHS) {
            X = JamSystem.RenderManager.GetScreenWidth() - thisUI.PaletteWidth
        }
        thisUI.Item = Helpers.CreateSprite(X, 0, EA.TopLeft, "Editor_White", RenderTree);
        var ScaleWidth = thisUI.PaletteWidth / thisUI.Item.GetWidth();
        var ScaleHeight = JamSystem.RenderManager.GetScreenHeight() / thisUI.Item.GetHeight();
        thisUI.Item.SetScale(ScaleWidth, ScaleHeight);
        thisUI.TabItem = Helpers.CreateSprite(0, -1, EA.TopLeft, "Editor_PaletteTab", RenderTree);
        thisUI.TabItem.SetColour(Colour);
        var TabX = X + thisUI.GetTrueWidth();
        if (RHS) {
            TabX = X
        }
        thisUI.TabItem.SetPositionX(TabX);
        if (RHS) {
            thisUI.TabItem.SetScaleX(-1)
        }
        if (!RHS) {
            thisUI.TabLabel = Helpers.CreateBitmapText(Label, 0, 0, EA.TopRight, "EditorFont", RenderTree);
            thisUI.TabLabel.SetPosition(TabX + 3, 10);
            thisUI.TabLabel.SetRotation(-Math.PI / 2)
        }
        if (RHS) {
            thisUI.TabLabel = Helpers.CreateBitmapText(Label, 0, 0, EA.TopLeft, "EditorFont", RenderTree);
            thisUI.TabLabel.SetPosition(TabX - 3, 10);
            thisUI.TabLabel.SetRotation(Math.PI / 2)
        }
        var AlteredColour = Colour;
        if (AlteredColour[0] > .07) {
            Colour[0] -= .07
        }
        if (AlteredColour[1] > .07) {
            Colour[1] -= .07
        }
        if (AlteredColour[2] > .07) {
            Colour[2] -= .07
        }
        thisUI.Item.SetColour(AlteredColour);
        thisUI.TabItem.SetPositionY(-1 + thisUI.TabItem.GetHeight() * Index);
        thisUI.TabLabel.SetPositionY(thisUI.TabLabel.GetPositionY() + thisUI.TabItem.GetHeight() * Index);
        thisUI.TextBoxUI = UITextBox.Create();
        thisUI.TextBoxUI.AddTextBoxItem(0, 0, "", false, false, RenderTree, undefined);
        thisUI.Close(thisUI);
        thisUI.PaletteBox = true;
        return thisUI.Item
    };
    UIPalette.GenerateNextBrushSpace = function GenSelectSpaceFn(thisUI, BrushSize) {
        if (thisUI.BrushPosition.x < 0) {
            thisUI.BrushPosition.x = thisUI.Item.GetPositionX() + 10;
            thisUI.BrushPosition.y = 10;
            return
        }
        if (thisUI.ScrollUI) {
            var Change = thisUI.ScrollUI.ResetScrollBar(thisUI.ObjectsAttached);
            thisUI.BrushPosition.y += Change
        }
        thisUI.BrushPosition.x += 10;
        if (thisUI.BrushPosition.x + BrushSize * 2 > thisUI.Item.GetPositionX() + thisUI.GetTrueWidth() - 20) {
            thisUI.BrushPosition.x = thisUI.Item.GetPositionX() + 10;
            thisUI.BrushPosition.y += 10;
            thisUI.BrushPosition.y += BrushSize;
            thisUI.Rows += 1;
            var ActualLength = thisUI.Rows * (BrushSize + 10) + 10;
            thisUI.CheckForScrollBar(ActualLength)
        } else {
            thisUI.BrushPosition.x += BrushSize
        }
    };
    UIPalette.UndoNextBrushSpace = function UndoSelectSpaceFn(thisUI, BrushSize) {
        if (BrushSize === UIPalette.prototype.BrushSizeSmall) {
            var BrushesPerLine = Math.floor((thisUI.PaletteWidth - 20) / (BrushSize + 10)) - 1;
            if (thisUI.BrushPosition.x === 10) {
                thisUI.BrushPosition.x = 10 + BrushesPerLine * (BrushSize + 10);
                thisUI.BrushPosition.y -= BrushSize + 10;
                thisUI.Rows -= 1
            } else {
                thisUI.BrushPosition.x -= BrushSize + 10
            }
        } else {
            thisUI.BrushPosition.y -= BrushSize + 10;
            thisUI.Rows -= 1
        }
        var ActualLength = thisUI.Rows * (BrushSize + 10) + 10;
        thisUI.CheckForScrollBar(ActualLength)
    };
    UIPalette.Open = function OpenPaletteFn(thisUI) {
        thisUI.RenderTree.SetPosition(0, 0);
        thisUI.IsOpen = true;
        var i = 0;
        for (i = 0; i < thisUI.PaletteBrushes.length; i += 1) {
            thisUI.PaletteBrushes[i].SetIsVisible(true)
        }
    };
    UIPalette.Close = function ClosePaletteFn(thisUI) {
        if (!thisUI.RHS) {
            thisUI.RenderTree.SetPosition(-thisUI.PaletteWidth, 0)
        }
        if (thisUI.RHS) {
            thisUI.RenderTree.SetPosition(thisUI.PaletteWidth, 0)
        }
        thisUI.IsOpen = false;
        thisUI.ScrollFocus = false;
        var i = 0;
        for (i = 0; i < thisUI.PaletteBrushes.length; i += 1) {
            thisUI.PaletteBrushes[i].SetIsVisible(false)
        }
        thisUI.TextBoxUI.SetIsVisible(false);
        thisUI.TextBoxUI.Item.SetText("");
        thisUI.TextBoxUI.BackingItem.SetPositionX(-50, -50)
    };
    UIPalette.AddBrushByIndex = function AddBrushIndexFn(thisUI, BrushIndex) {
        thisUI.GenerateNextBrushSpace(UIPalette.prototype.BrushSizeSmall);
        var BrushUI = UIBrush.Create();
        BrushUI.AddBrushByIndex(thisUI.BrushPosition.x, thisUI.BrushPosition.y, BrushIndex, UIPalette.prototype.BrushSizeSmall, thisUI.RenderTree);
        thisUI.ObjectsAttached[thisUI.ObjectsAttached.length] = BrushUI;
        thisUI.PaletteBrushes[thisUI.PaletteBrushes.length] = BrushUI;
        thisUI.TextBoxUI.ReattachObjects();
        thisUI.AllowSelection[thisUI.PaletteBrushes.length - 1] = true;
        thisUI.BrushPaletteOnly = true
    };
    UIPalette.AddBrushByEntity = function AddBrushEntityFn(thisUI, BrushEntities, Save) {
        if (BrushEntities.length === 0) {
            return
        }
        thisUI.GenerateNextBrushSpace(UIPalette.prototype.BrushSizeLarge);
        var BrushUI = UIBrush.Create();
        BrushUI.AddBrushByEntity(thisUI.BrushPosition.x, thisUI.BrushPosition.y, BrushEntities, UIPalette.prototype.BrushSizeLarge, thisUI.RenderTree);
        thisUI.ObjectsAttached[thisUI.ObjectsAttached.length] = BrushUI;
        thisUI.PaletteBrushes[thisUI.PaletteBrushes.length] = BrushUI;
        thisUI.TextBoxUI.ReattachObjects();
        if (Save) {
            BrushPaletteManager.Save(thisUI.PaletteBrushes, SettingsFileManager.BrushPaletteFile)
        }
        thisUI.BrushPaletteOnly = true
    };
    UIPalette.GetBrushClicked = function GetBrushClickedFn(thisUI, Entities, Editor) {
        if (thisUI.BrushClicked) {
            if (thisUI.BrushIndex !== -1) {
                if (Entities !== undefined) {
                    if (thisUI.PaletteBrushes[thisUI.BrushIndex].BrushInfo) {
                        Entities[0] = WorldFileManager.CreateEntity(500, 500, 0, 1, 1, null, thisUI.BrushIndex, null);
                        Entities[0].Sprite.SetColour([1, 1, 1, .5])
                    } else {
                        var BrushEntities = thisUI.PaletteBrushes[thisUI.BrushIndex].Entities;
                        Editor.GeneralFunctions.CopyEntityGroup(Editor, Entities, BrushEntities, true, false);
                        var i = 0;
                        for (i = 0; i < BrushEntities.length; i += 1) {
                            Editor.BrushOffsetX[i] = thisUI.PaletteBrushes[thisUI.BrushIndex].OffsetX[i];
                            Editor.BrushOffsetY[i] = thisUI.PaletteBrushes[thisUI.BrushIndex].OffsetY[i];
                            Entities[i].Sprite.SetColour([1, 1, 1, .5])
                        }
                    }
                }
            }
            thisUI.BrushClicked = false;
            return true
        }
        return false
    };
    UIPalette.ResetBrush = function ResetBrushFn(thisUI) {
        if (thisUI.BrushIndex !== -1) {
            if (thisUI.PaletteBrushes[thisUI.BrushIndex]) {
                thisUI.PaletteBrushes[thisUI.BrushIndex].Reset()
            }
        }
        thisUI.BrushIndex = -1
    };
    UIPalette.CheckRightClickCollision = function CheckRCCollFn(thisUI, X, Y) {
        var i = 0;
        for (i = 0; i < thisUI.PaletteBrushes.length; i += 1) {
            if (thisUI.PaletteBrushes[i].IsVisible()) {
                if (thisUI.PaletteBrushes[i].CheckCollision(X, Y)) {
                    return i
                }
            }
        }
        return -1
    };
    UIPalette.DeleteBrush = function DeleteBrushFn(thisUI, BrushSize) {
        thisUI.UndoNextBrushSpace(BrushSize);
        var OAIndex = thisUI.ObjectsAttached.indexOf(thisUI.PaletteBrushes[thisUI.BrushToDelete]);
        thisUI.ObjectsAttached.splice(OAIndex, 1);
        thisUI.PaletteBrushes[thisUI.BrushToDelete].RemoveItem();
        thisUI.PaletteBrushes.splice(thisUI.BrushToDelete, 1);
        var BrushesPerLine = Math.floor((thisUI.PaletteWidth - 20) / (BrushSize + 10)) - 1;
        var j = 0;
        for (j = thisUI.BrushToDelete; j < thisUI.PaletteBrushes.length; j += 1) {
            thisUI.PaletteBrushes[j].ShiftBackwards(BrushSize, BrushesPerLine);
            thisUI.CheckHidden(j)
        }
        thisUI.BrushToDelete = -1;
        if (BrushSize === UIPalette.prototype.BrushSizeLarge) {
            BrushPaletteManager.Save(thisUI.PaletteBrushes, SettingsFileManager.BrushPaletteFile)
        }
    };
    UIPalette.BrushesNonSelectable = function BrushesNonSelectableFn(thisUI) {
        var BrushSelectableCount = 0;
        var i = 0;
        for (i = 0; i < thisUI.PaletteBrushes.length; i += 1) {
            if (thisUI.AllowSelection[i]) {
                BrushSelectableCount += 1
            }
        }
        return BrushSelectableCount !== thisUI.PaletteBrushes.length
    };
    UIPalette.QuickShowBrush = function QuickShowBrushFn(thisUI, BrushtoShow, Selected) {
        if (BrushtoShow === -1) {
            var i = 0;
            for (i = 0; i < thisUI.PaletteBrushes.length; i += 1) {
                if (thisUI.PaletteBrushes[i].isHighlighted) {
                    thisUI.PaletteBrushes[i].HighlightItem(false, Selected)
                }
            }
        } else {
            if (thisUI.PaletteBrushes[BrushtoShow]) {
                thisUI.PaletteBrushes[BrushtoShow].HighlightItem(true, Selected)
            }
        }
    };
    UIPalette.ShiftBrushIndex = function ShiftBrushIndexFn(thisUI, Brush, X, Y, SwapIndex) {
        var PalWidth = thisUI.Item.GetPositionX() + thisUI.GetTrueWidth() - 20;
        var Amount = Math.floor(PalWidth / (10 + UIPalette.prototype.BrushSizeSmall));
        if (SwapIndex === undefined) {
            SwapIndex = Brush + X + Amount * Y
        } else {
            Y = SwapIndex > Brush ? 1 : -1
        }
        var BrushInfo = ObjectPaletteManager.ObjectPalette[Brush];
        var SwapBrushInfo = ObjectPaletteManager.ObjectPalette[SwapIndex];
        var LastInfo = 0,
            MovingIndex = 0,
            ChangeIndex = 0;
        if (Y === 0 && X !== 0) {
            ObjectPaletteManager.ObjectPalette[Brush] = SwapBrushInfo;
            ObjectPaletteManager.ObjectPalette[SwapIndex] = BrushInfo;
            thisUI.PaletteBrushes[Brush].ReplaceBrushInfo(Brush);
            thisUI.PaletteBrushes[SwapIndex].ReplaceBrushInfo(SwapIndex);
            thisUI.EntityPaletteToChange = [{
                A: Brush,
                B: SwapIndex
            }]
        } else if (Y === -1) {
            MovingIndex = Brush - 1;
            ChangeIndex = 0;
            while (MovingIndex !== SwapIndex - 1) {
                LastInfo = ObjectPaletteManager.ObjectPalette[MovingIndex];
                ObjectPaletteManager.ObjectPalette[MovingIndex + 1] = LastInfo;
                thisUI.PaletteBrushes[MovingIndex + 1].ReplaceBrushInfo(MovingIndex + 1);
                MovingIndex -= 1;
                thisUI.EntityPaletteToChange[ChangeIndex] = {
                    A: SwapIndex,
                    B: SwapIndex + ChangeIndex + 1
                };
                ChangeIndex += 1
            }
            ObjectPaletteManager.ObjectPalette[SwapIndex] = BrushInfo;
            thisUI.PaletteBrushes[SwapIndex].ReplaceBrushInfo(SwapIndex)
        } else if (Y === 1) {
            MovingIndex = Brush + 1;
            ChangeIndex = 0;
            while (MovingIndex !== SwapIndex + 1) {
                LastInfo = ObjectPaletteManager.ObjectPalette[MovingIndex];
                ObjectPaletteManager.ObjectPalette[MovingIndex - 1] = LastInfo;
                thisUI.PaletteBrushes[MovingIndex - 1].ReplaceBrushInfo(MovingIndex - 1);
                MovingIndex += 1;
                thisUI.EntityPaletteToChange[ChangeIndex] = {
                    A: SwapIndex,
                    B: SwapIndex - ChangeIndex - 1
                };
                ChangeIndex += 1
            }
            ObjectPaletteManager.ObjectPalette[SwapIndex] = BrushInfo;
            thisUI.PaletteBrushes[SwapIndex].ReplaceBrushInfo(SwapIndex)
        }
        ObjectPaletteManager.SavePalette(SettingsFileManager.ObjectPaletteFile);
        if (thisUI.PaletteBrushes[Brush].isFlashing) {
            thisUI.PaletteBrushes[Brush].isFlashing = false;
            thisUI.PaletteBrushes[SwapIndex].isFlashing = true
        }
        thisUI.ResetBrush();
        thisUI.BrushIndex = SwapIndex;
        thisUI.ForceBrushUpdate = true
    };
    UIPalette.UpdateBrushInfo = function UpdateBrushInfoFn(thisUI, Index) {
        thisUI.PaletteBrushes[Index].ReplaceBrushInfo(Index)
    };
    UIPalette.LimitObjectSelection = function LimitObjectSelectionFn(thisUI, Index, DisableThis) {
        var i = 0;
        if (DisableThis) {
            var BrushSelectableCount = 0;
            for (i = 0; i < thisUI.PaletteBrushes.length; i += 1) {
                if (thisUI.AllowSelection[i]) {
                    BrushSelectableCount += 1
                }
            }
            if (BrushSelectableCount === 1 && thisUI.AllowSelection[Index]) {
                for (i = 0; i < thisUI.PaletteBrushes.length; i += 1) {
                    thisUI.AllowSelection[i] = true;
                    thisUI.PaletteBrushes[i].TickItem.SetIsVisible(false);
                    thisUI.PaletteBrushes[i].AllowTick = false
                }
            } else {
                thisUI.AllowSelection[Index] = !thisUI.AllowSelection[Index]
            }
            if (thisUI.PaletteBrushes[0].TickItem) {
                for (i = 0; i < thisUI.PaletteBrushes.length; i += 1) {
                    if (thisUI.AllowSelection[i]) {
                        if (thisUI.PaletteBrushes[i].Item.GetIsVisible()) {
                            thisUI.PaletteBrushes[i].TickItem.SetIsVisible(true)
                        }
                        thisUI.PaletteBrushes[i].AllowTick = true
                    } else {
                        thisUI.PaletteBrushes[i].TickItem.SetIsVisible(false);
                        thisUI.PaletteBrushes[i].AllowTick = false
                    }
                }
            }
        } else {
            for (i = 0; i < thisUI.PaletteBrushes.length; i += 1) {
                if (i !== Index) {
                    thisUI.PaletteBrushes[i].TickItem.SetIsVisible(false);
                    thisUI.PaletteBrushes[i].AllowTick = false;
                    thisUI.AllowSelection[i] = false
                } else {
                    if (thisUI.PaletteBrushes[i].Item.GetIsVisible()) {
                        thisUI.PaletteBrushes[i].TickItem.SetIsVisible(true)
                    }
                    thisUI.PaletteBrushes[i].AllowTick = true;
                    thisUI.AllowSelection[i] = true
                }
            }
        }
        if (!thisUI.BrushesNonSelectable()) {
            for (i = 0; i < thisUI.PaletteBrushes.length; i += 1) {
                thisUI.PaletteBrushes[i].TickItem.SetIsVisible(false);
                thisUI.PaletteBrushes[i].AllowTick = false
            }
        }
    };
    UIPalette.HideObjectSelection = function HideObjectSelectionFn(thisUI, Index, Editor) {
        var i = 0,
            j = 0,
            Entities = [];
        if (thisUI.AllowSelection[Index]) {
            for (i = 0; i < Editor.World.GetLayerAmount(); i += 1) {
                Editor.World.GetLayer(i).GetAllEntities(Entities);
                for (j = 0; j < Entities.length; j += 1) {
                    if (Entities[j].ObjectPaletteIndex === Index) {
                        Entities[j].SetIsVisible(true)
                    }
                }
            }
        } else {
            for (i = 0; i < Editor.World.GetLayerAmount(); i += 1) {
                Editor.World.GetLayer(i).GetAllEntities(Entities);
                for (j = 0; j < Entities.length; j += 1) {
                    if (Entities[j].ObjectPaletteIndex === Index) {
                        Entities[j].SetIsVisible(false)
                    }
                }
            }
        }
    };
    UIPalette.IsObjectHidden = function IsObjectHiddenFn(thisUI, Index) {
        return !thisUI.AllowSelection[Index]
    };
    UIPalette.ReattachObjects = function ReattachFn(thisUI) {
        UIBox.ReattachObjects(thisUI);
        thisUI.RenderTree.RemoveChild(thisUI.TabItem);
        thisUI.RenderTree.AddChild(thisUI.TabItem);
        thisUI.RenderTree.RemoveChild(thisUI.TabLabel);
        thisUI.RenderTree.AddChild(thisUI.TabLabel)
    };
    UIPalette.Update = function UpdateFn(thisUI, TimeDelta, MouseX, MouseY) {
        thisUI.isFocused = false;
        if (!thisUI.IsOpen) {
            return
        }
        var i = 0;
        thisUI.ScrollFocus = thisUI.IsMouseOver(MouseX, MouseY);
        if (thisUI.ScrollUI && (thisUI.ScrollFocus || thisUI.SuperScrollFocus)) {
            thisUI.ScrollUI.Update(TimeDelta, MouseX, MouseY);
            if (thisUI.ScrollUI.ScrollDelta !== 0) {
                thisUI.UpdateScroll();
                thisUI.BrushPosition.y -= thisUI.ScrollUI.ScrollDelta
            }
        }
        if (thisUI.ScrollUI) {
            thisUI.SuperScrollFocus = thisUI.ScrollUI.Scrolling
        }
        if (thisUI.BrushPaletteOnly) {
            for (i = 0; i < thisUI.PaletteBrushes.length; i += 1) {
                thisUI.PaletteBrushes[i].Update(TimeDelta, MouseX, MouseY)
            }
        }
        thisUI.TextBoxUI.Update(TimeDelta, MouseX, MouseY);
        var FoundBrush = false;
        for (i = 0; i < thisUI.PaletteBrushes.length; i += 1) {
            if (thisUI.PaletteBrushes[i].BrushInfo) {
                FoundBrush = thisUI.PaletteBrushes[i].CheckCollision(MouseX, MouseY);
                if (FoundBrush) {
                    thisUI.TextBoxUI.SetIsVisible(true);
                    if (ObjectPaletteManager.ObjectPalette[i].Alias) {
                        thisUI.TextBoxUI.Item.SetText(ObjectPaletteManager.ObjectPalette[i].Alias)
                    } else {
                        thisUI.TextBoxUI.Item.SetText(ObjectPaletteManager.ObjectPalette[i].Name)
                    }
                    thisUI.TextBoxUI.BackingItem.SetPositionX(thisUI.PaletteBrushes[i].Item.GetPositionX() + 50);
                    thisUI.TextBoxUI.StartPosition.y = thisUI.PaletteBrushes[i].Item.GetPositionY();
                    thisUI.TextBoxUI.RescaleTextBox();
                    break
                }
            }
        }
        if (!FoundBrush && thisUI.TextBoxUI.IsVisible()) {
            thisUI.TextBoxUI.SetIsVisible(false)
        }
        UIBase.Update(thisUI, TimeDelta, MouseX, MouseY)
    };
    UIPalette.SetIsVisible = function SetIsVisibleFn(thisUI, Visible) {
        UIBox.SetIsVisible(thisUI, Visible);
        thisUI.TabItem.SetIsVisible(Visible);
        thisUI.TabLabel.SetIsVisible(Visible);
        var i = 0;
        for (i = 0; i < thisUI.PaletteBrushes.length; i += 1) {
            thisUI.PaletteBrushes[i].SetIsVisible(Visible)
        }
        thisUI.TextBoxUI.SetIsVisible(Visible)
    };
    UIPalette.CheckCollision = function CheckCollFn(thisUI, X, Y) {
        var CompensateX = thisUI.RenderTree.GetPositionX();
        var TrueWidth = thisUI.TabItem.GetWidth();
        var TrueHeight = thisUI.TabItem.GetHeight();
        if (thisUI.RHS) {
            CompensateX -= TrueWidth
        }
        if (X >= thisUI.TabItem.GetPositionX() + CompensateX && X <= TrueWidth + thisUI.TabItem.GetPositionX() + CompensateX && Y >= thisUI.TabItem.GetPositionY() && Y <= TrueHeight + thisUI.TabItem.GetPositionY()) {
            if (!thisUI.IsOpen) {
                thisUI.Open(thisUI)
            } else {
                thisUI.Close(thisUI)
            }
            return true
        }
        if (!thisUI.IsOpen) {
            return false
        }
        if (thisUI.BrushPaletteOnly) {
            var i = 0;
            for (i = 0; i < thisUI.PaletteBrushes.length; i += 1) {
                var BrushDelete = thisUI.PaletteBrushes[i].CheckDelete(X, Y);
                if (BrushDelete) {
                    thisUI.BrushToDelete = i;
                    thisUI.AllowConfirmation = true;
                    return true
                }
                var BrushHit = thisUI.PaletteBrushes[i].CheckCollision(X, Y);
                if (BrushHit) {
                    if (JamSystem.InputManager.GetKeyHeld(302) || JamSystem.InputManager.GetKeyHeld(303)) {
                        thisUI.BrushIndex = i
                    } else {
                        thisUI.ResetBrush();
                        thisUI.BrushIndex = i;
                        thisUI.BrushClicked = true;
                        thisUI.PaletteBrushes[i].isFlashing = true
                    }
                    return true
                }
            }
        }
        return UIBox.CheckCollision(thisUI, X, Y)
    };
    UIPalette.CheckCollisionPressed = function CheckCollPressFn(thisUI, X, Y) {
        return UIBox.CheckCollisionPressed(thisUI, X, Y)
    };
    UIPalette.RelocateItem = function RelocateItemFn(thisUI) {
        var ScaleHeight = JamSystem.RenderManager.GetScreenHeight() / thisUI.Item.GetHeight();
        thisUI.Item.SetScaleY(ScaleHeight);
        if (!thisUI.RHS) {
            thisUI.Item.SetPosition(0, 0)
        }
        if (thisUI.RHS) {
            var PosX = JamSystem.RenderManager.GetScreenWidth() - thisUI.GetTrueWidth();
            thisUI.TabItem.SetPositionX(PosX);
            thisUI.TabLabel.SetPositionX(PosX - 5);
            if (thisUI.ScrollUI) {
                thisUI.ScrollUI.BackingItem.SetPositionX(JamSystem.RenderManager.GetScreenWidth() - thisUI.ScrollBarWidth);
                thisUI.ScrollUI.Item.SetPositionX(JamSystem.RenderManager.GetScreenWidth() - thisUI.ScrollBarWidth)
            }
            if (thisUI.PaletteBrushes) {
                for (var k = 0; k < thisUI.PaletteBrushes.length; k += 1) {
                    if (thisUI.PaletteBrushes[k] !== thisUI) {
                        if (thisUI.PaletteBrushes[k].Item) {
                            thisUI.PaletteBrushes[k].Item.SetPositionX(thisUI.PaletteBrushes[k].Item.GetPositionX() - thisUI.Item.GetPositionX() + PosX)
                        }
                        thisUI.PaletteBrushes[k].BackingItem.SetPositionX(thisUI.PaletteBrushes[k].BackingItem.GetPositionX() - thisUI.Item.GetPositionX() + PosX);
                        thisUI.PaletteBrushes[k].EntityRenderTree.SetPositionX(thisUI.PaletteBrushes[k].EntityRenderTree.GetPositionX() - thisUI.Item.GetPositionX() + PosX);
                        thisUI.PaletteBrushes[k].CrossItem.SetPositionX(thisUI.PaletteBrushes[k].CrossItem.GetPositionX() - thisUI.Item.GetPositionX() + PosX)
                    }
                }
            }
            thisUI.Item.SetPosition(PosX, 0)
        }
        if (thisUI.PaletteBrushes) {
            var LastBrush = thisUI.PaletteBrushes[thisUI.PaletteBrushes.length - 1];
            if (LastBrush) {
                var LastHeight = LastBrush.BackingItem.GetPositionY() + LastBrush.GetTrueHeight() + 10;
                thisUI.CheckForScrollBar(LastHeight)
            }
        }
    };
    UIPalette.RemoveItem = function RemoveItemFn(thisUI) {
        Helpers.DestroyBitmapText(thisUI.TabLabel);
        Helpers.DestroySprite(thisUI.TabItem);
        Helpers.DestroySprite(thisUI.Item);
        thisUI.TextBoxUI.RemoveItem()
    };
    UIPalette.IsMouseOver = function IsMouseOverFn(thisUI, X, Y) {
        if (thisUI.IsOpen) {
            if (!thisUI.RHS && X < thisUI.PaletteWidth) {
                return true
            }
            if (thisUI.RHS && X > JamSystem.RenderManager.GetScreenWidth() - thisUI.PaletteWidth) {
                return true
            }
            if (thisUI.ScrollUI) {
                if (thisUI.ScrollUI.IsMouseOver(X, Y)) {
                    return true
                }
            }
        }
        var TabWidth = thisUI.TabItem.GetScaleX() * thisUI.TabItem.GetWidth();
        var TabHeight = thisUI.TabItem.GetScaleY() * thisUI.TabItem.GetHeight();
        var CompensateX = thisUI.RenderTree.GetPositionX();
        var PosX = thisUI.TabItem.GetPositionX() + CompensateX;
        if (Y > thisUI.TabItem.GetPositionY() && Y < thisUI.TabItem.GetPositionY() + TabHeight) {
            if (thisUI.RHS && X > PosX + TabWidth && X < PosX || !thisUI.RHS && X > PosX && X < PosX + TabWidth) {
                return true
            }
        }
        return false
    };
    UIPalette.Create = function UICreateFn() {
        var NewObject = UIBox.Create();
        NewObject.BrushPosition = new Vector2(-10, -10);
        NewObject.Rows = 1;
        NewObject.RHS = false;
        NewObject.TabItem = 0;
        NewObject.TabLabel = 0;
        NewObject.IsOpen = true;
        NewObject.BrushClicked = false;
        NewObject.BrushIndex = -1;
        NewObject.ForceBrushUpdate = false;
        NewObject.EntityPaletteToChange = [];
        NewObject.BrushToDelete = -1;
        NewObject.AllowConfirmation = false;
        NewObject.AllowSelection = [];
        NewObject.PaletteWidth = 0;
        NewObject.BrushPaletteOnly = false;
        NewObject.LastQuickShowBrush = -1;
        NewObject.QuickShowBrushSelected = false;
        NewObject.PaletteBrushes = [];
        NewObject.TextBoxUI = 0;
        NewObject.AddPalette = function AddBoxFn(Label, Colour, Width, RenderTree, Index, RHS) {
            return UIPalette.AddPalette(this, Label, Colour, Width, RenderTree, Index, RHS)
        };
        NewObject.GenerateNextBrushSpace = function GenSelectSpaceFn(BrushSize) {
            UIPalette.GenerateNextBrushSpace(this, BrushSize)
        };
        NewObject.UndoNextBrushSpace = function UndoSelectSpaceFn(BrushSize) {
            UIPalette.UndoNextBrushSpace(this, BrushSize)
        };
        NewObject.Open = function OpenPaletteFn() {
            UIPalette.Open(this)
        };
        NewObject.Close = function ClosePaletteFn() {
            UIPalette.Close(this)
        };
        NewObject.AddBrushByIndex = function AddBrushIndexFn(BrushIndex) {
            UIPalette.AddBrushByIndex(this, BrushIndex)
        };
        NewObject.AddBrushByEntity = function AddBrushEntityFn(BrushEntities, Save) {
            UIPalette.AddBrushByEntity(this, BrushEntities, Save)
        };
        NewObject.GetBrushClicked = function GetBrushClickedFn(Entities, Editor) {
            return UIPalette.GetBrushClicked(this, Entities, Editor)
        };
        NewObject.ResetBrush = function ResetBrushFn() {
            UIPalette.ResetBrush(this)
        };
        NewObject.CheckRightClickCollision = function CheckRCCollFn(X, Y) {
            return UIPalette.CheckRightClickCollision(this, X, Y)
        };
        NewObject.DeleteBrush = function DeleteBrushFn(BrushSize) {
            UIPalette.DeleteBrush(this, BrushSize)
        };
        NewObject.BrushesNonSelectable = function BrushesNonSelectableFn() {
            return UIPalette.BrushesNonSelectable(this)
        };
        NewObject.QuickShowBrush = function QuickShowBrushFn(BrushtoShow, Selected) {
            UIPalette.QuickShowBrush(this, BrushtoShow, Selected)
        };
        NewObject.ShiftBrushIndex = function ShiftBrushIndexFn(Brush, X, Y, SwapIndex) {
            UIPalette.ShiftBrushIndex(this, Brush, X, Y, SwapIndex)
        };
        NewObject.UpdateBrushInfo = function UpdateBrushInfoFn(Index) {
            UIPalette.UpdateBrushInfo(this, Index)
        };
        NewObject.LimitObjectSelection = function LimitObjectSelectionFn(Index, DisableThis) {
            UIPalette.LimitObjectSelection(this, Index, DisableThis)
        };
        NewObject.HideObjectSelection = function HideObjectSelectionFn(Index, Editor) {
            UIPalette.HideObjectSelection(this, Index, Editor)
        };
        NewObject.IsObjectHidden = function IsObjectHiddenFn(Index) {
            return UIPalette.IsObjectHidden(this, Index)
        };
        NewObject.ReattachObjects = function ReattachFn() {
            UIPalette.ReattachObjects(this)
        };
        NewObject.Update = function UpdateFn(TimeDelta, MouseX, MouseY) {
            UIPalette.Update(this, TimeDelta, MouseX, MouseY)
        };
        NewObject.SetIsVisible = function SetIsVisibleFn(Visible) {
            UIPalette.SetIsVisible(this, Visible)
        };
        NewObject.CheckCollision = function CheckCollFn(X, Y) {
            return UIPalette.CheckCollision(this, X, Y)
        };
        NewObject.CheckCollisionPressed = function CheckCollPressFn(X, Y) {
            return UIPalette.CheckCollisionPressed(this, X, Y)
        };
        NewObject.RelocateItem = function RelocateItemFn() {
            UIPalette.RelocateItem(this)
        };
        NewObject.RemoveItem = function RemoveItemFn() {
            UIPalette.RemoveItem(this)
        };
        NewObject.IsMouseOver = function IsMouseOverFn(X, Y) {
            return UIPalette.IsMouseOver(this, X, Y)
        };
        return NewObject
    };

    function PaletteCategory() {}
    PaletteCategory.prototype = {};

    function UIPaletteCategory() {}
    UIPaletteCategory.prototype = {};
    UIPaletteCategory.AddPalette = function AddBoxFn(thisUI, Label, Colour, Width, RenderTree, Index, RHS) {
        UIPalette.AddPalette(thisUI, Label, Colour, Width, RenderTree, Index, RHS);
        Debug.Log("PALETTE INFO Found " + ObjectPaletteManager.ObjectPalette.length + " Objects for Palette ");
        Debug.Log("PALETTE INFO Found " + ObjectPaletteManager.ObjectCategory.length + " Categories ");
        var i = 0;
        for (i = 0; i < ObjectPaletteManager.ObjectCategory.length; i += 1) {
            Debug.Log("PALETTE INFO Found " + ObjectPaletteManager.ObjectCategory[i].Items.length + " Objects for Category " + i);
            thisUI.AddCategory(ObjectPaletteManager.ObjectCategory[i].Name, i)
        }
        if (!thisUI.Categories[0]) {
            thisUI.AddCategory("Unknown", 0)
        }
    };
    UIPaletteCategory.Open = function OpenPaletteFn(thisUI) {
        UIPalette.Open(thisUI);
        thisUI.CalculatePlacement()
    };
    UIPaletteCategory.Close = function ClosePaletteFn(thisUI) {
        UIPalette.Close(thisUI)
    };
    UIPaletteCategory.AddBrushByIndex = function AddBrushIndexFn(thisUI, BrushIndex) {
        UIPalette.AddBrushByIndex(thisUI, BrushIndex);
        var ObjectLocation = thisUI.ObjectsAttached.length - 1;
        var i = 0,
            CategoryIndex = 0,
            CategoryPlacement = -1;
        for (i = 0; i < ObjectPaletteManager.ObjectCategory.length; i += 1) {
            if (ObjectPaletteManager.ObjectCategory[i].Items) {
                CategoryPlacement = ObjectPaletteManager.ObjectCategory[i].Items.indexOf(ObjectPaletteManager.ObjectPalette[BrushIndex].Name);
                if (CategoryPlacement !== -1) {
                    CategoryIndex = i;
                    break
                }
            }
        }
        if (CategoryPlacement === -1) {
            var Slot = ObjectPaletteManager.ObjectCategory[CategoryIndex].Items.length;
            thisUI.Categories[CategoryIndex].Items[Slot] = thisUI.ObjectsAttached[ObjectLocation];
            ObjectPaletteManager.ObjectCategory[CategoryIndex].Items[Slot] = ObjectPaletteManager.ObjectPalette[BrushIndex].Name;
            thisUI.SavePalette = true
        } else {
            if (thisUI.Categories[CategoryIndex].Items[CategoryPlacement]) {
                CategoryPlacement = ObjectPaletteManager.ObjectCategory[CategoryIndex].Items.length
            }
            thisUI.Categories[CategoryIndex].Items[CategoryPlacement] = thisUI.ObjectsAttached[ObjectLocation]
        }
        thisUI.CalculatePlacement()
    };
    UIPaletteCategory.KillEmptySlots = function KillEmptySlotsFn(thisUI) {
        var i = 0,
            j = 0;
        for (i = 0; i < thisUI.Categories.length; i += 1) {
            for (j = 0; j < thisUI.Categories[i].Items.length; j += 1) {
                if (thisUI.Categories[i].Items[j] === undefined) {
                    thisUI.Categories[i].Items.splice(j, 1);
                    ObjectPaletteManager.ObjectCategory[i].Items.splice(j, 1);
                    thisUI.SavePalette = true
                }
            }
        }
    };
    UIPaletteCategory.AddCategory = function AddCategoryFn(thisUI, Name, Index) {
        var NewCatIndex = Index === undefined ? thisUI.Categories.length : Index;
        var NewCategory = new PaletteCategory;
        NewCategory.Items = [];
        NewCategory.Name = Name;
        NewCategory.Open = false;
        NewCategory.Flashing = false;
        NewCategory.FlashingItem = -1;
        NewCategory.UI = UITextBox.Create();
        NewCategory.UI.AddTextBoxItem(0, NewCatIndex * 34, NewCategory.Name, false, false, thisUI.RenderTree, thisUI.PaletteWidth);
        NewCategory.UI.BackingItem.SetColour([0, 0, 0, 1]);
        if (thisUI.Categories[NewCatIndex]) {
            thisUI.Categories.splice(NewCatIndex, 0, NewCategory);
            ObjectPaletteManager.ObjectCategory.splice(NewCatIndex, 0, new ObjectCategory);
            ObjectPaletteManager.ObjectCategory[NewCatIndex] = new ObjectCategory;
            ObjectPaletteManager.ObjectCategory[NewCatIndex].Name = NewCategory.Name;
            ObjectPaletteManager.ObjectCategory[NewCatIndex].Items = [];
            ObjectPaletteManager.SavePalette(SettingsFileManager.ObjectPaletteFile)
        } else {
            thisUI.Categories[NewCatIndex] = NewCategory;
            if (!ObjectPaletteManager.ObjectCategory[NewCatIndex]) {
                ObjectPaletteManager.ObjectCategory[NewCatIndex] = new ObjectCategory;
                ObjectPaletteManager.ObjectCategory[NewCatIndex].Name = NewCategory.Name;
                ObjectPaletteManager.ObjectCategory[NewCatIndex].Items = []
            }
        }
        thisUI.ObjectsAttached[thisUI.ObjectsAttached.length] = NewCategory.UI;
        if (thisUI.ScrollUI) {
            thisUI.ScrollUI.ReattachObjects()
        }
        if (thisUI.TextBoxUI) {
            thisUI.TextBoxUI.ReattachObjects()
        }
    };
    UIPaletteCategory.RemoveCategory = function RemoveCategoryFn(thisUI, Index) {
        if (thisUI.Categories[Index]) {
            var i = 0,
                j = 0;
            for (i = 0; i < thisUI.Categories[Index].Items.length; i += 1) {
                var Item = thisUI.Categories[Index].Items[i].BrushIndex;
                var NewIndex = thisUI.Categories[0].Items.length;
                thisUI.Categories[0].Items[NewIndex] = thisUI.Categories[Index].Items[i];
                ObjectPaletteManager.ObjectCategory[0].Items[NewIndex] = ObjectPaletteManager.ObjectPalette[Item].Name
            }
            thisUI.ObjectsAttached.splice(thisUI.ObjectsAttached.indexOf(thisUI.Categories[Index].UI), 1);
            thisUI.Categories[Index].UI.RemoveItem();
            thisUI.Categories.splice(Index, 1);
            ObjectPaletteManager.ObjectCategory.splice(Index, 1);
            ObjectPaletteManager.SavePalette(SettingsFileManager.ObjectPaletteFile)
        }
        thisUI.CalculatePlacement()
    };
    UIPaletteCategory.MoveCategory = function MoveCategoryFn(thisUI, Index, To) {
        if (thisUI.Categories[Index]) {
            var TempCategory = thisUI.Categories[Index];
            thisUI.Categories.splice(Index, 1);
            ObjectPaletteManager.ObjectCategory.splice(Index, 1);
            thisUI.Categories.splice(To, 0, TempCategory);
            ObjectPaletteManager.ObjectCategory.splice(To, 0, new ObjectCategory);
            ObjectPaletteManager.ObjectCategory[To] = new ObjectCategory;
            ObjectPaletteManager.ObjectCategory[To].Name = TempCategory.Name;
            ObjectPaletteManager.ObjectCategory[To].Items = [];
            var i = 0;
            for (i = 0; i < TempCategory.Items.length; i += 1) {
                var Item = TempCategory.Items[i].BrushIndex;
                ObjectPaletteManager.ObjectCategory[To].Items[i] = ObjectPaletteManager.ObjectPalette[Item].Name
            }
            ObjectPaletteManager.SavePalette(SettingsFileManager.ObjectPaletteFile)
        }
        thisUI.CalculatePlacement()
    };
    UIPaletteCategory.GetIndexFromName = function GetIndexFromNameFn(thisUI, Name) {
        var i = 0;
        for (i = 0; i < thisUI.Categories.length; i += 1) {
            if (thisUI.Categories[i].Name === Name) {
                return i
            }
        }
        return -1
    };
    UIPaletteCategory.GetCategoryNameFromObjectIndex = function GetCategoryNameFromObjectIndexFn(thisUI, PaletteIndex) {
        var i = 0,
            j = 0;
        for (i = 0; i < thisUI.Categories.length; i += 1) {
            for (j = 0; j < thisUI.Categories[i].Items.length; j += 1) {
                var ObjIndex = thisUI.Categories[i].Items[j].BrushIndex;
                if (ObjIndex === PaletteIndex) {
                    return thisUI.Categories[i].Name
                }
            }
        }
        return "Not Found"
    };
    UIPaletteCategory.GetCategoryIndexFromObjectIndex = function GetCategoryIndexFromObjectIndexFn(thisUI, PaletteIndex) {
        var i = 0,
            j = 0;
        for (i = 0; i < thisUI.Categories.length; i += 1) {
            for (j = 0; j < thisUI.Categories[i].Items.length; j += 1) {
                if (thisUI.Categories[i].Items[j]) {
                    if (thisUI.Categories[i].Items[j].BrushIndex === PaletteIndex) {
                        return i
                    }
                }
            }
        }
        return -1
    };
    UIPaletteCategory.GetCategoryPositionFromObjectIndex = function GetCategoryPositionFromObjectIndexFn(thisUI, PaletteIndex) {
        var i = 0,
            j = 0;
        for (i = 0; i < thisUI.Categories.length; i += 1) {
            for (j = 0; j < thisUI.Categories[i].Items.length; j += 1) {
                if (thisUI.Categories[i].Items[j].BrushIndex === PaletteIndex) {
                    return j
                }
            }
        }
        return -1
    };
    UIPaletteCategory.AlterObjectCategory = function AlterObjectCategoryFn(thisUI, CategoryName, PalIndex) {
        var Index = thisUI.GetIndexFromName(CategoryName);
        if (Index === -1) {
            thisUI.AddCategory(CategoryName, thisUI.Categories.length);
            Index = thisUI.Categories.length - 1
        }
        var i = 0,
            j = 0;
        for (i = 0; i < thisUI.Categories.length; i += 1) {
            for (j = 0; j < thisUI.Categories[i].Items.length; j += 1) {
                if (PalIndex === thisUI.Categories[i].Items[j].BrushIndex) {
                    var Object = thisUI.Categories[i].Items[j];
                    thisUI.Categories[i].Items.splice(j, 1);
                    thisUI.Categories[Index].Items.splice(thisUI.Categories[Index].Items.length, 0, Object);
                    ObjectPaletteManager.ObjectCategory[i].Items.splice(j, 1);
                    var Item = Object.BrushIndex;
                    ObjectPaletteManager.ObjectCategory[Index].Items.splice(ObjectPaletteManager.ObjectCategory[Index].Items.length, 0, ObjectPaletteManager.ObjectPalette[Item].Name);
                    ObjectPaletteManager.SavePalette(SettingsFileManager.ObjectPaletteFile);
                    break
                }
            }
        }
        thisUI.CalculatePlacement()
    };
    UIPaletteCategory.MoveObjectInCategory = function MoveObjectInCategoryFn(thisUI, Category, IndexTo, PaletteIndex) {
        var j = 0;
        for (j = 0; j < thisUI.Categories[Category].Items.length; j += 1) {
            if (PaletteIndex === thisUI.Categories[Category].Items[j].BrushIndex) {
                var Object = thisUI.Categories[Category].Items[j];
                var CategoryPlacement = j;
                if (IndexTo < 0) {
                    IndexTo = 0
                }
                if (IndexTo >= thisUI.Categories[Category].Items.length) {
                    IndexTo = thisUI.Categories[Category].Items.length - 1
                }
                thisUI.Categories[Category].Items.splice(CategoryPlacement, 1);
                thisUI.Categories[Category].Items.splice(IndexTo, 0, Object);
                ObjectPaletteManager.ObjectCategory[Category].Items.splice(CategoryPlacement, 1);
                ObjectPaletteManager.ObjectCategory[Category].Items.splice(IndexTo, 0, ObjectPaletteManager.ObjectPalette[PaletteIndex].Name);
                return
            }
        }
    };
    UIPaletteCategory.CalculatePlacement = function CalculatePlacementFn(thisUI) {
        if (!thisUI.IsOpen) {
            return
        }
        var StartScrollY = 0;
        if (thisUI.ScrollUI) {
            StartScrollY = thisUI.ScrollUI.Item.GetPositionY()
        }
        var Position = new Vector2(0, 0);
        var i = 0,
            j = 0;
        for (i = 0; i < thisUI.Categories.length; i += 1) {
            thisUI.Categories[i].UI.MoveTo(Position.x, Position.y);
            Position.y += 34;
            if (thisUI.Categories[i].Open && thisUI.Categories[i].Items.length !== 0) {
                Position.y += 5;
                for (j = 0; j < thisUI.Categories[i].Items.length; j += 1) {
                    if (thisUI.Categories[i].Items[j]) {
                        thisUI.Categories[i].Items[j].MoveTo(Position.x + 5, Position.y);
                        Position.x += UIPalette.prototype.BrushSizeSmall + 10;
                        if (j !== thisUI.Categories[i].Items.length - 1) {
                            if (Position.x + UIPalette.prototype.BrushSizeSmall > thisUI.Item.GetPositionX() + thisUI.GetTrueWidth() - 20) {
                                Position.x = 0;
                                Position.y += UIPalette.prototype.BrushSizeSmall + 10
                            }
                        }
                        thisUI.Categories[i].Items[j].SetIsVisible(true)
                    }
                }
                Position.y += 48
            } else {
                for (j = 0; j < thisUI.Categories[i].Items.length; j += 1) {
                    if (thisUI.Categories[i].Items[j]) {
                        thisUI.Categories[i].Items[j].SetIsVisible(false)
                    }
                }
            }
            Position.x = 0
        }
        thisUI.CheckForScrollBar(Position.y);
        if (thisUI.ScrollUI) {
            if (StartScrollY > 0) {
                for (i = 0; i < thisUI.ObjectsAttached.length; i += 1) {
                    thisUI.ObjectsAttached[i].ShiftBy(0, -(StartScrollY * thisUI.ScrollUI.ScrollSpeed))
                }
            }
            thisUI.ScrollUI.Item.SetPositionY(StartScrollY)
        }
    };
    UIPaletteCategory.CheckHidden = function HiddenFn(thisUI, Item) {
        return
    };
    UIPaletteCategory.CheckCategoryCollision = function CheckCategoryCollisionFn(thisUI, X, Y) {
        var i = 0;
        for (i = 0; i < thisUI.Categories.length; i += 1) {
            if (thisUI.Categories[i].UI.CheckCollision(X, Y)) {
                return i
            }
        }
        return -1
    };
    UIPaletteCategory.DeleteBrush = function DeleteBrushFn(thisUI, BrushSize) {
        var Category = thisUI.GetCategoryIndexFromObjectIndex(thisUI.BrushToDelete);
        var CategoryPlacement = thisUI.GetCategoryPositionFromObjectIndex(thisUI.BrushToDelete);
        thisUI.Categories[Category].Items.splice(CategoryPlacement, 1);
        ObjectPaletteManager.ObjectCategory[Category].Items.splice(CategoryPlacement, 1);
        ObjectPaletteManager.SavePalette(SettingsFileManager.ObjectPaletteFile);
        UIPalette.DeleteBrush(thisUI, BrushSize);
        thisUI.CalculatePlacement()
    };
    UIPaletteCategory.ReattachObjects = function ReattachFn(thisUI) {
        UIPalette.ReattachObjects(thisUI);
        var i = 0;
        for (i = 0; i < thisUI.Categories.length; i += 1) {
            thisUI.Categories[i].UI.ReattachObjects()
        }
    };
    UIPaletteCategory.Update = function UpdateFn(thisUI, TimeDelta, MouseX, MouseY) {
        if (thisUI.SavePalette) {
            ObjectPaletteManager.SavePalette(SettingsFileManager.ObjectPaletteFile);
            thisUI.SavePalette = false
        }
        thisUI.isFocused = false;
        if (!thisUI.IsOpen) {
            return
        }
        thisUI.ScrollFocus = thisUI.IsMouseOver(MouseX, MouseY);
        if (thisUI.ScrollUI && (thisUI.ScrollFocus || thisUI.SuperScrollFocus)) {
            thisUI.ScrollUI.Update(TimeDelta, MouseX, MouseY);
            if (thisUI.ScrollUI.ScrollDelta !== 0) {
                thisUI.UpdateScroll();
                thisUI.BrushPosition.y -= thisUI.ScrollUI.ScrollDelta
            }
        }
        if (thisUI.ScrollUI) {
            thisUI.SuperScrollFocus = thisUI.ScrollUI.Scrolling
        }
        thisUI.TextBoxUI.Update(TimeDelta, MouseX, MouseY);
        var i = 0,
            j = 0;
        for (i = 0; i < thisUI.PaletteBrushes.length; i += 1) {
            var Category = thisUI.GetCategoryIndexFromObjectIndex(i);
            thisUI.PaletteBrushes[i].Update(TimeDelta, MouseX, MouseY);
            if (thisUI.PaletteBrushes[i].isHighlighted && !thisUI.PaletteBrushes[i].IsVisible()) {
                thisUI.Modifier += TimeDelta;
                if (thisUI.Modifier > .12) {
                    if (thisUI.FlashAmount === 0) {
                        thisUI.FlashAmount = 1
                    } else {
                        thisUI.FlashAmount = 0
                    }
                    thisUI.Categories[Category].UI.Item.SetColour([thisUI.FlashAmount, thisUI.FlashAmount, 1, 1]);
                    thisUI.Categories[Category].Flashing = true;
                    thisUI.Categories[Category].FlashingItem = i;
                    thisUI.Modifier = 0
                }
            } else if (thisUI.Categories[Category]) {
                if (thisUI.Categories[Category].FlashingItem === i) {
                    thisUI.Categories[Category].FlashingItem = -1;
                    thisUI.Categories[Category].Flashing = false
                }
            }
            if (thisUI.PaletteBrushes[i].isFlashing) {
                if (JamSystem.InputManager.GetKeyHeld(300) || JamSystem.InputManager.GetKeyHeld(301)) {
                    var ObjectCategoryPlacement, PalWidth, Amount;
                    if (JamSystem.InputManager.GetKeyPressed(200)) {
                        ObjectCategoryPlacement = thisUI.GetCategoryPositionFromObjectIndex(i);
                        if (ObjectCategoryPlacement - 1 >= 0) {
                            thisUI.MoveObjectInCategory(Category, ObjectCategoryPlacement - 1, i);
                            ObjectPaletteManager.SavePalette(SettingsFileManager.ObjectPaletteFile);
                            thisUI.CalculatePlacement();
                            thisUI.PaletteBrushes[i].isFlashing = true
                        }
                    }
                    if (JamSystem.InputManager.GetKeyPressed(201)) {
                        ObjectCategoryPlacement = thisUI.GetCategoryPositionFromObjectIndex(i);
                        if (ObjectCategoryPlacement + 1 < thisUI.Categories[Category].Items.length) {
                            thisUI.MoveObjectInCategory(Category, ObjectCategoryPlacement + 1, i);
                            ObjectPaletteManager.SavePalette(SettingsFileManager.ObjectPaletteFile);
                            thisUI.CalculatePlacement();
                            thisUI.PaletteBrushes[i].isFlashing = true
                        }
                    }
                    if (JamSystem.InputManager.GetKeyPressed(202)) {
                        PalWidth = thisUI.Item.GetPositionX() + thisUI.GetTrueWidth() - 20;
                        Amount = Math.floor(PalWidth / (10 + UIPalette.prototype.BrushSizeSmall));
                        ObjectCategoryPlacement = thisUI.GetCategoryPositionFromObjectIndex(i);
                        if (ObjectCategoryPlacement - Amount >= 0) {
                            thisUI.MoveObjectInCategory(Category, ObjectCategoryPlacement - Amount, i);
                            ObjectPaletteManager.SavePalette(SettingsFileManager.ObjectPaletteFile);
                            thisUI.CalculatePlacement();
                            thisUI.PaletteBrushes[i].isFlashing = true
                        }
                    }
                    if (JamSystem.InputManager.GetKeyPressed(203)) {
                        PalWidth = thisUI.Item.GetPositionX() + thisUI.GetTrueWidth() - 20;
                        Amount = Math.floor(PalWidth / (10 + UIPalette.prototype.BrushSizeSmall));
                        ObjectCategoryPlacement = thisUI.GetCategoryPositionFromObjectIndex(i);
                        if (ObjectCategoryPlacement + Amount < thisUI.Categories[Category].Items.length) {
                            thisUI.MoveObjectInCategory(Category, ObjectCategoryPlacement + Amount, i);
                            ObjectPaletteManager.SavePalette(SettingsFileManager.ObjectPaletteFile);
                            thisUI.CalculatePlacement();
                            thisUI.PaletteBrushes[i].isFlashing = true
                        }
                    }
                    if (JamSystem.InputManager.GetKeyPressed(636)) {
                        thisUI.MoveObjectInCategory(Category, 0, i);
                        ObjectPaletteManager.SavePalette(SettingsFileManager.ObjectPaletteFile);
                        thisUI.CalculatePlacement();
                        thisUI.PaletteBrushes[i].isFlashing = true
                    }
                    if (JamSystem.InputManager.GetKeyPressed(637)) {
                        thisUI.MoveObjectInCategory(Category, thisUI.Categories[Category].Items.length - 1, i);
                        ObjectPaletteManager.SavePalette(SettingsFileManager.ObjectPaletteFile);
                        thisUI.CalculatePlacement();
                        thisUI.PaletteBrushes[i].isFlashing = true
                    }
                    if (JamSystem.InputManager.GetKeyPressed(634)) {
                        for (j = 0; j < thisUI.Categories[Category].Items.length; j += 1) {
                            if (thisUI.Categories[Category].Items[j].Item.GetPositionY() > 0) {
                                thisUI.MoveObjectInCategory(Category, j, i);
                                ObjectPaletteManager.SavePalette(SettingsFileManager.ObjectPaletteFile);
                                thisUI.CalculatePlacement();
                                thisUI.PaletteBrushes[i].isFlashing = true;
                                break
                            }
                        }
                    }
                    if (JamSystem.InputManager.GetKeyPressed(635)) {
                        for (j = thisUI.Categories[Category].Items.length - 1; j > -1; j -= 1) {
                            if (thisUI.Categories[Category].Items[j].Item.GetPositionY() < JamSystem.RenderManager.GetScreenHeight()) {
                                thisUI.MoveObjectInCategory(Category, j, i);
                                ObjectPaletteManager.SavePalette(SettingsFileManager.ObjectPaletteFile);
                                thisUI.CalculatePlacement();
                                thisUI.PaletteBrushes[i].isFlashing = true;
                                break
                            }
                        }
                    }
                }
            }
        }
        var FoundBrush = false;
        for (i = 0; i < thisUI.Categories.length; i += 1) {
            if (thisUI.Categories[i].UI.IsVisible()) {
                thisUI.Categories[i].UI.Update(TimeDelta, MouseX, MouseY);
                if (!thisUI.Categories[i].Flashing) {
                    var Open = thisUI.Categories[i].Open;
                    if (Open) {
                        thisUI.Categories[i].UI.Item.SetColour([1, 0, 0, 1])
                    } else {
                        thisUI.Categories[i].UI.Item.SetColour([1, 1, 1, 1])
                    }
                }
            }
            if (thisUI.Categories[i].Open) {
                if (!FoundBrush) {
                    for (j = 0; j < thisUI.Categories[i].Items.length; j += 1) {
                        var Item = thisUI.Categories[i].Items[j];
                        FoundBrush = Item.CheckCollision(MouseX, MouseY);
                        if (FoundBrush) {
                            thisUI.TextBoxUI.SetIsVisible(true);
                            if (ObjectPaletteManager.ObjectPalette[Item.BrushIndex].Alias) {
                                thisUI.TextBoxUI.Item.SetText(ObjectPaletteManager.ObjectPalette[Item.BrushIndex].Alias)
                            } else {
                                thisUI.TextBoxUI.Item.SetText(ObjectPaletteManager.ObjectPalette[Item.BrushIndex].Name)
                            }
                            thisUI.TextBoxUI.BackingItem.SetPositionX(thisUI.PaletteBrushes[Item.BrushIndex].Item.GetPositionX() + 50);
                            thisUI.TextBoxUI.StartPosition.y = thisUI.PaletteBrushes[Item.BrushIndex].Item.GetPositionY();
                            thisUI.TextBoxUI.RescaleTextBox();
                            break
                        }
                    }
                }
            }
        }
        if (!FoundBrush && thisUI.TextBoxUI.IsVisible()) {
            thisUI.TextBoxUI.SetIsVisible(false)
        }
        UIBase.Update(thisUI, TimeDelta, MouseX, MouseY)
    };
    UIPaletteCategory.SetIsVisible = function SetIsVisibleFn(thisUI, Visible) {
        var i = 0;
        for (i = 0; i < thisUI.Categories.length; i += 1) {
            if (!thisUI.Categories[i]) {
                thisUI.AddCategory("! Missing !", i)
            }
            thisUI.Categories[i].UI.SetIsVisible(Visible)
        }
        UIPalette.SetIsVisible(thisUI, Visible)
    };
    UIPaletteCategory.CheckCollision = function CheckCollFn(thisUI, X, Y) {
        var CompensateX = thisUI.RenderTree.GetPositionX();
        var TrueWidth = thisUI.TabItem.GetWidth();
        var TrueHeight = thisUI.TabItem.GetHeight();
        if (thisUI.RHS) {
            CompensateX -= TrueWidth
        }
        if (X >= thisUI.TabItem.GetPositionX() + CompensateX && X <= TrueWidth + thisUI.TabItem.GetPositionX() + CompensateX && Y >= thisUI.TabItem.GetPositionY() && Y <= TrueHeight + thisUI.TabItem.GetPositionY()) {
            if (!thisUI.IsOpen) {
                thisUI.Open(thisUI)
            } else {
                thisUI.Close(thisUI)
            }
            return true
        }
        if (!thisUI.IsOpen) {
            return false
        }
        var i = 0,
            j = 0;
        for (i = 0; i < thisUI.Categories.length; i += 1) {
            if (thisUI.Categories[i].UI.CheckCollision(X, Y)) {
                thisUI.Categories[i].Open = !thisUI.Categories[i].Open;
                if (thisUI.Categories[i].Open) {
                    thisUI.Categories[i].UI.Item.SetColour([1, 0, 0, 1])
                }
                if (!thisUI.Categories[i].Open) {
                    thisUI.Categories[i].UI.Item.SetColour([1, 1, 1, 1])
                }
                thisUI.CalculatePlacement();
                return true
            }
            if (thisUI.Categories[i].Open) {
                for (j = 0; j < thisUI.Categories[i].Items.length; j += 1) {
                    var BrushIndex = thisUI.Categories[i].Items[j].BrushIndex;
                    var BrushDelete = thisUI.Categories[i].Items[j].CheckDelete(X, Y);
                    if (BrushDelete) {
                        thisUI.BrushToDelete = BrushIndex;
                        thisUI.AllowConfirmation = true;
                        return true
                    }
                    var BrushHit = thisUI.Categories[i].Items[j].CheckCollision(X, Y);
                    if (BrushHit) {
                        thisUI.ResetBrush();
                        thisUI.BrushIndex = BrushIndex;
                        thisUI.BrushClicked = true;
                        thisUI.PaletteBrushes[BrushIndex].isFlashing = true;
                        return true
                    }
                }
            }
        }
        return UIBox.CheckCollision(thisUI, X, Y)
    };
    UIPaletteCategory.CheckCollisionPressed = function CheckCollPressFn(thisUI, X, Y) {
        return UIPalette.CheckCollisionPressed(thisUI, X, Y)
    };
    UIPaletteCategory.RelocateItem = function RelocateItemFn(thisUI) {
        UIPalette.RelocateItem(thisUI)
    };
    UIPaletteCategory.RemoveItem = function RemoveItemFn(thisUI) {
        UIPalette.RemoveItem(thisUI)
    };
    UIPaletteCategory.IsMouseOver = function IsMouseOverFn(thisUI, X, Y) {
        return UIPalette.IsMouseOver(thisUI, X, Y)
    };
    UIPaletteCategory.Create = function UICreateFn() {
        var NewObject = UIPalette.Create();
        NewObject.Categories = [];
        NewObject.IsPaletteCategory = true;
        NewObject.SavePalette = false;
        NewObject.AddPalette = function AddBoxFn(Label, Colour, Width, RenderTree, Index, RHS) {
            return UIPaletteCategory.AddPalette(this, Label, Colour, Width, RenderTree, Index, RHS)
        };
        NewObject.Open = function OpenPaletteFn() {
            UIPaletteCategory.Open(this)
        };
        NewObject.Close = function ClosePaletteFn() {
            UIPaletteCategory.Close(this)
        };
        NewObject.GetIndexFromName = function GetIndexFromNameFn(Name) {
            return UIPaletteCategory.GetIndexFromName(this, Name)
        };
        NewObject.GetCategoryNameFromObjectIndex = function GetCategoryNameFromObjectIndexFn(PaletteIndex) {
            return UIPaletteCategory.GetCategoryNameFromObjectIndex(this, PaletteIndex)
        };
        NewObject.GetCategoryPositionFromObjectIndex = function GetCategoryPositionFromObjectIndexFn(PaletteIndex) {
            return UIPaletteCategory.GetCategoryPositionFromObjectIndex(this, PaletteIndex)
        };
        NewObject.AlterObjectCategory = function AlterObjectCategoryFn(CategoryName, PalIndex) {
            UIPaletteCategory.AlterObjectCategory(this, CategoryName, PalIndex)
        };
        NewObject.GetCategoryIndexFromObjectIndex = function GetCategoryNameFromObjectIndexFn(PaletteIndex) {
            return UIPaletteCategory.GetCategoryIndexFromObjectIndex(this, PaletteIndex)
        };
        NewObject.MoveObjectInCategory = function MoveObjectInCategoryFn(Category, IndexTo, PaletteIndex) {
            UIPaletteCategory.MoveObjectInCategory(this, Category, IndexTo, PaletteIndex)
        };
        NewObject.AddBrushByIndex = function AddBrushIndexFn(BrushIndex) {
            UIPaletteCategory.AddBrushByIndex(this, BrushIndex)
        };
        NewObject.KillEmptySlots = function KillEmptySlotsFn() {
            UIPaletteCategory.KillEmptySlots(this)
        };
        NewObject.AddCategory = function AddCategoryFn(Name, Index) {
            UIPaletteCategory.AddCategory(this, Name, Index)
        };
        NewObject.RemoveCategory = function RemoveCategoryFn(Index) {
            UIPaletteCategory.RemoveCategory(this, Index)
        };
        NewObject.MoveCategory = function MoveCategoryFn(Index, To) {
            UIPaletteCategory.MoveCategory(this, Index, To)
        };
        NewObject.CalculatePlacement = function CalculatePlacementFn() {
            UIPaletteCategory.CalculatePlacement(this)
        };
        NewObject.CheckHidden = function HiddenFn(Item) {
            UIPaletteCategory.CheckHidden(this, Item)
        };
        NewObject.CheckCategoryCollision = function CheckCategoryCollisionFn(X, Y) {
            return UIPaletteCategory.CheckCategoryCollision(this, X, Y)
        };
        NewObject.DeleteBrush = function DeleteBrushFn(BrushSize) {
            UIPaletteCategory.DeleteBrush(this, BrushSize)
        };
        NewObject.ReattachObjects = function ReattachFn() {
            UIPaletteCategory.ReattachObjects(this)
        };
        NewObject.Update = function UpdateFn(TimeDelta, MouseX, MouseY) {
            UIPaletteCategory.Update(this, TimeDelta, MouseX, MouseY)
        };
        NewObject.SetIsVisible = function SetIsVisibleFn(Visible) {
            UIPaletteCategory.SetIsVisible(this, Visible)
        };
        NewObject.CheckCollision = function CheckCollFn(X, Y) {
            return UIPaletteCategory.CheckCollision(this, X, Y)
        };
        NewObject.CheckCollisionPressed = function CheckCollPressFn(X, Y) {
            return UIPaletteCategory.CheckCollisionPressed(this, X, Y)
        };
        NewObject.RelocateItem = function RelocateItemFn() {
            UIPaletteCategory.RelocateItem(this)
        };
        NewObject.RemoveItem = function RemoveItemFn() {
            UIPaletteCategory.RemoveItem(this)
        };
        NewObject.IsMouseOver = function IsMouseOverFn(X, Y) {
            return UIPaletteCategory.IsMouseOver(this, X, Y)
        };
        return NewObject
    };

    function UIDropDownBox() {}
    UIDropDownBox.prototype = {};
    UIDropDownBox.AddDropBox = function AddBoxFn(thisUI, X, Y, TextItems, RenderTree) {
        Debug.Assert(TextItems !== undefined && X !== undefined && Y !== undefined && RenderTree !== undefined, "PROBLEM! AddDropBox - missing param! Something undefined...");
        Debug.Assert(typeof X === "number" && typeof Y === "number" && typeof TextItems === "object", "PROBLEM! AddDropBox - vars do not match type!");
        thisUI.RenderTree = RenderTree;
        thisUI.PrimaryType = 0;
        thisUI.LastType = 0;
        var MaxText = TextItems.length;
        for (var i = 0; i < TextItems.length; i += 1) {
            var MultiTextBoxUI = UITextBox.Create();
            MultiTextBoxUI.AddTextBoxItem(X, Y + thisUI.TextBoxSpacing + i * thisUI.TextBoxSpacing, TextItems[i], false, false, RenderTree, thisUI.UltimateWidth + 20, i % 2);
            thisUI.TextObjects[thisUI.TextObjects.length] = MultiTextBoxUI;
            if (i % 2 === 0) {
                MultiTextBoxUI.BackingItem.SetColour([.3, .3, .3, 1])
            } else {
                MultiTextBoxUI.BackingItem.SetColour([.1, .1, .1, 1])
            }
        }
    };
    UIDropDownBox.SetDefaultValue = function SetDefaultFn(thisUI, Value) {
        thisUI.LastType = thisUI.PrimaryType = Value
    };
    UIDropDownBox.GetValue = function GetFormatTextFn(thisUI) {
        thisUI.LastType = thisUI.PrimaryType;
        return thisUI.PrimaryType
    };
    UIDropDownBox.AnyChanges = function AnyChangesFn(thisUI) {
        return thisUI.PrimaryType !== thisUI.LastType
    };
    UIDropDownBox.ReattachObjects = function ReattachFn(thisUI) {
        var j = 0;
        for (j = 0; j < thisUI.TextObjects.length; j += 1) {
            thisUI.TextObjects[j].ReattachObjects()
        }
    };
    UIDropDownBox.Update = function UpdateFn(thisUI, TimeDelta, MouseX, MouseY) {
        var j = 0;
        for (j = 0; j < thisUI.TextObjects.length; j += 1) {
            thisUI.TextObjects[j].Update(TimeDelta, MouseX, MouseY);
            if (thisUI.TextObjects[j].CheckCollision(MouseX, MouseY)) {
                thisUI.TextObjects[j].BackingItem.SetColour([.8, .8, .8, 1])
            } else {
                if (j % 2 === 0) {
                    thisUI.TextObjects[j].BackingItem.SetColour([.3, .3, .3, 1])
                } else {
                    thisUI.TextObjects[j].BackingItem.SetColour([.1, .1, .1, 1])
                }
            }
        }
        UIBase.Update(thisUI, TimeDelta, MouseX, MouseY)
    };
    UIDropDownBox.SetIsVisible = function SetIsVisibleFn(thisUI, Visible) {
        var i = 0;
        for (i = 0; i < thisUI.TextObjects.length; i += 1) {
            thisUI.TextObjects[i].SetIsVisible(Visible)
        }
    };
    UIDropDownBox.CheckCollision = function CheckCollFn(thisUI, X, Y) {
        if (!thisUI.isSuperFocused) {
            return
        }
        var i = 0;
        for (i = 0; i < thisUI.TextObjects.length; i += 1) {
            if (thisUI.TextObjects[i].CheckCollision(X, Y)) {
                thisUI.PrimaryType = i;
                thisUI.isSuperFocused = false;
                thisUI.SetIsVisible(false);
                return true
            }
        }
        thisUI.isSuperFocused = false;
        thisUI.SetIsVisible(false);
        return false
    };
    UIDropDownBox.RemoveItem = function RemoveItemFn(thisUI) {
        var j = 0;
        for (j = 0; j < thisUI.TextObjects.length; j += 1) {
            thisUI.TextObjects[j].RemoveItem()
        }
    };
    UIDropDownBox.MoveTo = function MoveToFn(thisUI, X, Y) {
        for (var j = 0; j < thisUI.TextObjects.length; j += 1) {
            if (j === 0) {
                thisUI.TextObjects[j].MoveTo(X, Y)
            } else {
                thisUI.TextObjects[j].MoveTo(X, Y + (thisUI.TextBoxSpacing - 2) * j)
            }
        }
        var LastTextPosition = thisUI.TextObjects[thisUI.TextObjects.length - 1].BackingItem.GetPositionY();
        var TextHeight = thisUI.TextObjects[thisUI.TextObjects.length - 1].GetTrueHeight() + 10;
        if (LastTextPosition + TextHeight > JamSystem.RenderManager.GetScreenHeight()) {
            var Delta = JamSystem.RenderManager.GetScreenHeight() - (thisUI.TextObjects[thisUI.TextObjects.length - 1].BackingItem.GetPositionY() + TextHeight);
            thisUI.MoveTo(X, Y + Delta)
        }
    };
    UIDropDownBox.IsVisible = function VisibleFn(thisUI) {
        return thisUI.TextObjects[0].IsVisible()
    };
    UIDropDownBox.IsMouseOver = function IsMouseOverFn(thisUI, X, Y) {
        var j = 0;
        for (j = 0; j < thisUI.TextObjects.length; j += 1) {
            if (thisUI.TextObjects[j].CheckCollision) {
                return true
            }
        }
        return false
    };
    UIDropDownBox.Create = function UICreateFn() {
        var NewObject = UIBase.Create();
        NewObject.TextObjects = [];
        NewObject.PrimaryType = 0;
        NewObject.LastType = 0;
        NewObject.AddDropBox = function AddBoxFn(X, Y, TextItems, RenderTree) {
            return UIDropDownBox.AddDropBox(this, X, Y, TextItems, RenderTree)
        };
        NewObject.GetValue = function GetFormatTextFn() {
            return UIDropDownBox.GetValue(this)
        };
        NewObject.AnyChanges = function AnyChangesFn() {
            return UIDropDownBox.AnyChanges(this)
        };
        NewObject.SetDefaultValue = function SetDefaultFn(Value) {
            UIDropDownBox.SetDefaultValue(this, Value)
        };
        NewObject.ReattachObjects = function ReattachFn() {
            UIDropDownBox.ReattachObjects(this)
        };
        NewObject.Update = function UpdateFn(TimeDelta, MouseX, MouseY) {
            UIDropDownBox.Update(this, TimeDelta, MouseX, MouseY)
        };
        NewObject.SetIsVisible = function SetIsVisibleFn(Visible) {
            UIDropDownBox.SetIsVisible(this, Visible)
        };
        NewObject.CheckCollision = function CheckCollFn(X, Y) {
            return UIDropDownBox.CheckCollision(this, X, Y)
        };
        NewObject.IsVisible = function VisibleFn() {
            return UIDropDownBox.IsVisible(this)
        };
        NewObject.RemoveItem = function RemoveItemFn() {
            UIDropDownBox.RemoveItem(this)
        };
        NewObject.MoveTo = function MoveToFn(X, Y) {
            UIDropDownBox.MoveTo(this, X, Y)
        };
        NewObject.IsMouseOver = function IsMouseOverFn(X, Y) {
            return UIDropDownBox.IsMouseOver(this, X, Y)
        };
        return NewObject
    };

    function UIFileBox() {}
    UIFileBox.LoadingType = 0;
    UIFileBox.SavingType = 1;
    UIFileBox.NewType = 2;
    UIFileBox.prototype = {};
    UIFileBox.AddBox = function AddBoxFn(thisUI, Type, RenderTree) {
        Debug.Assert(RenderTree !== undefined, "PROBLEM! Add UIFileBox Box - missing param! Something undefined...");
        thisUI.RenderTree = RenderTree;
        var CentreWidth = JamSystem.RenderManager.GetScreenWidth() / 2;
        var CentreHeight = JamSystem.RenderManager.GetScreenHeight() / 2;
        UIBox.AddDialogBox(thisUI, CentreWidth - CentreWidth / 4, CentreHeight - CentreHeight / 6, CentreWidth / 2, CentreHeight / 3, RenderTree);
        thisUI.BoxType = Type;
        thisUI.MainButtonUI = UIButton.Create();
        thisUI.MainButtonUI.AddButton(CentreWidth - 110, CentreHeight + CentreHeight / 6, "LOAD", false, RenderTree);
        thisUI.CancelUI = UIButton.Create();
        thisUI.CancelUI.AddButton(CentreWidth + 40, CentreHeight + CentreHeight / 6, "CANCEL", false, RenderTree);
        thisUI.FileLocationUI = UIEditBox.Create();
        thisUI.FileLocationUI.AddEditBoxItem(CentreWidth - 350, CentreHeight, UIEditBox.prototype.editBoxType.Normal, null, undefined, RenderTree);
        thisUI.FileLocationUI.SetDefaultValue("assets\\Levels\\TestGameLevel.json")
    };
    UIFileBox.Resize = function ResizeFn(thisUI) {
        var ItemWidth = thisUI.FileLocationUI.BackingItem.GetWidth() * thisUI.FileLocationUI.BackingItem.GetScaleX();
        var BoxWidth = thisUI.GetTrueWidth();
        var ScaleWidth = 1;
        ScaleWidth = (ItemWidth + 20) / thisUI.Item.GetWidth();
        thisUI.Item.SetScaleX(ScaleWidth);
        thisUI.BackingItem.SetScaleX(ScaleWidth);
        var PosX = JamSystem.RenderManager.GetScreenWidth() / 2 - thisUI.GetTrueWidth() / 2;
        thisUI.Item.SetPositionX(PosX);
        thisUI.BackingItem.SetPositionX(PosX);
        thisUI.FileLocationUI.Item.SetPositionX(PosX + 20);
        thisUI.FileLocationUI.BackingItem.SetPositionX(PosX + 10);
        thisUI.FileLocationUI.WhiteSelectBox.SetPositionX(PosX + 20)
    };
    UIFileBox.Reset = function ResetFn(thisUI) {
        thisUI.ButtonPressed = false;
        thisUI.CancelPressed = false
    };
    UIFileBox.MoveBox = function MoveBoxFn(thisUI, MouseX, MouseY) {
        var DiffX = MouseX - thisUI.LastDragPosition.x;
        var DiffY = MouseY - thisUI.LastDragPosition.y;
        if (thisUI.MainButtonUI) {
            thisUI.MainButtonUI.UpdatePosition(DiffX, DiffY)
        }
        if (thisUI.CancelUI) {
            thisUI.CancelUI.UpdatePosition(DiffX, DiffY)
        }
        thisUI.FileLocationUI.UpdatePosition(DiffX, DiffY);
        UIBox.MoveBox(thisUI, MouseX, MouseY)
    };
    UIFileBox.ChangeType = function ChangeTypeFn(thisUI, Type, File) {
        thisUI.BoxType = Type;
        if (Type === UIFileBox.LoadingType) {
            thisUI.MainButtonUI.SetButtonText("LOAD");
            thisUI.SetTitleBar("LOAD FILE")
        }
        if (Type === UIFileBox.SavingType) {
            thisUI.MainButtonUI.SetButtonText("SAVE");
            thisUI.SetTitleBar("SAVE FILE AS")
        }
        if (Type === UIFileBox.NewType) {
            thisUI.MainButtonUI.SetButtonText("NEW");
            thisUI.SetTitleBar("NEW LEVEL")
        }
        thisUI.FileLocationUI.SetDefaultValue(File)
    };
    UIFileBox.GetFile = function GetFileFn(thisUI) {
        return thisUI.FileLocationUI.GetValue()
    };
    UIFileBox.ReattachObjects = function ReattachFn(thisUI) {
        UIBox.ReattachObjects(thisUI);
        if (thisUI.MainButtonUI) {
            thisUI.MainButtonUI.ReattachObjects()
        }
        thisUI.CancelUI.ReattachObjects();
        thisUI.FileLocationUI.ReattachObjects()
    };
    UIFileBox.Update = function UpdateFn(thisUI, TimeDelta, MouseX, MouseY) {
        if (!JamSystem.InputManager.GetMouseButtonHeld(0)) {
            thisUI.isFocused = false
        }
        thisUI.FileLocationUI.Update(TimeDelta, MouseX, MouseY);
        if (thisUI.MainButtonUI) {
            thisUI.MainButtonUI.Update(TimeDelta, MouseX, MouseY)
        }
        thisUI.CancelUI.Update(TimeDelta, MouseX, MouseY);
        if (thisUI.BackingItem && thisUI.isFocused && !thisUI.ScrollUI.isFocused) {
            thisUI.MoveBox(MouseX, MouseY);
            thisUI.LastDragPosition.x = MouseX;
            thisUI.LastDragPosition.y = MouseY
        }
        if (thisUI.TitleBarItem) {
            if (thisUI.TitleBarItem.pszText !== thisUI.TitleText) {
                thisUI.TitleBarItem.SetText(thisUI.TitleText);
                thisUI.Resize()
            }
        }
        UIBase.Update(thisUI, TimeDelta, MouseX, MouseY)
    };
    UIFileBox.SetIsVisible = function SetIsVisibleFn(thisUI, Visible) {
        UIBox.SetIsVisible(thisUI, Visible);
        if (thisUI.MainButtonUI) {
            thisUI.MainButtonUI.SetIsVisible(Visible)
        }
        thisUI.CancelUI.SetIsVisible(Visible);
        thisUI.FileLocationUI.SetIsVisible(Visible)
    };
    UIFileBox.CheckCollision = function CheckCollFn(thisUI, X, Y) {
        if (thisUI.MainButtonUI) {
            if (thisUI.MainButtonUI.CheckCollision(X, Y)) {
                thisUI.ButtonPressed = true;
                return true
            }
        }
        if (thisUI.CancelUI.CheckCollision(X, Y)) {
            thisUI.CancelPressed = true;
            return true
        }
        if (thisUI.FileLocationUI.CheckCollision(X, Y)) {
            return true
        }
        UIBox.CheckCollision(thisUI, X, Y);
        return false
    };
    UIFileBox.UpdatePosition = function UpdatePosFn(thisUI, DeltaX, DeltaY) {
        UIBox.UpdatePosition(thisUI, DeltaX, DeltaY);
        if (thisUI.MainButtonUI) {
            thisUI.MainButtonUI.UpdatePosition(DeltaX, DeltaY)
        }
        thisUI.CancelUI.UpdatePosition(DeltaX, DeltaY);
        thisUI.FileLocationUI.UpdatePosition(DeltaX, DeltaY)
    };
    UIFileBox.RelocateItem = function RelocateItemFn(thisUI) {
        UIBox.RelocateItem(thisUI);
        thisUI.Resize(thisUI)
    };
    UIFileBox.Create = function UICreateFn() {
        var NewObject = UIBox.Create();
        NewObject.BoxType = UIFileBox.LoadingType;
        NewObject.AllowResize = false;
        NewObject.ButtonPressed = false;
        NewObject.CancelPressed = false;
        NewObject.MainButtonUI = 0;
        NewObject.CancelUI = 0;
        NewObject.FileLocationUI = 0;
        NewObject.AddBox = function AddBoxFn(Load, RenderTree) {
            UIFileBox.AddBox(this, Load, RenderTree)
        };
        NewObject.Resize = function ResizeFn() {
            UIFileBox.Resize(this)
        };
        NewObject.Reset = function ResetFn() {
            UIFileBox.Reset(this)
        };
        NewObject.MoveBox = function MoveBoxFn(MouseX, MouseY) {
            UIFileBox.MoveBox(this, MouseX, MouseY)
        };
        NewObject.ChangeType = function ChangeTypeFn(Type, File) {
            UIFileBox.ChangeType(this, Type, File)
        };
        NewObject.GetFile = function GetFileFn() {
            return UIFileBox.GetFile(this)
        };
        NewObject.ReattachObjects = function ReattachFn() {
            UIFileBox.ReattachObjects(this)
        };
        NewObject.Update = function UpdateFn(TimeDelta, MouseX, MouseY) {
            UIFileBox.Update(this, TimeDelta, MouseX, MouseY)
        };
        NewObject.SetIsVisible = function SetIsVisibleFn(Visible) {
            UIFileBox.SetIsVisible(this, Visible)
        };
        NewObject.CheckCollision = function CheckCollFn(X, Y) {
            return UIFileBox.CheckCollision(this, X, Y)
        };
        NewObject.UpdatePosition = function UpdatePosFn(DeltaX, DeltaY) {
            UIFileBox.UpdatePosition(this, DeltaX, DeltaY)
        };
        NewObject.RelocateItem = function RelocateItemFn() {
            UIFileBox.RelocateItem(this)
        };
        return NewObject
    };

    function UIBase() {}
    UIBase.prototype = {
        BoxSpacing: 40,
        ScrollBarWidth: 20,
        UltimateWidth: 240,
        MaxItems: 8,
        TextBoxSpacing: 32,
        ShiftX: 220,
        CheckBoxSize: 15,
        FlashAmount: .02
    };
    UIBase.ReattachObjects = function ReattachFn(thisUI) {
        if (thisUI.BackingItem) {
            thisUI.RenderTree.RemoveChild(thisUI.BackingItem);
            thisUI.RenderTree.AddChild(thisUI.BackingItem)
        }
        if (thisUI.Item) {
            thisUI.RenderTree.RemoveChild(thisUI.Item);
            thisUI.RenderTree.AddChild(thisUI.Item)
        }
    };
    UIBase.Update = function UpdateFn(thisUI, TimeDelta, MouseX, MouseY) {
        if (thisUI.InfoItem) {
            if (thisUI.InfoShow && !thisUI.InfoItem.IsVisible()) {
                thisUI.InfoWaitTimer += TimeDelta;
                if (thisUI.InfoWaitTimer > .6) {
                    thisUI.InfoItem.ReattachObjects();
                    thisUI.InfoItem.SetIsVisible(true)
                }
            }
        }
    };
    UIBase.SetIsVisible = function SetIsVisibleFn(thisUI, Visible) {
        if (thisUI.Item) {
            thisUI.Item.SetIsVisible(Visible)
        }
        if (thisUI.BackingItem) {
            thisUI.BackingItem.SetIsVisible(Visible)
        }
    };
    UIBase.GetTop = function TopFn(thisUI) {
        return thisUI.Item.GetPositionY()
    };
    UIBase.GetTrueWidth = function TrueWidthFn(thisUI) {
        return thisUI.Item.GetWidth() * thisUI.Item.GetScaleX()
    };
    UIBase.GetTrueHeight = function TrueHeightFn(thisUI) {
        return thisUI.Item.GetHeight() * thisUI.Item.GetScaleY()
    };
    UIBase.CheckCollision = function CheckCollFn(thisUI, X, Y) {
        var TrueWidth = thisUI.GetTrueWidth();
        var TrueHeight = thisUI.GetTrueHeight();
        if (X >= thisUI.Item.GetPositionX() && X <= TrueWidth + thisUI.Item.GetPositionX() && Y >= thisUI.Item.GetPositionY() && Y <= TrueHeight + thisUI.Item.GetPositionY()) {
            return true
        }
    };
    UIBase.CheckCollisionPressed = function CheckCollPressFn(thisUI, X, Y) {
        return false
    };
    UIBase.UpdatePosition = function UpdatePosFn(thisUI, DeltaX, DeltaY) {
        if (thisUI.Item) {
            thisUI.Item.SetPosition(thisUI.Item.GetPositionX() + DeltaX, thisUI.Item.GetPositionY() + DeltaY)
        }
        if (thisUI.BackingItem) {
            thisUI.BackingItem.SetPosition(thisUI.BackingItem.GetPositionX() + DeltaX, thisUI.BackingItem.GetPositionY() + DeltaY)
        }
        thisUI.StartPosition.y += DeltaY
    };
    UIBase.IsVisible = function VisibleFn(thisUI) {
        return thisUI.Item.GetIsVisible()
    };
    UIBase.Scroll = function ScrollFn(thisUI, Delta) {
        var NewPosition;
        if (thisUI.Item) {
            NewPosition = thisUI.Item.GetPositionY() - Delta;
            thisUI.Item.SetPositionY(NewPosition)
        }
        if (thisUI.BackingItem) {
            NewPosition = thisUI.BackingItem.GetPositionY() - Delta;
            thisUI.BackingItem.SetPositionY(NewPosition)
        }
        if (NewPosition) {
            thisUI.StartPosition.y = NewPosition
        }
    };
    UIBase.RelocateItem = function RelocateItemFn(thisUI) {};
    UIBase.MoveTo = function MoveToFn(thisUI, X, Y) {
        if (thisUI.Item) {
            if (X === undefined) {
                X = thisUI.Item.GetPositionX()
            }
            if (Y === undefined) {
                Y = thisUI.Item.GetPositionY()
            }
            thisUI.Item.SetPosition(X, Y)
        }
        if (thisUI.BackingItem) {
            if (X === undefined) {
                X = thisUI.BackingItem.GetPositionX()
            }
            if (Y === undefined) {
                Y = thisUI.BackingItem.GetPositionY()
            }
            thisUI.BackingItem.SetPosition(X, Y)
        }
    };
    UIBase.ShiftBy = function ShiftByFn(thisUI, X, Y) {
        if (thisUI.Item) {
            var A = thisUI.Item.GetPositionX();
            var B = thisUI.Item.GetPositionY();
            thisUI.Item.SetPosition(A + X, B + Y)
        }
        if (thisUI.BackingItem) {
            var C = thisUI.BackingItem.GetPositionX();
            var D = thisUI.BackingItem.GetPositionY();
            thisUI.BackingItem.SetPosition(C + X, D + Y)
        }
    };
    UIBase.RemoveItem = function RemoveItemFn(thisUI) {
        Debug.Log("USING BASE FOR 'REMOVE ITEM' - MISSING FUNCTIONALITY FOR INHERITED CLASS")
    };
    UIBase.IsMouseOver = function IsMouseOverFn(thisUI, X, Y) {
        var Width, Height;
        if (thisUI.BackingItem) {
            Width = thisUI.BackingItem.GetScaleX() * thisUI.BackingItem.GetWidth();
            Height = thisUI.BackingItem.GetScaleY() * thisUI.BackingItem.GetHeight();
            return X > thisUI.BackingItem.GetPositionX() && X < thisUI.BackingItem.GetPositionX() + Width && Y > thisUI.BackingItem.GetPositionY() && Y < thisUI.BackingItem.GetPositionY() + Height
        }
        if (thisUI.Item) {
            Width = thisUI.Item.GetScaleX() * thisUI.Item.GetWidth();
            Height = thisUI.Item.GetScaleY() * thisUI.Item.GetHeight();
            return X > thisUI.Item.GetPositionX() && X < thisUI.Item.GetPositionX() + Width && Y > thisUI.Item.GetPositionY() && Y < thisUI.Item.GetPositionY() + Height
        }
        return false
    };
    UIBase.ShowInfoBox = function ShowInfoBoxFn(thisUI, Visible, Position) {
        if (!thisUI.InfoItem && Visible) {
            thisUI.SetInfoBoxText("")
        }
        if (thisUI.InfoItem) {
            if (Visible && !thisUI.InfoItem.IsVisible()) {
                thisUI.InfoShow = true;
                thisUI.InfoItem.MoveTo(Position.x + thisUI.GetTrueWidth() + 20, Position.y)
            }
            if (!Visible) {
                thisUI.InfoWaitTimer = 0;
                thisUI.InfoShow = false;
                thisUI.InfoItem.SetIsVisible(false)
            }
        }
    };
    UIBase.SetInfoBoxText = function SetInfoBoxTextFn(thisUI, Text) {
        if (!thisUI.InfoItem) {
            thisUI.InfoItem = UITextBox.Create();
            thisUI.InfoItem.AddTextBoxItem(0, 0, "No Info", false, false, thisUI.RenderTree);
            thisUI.InfoItem.BackingItem.SetColour([1, 0, 1, 1]);
            thisUI.InfoItem.SetIsVisible(false)
        }
        if (Text !== "") {
            thisUI.InfoItem.Item.SetText(Text)
        }
    };
    UIBase.GetLabel = function GetLabelFn(thisUI) {
        if (thisUI.TextBoxUI) {
            return thisUI.TextBoxUI.Item.GetText()
        }
        return 0
    };
    UIBase.Create = function UICreateFn() {
        var NewObject = new UIBase;
        NewObject.Item = 0;
        NewObject.BackingItem = 0;
        NewObject.InfoItem = 0;
        NewObject.InfoWaitTimer = 0;
        NewObject.InfoShow = false;
        NewObject.isFocused = false;
        NewObject.isSuperFocused = false;
        NewObject.RenderTree = 0;
        NewObject.StartPosition = new Vector2;
        NewObject.ColourArray = [1, 1, 1, 1];
        NewObject.Modifier = NewObject.FlashAmount;
        NewObject.ReattachObjects = function ReattachFn() {
            UIBase.ReattachObjects(this)
        };
        NewObject.Update = function UpdateFn(TimeDelta, MouseX, MouseY) {
            UIBase.Update(this, TimeDelta, MouseX, MouseY)
        };
        NewObject.SetIsVisible = function SetIsVisibleFn(Visible) {
            UIBase.SetIsVisible(this, Visible)
        };
        NewObject.GetTop = function TopFn() {
            return UIBase.GetTop(this)
        };
        NewObject.GetTrueWidth = function TrueWidthFn() {
            return UIBase.GetTrueWidth(this)
        };
        NewObject.GetTrueHeight = function TrueHeightFn() {
            return UIBase.GetTrueHeight(this)
        };
        NewObject.CheckCollision = function CheckCollFn(X, Y) {
            return UIBase.CheckCollision(this, X, Y)
        };
        NewObject.CheckCollisionPressed = function CheckCollPressFn(X, Y) {
            return UIBase.CheckCollisionPressed(this, X, Y)
        };
        NewObject.UpdatePosition = function UpdatePosFn(DeltaX, DeltaY) {
            UIBase.UpdatePosition(this, DeltaX, DeltaY)
        };
        NewObject.IsVisible = function VisibleFn() {
            return UIBase.IsVisible(this)
        };
        NewObject.Scroll = function ScrollFn(Delta) {
            UIBase.Scroll(this, Delta)
        };
        NewObject.RelocateItem = function RelocateItemFn() {
            UIBase.RelocateItem(this)
        };
        NewObject.MoveTo = function MoveToFn(X, Y) {
            UIBase.MoveTo(this, X, Y)
        };
        NewObject.ShiftBy = function ShiftByFn(X, Y) {
            UIBase.ShiftBy(this, X, Y)
        };
        NewObject.RemoveItem = function RemoveItemFn() {
            UIBase.RemoveItem(this)
        };
        NewObject.IsMouseOver = function IsMouseOverFn(X, Y) {
            return UIBase.IsMouseOver(this, X, Y)
        };
        NewObject.ShowInfoBox = function ShowInfoBoxFn(Visible, Position) {
            UIBase.ShowInfoBox(this, Visible, Position)
        };
        NewObject.SetInfoBoxText = function SetInfoBoxTextFn(Text) {
            UIBase.SetInfoBoxText(this, Text)
        };
        NewObject.GetLabel = function GetLabelFn() {
            return UIBase.GetLabel(this)
        };
        return NewObject
    };

    function ExplosionInfo() {}
    ExplosionInfo.prototype = {};

    function Button() {}
    Button.NormalColour = [1, 1, 1, 1];
    Button.HighlightColour = [1, 1, 0, 1];
    Button.SelectedColour = [1, .5, 0, 1];
    Button.DisabledColour = [.5, .5, .5, .5];
    Button.prototype = {
        SetParent: function SetParentFn(Parent) {
            this.BackingLeft.RemoveFromParent();
            this.BackingMiddle.RemoveFromParent();
            this.BackingRight.RemoveFromParent();
            if (Parent) {
                Parent.AddChild(this.BackingLeft);
                Parent.AddChild(this.BackingMiddle);
                Parent.AddChild(this.BackingRight)
            }
            if (this.Graphic) {
                this.Graphic.RemoveFromParent();
                if (Parent) {
                    Parent.AddChild(this.Graphic)
                }
            }
            if (this.Graphic2) {
                this.Graphic2.RemoveFromParent();
                if (Parent) {
                    Parent.AddChild(this.Graphic2)
                }
            }
            if (this.ButtonText) {
                this.ButtonText.RemoveFromParent();
                if (Parent) {
                    Parent.AddChild(this.ButtonText)
                }
            }
        },
        SetPosition: function SetPositionFn(X, Y) {
            var NewX = X,
                NewY = Y;
            if (X === undefined && this.ButtonText) {
                NewX = this.ButtonText.GetPositionX()
            }
            if (Y === undefined && this.ButtonText) {
                NewY = this.ButtonText.GetPositionY()
            }
            if (this.ButtonText) {
                this.ButtonText.SetPosition(NewX, NewY)
            }
            if (X === undefined && this.Graphic) {
                NewX = this.Graphic.GetPositionX()
            }
            if (X === undefined && this.Graphic) {
                NewY = this.Graphic.GetPositionY()
            }
            if (this.Graphic) {
                this.Graphic.SetPosition(NewX, NewY)
            }
            this.RegeneratePositionScale(true)
        },
        GetTextPosition: function GetTextPositionFn(X, Y) {
            return this.ButtonText.GetPosition()
        },
        SetScale: function SetScaleFn(X, Y) {
            if (!X) {
                X = 1
            }
            if (!Y) {
                Y = 1
            }
            this.BackingLeft.SetScale(this.BackingLeft.GetScaleX() * X, this.BackingLeft.GetScaleY() * Y);
            this.BackingMiddle.SetScale(this.BackingMiddle.GetScaleX() * X, this.BackingMiddle.GetScaleY() * Y);
            this.BackingRight.SetScale(this.BackingRight.GetScaleX() * X, this.BackingRight.GetScaleY() * Y);
            if (this.Graphic) {
                this.Graphic.SetScale(X, Y)
            }
            if (this.Graphic2) {
                this.Graphic2.SetScale(X, Y)
            }
            if (this.ButtonText) {
                this.ButtonText.SetScale(this.ButtonText.GetScaleX() * X, this.ButtonText.GetScaleY() * Y)
            }
            if (this.ButtonSubText) {
                this.ButtonSubText.SetScale(this.ButtonSubText.GetScaleX() * X, this.ButtonSubText.GetScaleY() * Y)
            }
            this.RegeneratePositionScale()
        },
        AlterGraphic: function AlterGraphicFn(PrimaryGraphic, NewTexture) {
            var TextureInfo = Helpers.GetTextureInfoFromImageName(NewTexture);
            if (PrimaryGraphic && this.Graphic) {
                this.Graphic.SetTexture(TextureInfo.Texture, TextureInfo.Frame)
            }
            if (!PrimaryGraphic && this.Graphic2) {
                this.Graphic2.SetTexture(TextureInfo.Texture, TextureInfo.Frame)
            }
        },
        Update: function UpdateFn(dt) {
            if (this.Disabled) {
                return
            }
            if (this.CheckCollision()) {
                if (!this.MouseOver) {
                    this.BackingLeft.SetColour(Button.HighlightColour);
                    this.BackingMiddle.SetColour(Button.HighlightColour);
                    this.BackingRight.SetColour(Button.HighlightColour);
                    this.MouseOver = true;
                    Helpers.PlaySound("OptionIndicated")
                }
            } else if (this.MouseOver && !this.ForcedHighlight) {
                this.BackingLeft.SetColour(Button.NormalColour);
                this.BackingMiddle.SetColour(Button.NormalColour);
                this.BackingRight.SetColour(Button.NormalColour);
                this.MouseOver = false
            } else if (this.MouseOver && this.ForcedHighlight) {
                this.BackingLeft.SetColour(Button.SelectedColour);
                this.BackingMiddle.SetColour(Button.SelectedColour);
                this.BackingRight.SetColour(Button.SelectedColour);
                this.MouseOver = false
            }
        },
        IsPressed: function IsPressedFn() {
            if (!this.IsVisible()) {
                return false
            }
            if (this.Disabled) {
                return false
            }
            if (this.CheckCollision()) {
                return JamSystem.InputManager.GetMouseButtonPressed(0)
            }
            return false
        },
        ForceHighlight: function ForceHighlightFn(Show) {
            this.ForcedHighlight = Show;
            this.BackingLeft.SetColour(Show ? Button.HighlightColour : Button.NormalColour);
            this.BackingMiddle.SetColour(Show ? Button.HighlightColour : Button.NormalColour);
            this.BackingRight.SetColour(Show ? Button.HighlightColour : Button.NormalColour)
        },
        ForceSelected: function ForceSelectedFn(Show) {
            this.ForcedHighlight = Show;
            this.BackingLeft.SetColour(Show ? Button.SelectedColour : Button.NormalColour);
            this.BackingMiddle.SetColour(Show ? Button.SelectedColour : Button.NormalColour);
            this.BackingRight.SetColour(Show ? Button.SelectedColour : Button.NormalColour)
        },
        Flash: function FlashFn() {
            this.FlashTimer += 1;
            if (this.FlashTimer % 20 < 12) {
                this.SetIsVisible(true)
            } else {
                this.SetIsVisible(false)
            }
        },
        CreateExplosion: function CreateExplosionFn(RenderTree) {
            var i = 0;
            this.Explosion = [];
            for (i = 0; i < 30; i += 1) {
                this.Explosion[i] = new ExplosionInfo;
                this.Explosion[i].Image = Helpers.CreateSprite(this.BackingMiddle.GetPositionX() + this.BackingMiddle.GetWidth() * this.BackingMiddle.GetScaleX() / 2, this.ButtonText.GetPositionY(), EA.Default, "FireworkRed", RenderTree);
                this.Explosion[i].Image.SetColour([1, 1, 1, 1]);
                if (Math.random() > .5) {
                    this.Explosion[i].VelocityX = Math.random() * 15
                } else {
                    this.Explosion[i].VelocityX = -Math.random() * 15
                }
                if (Math.random() > .5) {
                    this.Explosion[i].VelocityY = Math.random() * 15
                } else {
                    this.Explosion[i].VelocityY = -Math.random() * 15
                }
                this.Explosion[i].Alpha = 1;
                this.Explosion[i].Scale = Math.random() * 7;
                this.Explosion[i].Image.SetScale(this.Explosion[i].Scale, this.Explosion[i].Scale)
            }
            Helpers.PlaySound("HangarOptionActive")
        },
        UpdateExplosion: function UpdateExplosion(TimeDelta) {
            for (i = 0; i < 30; i += 1) {
                this.Explosion[i].Image.SetPositionX(this.Explosion[i].Image.GetPositionX() + this.Explosion[i].VelocityX);
                this.Explosion[i].Image.SetPositionY(this.Explosion[i].Image.GetPositionY() - this.Explosion[i].VelocityY);
                this.Explosion[i].Image.SetColour([.2, .2, .2, this.Explosion[i].Alpha]);
                this.Explosion[i].Image.SetScale(this.Explosion[i].Scale, this.Explosion[i].Scale);
                this.Explosion[i].VelocityY -= .5;
                this.Explosion[i].Scale -= .02;
                this.Explosion[i].Alpha -= .011;
                if (this.Explosion[i].Alpha < 0) {
                    this.Explosion[i].Alpha = 0
                }
            }
        },
        IsExplosionComplete: function IsExplosionCompleteFn() {
            return this.Explosion[0].Alpha === 0
        },
        Disable: function DisableFn(Disable) {
            this.Disabled = Disable;
            this.BackingLeft.SetColour(Disable ? Button.DisabledColour : Button.NormalColour);
            this.BackingMiddle.SetColour(Disable ? Button.DisabledColour : Button.NormalColour);
            this.BackingRight.SetColour(Disable ? Button.DisabledColour : Button.NormalColour);
            if (this.Graphic) {
                this.Graphic.SetColour(Disable ? Button.DisabledColour : Button.NormalColour)
            }
            if (this.Graphic2) {
                this.Graphic2.SetColour(Disable ? Button.DisabledColour : Button.NormalColour)
            }
            if (this.ButtonText) {
                this.ButtonText.SetColour(Disable ? Button.DisabledColour : [1, .5, 0, 1])
            }
        },
        SetIsVisible: function SetIsVisibleFn(Visible) {
            if (this.ButtonText) {
                this.ButtonText.SetIsVisible(Visible)
            }
            this.BackingLeft.SetIsVisible(Visible);
            this.BackingMiddle.SetIsVisible(Visible);
            this.BackingRight.SetIsVisible(Visible);
            if (this.Graphic) {
                this.Graphic.SetIsVisible(Visible)
            }
            if (this.Graphic2) {
                this.Graphic2.SetIsVisible(Visible)
            }
        },
        IsVisible: function IsVisibleFn() {
            return this.BackingMiddle.GetIsVisible()
        },
        Destroy: function DestroyFn() {
            if (this.ButtonText) {
                Helpers.DestroyBitmapText(this.ButtonText)
            }
            Helpers.DestroySprite(this.BackingLeft);
            Helpers.DestroySprite(this.BackingMiddle);
            Helpers.DestroySprite(this.BackingRight);
            if (this.Graphic) {
                Helpers.DestroySprite(this.Graphic)
            }
            if (this.Graphic2) {
                Helpers.DestroySprite(this.Graphic2)
            }
            for (i = 0; i < 30; i += 1) {
                if (this.Explosion) {
                    Helpers.DestroySprite(this.Explosion[i].Image)
                }
            }
            if (this.ButtonSubText) {
                Helpers.DestroyBitmapText(this.ButtonSubText)
            }
        },
        CheckCollision: function CheckCollisionFn() {
            if (!this.IsVisible()) {
                return false
            }
            if (this.Disabled) {
                return false
            }
            var MouseX = JamSystem.InputManager.GetMouseX();
            var MouseY = JamSystem.InputManager.GetMouseY();
            var Left = this.BackingLeft.GetPositionX();
            var Right = this.BackingRight.GetPositionX() + this.BackingRight.GetScaleX() * this.BackingRight.GetWidth();
            var Middle = this.BackingMiddle.GetPositionY();
            Middle += this.RenderTree.GetPositionY();
            var Top = Middle - this.BackingRight.GetHeight() * this.BackingMiddle.GetScaleY() / 2;
            var Bottom = Middle + this.BackingRight.GetHeight() * this.BackingMiddle.GetScaleY() / 2;
            Left += this.RenderTree.GetPositionX();
            Right += this.RenderTree.GetPositionX();
            return MouseX > Left && MouseX < Right && MouseY < Bottom && MouseY > Top
        },
        RegeneratePositionScale: function RegeneratePositionScaleFn(IgnoreScale) {
            if (this.ButtonText && !this.Graphic && !this.Graphic2) {
                if (!IgnoreScale) {
                    this.BackingMiddle.SetScaleX(this.ButtonText.GetWidth() * this.ButtonText.GetScaleX() + 16)
                }
                this.BackingMiddle.SetPositionX(this.ButtonText.GetPositionX());
                this.BackingLeft.SetPositionX(this.BackingMiddle.GetPositionX() - this.BackingMiddle.GetWidth() * this.BackingMiddle.GetScaleX() / 2);
                this.BackingRight.SetPositionX(this.BackingMiddle.GetPositionX() + this.BackingMiddle.GetWidth() * this.BackingMiddle.GetScaleX() / 2);
                this.BackingMiddle.SetPositionY(this.ButtonText.GetPositionY());
                this.BackingLeft.SetPositionY(this.BackingMiddle.GetPositionY());
                this.BackingRight.SetPositionY(this.BackingMiddle.GetPositionY());
                if (this.ButtonSubText) {
                    this.ButtonSubText.SetPosition(this.ButtonText.GetPositionX() + 30, this.ButtonText.GetPositionY() + 20)
                }
            } else if (!this.ButtonText && this.Graphic && !this.Graphic2) {
                if (!IgnoreScale) {
                    this.BackingMiddle.SetScaleX(this.Graphic.GetWidth() * this.Graphic.GetScaleX() + 16)
                }
                this.BackingMiddle.SetPositionX(this.Graphic.GetPositionX());
                this.BackingLeft.SetPositionX(this.BackingMiddle.GetPositionX() - this.BackingMiddle.GetWidth() * this.BackingMiddle.GetScaleX() / 2);
                this.BackingRight.SetPositionX(this.BackingMiddle.GetPositionX() + this.BackingMiddle.GetWidth() * this.BackingMiddle.GetScaleX() / 2);
                this.BackingMiddle.SetPositionY(this.Graphic.GetPositionY());
                this.BackingLeft.SetPositionY(this.BackingMiddle.GetPositionY());
                this.BackingRight.SetPositionY(this.BackingMiddle.GetPositionY())
            } else if (this.ButtonText && this.Graphic && !this.Graphic2) {
                this.ButtonText.SetPositionX(this.Graphic.GetPositionX() + this.Graphic.GetWidth() * this.Graphic.GetScaleX() + 10);
                if (!IgnoreScale) {
                    this.BackingMiddle.SetScaleX(this.ButtonText.GetWidth() * this.ButtonText.GetScaleX() + this.Graphic.GetWidth() * this.Graphic.GetScaleX() + 16)
                }
                this.BackingMiddle.SetPositionX(this.Graphic.GetPositionX() - 8);
                this.BackingLeft.SetPositionX(this.BackingMiddle.GetPositionX() - this.BackingMiddle.GetWidth() * this.BackingMiddle.GetScaleX() / 2);
                this.BackingRight.SetPositionX(this.BackingMiddle.GetPositionX() + this.BackingMiddle.GetWidth() * this.BackingMiddle.GetScaleX() / 2);
                this.BackingMiddle.SetPositionY(this.Graphic.GetPositionY());
                this.BackingLeft.SetPositionY(this.BackingMiddle.GetPositionY());
                this.BackingRight.SetPositionY(this.BackingMiddle.GetPositionY())
            } else if (this.Graphic && this.Graphic2) {
                this.Graphic2.SetPositionX(this.Graphic.GetPositionX() + this.Graphic.GetWidth() * this.Graphic.GetScaleX() + 10);
                if (!IgnoreScale) {
                    this.BackingMiddle.SetScaleX(this.Graphic.GetWidth() * this.Graphic.GetScaleX() + this.Graphic2.GetWidth() * this.Graphic2.GetScaleX() + 16)
                }
                this.BackingMiddle.SetPositionX(this.Graphic.GetPositionX() - 8);
                this.BackingLeft.SetPositionX(this.BackingMiddle.GetPositionX() - this.BackingMiddle.GetWidth() * this.BackingMiddle.GetScaleX() / 2);
                this.BackingRight.SetPositionX(this.BackingMiddle.GetPositionX() + this.BackingMiddle.GetWidth() * this.BackingMiddle.GetScaleX() / 2);
                this.BackingMiddle.SetPositionY(this.Graphic.GetPositionY());
                this.BackingLeft.SetPositionY(this.BackingMiddle.GetPositionY());
                this.BackingRight.SetPositionY(this.BackingMiddle.GetPositionY())
            }
        }
    };
    Button.Create = function CreateFn(X, Y, szText, Graphic, Graphic2, SubText, RenderTree) {
        var NewObject = new Button;
        NewObject.BackingLeft = Helpers.CreateSprite(X, Y, EA.MiddleRight, "PanelLeft01", RenderTree);
        NewObject.BackingLeft.SetColour(Button.NormalColour);
        NewObject.BackingRight = Helpers.CreateSprite(X, Y, EA.MiddleLeft, "PanelRight01", RenderTree);
        NewObject.BackingRight.SetColour(Button.NormalColour);
        NewObject.BackingMiddle = Helpers.CreateSprite(X, Y, EA.Default, "PanelMiddle01", RenderTree);
        NewObject.BackingMiddle.SetColour(Button.NormalColour);
        if (szText) {
            NewObject.ButtonText = Helpers.CreateBitmapText(szText, X, Y, EA.Default, "PanelFont", RenderTree);
            NewObject.ButtonText.SetColour([1, .5, 0, 1]);
            NewObject.ButtonText.SetScale(.5, .5)
        }
        if (SubText) {
            NewObject.ButtonSubText = Helpers.CreateBitmapText(SubText, X, Y, EA.Default, "PanelFont", RenderTree);
            NewObject.ButtonSubText.SetColour([1, .5, 0, 1]);
            NewObject.ButtonSubText.SetScale(.2, .2)
        }
        if (Graphic) {
            NewObject.Graphic = Helpers.CreateSprite(X, Y, EA.MiddleLeft, Graphic, RenderTree)
        }
        if (Graphic2) {
            NewObject.Graphic2 = Helpers.CreateSprite(X, Y, EA.MiddleLeft, Graphic2, RenderTree)
        }
        NewObject.RenderTree = RenderTree;
        NewObject.RegeneratePositionScale();
        NewObject.MouseOver = false;
        NewObject.ForcedHighlight = false;
        NewObject.Disabled = false;
        NewObject.FlashTimer = 0;
        return NewObject
    };

    function ButtonGraphic() {}
    ButtonGraphic.NormalColour = [1, 1, 1, 1];
    ButtonGraphic.HighlightColour = [1, 1, 0, 1];
    ButtonGraphic.SelectedColour = [1, 1, 0, 1];
    ButtonGraphic.DisabledColour = [0, 0, 0, .5];
    ButtonGraphic.prototype = {
        SetParent: function SetParentFn(Parent) {
            if (this.Graphic) {
                this.Graphic.RemoveFromParent();
                if (Parent) {
                    Parent.AddChild(this.Graphic)
                }
            }
        },
        SetPosition: function SetPositionFn(X, Y) {
            var NewX = X,
                NewY = Y;
            if (!X) {
                NewX = this.Graphic.GetPositionX()
            }
            if (!Y) {
                NewY = this.Graphic.GetPositionY()
            }
            this.Graphic.SetPosition(NewX, NewY)
        },
        SetScale: function SetScaleFn(X, Y) {
            if (!X) {
                X = 1
            }
            if (!Y) {
                Y = 1
            }
            this.Graphic.SetScale(X, Y);
            this.TrueBackingScale = new Vector2(this.Graphic.GetScaleX(), this.Graphic.GetScaleY())
        },
        SetRotation: function SetRotationFn(Angle) {
            this.Graphic.SetRotation(Angle)
        },
        AlterGraphic: function AlterGraphicFn(PrimaryGraphic, NewTexture) {
            var TextureInfo = Helpers.GetTextureInfoFromImageName(NewTexture);
            this.Graphic.SetTexture(TextureInfo.Texture, TextureInfo.Frame)
        },
        Update: function UpdateFn(dt) {
            if (this.CheckCollision()) {
                if (!this.MouseOver) {
                    var X = 1.2,
                        Y = 1.2;
                    this.Graphic.SetScale(this.Graphic.GetScaleX() * X, this.Graphic.GetScaleY() * Y);
                    this.MouseOver = true;
                    Helpers.PlaySound("OptionIndicated")
                }
            } else if (this.MouseOver && !this.ForcedHighlight) {
                this.Graphic.SetScale(this.TrueBackingScale.x, this.TrueBackingScale.y);
                this.MouseOver = false
            }
        },
        IsPressed: function IsPressedFn() {
            if (this.CheckCollision()) {
                var Pressed = JamSystem.InputManager.GetMouseButtonPressed(0);
                Debug.Log("Pressed " + Pressed);
                if (Pressed) {
                    Globals.BounceImage(this.Graphic)
                }
                return Pressed
            }
            return false
        },
        ForceHighlight: function ForceHighlightFn(Show) {
            this.ForcedHighlight = Show;
            this.Graphic.SetColour(Show ? ButtonGraphic.HighlightColour : ButtonGraphic.NormalColour)
        },
        ForceSelected: function ForceSelectedFn(Show) {
            this.ForcedHighlight = Show;
            this.Graphic.SetColour(Show ? ButtonGraphic.SelectedColour : ButtonGraphic.NormalColour)
        },
        Disable: function DisableFn(Disable) {
            this.Disabled = Disable;
            if (this.Graphic) {
                this.Graphic.SetColour(Disable ? ButtonGraphic.DisabledColour : ButtonGraphic.NormalColour)
            }
        },
        SetIsVisible: function SetIsVisibleFn(Visible) {
            if (this.Graphic) {
                this.Graphic.SetIsVisible(Visible)
            }
        },
        IsVisible: function IsVisibleFn() {
            return this.Graphic.GetIsVisible()
        },
        Destroy: function DestroyFn() {
            if (this.Graphic) {
                Helpers.DestroySprite(this.Graphic)
            }
        },
        CheckCollision: function CheckCollisionFn() {
            if (this.Disabled) {
                return false
            }
            var MouseX = JamSystem.InputManager.GetMouseX() * MouseScaler;
            var MouseY = JamSystem.InputManager.GetMouseY() * MouseScaler;
            var Left = this.Graphic.GetPositionX() - this.Graphic.GetScaleX() * this.Graphic.GetWidth() / 2;
            var Right = this.Graphic.GetPositionX() + this.Graphic.GetScaleX() * this.Graphic.GetWidth() / 2;
            var Middle = this.Graphic.GetPositionY();
            var Top = Middle - this.Graphic.GetHeight() * this.Graphic.GetScaleY() / 2;
            var Bottom = Middle + this.Graphic.GetHeight() * this.Graphic.GetScaleY() / 2;
            return MouseX > Left && MouseX < Right && MouseY < Bottom && MouseY > Top
        }
    };
    ButtonGraphic.Create = function CreateFn(X, Y, Graphic, RenderTree) {
        var NewObject = new ButtonGraphic;
        NewObject.Graphic = Helpers.CreateSprite(X, Y, EA.Default, Graphic, RenderTree);
        NewObject.RenderTree = RenderTree;
        NewObject.TrueBackingScale = new Vector2(NewObject.Graphic.GetScaleX(), NewObject.Graphic.GetScaleY());
        NewObject.MouseOver = false;
        NewObject.ForcedHighlight = false;
        NewObject.Disabled = false;
        return NewObject
    };

    function LoadingAnimation() {}
    LoadingAnimation.prototype = {
        SetIsVisible: function SetIsVisible(Visible) {
            this.BootupSprite.SetIsVisible(Visible);
            if (Visible) {
                JamSystem.RenderManager.SetClearColour(1, 1, 1)
            }
        },
        Reset: function Reset() {},
        Update: function Update(TimeDelta) {},
        Destroy: function DestroyFn() {
            Helpers.DestroySprite(this.BootupSprite)
        }
    };
    LoadingAnimation.Create = function CreateFn() {
        var NewObject = new LoadingAnimation;
        NewObject.BootupSprite = Helpers.CreateSprite(75, JamSystem.RenderManager.GetScreenHeight() - 160, EA.Default, "DenkiLogo", GlobalMain.RootTree);
        NewObject.SetIsVisible(true);
        return NewObject
    };

    function Panel() {}
    Panel.prototype = {
        SetDimensions: function SetDimensionsFn(Width, Height) {
            this.Backing.SetScale(Width, Height);
            var Scale = 1;
            this.SurroundTL.SetPosition(-Width / 2, -Height / 2);
            this.SurroundTR.SetPosition(Width / 2, -Height / 2);
            this.SurroundBL.SetPosition(-Width / 2, Height / 2);
            this.SurroundBR.SetPosition(Width / 2, Height / 2);
            this.SurroundTL.SetScale(Scale, Scale);
            this.SurroundTR.SetScale(-Scale, Scale);
            this.SurroundBL.SetScale(Scale, -Scale);
            this.SurroundBR.SetScale(-Scale, -Scale);
            this.SurroundBarLeft.SetPosition(-Width / 2, 0);
            this.SurroundBarRight.SetPosition(Width / 2, 0);
            this.SurroundBarTop.SetPosition(0, -Height / 2);
            this.SurroundBarBottom.SetPosition(0, Height / 2);
            this.SurroundBarLeft.SetScale(Height, Scale);
            this.SurroundBarRight.SetScale(Height, Scale);
            this.SurroundBarTop.SetScale(Width, Scale);
            this.SurroundBarBottom.SetScale(Width, -Scale)
        },
        SetIsVisible: function SetIsVisibleFn(Visible) {
            this.Root.SetIsVisible(Visible)
        },
        SetGFX: function SetGFXFn(Corner, Edge, Colour) {
            var TextureInfo = Helpers.GetTextureInfoFromImageName(Corner);
            this.SurroundTL.SetTexture(TextureInfo.Texture, TextureInfo.Frame);
            this.SurroundTR.SetTexture(TextureInfo.Texture, TextureInfo.Frame);
            this.SurroundBL.SetTexture(TextureInfo.Texture, TextureInfo.Frame);
            this.SurroundBR.SetTexture(TextureInfo.Texture, TextureInfo.Frame);
            TextureInfo = Helpers.GetTextureInfoFromImageName(Edge);
            this.SurroundBarLeft.SetTexture(TextureInfo.Texture, TextureInfo.Frame);
            this.SurroundBarRight.SetTexture(TextureInfo.Texture, TextureInfo.Frame);
            this.SurroundBarTop.SetTexture(TextureInfo.Texture, TextureInfo.Frame);
            this.SurroundBarBottom.SetTexture(TextureInfo.Texture, TextureInfo.Frame);
            this.Backing.SetColour(Colour)
        },
        Destroy: function DestroyFn() {
            Helpers.DestroySprite(this.SurroundBarLeft);
            Helpers.DestroySprite(this.SurroundBarRight);
            Helpers.DestroySprite(this.SurroundBarTop);
            Helpers.DestroySprite(this.SurroundBarBottom);
            Helpers.DestroySprite(this.SurroundTL);
            Helpers.DestroySprite(this.SurroundTR);
            Helpers.DestroySprite(this.SurroundBL);
            Helpers.DestroySprite(this.SurroundBR);
            Helpers.DestroyTree(this.Backing)
        }
    };
    Panel.Create = function CreateFn(x, y, Width, Height, Parent) {
        var NewObject = new Panel;
        NewObject.Root = Helpers.CreateTree(x, y, Parent);
        NewObject.Root.SetIsVisible(true);
        NewObject.Backing = Helpers.CreateSprite(0, 0, EA.Default, "White", NewObject.Root);
        var Scale = 1;
        NewObject.SurroundTL = Helpers.CreateSprite(-Width / 2, -Height / 2, EA.BottomRight, "PanelCorner", NewObject.Root);
        NewObject.SurroundTR = Helpers.CreateSprite(Width / 2, -Height / 2, EA.BottomRight, "PanelCorner", NewObject.Root);
        NewObject.SurroundBL = Helpers.CreateSprite(-Width / 2, Height / 2, EA.BottomRight, "PanelCorner", NewObject.Root);
        NewObject.SurroundBR = Helpers.CreateSprite(Width / 2, Height / 2, EA.BottomRight, "PanelCorner", NewObject.Root);
        NewObject.SurroundBarLeft = Helpers.CreateSprite(-Width / 2, 0, EA.BottomMiddle, "PanelEdge", NewObject.Root);
        NewObject.SurroundBarLeft.SetRotation(-Math.PI / 2);
        NewObject.SurroundBarRight = Helpers.CreateSprite(Width / 2, 0, EA.BottomMiddle, "PanelEdge", NewObject.Root);
        NewObject.SurroundBarRight.SetRotation(Math.PI / 2);
        NewObject.SurroundBarTop = Helpers.CreateSprite(0, -Height / 2, EA.BottomMiddle, "PanelEdge", NewObject.Root);
        NewObject.SurroundBarBottom = Helpers.CreateSprite(0, Height / 2, EA.BottomMiddle, "PanelEdge", NewObject.Root);
        NewObject.SetDimensions(Width, Height);
        return NewObject
    };

    function TriPanel() {}
    TriPanel.prototype = {
        SetIsVisible: function SetIsVisibleFn(Visible) {
            this.Root.SetIsVisible(Visible)
        },
        SetGFX: function SetGFXFn(Left, Middle, Right) {
            var TextureInfo = Helpers.GetTextureInfoFromImageName(Left);
            this.BackingLeft.SetTexture(TextureInfo.Texture, TextureInfo.Frame);
            TextureInfo = Helpers.GetTextureInfoFromImageName(Middle);
            this.BackingMiddle.SetTexture(TextureInfo.Texture, TextureInfo.Frame);
            TextureInfo = Helpers.GetTextureInfoFromImageName(Right);
            this.BackingRight.SetTexture(TextureInfo.Texture, TextureInfo.Frame)
        },
        Destroy: function DestroyFn() {
            Helpers.DestroySprite(this.BackingLeft);
            Helpers.DestroySprite(this.BackingMiddle);
            Helpers.DestroySprite(this.BackingRight);
            if (this.Text) {
                Helpers.DestroyBitmapText(this.Text)
            }
        }
    };
    TriPanel.Create = function CreateFn(x, y, Width, Height, Text, ScaleX, ScaleY, Parent) {
        var NewObject = new TriPanel;
        NewObject.Root = Helpers.CreateTree(0, 0, Parent);
        NewObject.Root.SetIsVisible(true);
        NewObject.BackingLeft = Helpers.CreateSprite(0, 0, EA.MiddleRight, "PanelLeft", NewObject.Root);
        NewObject.BackingMiddle = Helpers.CreateSprite(0, 0, EA.Default, "PanelMiddle", NewObject.Root);
        NewObject.BackingRight = Helpers.CreateSprite(0, 0, EA.MiddleLeft, "PanelRight", NewObject.Root);
        NewObject.Text = Helpers.CreateBitmapText("", x, y, EA.Default, "PanelFont", NewObject.Root);
        if (Width !== undefined && Height !== undefined) {
            NewObject.BackingMiddle.SetScale(Width / NewObject.BackingMiddle.GetWidth(), Height / NewObject.BackingMiddle.GetHeight());
            NewObject.BackingLeft.SetScaleY(Height / NewObject.BackingLeft.GetHeight());
            NewObject.BackingRight.SetScaleY(Height / NewObject.BackingRight.GetHeight())
        }
        if (Text) {
            NewObject.Text.SetText(Text);
            var Length = NewObject.Text.GetWidth();
            NewObject.BackingMiddle.SetScaleX(Length)
        }
        NewObject.BackingMiddle.SetScale(NewObject.BackingMiddle.GetScaleX() * ScaleX, NewObject.BackingMiddle.GetScaleY() * ScaleY);
        NewObject.BackingLeft.SetScale(NewObject.BackingLeft.GetScaleX() * ScaleX, NewObject.BackingLeft.GetScaleY() * ScaleY);
        NewObject.BackingRight.SetScale(NewObject.BackingRight.GetScaleX() * ScaleX, NewObject.BackingRight.GetScaleY() * ScaleY);
        NewObject.BackingMiddle.SetPosition(x, y);
        NewObject.BackingLeft.SetPosition(NewObject.BackingMiddle.GetPositionX() - NewObject.BackingMiddle.GetScaleX() * NewObject.BackingMiddle.GetWidth() * .5, y);
        NewObject.BackingRight.SetPosition(NewObject.BackingMiddle.GetPositionX() + NewObject.BackingMiddle.GetScaleX() * NewObject.BackingMiddle.GetWidth() * .5, y);
        return NewObject
    };

    function StateGame() {}
    StateGame.prototype = {
        Reset: function ResetFn() {
            Debug.Log("Reset Game");
            SystemsManager.Reset();
            GlobalMain.WorldManager.ReadyForPlay();
            GlobalMain.CameraManager.SetViewDimensions(JamSystem.RenderManager.GetScreenWidth(), StateGame.WorldViewHeight)
        },
        Start: function StartFn() {
            Debug.Log("Start Game")
        },
        Update: function UpdateFn(TimeDelta) {},
        Destroy: function DestroyFn() {
            GlobalMain.WorldManager.Reset();
            SystemsManager.Reset()
        }
    };
    StateGame.Create = function GameCreateFn() {
        var NewObject = new StateGame;
        return NewObject
    };

    function StateInitialLoader() {}
    StateInitialLoader.StateBootup = 0;
    StateInitialLoader.StateBootupPause = 1;
    StateInitialLoader.StateJakeInit = 2;
    StateInitialLoader.StatePaletteInit = 3;
    StateInitialLoader.StateBrushInit = 4;
    StateInitialLoader.StateFinished = 5;
    StateInitialLoader.ProgressBarWidth = 1280;
    StateInitialLoader.ProgressBarHeight = 10;
    StateInitialLoader.prototype = {
        StartJakeInit: function StartJakeInitFn() {
            Jake.Init(0, Application.Distribution);
            JamSystem.AssetManager.LoadShader("assets/Working/CustomShaders.cgfx.json");
            JamSystem.AssetManager.LoadTexture("assets/Working/Misc.json");
            JamSystem.AssetManager.LoadTexture("assets/Working/PanelFont.json");
            JamSystem.AssetManager.LoadTexture("assets/Working/PanelFontSmall.json");
            JamSystem.AssetManager.LoadTexture("assets/Working/PanelFontSmall2.json");
            JamSystem.AssetManager.LoadTexture("assets/Working/NumberFont.json");
            JamSystem.AssetManager.LoadSoundBank("assets/Working/GameDecompress.tar", true);
            JamSystem.AssetManager.LoadAudioInfo(Application.AudioInfoFile, !Application.Distribution);
            JamSystem.AssetManager.LoadText(Application.TextFile, !Application.Distribution);
            JamSystem.ScriptManager.LoadScriptFile(Application.CeremonyScriptFile, !Application.Distribution);
            this.TotalAssets = JamSystem.AssetManager.GetTexturesLeft() + JamSystem.AssetManager.GetSoundBanksLeft();
            var ParseFile = function ParseFileFn(psData, iDataSize, psUserData) {
                if (psData === null) {
                    return
                }
                Debug.Log("Parsing level file");
                GlobalMain.LevelsData = JSON.parse(psData)
            };
            GlobalMain.LevelsData = null;
            GlobalMain.LevelsFile = File.Load("assets/Working/Levels.json", ParseFile, null, null);
            GlobalMain.ShopManager = GameStoreManager.Create();
            GlobalMain.LifetimeStatManager = LifetimeStatManager.Create();
            EntityRegistry.Init();
            ScriptFunctions.Init();
            ScriptEntityFunctions.Init();
            if (!Application.Distribution) {
                SettingsFileManager.Init();
                SettingsFileManager.Load(Application.SettingsFile, true)
            }
        },
        CreateFontTable: function CreateFontTable() {
            var miRefUnicodeToImgNum = [];
            var i;
            for (i = 0; i < 91; i += 1) {
                miRefUnicodeToImgNum[32 + i] = i
            }
            return miRefUnicodeToImgNum;
            var ImageInfo = Helpers.GetTextureInfoFromImageName("PanelFont_0");
            var iImgRefId = ImageInfo.Frame;
            miRefUnicodeToImgNum[32] = Helpers.GetTextureInfoFromImageName("PanelFontSpace").Frame;
            var i;
            for (i = 33; i <= 90; i += 1) {
                miRefUnicodeToImgNum[i] = iImgRefId;
                iImgRefId += 1
            }
            for (i = 97; i <= 122; i += 1) {
                miRefUnicodeToImgNum[i] = iImgRefId;
                iImgRefId += 1
            }
            miRefUnicodeToImgNum[161] = iImgRefId;
            iImgRefId += 1;
            miRefUnicodeToImgNum[171] = iImgRefId;
            iImgRefId += 1;
            miRefUnicodeToImgNum[187] = iImgRefId;
            iImgRefId += 1;
            for (i = 191; i <= 196; i += 1) {
                miRefUnicodeToImgNum[i] = iImgRefId;
                iImgRefId += 1
            }
            for (i = 199; i <= 207; i += 1) {
                miRefUnicodeToImgNum[i] = iImgRefId;
                iImgRefId += 1
            }
            for (i = 210; i <= 214; i += 1) {
                miRefUnicodeToImgNum[i] = iImgRefId;
                iImgRefId += 1
            }
            for (i = 217; i <= 220; i += 1) {
                miRefUnicodeToImgNum[i] = iImgRefId;
                iImgRefId += 1
            }
            miRefUnicodeToImgNum[223] = iImgRefId;
            iImgRefId += 1;
            miRefUnicodeToImgNum[966] = iImgRefId;
            iImgRefId += 1;
            for (i = 224; i <= 228; i += 1) {
                miRefUnicodeToImgNum[i] = iImgRefId;
                iImgRefId += 1
            }
            for (i = 231; i <= 239; i += 1) {
                miRefUnicodeToImgNum[i] = iImgRefId;
                iImgRefId += 1
            }
            for (i = 242; i <= 246; i += 1) {
                miRefUnicodeToImgNum[i] = iImgRefId;
                iImgRefId += 1
            }
            for (i = 249; i <= 252; i += 1) {
                miRefUnicodeToImgNum[i] = iImgRefId;
                iImgRefId += 1
            }
            for (i = 255; i <= 257; i += 1) {
                miRefUnicodeToImgNum[i] = iImgRefId;
                iImgRefId += 1
            }
            for (i = 338; i <= 339; i += 1) {
                miRefUnicodeToImgNum[i] = iImgRefId;
                iImgRefId += 1
            }
            miRefUnicodeToImgNum[376] = iImgRefId;
            iImgRefId += 1;
            for (i = 8304; i <= 8313; i += 1) {
                miRefUnicodeToImgNum[i] = iImgRefId;
                iImgRefId += 1
            }
            for (i = 8320; i <= 8329; i += 1) {
                miRefUnicodeToImgNum[i] = iImgRefId;
                iImgRefId += 1
            }
            miRefUnicodeToImgNum[189] = iImgRefId;
            iImgRefId += 1;
            miRefUnicodeToImgNum[176] = iImgRefId;
            iImgRefId += 1;
            miRefUnicodeToImgNum[169] = iImgRefId;
            iImgRefId += 1;
            miRefUnicodeToImgNum[8316] = iImgRefId;
            iImgRefId += 1;
            miRefUnicodeToImgNum[8315] = iImgRefId;
            iImgRefId += 1;
            miRefUnicodeToImgNum[8314] = iImgRefId;
            iImgRefId += 1;
            for (i = 8544; i <= 8552; i += 1) {
                miRefUnicodeToImgNum[i] = iImgRefId;
                iImgRefId += 1
            }
            miRefUnicodeToImgNum[8553] = iImgRefId;
            iImgRefId += 1;
            miRefUnicodeToImgNum[8554] = iImgRefId;
            iImgRefId += 1;
            miRefUnicodeToImgNum[8555] = iImgRefId;
            iImgRefId += 1;
            miRefUnicodeToImgNum[8556] = iImgRefId;
            iImgRefId += 1;
            return miRefUnicodeToImgNum
        },
        CreateLetterFontTable: function CreateLetterFontTable() {
            var miRefUnicodeToImgNum = [];
            var i;
            for (i = 0; i < 26; i += 1) {
                miRefUnicodeToImgNum[65 + i] = i
            }
            return miRefUnicodeToImgNum
        },
        CreateNumberFontTable: function CreateNumberFontTable() {
            var miRefUnicodeToImgNum = [];
            var i;
            for (i = 0; i < 10; i += 1) {
                miRefUnicodeToImgNum[48 + i] = i
            }
            return miRefUnicodeToImgNum
        },
        StartPaletteInit: function PaletteInitFn() {
            var FileToUse = SettingsFileManager.ObjectPaletteFile ? SettingsFileManager.ObjectPaletteFile : Application.ObjectPaletteFile;
            ObjectPaletteManager.Init(FileToUse, !Application.Distribution)
        },
        StartBrushInit: function BrushInitFn() {
            var FileToUse = SettingsFileManager.BrushPaletteFile ? SettingsFileManager.BrushPaletteFile : Application.BrushPaletteFile;
            BrushPaletteManager.Init(FileToUse, !Application.Distribution)
        },
        Finish: function FinishFn() {
            var CharToImageTable = this.CreateFontTable();
            JamSystem.AssetManager.CreateBitmapFont("PanelFont", "assets/Working/PanelFont.json", CharToImageTable, -10, 0, "$", 1);
            JamSystem.AssetManager.CreateBitmapFont("PanelFontSmall", "assets/Working/PanelFontSmall.json", CharToImageTable, 0, 0, "$", 1);
            JamSystem.AssetManager.CreateBitmapFont("PanelFontSmall2", "assets/Working/PanelFontSmall2.json", CharToImageTable, 0, 0, "$", 1);
            CharToImageTable = this.CreateNumberFontTable();
            JamSystem.AssetManager.CreateBitmapFont("NumberFont", "assets/Working/NumberFont.json", CharToImageTable, 0, 0, "$", 1);
            JamSystem.SoundManager.FinialiseAudioInfo();
            JamSystem.SoundManager.SetCategoryVolume(0, 1);
            JamSystem.SoundManager.SetCategoryVolume(1, 1);
            JamSystem.SoundManager.SetCategoryVolume(2, 1);
            GlobalMain.WorldManager = WorldManager.Create();
            SystemsManager.Init();
            GlobalMain.OutOfFocusManager = OutOfFocusManager.Create();
            if (!Application.Distribution) {
                GlobalMain.Editor = Editor.Create(GlobalMain.World, GlobalMain.CameraManager.Camera, GlobalMain);
                GlobalMain.Editor.LoadFile = SettingsFileManager.FileToLoad;
                GlobalMain.Editor.SaveFile = SettingsFileManager.FileToLoad
            }
            GlobalMain.ViewportChanged();
            var LevelFile;
            if (!Application.Distribution) {
                LevelFile = SettingsFileManager.FileToLoad
            } else {
                LevelFile = Application.LevelFile
            }
            GlobalMain.StateManager.BeginLoadLevel(LevelFile, StateManager.StateLevelSelect)
        },
        Update: function UpdateFn(TimeDelta) {
            switch (this.State) {
                case StateInitialLoader.StateBootup:
                    if (JamSystem.AssetManager.GetIsAllLoaded()) {
                        this.BackgroundSprite = Helpers.CreateSprite(JamSystem.RenderManager.GetScreenWidth() / 2, JamSystem.RenderManager.GetScreenHeight() / 2, EA.Default, "LoadingScreen", GlobalMain.RootTree);
                        this.ProgressBarBackground = Helpers.CreateSprite(JamSystem.RenderManager.GetScreenWidth() / 2, JamSystem.RenderManager.GetScreenHeight() - 50, EA.Default, "ProgressBar", GlobalMain.RootTree);
                        this.ProgressBarBackground.SetScale(StateInitialLoader.ProgressBarWidth, StateInitialLoader.ProgressBarHeight);
                        this.ProgressBarBackground.SetColour([0, 0, 0, .25]);
                        this.ProgressBar = Helpers.CreateSprite(JamSystem.RenderManager.GetScreenWidth() / 2 - StateInitialLoader.ProgressBarWidth / 2, JamSystem.RenderManager.GetScreenHeight() - 50, EA.MiddleLeft, "ProgressBar", GlobalMain.RootTree);
                        this.ProgressBar.SetScale(0, StateInitialLoader.ProgressBarHeight);
                        this.ProgressBar.SetColour([1, 0, 0, .25]);
                        this.ProgressSprite = Helpers.CreateSprite(0, 0, EA.Default, "ProgressIndicator01", GlobalMain.RootTree);
                        this.ProgressSprite.SetRotation(.2);
                        this.ProgressTimer = 0;
                        GlobalMain.LoadingAnimation = LoadingAnimation.Create();
                        this.State = StateInitialLoader.StateBootupPause
                    }
                    break;
                case StateInitialLoader.StateBootupPause:
                    this.StartJakeInit();
                    this.State = StateInitialLoader.StateJakeInit;
                    break;
                case StateInitialLoader.StateJakeInit:
                    GlobalMain.LoadingAnimation.Update(TimeDelta);
                    if (JamSystem.AssetManager.GetIsAllLoaded() && GlobalMain.LevelsData) {
                        if (!Application.Distribution) {
                            if (SettingsFileManager.GetIsReady()) {
                                if (SettingsFileManager.HasLoadingFailed()) {
                                    SettingsFileManager.Save(Application.LevelFile, Application.SettingsFile);
                                    return
                                }
                            }
                            if (!SettingsFileManager.GetIsReady()) {
                                break
                            }
                        }
                        this.StartPaletteInit();
                        this.State = StateInitialLoader.StatePaletteInit
                    }
                    break;
                case StateInitialLoader.StatePaletteInit:
                    GlobalMain.LoadingAnimation.Update(TimeDelta);
                    if (ObjectPaletteManager.GetIsReady()) {
                        if (!JamSystem.SaveDataManager.PendingLoads) {
                            if (Application.Distribution) {
                                this.Finish();
                                this.State = StateInitialLoader.StateFinished
                            } else {
                                this.StartBrushInit();
                                this.State = StateInitialLoader.StateBrushInit
                            }
                        }
                    }
                    break;
                case StateInitialLoader.StateBrushInit:
                    GlobalMain.LoadingAnimation.Update(TimeDelta);
                    if (BrushPaletteManager.GetIsReady()) {
                        if (!JamSystem.SaveDataManager.PendingLoads) {
                            this.Finish();
                            this.State = StateInitialLoader.StateFinished
                        }
                    }
                    break
            }
            if (this.State !== StateInitialLoader.StateBootup) {
                var AssetsLeft = JamSystem.AssetManager.GetTexturesLeft() + JamSystem.AssetManager.GetSoundBanksLeft();
                this.TotalAssets = Math.max(AssetsLeft, this.TotalAssets);
                var Percent = 1 - AssetsLeft / this.TotalAssets;
                var x = JamSystem.RenderManager.GetScreenWidth() / 2 - StateInitialLoader.ProgressBarWidth / 2 + Percent * StateInitialLoader.ProgressBarWidth;
                this.ProgressSprite.SetPosition(x, JamSystem.RenderManager.GetScreenHeight() - 50);
                this.ProgressBar.SetScale(Percent * StateInitialLoader.ProgressBarWidth, StateInitialLoader.ProgressBarHeight);
                this.ProgressTimer += 1;
                if (this.ProgressTimer % 8 < 4) {
                    this.ProgressSprite.SetFrame(this.ProgressSprite.psTexture.GetFrameIndexFromName("ProgressIndicator01"))
                } else {
                    this.ProgressSprite.SetFrame(this.ProgressSprite.psTexture.GetFrameIndexFromName("ProgressIndicator02"))
                }
            }
        },
        Destroy: function DestroyFn() {
            Helpers.DestroySprite(this.ProgressBarBackground);
            Helpers.DestroySprite(this.ProgressBar);
            Helpers.DestroySprite(this.ProgressSprite);
            Helpers.DestroySprite(this.BackgroundSprite)
        }
    };
    StateInitialLoader.Create = function CreateFn() {
        var NewObject = new StateInitialLoader;
        NewObject.State = StateInitialLoader.StateBootup;
        NewObject.TotalAssets = 0;
        NewObject.BackgroundSprite = null;
        NewObject.ProgressBarBackground = null;
        NewObject.ProgressBar = null;
        NewObject.ProgressSprite = null;
        NewObject.ProgressTimer = 0;
        NewObject.SaveDataTimeWaiting = 0;
        JamSystem.AssetManager.LoadTexture("assets/Working/Loading.json");
        return NewObject
    };

    function StateLevelLoader() {}
    StateLevelLoader.FakeTime = 0;
    StateLevelLoader.prototype = {
        Update: function UpdateFn(TimeDelta) {
            if (!this.HasStarted) {
                this.ProjectedTime = JamSystem.GetTrueTime() + StateLevelLoader.FakeTime;
                WorldFileManager.Load(GlobalMain.World, this.FileName, !Application.Distribution);
                GlobalMain.LoadingAnimation.SetIsVisible(true);
                this.HasStarted = true
            }
            GlobalMain.LoadingAnimation.Update(TimeDelta);
            if (WorldFileManager.GetIsReady() && JamSystem.ScriptManager.GetIsReady() && JamSystem.GetTrueTime() > this.ProjectedTime) {
                if (!Application.Distribution) {
                    if (GlobalMain.Editor) {
                        GlobalMain.Editor.SaveFile = this.FileName;
                        GlobalMain.Editor.LoadFile = this.FileName
                    }
                }
                GlobalMain.WorldManager.Reset();
                SystemsManager.Reset();
                GlobalMain.WorldManager.ReadyForPlay();
                GlobalMain.LoadingAnimation.SetIsVisible(false);
                JamSystem.RenderManager.SetClearColour(1, 1, 1);
                this.IsLoading = false;
                GlobalMain.IsLoadFinished = true;
                GlobalMain.IsLoadSuccess = WorldFileManager.Success;
                GlobalMain.StateManager.RequestChangeState(this.NextState)
            }
        },
        Destroy: function DestroyFn() {}
    };
    var EditorLoadLevel = function EditorLoadLevelFn(FileName) {
        GlobalMain.IsLoadFinished = false;
        GlobalMain.IsLoadSuccess = false;
        GlobalMain.StateManager.BeginLoadLevel(FileName, StateManager.StateEdit)
    };
    StateLevelLoader.Create = function CreateFn(FileName, NextState) {
        var NewObject = new StateLevelLoader;
        if (NextState === StateManager.StateGame) {
            NewObject.ToGame = true
        }
        NewObject.FileName = FileName;
        NewObject.NextState = NextState;
        NewObject.HasStarted = false;
        NewObject.IsLoading = true;
        NewObject.ProjectedTime = 0;
        GlobalMain.Load = EditorLoadLevel;
        GlobalMain.IsLoadFinished = false;
        GlobalMain.IsLoadSuccess = false;
        return NewObject
    };

    function StateManager() {}
    StateManager.StateNone = 0;
    StateManager.StateInitialLoader = 1;
    StateManager.StateLoadLevel = 2;
    StateManager.StateLevelSelect = 3;
    StateManager.StateGame = 4;
    StateManager.StateHelp = 5;
    StateManager.StateEdit = 6;
    StateManager.prototype = {
        StartState: function StartStateFn(NewState) {
            Debug.Log("StateManager.StartState : " + NewState);
            this.State = NewState;
            this.RequestedState = NewState;
            switch (this.State) {
                case StateManager.StateNone:
                    break;
                case StateManager.StateInitialLoader:
                    GlobalMain.StateObject = StateInitialLoader.Create();
                    break;
                case StateManager.StateLoadLevel:
                    GlobalMain.StateObject = StateLevelLoader.Create(this.LoadLevelFileName, this.LoadLevelNextState);
                    break;
                case StateManager.StateLevelSelect:
                    LevelSelect.Init();
                    break;
                case StateManager.StateGame:
                    GameState.Init();
                    break;
                case StateManager.StateHelp:
                    Help.Init();
                    break;
                case StateManager.StateEdit:
                    GlobalMain.World.RootTreeTranslate.SetPosition(JamSystem.RenderManager.GetScreenWidth() / 2, JamSystem.RenderManager.GetScreenHeight() / 2);
                    GlobalMain.EditActive = true;
                    GlobalMain.Editor.SetIsActive(true);
                    if (!GlobalMain.IsPaused) {
                        GlobalMain.WorldManager.Reset();
                        SystemsManager.Reset()
                    }
                    GlobalMain.World.ShowEditMode(true);
                    JamSystem.RenderManager.SetClearColour(.5, .5, .5);
                    break
            }
        },
        EndState: function EndStateFn() {
            switch (this.State) {
                case StateManager.StateLevelSelect:
                    LevelSelect.ShutDown();
                    break;
                case StateManager.StateGame:
                    GameState.ShutDown();
                    break;
                case StateManager.StateHelp:
                    Help.ShutDown();
                    break;
                case StateManager.StateEdit:
                    GlobalMain.EditActive = false;
                    GlobalMain.Editor.SetIsActive(false);
                    GlobalMain.World.ShowEditMode(false);
                    JamSystem.RenderManager.SetClearColour(0, 0, 0);
                    if (GlobalMain.IsPaused) {
                        return
                    }
                    break
            }
            if (GlobalMain.StateObject) {
                GlobalMain.StateObject.Destroy();
                GlobalMain.StateObject = undefined
            }
        },
        RequestChangeState: function RequestChangeStateFn(NewState) {
            this.RequestedState = NewState
        },
        BeginLoadLevel: function BeginLoadLevelFn(FileName, NextState) {
            var j = FileName.length - 1;
            while (j && FileName.charAt(j) !== "\\" && FileName.charAt(j) !== "/") {
                j -= 1
            }
            j += 1;
            this.LoadLevelName = FileName.substring(j, FileName.length - 5);
            this.LoadLevelFileName = FileName;
            this.LoadLevelNextState = NextState;
            this.RequestChangeState(StateManager.StateLoadLevel)
        },
        StartSlowMo: function StartSlowMoFn(Delay) {
            return;
            this.SlowMoDelay = Delay;
            this.SlowMoTimer = 0
        },
        Reset: function ResetFn() {},
        UpdateTestKeys: function UpdateTestKeysFn() {
            switch (this.State) {
                case StateManager.StateNone:
                case StateManager.StateInitialLoader:
                case StateManager.StateGame:
                    break
            }
        },
        Update: function UpdateFn(TimeDelta) {
            if (this.SlowMoDelay) {
                this.SlowMoTimer += 1;
                if (this.SlowMoTimer === 10) {
                    this.SlowMoTimer = 0;
                    this.SlowMoDelay -= 1
                } else {
                    return
                }
            }
            if (this.RequestedState !== this.State) {
                this.EndState();
                this.StartState(this.RequestedState)
            }
            if (this.State !== StateManager.StateInitialLoader && this.State !== StateManager.StateLoadLevel) {
                if (!GlobalMain.OutOfFocusManager.Update(TimeDelta)) {
                    return
                }
            }
            if (this.State !== StateManager.StateInitialLoader && this.State !== StateManager.StateLoadLevel && this.State !== StateManager.StateEdit) {
                if (GlobalMain.IsPaused) {
                    SystemsManager.UpdatePaused(TimeDelta)
                } else {
                    GlobalMain.WorldManager.Update(TimeDelta);
                    SystemsManager.Update(TimeDelta)
                }
            }
            switch (this.State) {
                case StateManager.StateNone:
                    return;
                case StateManager.StateInitialLoader:
                case StateManager.StateLoadLevel:
                    GlobalMain.StateObject.Update(TimeDelta);
                    break;
                case StateManager.StateLevelSelect:
                    LevelSelect.Update();
                    break;
                case StateManager.StateGame:
                    GameState.Update();
                    break;
                case StateManager.StateHelp:
                    Help.Update();
                    break;
                case StateManager.StateEdit:
                    if (GlobalMain.Editor.CanILeave()) {
                        if (JamSystem.InputManager.GetKeyPressed(401)) {
                            this.RequestChangeState(StateManager.StateGame)
                        }
                    }
                    GlobalMain.Editor.Update(TimeDelta);
                    if (JamSystem.InputManager.GetKeyPressed(7)) {
                        if (GlobalMain.Editor.SelectionEntities.length) {
                            GlobalMain.CameraManager.Camera.SetPosition(GlobalMain.Editor.SelectionEntities[0].x, GlobalMain.Editor.SelectionEntities[0].y)
                        }
                    }
                    GlobalMain.CameraManager.FinaliseCamera();
                    break
            }
            if (!Application.Distribution) {
                if (this.State === StateManager.StateGame) {
                    if (JamSystem.InputManager.GetKeyPressed(401)) {
                        GlobalMain.StateManager.RequestChangeState(StateManager.StateEdit)
                    }
                }
            }
            if (this.State !== StateManager.StateInitialLoader && this.State !== StateManager.StateLoadLevel && !Application.Distribution) {
                if (JamSystem.InputManager.GetKeyPressed(500) || JamSystem.InputManager.GetKeyPressed(506)) {
                    GlobalMain.World.ToggleDebugStats()
                }
                GlobalMain.World.UpdateDebugStats()
            }
            this.UpdateTestKeys()
        },
        Destroy: function DestroyFn() {}
    };
    StateManager.Create = function CreateFn() {
        var NewObject = new StateManager;
        NewObject.State = StateManager.StateNone;
        NewObject.RequestedState = StateManager.StateInitialLoader;
        NewObject.LoadLevelName = "";
        NewObject.LoadLevelFileName = "";
        NewObject.LoadLevelNextState = -1;
        NewObject.SoundOn = true;
        NewObject.SlowMoDelay = 0;
        NewObject.SlowMoTimer = 0;
        return NewObject
    };

    function MusicManager() {}
    MusicManager.prototype = {
        SetMusic: function SetMusicFn(MusicName, Volume) {
            JamSystem.SoundManager.StopSoundHandle(this.MusicLoopHandle);
            if (MusicName) {
                var FileName = "assets/Working/" + MusicName + ".ogg";
                if (!JamSystem.AssetManager.GetSoundInfoFromSoundName(MusicName)) {
                    this.PlayingStart = true;
                    JamSystem.SoundManager.PlaySoundDetailed(MusicName + "Start", 0, 1, Volume, this.RequestLooped, this.MusicLoopHandle);
                    JamSystem.SoundManager.LockSoundHandle(this.MusicLoopHandle, true)
                } else {
                    this.PlayingStart = false;
                    JamSystem.SoundManager.PlaySoundDetailed(MusicName, 0, 1, Volume, this.RequestLooped, this.MusicLoopHandle);
                    JamSystem.SoundManager.LockSoundHandle(this.MusicLoopHandle, true)
                }
            }
        },
        RequestChangeMusic: function RequestChangeMusicFn(MusicName, Volume, Looped) {
            if (this.RequestMusicName !== MusicName) {
                this.RequestMusicName = MusicName;
                this.RequestVolume = Volume;
                this.RequestLooped = Looped;
                if (MusicName) {
                    Debug.Log("Request Music " + MusicName);
                    var FileName = "assets/Working/" + MusicName + "Start.ogg";
                    if (!JamSystem.AssetManager.DoesSoundBankExist(FileName)) {
                        JamSystem.AssetManager.CreateSoundBank(FileName)
                    }
                }
            }
        },
        SetPitch: function SetPitchFn(Pitch) {
            JamSystem.SoundManager.SetSoundPitchHandle(this.MusicLoopHandle, Pitch)
        },
        SetVolume: function SetVolumeFn(Volume) {
            this.Volume = Volume;
            JamSystem.SoundManager.SetSoundVolumeHandle(this.MusicLoopHandle, Volume)
        },
        Update: function UpdateFn(TimeDelta) {
            if (this.RequestMusicName !== this.MusicName) {
                if (this.RequestMusicName) {
                    if (JamSystem.AssetManager.GetSoundInfoFromSoundName(this.RequestMusicName + "Start")) {
                        JamSystem.SoundManager.FinialiseAudioInfo();
                        var FileName = "assets/Working/" + this.RequestMusicName + ".ogg";
                        if (!JamSystem.AssetManager.DoesSoundBankExist(FileName)) {
                            JamSystem.AssetManager.CreateSoundBank(FileName)
                        }
                        this.SetMusic(this.RequestMusicName, this.RequestVolume);
                        this.MusicName = this.RequestMusicName;
                        this.Volume = this.RequestVolume
                    }
                } else {
                    this.PlayingStart = false;
                    this.MusicName = this.RequestMusicName;
                    this.Volume = this.RequestVolume;
                    JamSystem.SoundManager.StopSoundHandle(this.MusicLoopHandle)
                }
            }
            if (this.MusicName && this.PlayingStart) {
                if (JamSystem.AssetManager.GetSoundInfoFromSoundName(this.MusicName)) {
                    JamSystem.SoundManager.FinialiseAudioInfo();
                    Debug.Log("Swapping to full piece");
                    var Position = JamSystem.SoundManager.GetSoundOffsetHandle(this.MusicLoopHandle);
                    JamSystem.SoundManager.StopSoundHandle(this.MusicLoopHandle);
                    JamSystem.SoundManager.PlaySoundDetailed(this.MusicName, Position, 1, this.Volume, this.RequestLooped, this.MusicLoopHandle);
                    JamSystem.SoundManager.LockSoundHandle(this.MusicLoopHandle, true);
                    this.PlayingStart = false
                }
            }
            if (this.MusicName && !this.RequestLooped && !JamSystem.SoundManager.GetIsSoundPlayingHandle(this.MusicLoopHandle)) {
                JamSystem.SoundManager.StopSoundHandle(this.MusicLoopHandle);
                this.MusicName = "";
                this.RequestMusicName = ""
            }
        },
        Reset: function ResetFn() {},
        Destroy: function DestroyFn() {
            JamSystem.SoundManager.StopSoundHandle(this.MusicLoopHandle)
        }
    };
    MusicManager.Create = function CreateFn() {
        var NewObject = new MusicManager;
        NewObject.MusicName = null;
        NewObject.RequestMusicName = null;
        NewObject.PlayingStart = false;
        NewObject.MusicLoopHandle = SoundManagerHandle.Create();
        return NewObject
    };

    function GameStoreManager() {}
    GameStoreManager.prototype = {
        Initialise: function InitialiseFn() {
            JamSystem.StoreShopManager.EmptyBasket();
            var i = 0;
            for (i = 0; i < NUM_PAGES; i += 1) {
                Debug.Log("PACK " + i + " Purchased? " + this.IsPackPurchased(i))
            }
        },
        IsPackPurchased: function IsPackPurchasedFn(Page) {
            if (!Application.AllowPayment) {
                return true
            }
            if (Page === 0) {
                return true
            }
            var Items = JamSystem.StoreShopManager.GetItems();
            var UserItems = JamSystem.StoreShopManager.GetUserItems();
            if (UserItems) {
                if (UserItems.hasOwnProperty("packA") && Page === 1) {
                    return true
                }
                if (UserItems.hasOwnProperty("packB") && Page === 2) {
                    return true
                }
                if (UserItems.hasOwnProperty("packC") && Page === 3) {
                    return true
                }
                if (UserItems.hasOwnProperty("packD") && Page === 4) {
                    return true
                }
                if (UserItems.hasOwnProperty("packE") && Page === 5) {
                    return true
                }
                if (UserItems.hasOwnProperty("packF")) {
                    return true
                }
            }
            return false
        },
        DisplayBuyGame: function DisplayBuyGameFn(Page) {
            GlobalMain.MusicManager.SetVolume(.25);
            Helpers.PlaySound("QuestPreview");
            this.Backing = Helpers.CreateSprite(0, 0, EA.TopLeft, "BuyGame", GadgetTree.GetLayer(LAYERS_HUD));
            var Lookup = "DATATEXT_ID_UPSELL_PACK_NAME_" + Page;
            var Text = JamSystem.TextManager.GetText(Lookup);
            this.ConfirmText = Helpers.CreateBitmapText(Text, JamSystem.RenderManager.GetScreenWidth() / 2 + 375, 195, EA.Default, "PanelFont", GadgetTree.GetLayer(LAYERS_HUD));
            this.DifficultyUnderText = Helpers.CreateBitmapText("*****", JamSystem.RenderManager.GetScreenWidth() / 2 + 235, 385, EA.MiddleLeft, "PanelFont", GadgetTree.GetLayer(LAYERS_HUD));
            this.DifficultyUnderText.SetScale(.9, .9);
            this.DifficultyUnderText.SetColour([.8, .8, .8, .5]);
            Lookup = "DATATEXT_ID_UPSELL_DIFFICULTY_" + (Page + 1);
            Text = JamSystem.TextManager.GetText(Lookup);
            this.DifficultyText = Helpers.CreateBitmapText(Text, JamSystem.RenderManager.GetScreenWidth() / 2 + 235, 385, EA.MiddleLeft, "PanelFont", GadgetTree.GetLayer(LAYERS_HUD));
            this.DifficultyText.SetScale(.9, .9);
            this.YesButton = Helpers.CreateSprite(JamSystem.RenderManager.GetScreenWidth() / 2 + 150, 600, EA.Default, "ButtonYes", GadgetTree.GetLayer(LAYERS_HUD));
            dwWidth = this.YesButton.GetWidth();
            dwHeight = this.YesButton.GetHeight();
            this.YesButtonArea = {};
            this.YesButtonArea.x = this.YesButton.GetPositionX() - dwWidth * .5;
            this.YesButtonArea.y = this.YesButton.GetPositionY() - dwHeight * .5;
            this.YesButtonArea.x2 = this.YesButton.GetPositionX() + dwWidth * .5;
            this.YesButtonArea.y2 = this.YesButton.GetPositionY() + dwHeight * .5;
            Touch.Add(this.YesButtonArea);
            this.OKButton = Helpers.CreateSprite(JamSystem.RenderManager.GetScreenWidth() / 2, 300, EA.Default, "ButtonYes", GadgetTree.GetLayer(LAYERS_HUD));
            dwWidth = this.OKButton.GetWidth();
            dwHeight = this.OKButton.GetHeight();
            this.OKButtonArea = {};
            this.OKButtonArea.x = this.OKButton.GetPositionX() - dwWidth * .5;
            this.OKButtonArea.y = this.OKButton.GetPositionY() - dwHeight * .5;
            this.OKButtonArea.x2 = this.OKButton.GetPositionX() + dwWidth * .5;
            this.OKButtonArea.y2 = this.OKButton.GetPositionY() + dwHeight * .5;
            this.OKButton.SetIsVisible(false);
            this.NoButton = Helpers.CreateSprite(JamSystem.RenderManager.GetScreenWidth() / 2 + 410, 600, EA.Default, "ButtonNo", GadgetTree.GetLayer(LAYERS_HUD));
            dwWidth = this.NoButton.GetWidth();
            dwHeight = this.NoButton.GetHeight();
            this.NoButtonArea = {};
            this.NoButtonArea.x = this.NoButton.GetPositionX() - dwWidth * .5;
            this.NoButtonArea.y = this.NoButton.GetPositionY() - dwHeight * .5;
            this.NoButtonArea.x2 = this.NoButton.GetPositionX() + dwWidth * .5;
            this.NoButtonArea.y2 = this.NoButton.GetPositionY() + dwHeight * .5;
            Touch.Add(this.NoButtonArea);
            this.BuyAllButton = Helpers.CreateSprite(JamSystem.RenderManager.GetScreenWidth() / 2 + 280, 600, EA.Default, "ButtonBuyAll", GadgetTree.GetLayer(LAYERS_HUD));
            dwWidth = this.BuyAllButton.GetWidth();
            dwHeight = this.BuyAllButton.GetHeight();
            this.BuyAllButtonArea = {};
            this.BuyAllButtonArea.x = this.BuyAllButton.GetPositionX() - dwWidth * .5;
            this.BuyAllButtonArea.y = this.BuyAllButton.GetPositionY() - dwHeight * .5;
            this.BuyAllButtonArea.x2 = this.BuyAllButton.GetPositionX() + dwWidth * .5;
            this.BuyAllButtonArea.y2 = this.BuyAllButton.GetPositionY() + dwHeight * .5;
            Touch.Add(this.BuyAllButtonArea);
            this.DontAllowContinue = true;
            this.DoneBought = false;
            this.PurchaseAttempted = false;
            this.Page = Page;
            this.Timer = 0;
            this.SuperCheatOpen = false;
            GlobalMain.MetricsManager.SeePaymentScreen(this.Page)
        },
        CanIProgress: function CanIProgressFn() {
            var Complete = JamSystem.StoreShopManager.CheckoutComplete && !this.DontAllowContinue;
            if (Complete && this.ConfirmText) {
                Helpers.DestroyBitmapText(this.ConfirmText);
                this.ConfirmText = null;
                GlobalMain.MusicManager.SetVolume(1)
            }
            if (Complete && this.OKButton) {
                Helpers.DestroySprite(this.OKButton);
                Touch.Remove(this.OKButtonArea);
                this.OKButton = null
            }
            return Complete
        },
        ShowBoughtGame: function BuyGameFn() {
            var psEffect = EntityEffect.Create(0, 0, ENTITYEFFECT_TYPE_SCREEN_FLASH_LONGER, GadgetTree.GetLayer(LAYERS_HUD));
            EntityManager.Add(psEffect);
            if (this.Page === -1) {
                LevelSelect.UpdateInfo(false);
                LevelSelect.dwScript = Script.Add(ScriptData.BoughtAll);
                LevelSelect.eMode = LEVELSELECT_MODE_NORMAL_COMPLETE
            }
            GlobalMain.MusicManager.SetVolume(1);
            GlobalMain.MetricsManager.PaymentSuccessful(this.Page)
        },
        ShowRejectedGame: function BuyGameFn() {
            GlobalMain.MusicManager.SetVolume(1);
            if (this.PurchaseAttempted) {
                GlobalMain.MetricsManager.PaymentFailed(this.Page)
            }
        },
        Update: function UpdateFn(TimeDelta) {
            var psArea = null;
            if (this.YesButton || this.OKButton) {
                psArea = Touch.Test(JamSystem.InputManager.GetMouseButtonPressed(0))
            }
            if (this.YesButton) {
                if (psArea === this.YesButtonArea) {
                    Globals.BounceImage(this.YesButton);
                    var Pack = "packA";
                    if (this.Page === 2) {
                        Pack = "packB"
                    } else if (this.Page === 3) {
                        Pack = "packC"
                    } else if (this.Page === 4) {
                        Pack = "packD"
                    } else if (this.Page === 5) {
                        Pack = "packE"
                    }
                    JamSystem.StoreShopManager.EmptyBasket();
                    JamSystem.StoreShopManager.AddToBasket(Pack, 1);
                    JamSystem.StoreShopManager.ShowConfirmPurchase();
                    GlobalMain.MetricsManager.AcceptPayment(this.Page);
                    this.PurchaseAttempted = true;
                    this.ButtonPressed = true;
                    return
                }
            }
            if (this.NoButton) {
                if (psArea === this.NoButtonArea) {
                    Globals.BounceImage(this.NoButton);
                    JamSystem.StoreShopManager.EmptyBasket();
                    GlobalMain.MetricsManager.DeclinePayment(this.Page);
                    this.PurchaseAttempted = false;
                    this.ButtonPressed = true;
                    return
                }
            }
            if (this.BuyAllButton) {
                if (psArea === this.BuyAllButtonArea) {
                    Globals.BounceImage(this.BuyAllButton);
                    JamSystem.StoreShopManager.EmptyBasket();
                    this.Page = -1;
                    JamSystem.StoreShopManager.AddToBasket("packF", 1);
                    JamSystem.StoreShopManager.ShowConfirmPurchase();
                    GlobalMain.MetricsManager.AcceptPayment(this.Page);
                    this.PurchaseAttempted = true;
                    this.ButtonPressed = true;
                    return
                }
            }
            if (Script.GetIsFinished(LevelSelect.dwScript)) {
                if (!this.SuperCheatOpen) {
                    this.SuperCheatOpen = JamSystem.InputManager.GetKeyPressed(0) && Application.Cheats
                }
                if (JamSystem.StoreShopManager.CheckoutComplete && this.ButtonPressed && this.DontAllowContinue || this.SuperCheatOpen) {
                    this.Timer += TimeDelta;
                    if (this.YesButton) {
                        Helpers.DestroySprite(this.YesButton);
                        Touch.Remove(this.YesButtonArea);
                        this.YesButton = null
                    }
                    if (this.NoButton) {
                        Helpers.DestroySprite(this.NoButton);
                        Touch.Remove(this.NoButtonArea);
                        this.NoButton = null
                    }
                    if (this.BuyAllButton) {
                        Helpers.DestroySprite(this.BuyAllButton);
                        Touch.Remove(this.BuyAllButtonArea);
                        this.BuyAllButton = null
                    }
                    if (this.Backing) {
                        Helpers.DestroySprite(this.Backing);
                        this.Backing = null
                    }
                    if (this.ConfirmText) {
                        Helpers.DestroyBitmapText(this.ConfirmText);
                        this.ConfirmText = null
                    }
                    if (this.DifficultyText) {
                        Helpers.DestroySprite(this.DifficultyText);
                        this.DifficultyText = null
                    }
                    if (this.DifficultyUnderText) {
                        Helpers.DestroySprite(this.DifficultyUnderText);
                        this.DifficultyUnderText = null
                    }
                    if (!this.DoneBought) {
                        if (this.IsPackPurchased(this.Page) || this.SuperCheatOpen) {
                            this.ShowBoughtGame();
                            Helpers.PlaySound("BoughtGame");
                            this.DoneBought = true
                        } else {
                            this.ShowRejectedGame();
                            Helpers.PlaySound("NoPurchase");
                            this.DoneBought = true;
                            this.Timer = 4
                        }
                    }
                    if (this.Timer > 3) {
                        this.DontAllowContinue = false;
                        this.ButtonPressed = false
                    }
                }
            }
        },
        Destroy: function DestroyFn() {}
    };
    GameStoreManager.Create = function CreateFn() {
        var NewObject = new GameStoreManager;
        GlobalMain.GameStoreManager = NewObject;
        NewObject.Initialise();
        NewObject.Backing = null;
        NewObject.DontAllowContinue = false;
        NewObject.ButtonPressed = false;
        NewObject.DoneBought = false;
        NewObject.PurchaseAttempted = false;
        NewObject.Timer = 0;
        return NewObject
    };

    function LifetimeStatManager() {}
    LifetimeStatManager.Version = 0;
    LifetimeStatManager.SavedDataCallback = function SavedDataCallbackFn(Key, Success) {
        if (!Success) {
            Debug.Log("****** LifetimeStatManager Save Data failed")
        }
    };
    LifetimeStatManager.LoadedProgressCallback = function LoadedProgressCallbackFn(key, complexObject) {
        Debug.Log("LIFETIMESTATSCALLBACK ******************************************");
        var ths = GlobalMain.LifetimeStatManager;
        if (!complexObject) {
            Debug.Log("****** Lifetime progress data Failed");
            ths.LoadedData = false;
            return
        }
        if (complexObject.Version !== LifetimeStatManager.Version) {
            Debug.Log("****** Lifetime data out of date");
            ths.LoadedData = false;
            return
        }
        var i = 0;
        if (key === "LifetimeData" && complexObject) {
            ths.SavedState = complexObject;
            ths.LoadedData = true
        }
        ths.CallbackReturned = true
    };
    LifetimeStatManager.prototype = {
        SetLevelFinished: function SetLevelFinishedFn(Level, Moves, Time, Score, ChallengeDone) {
            var AllowSave = false;
            if (this.SavedState.Levels[Level].Played) {
                if (this.SavedState.Levels[Level].Moves === 0 || this.SavedState.Levels[Level].Moves > Moves) {
                    this.SavedState.Levels[Level].Moves = Moves;
                    AllowSave = true
                }
                if (this.SavedState.Levels[Level].Time === 0 || this.SavedState.Levels[Level].Time > Time) {
                    this.SavedState.Levels[Level].Time = Time;
                    AllowSave = true
                }
                if (this.SavedState.Levels[Level].Score === 0 || this.SavedState.Levels[Level].Score < Score) {
                    this.SavedState.Levels[Level].Score = Score;
                    AllowSave = true
                }
            } else {
                this.SavedState.Levels[Level].Moves = Moves;
                this.SavedState.Levels[Level].Time = Time;
                this.SavedState.Levels[Level].Score = Score;
                AllowSave = true
            }
            if (!this.SavedState.Levels[Level].ChallengeDone) {
                this.SavedState.Levels[Level].ChallengeDone = ChallengeDone;
                AllowSave = true
            }
            if (AllowSave) {
                GlobalMain.TurbulenzProducts.SetLeaderboardScore(this.GetTotalScore());
                this.DataRequiresSaved = true
            }
        },
        SetPlayed: function SetPlayedFn(Level) {
            this.SavedState.Levels[Level].Played = true;
            this.DataRequiresSaved = true
        },
        GetPlayed: function GetPlayedFn(Level) {
            return this.SavedState.Levels[Level].Played
        },
        GetCompleted: function GetCompletedFn(Level) {
            return this.SavedState.Levels[Level].Score > 0
        },
        GetMoves: function GetMovesFn(Level) {
            return this.SavedState.Levels[Level].Moves
        },
        GetTime: function GetTimeFn(Level) {
            return this.SavedState.Levels[Level].Time
        },
        GetScore: function GetScoreFn(Level) {
            return this.SavedState.Levels[Level].Score
        },
        GetChallengeDone: function GetChallengeDoneFn(Level) {
            return this.SavedState.Levels[Level].ChallengeDone
        },
        GetTotalScore: function GetTotalScoreFn() {
            var Total = 0,
                i = 0;
            for (i = 0; i < this.SavedState.Levels.length; i += 1) {
                Total += this.SavedState.Levels[i].Score
            }
            return Total
        },
        GetTotalCompleted: function GetTotalCompletedFn() {
            var Total = 0,
                i = 0;
            for (i = 0; i < this.SavedState.Levels.length; i += 1) {
                if (this.SavedState.Levels[i].Score > 0) {
                    Total += 1
                }
            }
            return Total
        },
        SetPageCompletedSeen: function SetPageCompletedSeenFn(Page) {
            this.SavedState.Page[Page].CompleteSeen = true;
            this.DataRequiresSaved = true
        },
        GetPageCompletedSeen: function GetPageCompletedSeenFn(Page) {
            return this.SavedState.Page[Page].CompleteSeen
        },
        SetSecretUnlockedSeen: function SetPageCompletedSeenFn(Page) {
            this.SavedState.Page[Page].SecretUnlockedSeen = true;
            this.DataRequiresSaved = true
        },
        GetSecretUnlockedSeen: function GetSecretUnlockedSeenFn(Page) {
            return this.SavedState.Page[Page].SecretUnlockedSeen
        },
        SetSetCompletedSeen: function SetSetCompletedSeenFn(Page) {
            this.SavedState.Page[Page].SetCompletedSeen = true;
            this.DataRequiresSaved = true
        },
        GetSetCompletedSeen: function GetSetCompletedSeenFn(Page) {
            return this.SavedState.Page[Page].SetCompletedSeen
        },
        GetPageCompleted: function GetPageCompletedFn(Page) {
            var Count;
            var Theme = Page / 2;
            var Start = Theme * TOTAL_LEVELS;
            if ((Page & 1) === 0) {
                Count = TOTAL_NORMAL_LEVELS
            } else {
                Start += TOTAL_NORMAL_LEVELS;
                Count = TOTAL_SECRET_LEVELS
            }
            var Completed = 0,
                i = 0;
            for (i = Start; i < Start + Count; i += 1) {
                if (this.GetPlayed(i) && this.GetScore(i) !== 0) {
                    Completed += 1
                }
            }
            return Completed === Count
        },
        GetLevelsCompleted: function GetLevelsCompletedFn(Page, Secret) {
            var Completed = 0;
            var Start = Page * TOTAL_LEVELS;
            var NumLevels = TOTAL_NORMAL_LEVELS;
            if (Secret) {
                Start += TOTAL_NORMAL_LEVELS;
                NumLevels = TOTAL_SECRET_LEVELS
            }
            var j = 0;
            for (j = 0; j < NumLevels; j += 1) {
                if (this.GetCompleted(Start + j)) {
                    Completed += 1
                }
            }
            return Completed
        },
        GetAllChallengesCompleted: function GetAllChallengesCompletedFn(StarsOnly) {
            var j = 0,
                Count = 0;
            for (j = 0; j < NUM_PAGES; j += 1) {
                Count += this.GetChallengesCompleted(j, false);
                if (!StarsOnly) {
                    Count += this.GetChallengesCompleted(j, true)
                }
            }
            return Count
        },
        GetAllSecretPagesOpen: function GetAllSecretPagesOpenFn() {
            var i, Count = 0;
            for (i = 0; i < NUM_PAGES; i += 1) {
                if (Records.GetChallengesCompleted(i, 0) >= STARS_PER_SECRET) {
                    Count += 1
                }
            }
            return Count
        },
        GetChallengesCompleted: function GetChallengesCompletedFn(Page, Secret) {
            var Completed = 0;
            var Start = Page * TOTAL_LEVELS;
            var NumLevels = TOTAL_NORMAL_LEVELS;
            if (Secret) {
                Start += TOTAL_NORMAL_LEVELS;
                NumLevels = TOTAL_SECRET_LEVELS
            }
            var j = 0;
            for (j = 0; j < NumLevels; j += 1) {
                if (this.GetChallengeDone(Start + j)) {
                    Completed += 1
                }
            }
            return Completed
        },
        GetAllNormalCompleted: function GetAllNormalCompletedFn() {
            var i = 0,
                j = 0;
            for (j = 0; j < NUM_PAGES; j += 1) {
                for (i = 0; i < TOTAL_NORMAL_LEVELS; i += 1) {
                    var k = j * TOTAL_LEVELS + i;
                    if (!this.GetPlayed(k) || this.GetScore(k) === 0) {
                        return false
                    }
                }
            }
            return true
        },
        SetAllNormalCompletedSeen: function SetAllNormalCompletedSeenFn() {
            this.SavedState.AllNormalComplete = true;
            this.DataRequiresSaved = true
        },
        GetAllNormalCompletedSeen: function GetAllNormalCompletedSeenFn() {
            return this.SavedState.AllNormalComplete
        },
        GetAllNormalBonusCompleted: function GetAllNormalBonusCompletedFn() {
            var i = 0,
                j = 0;
            for (j = 0; j < NUM_PAGES; j += 1) {
                for (i = 0; i < TOTAL_NORMAL_LEVELS; i += 1) {
                    var k = j * TOTAL_LEVELS + i;
                    if (!this.GetChallengeDone(k)) {
                        return false
                    }
                }
            }
            return true
        },
        SetAllNormalBonusCompletedSeen: function SetAllNormalBonusCompletedSeenFn() {
            this.SavedState.AllNormalBonusComplete = true;
            this.DataRequiresSaved = true
        },
        GetAllNormalBonusCompletedSeen: function GetAllNormalBonusCompletedSeenFn() {
            return this.SavedState.AllNormalBonusComplete
        },
        GetAllSecretCompleted: function GetAllSecretCompletedFn() {
            var i = 0,
                j = 0;
            for (j = 0; j < NUM_PAGES; j += 1) {
                for (i = 0; i < TOTAL_SECRET_LEVELS; i += 1) {
                    var k = j * TOTAL_LEVELS + TOTAL_NORMAL_LEVELS + i;
                    if (!this.GetPlayed(k) || this.GetScore(k) === 0) {
                        return false
                    }
                }
            }
            return true
        },
        SetAllSecretCompletedSeen: function SetAllSecretCompletedSeenFn() {
            this.SavedState.AllSecretComplete = true;
            this.DataRequiresSaved = true
        },
        GetAllSecretCompletedSeen: function GetAllSecretCompletedSeenFn() {
            return this.SavedState.AllSecretComplete
        },
        GetAllCompleted: function GetAllCompletedFn() {
            var i = 0;
            for (i = 0; i < NUM_LEVELS; i += 1) {
                if (!this.GetPlayed(i) || this.GetScore(i) === 0) {
                    return false
                }
            }
            return true
        },
        SetAllCompletedSeen: function SetAllCompletedSeenFn() {
            this.SavedState.AllComplete = true;
            this.DataRequiresSaved = true
        },
        GetAllCompletedSeen: function GetAllCompletedSeenFn() {
            return this.SavedState.AllComplete
        },
        GetAllChallenge: function GetAllChallengeFn() {
            var i = 0;
            for (i = 0; i < NUM_LEVELS; i += 1) {
                if (!this.GetPlayed(i) || !this.GetChallengeDone(i)) {
                    return false
                }
            }
            return true
        },
        SetAllChallengeSeen: function SetAllChallengeSeenFn() {
            this.SavedState.AllChallenge = true;
            this.DataRequiresSaved = true
        },
        GetAllChallengeSeen: function GetAllChallengeSeenFn() {
            return this.SavedState.AllChallenge
        },
        SetFirstPlaySeen: function SetFirstPlaySeenFn() {
            this.SavedState.FirstPlay = true;
            this.DataRequiresSaved = true
        },
        GetFirstPlaySeen: function GetFirstPlaySeenFn() {
            return this.SavedState.FirstPlay
        },
        SetHelpSeen: function SetHelpSeenFn() {
            this.SavedState.Help = true;
            this.DataRequiresSaved = true
        },
        GetHelpSeen: function GetHelpSeenFn() {
            return this.SavedState.Help
        },
        SetFlipSeen: function SetFlipSeenFn() {
            this.SavedState.Flip = true;
            this.DataRequiresSaved = true
        },
        GetFlipSeen: function GetFlipSeenFn() {
            return this.SavedState.Flip
        },
        SetFirstPageCeremonySeen: function SetFirstPageCeremonySeenFn() {
            this.SavedState.FirstPageCeremonySeen = true;
            this.DataRequiresSaved = true
        },
        GetFirstPageCeremonySeen: function GetFirstPageCeremonySeenFn() {
            return this.SavedState.FirstPageCeremonySeen
        },
        SaveAnyData: function SaveAnyDataFn() {
            if (this.DataRequiresSaved) {
                this.SavedState.Version = LifetimeStatManager.Version;
                JamSystem.SaveDataManager.SaveData("LifetimeData", this.SavedState, LifetimeStatManager.SavedDataCallback);
                this.TimeDelay = 0;
                this.DataRequiresSaved = false
            }
            this.LoadedData = true
        },
        Clear: function ClearFn() {
            this.SavedState.Levels = [];
            this.SavedState.Page = [];
            this.SavedState.AllNormalComplete = false;
            this.SavedState.AllNormalBonusComplete = false;
            this.SavedState.AllSecretComplete = false;
            this.SavedState.AllComplete = false;
            this.SavedState.AllChallenge = false;
            this.SavedState.Help = false;
            this.SavedState.FirstPageCeremonySeen = false;
            this.SavedState.Flip = false;
            var i = 0;
            for (i = 0; i < NUM_LEVELS; i += 1) {
                this.SavedState.Levels[i] = {};
                this.SavedState.Levels[i].Played = false;
                this.SavedState.Levels[i].Moves = 0;
                this.SavedState.Levels[i].Time = 0;
                this.SavedState.Levels[i].Score = 0;
                this.SavedState.Levels[i].ChallengeDone = false
            }
            for (i = 0; i < NUM_PAGES * 2; i += 1) {
                this.SavedState.Page[i] = {};
                this.SavedState.Page[i].CompleteSeen = false;
                this.SavedState.Page[i].SecretUnlockedSeen = false;
                this.SavedState.Page[i].SetCompletedSeen = false
            }
            this.DataRequiresSaved = true
        },
        Reset: function ResetFn() {},
        Update: function UpdateFn(TimeDelta) {
            this.SaveAnyData()
        },
        Destroy: function DestroyFn() {}
    };
    LifetimeStatManager.Create = function CreateFn() {
        var NewObject = new LifetimeStatManager;
        GlobalMain.LifetimeStatManager = NewObject;
        NewObject.SavedState = {};
        NewObject.Clear();
        NewObject.DataRequiresSaved = false;
        NewObject.CallbackReturned = false;
        Debug.Log("Request Lifetime Stat Data");
        JamSystem.SaveDataManager.LoadData("LifetimeData", LifetimeStatManager.LoadedProgressCallback);
        return NewObject
    };

    function MetricsManager() {}
    MetricsManager.prototype = {
        Fullscreen: function FullscreenFn(UsedMouse) {
            var Value = 0;
            if (UsedMouse) {
                Value = 1
            }
            JamSystem.SendMetricEvent("Fullscreen", Value)
        },
        ToggleAudio: function ToggleAudioFn(UsedMouse) {
            var Value = 0;
            if (UsedMouse) {
                Value = 1
            }
            JamSystem.SendMetricEvent("ToggleAudio", Value)
        },
        EndSession: function EndSessionFn() {
            JamSystem.SendMetricEvent("EndSession", 0)
        },
        ClearData: function ClearDataFn() {
            JamSystem.SendMetricEvent("ClearData", 0)
        },
        ViewHelp: function ViewHelpFn() {
            JamSystem.SendMetricEvent("ViewHelp", 0)
        },
        StartGame: function StartGameFn(Level) {
            JamSystem.SendMetricEvent("StartGame", Level)
        },
        PauseGame: function PauseGameFn() {
            JamSystem.SendMetricEvent("PauseGame", 0)
        },
        QuitGame: function QuitGameFn() {
            JamSystem.SendMetricEvent("QuitGame", 0)
        },
        RestartGame: function RestartGameFn() {
            JamSystem.SendMetricEvent("RestartGame", 0)
        },
        EndGame: function EndGameFn(Score, Moves, Time, ChallengeDone) {
            var ArrayVals = [Score, Moves, Time, 0];
            if (ChallengeDone) {
                ArrayVals[3] = 1
            }
            JamSystem.SendMetricEvent("EndGame", ArrayVals)
        },
        SeePaymentScreen: function SeePaymentScreenFn(Page) {
            JamSystem.SendMetricEvent("SeePaymentScreen", Page)
        },
        AcceptPayment: function AcceptPaymentFn(Page) {
            JamSystem.SendMetricEvent("AcceptPayment", Page)
        },
        DeclinePayment: function DeclinePaymentFn(Page) {
            JamSystem.SendMetricEvent("DeclinePayment", Page)
        },
        PaymentFailed: function PaymentFailedFn(Page) {
            JamSystem.SendMetricEvent("PaymentFailed", Page)
        },
        PaymentSuccessful: function PaymentSuccessfulFn(Page) {
            JamSystem.SendMetricEvent("PaymentSuccessful", Page)
        }
    };
    MetricsManager.Create = function CreateFn() {
        var NewObject = new MetricsManager;
        GlobalMain.MetricsManager = NewObject;
        var ArrayVals = [0, 0, 0, 0, 0, 0, 0];
        if (JamSystem.GetCanvasMode()) {
            ArrayVals[0] = 1
        }
        var UserItems = JamSystem.StoreShopManager.GetUserItems();
        if (UserItems) {
            if (UserItems.hasOwnProperty("packA")) {
                ArrayVals[1] = 1
            }
            if (UserItems.hasOwnProperty("packB")) {
                ArrayVals[2] = 1
            }
            if (UserItems.hasOwnProperty("packC")) {
                ArrayVals[3] = 1
            }
            if (UserItems.hasOwnProperty("packD")) {
                ArrayVals[4] = 1
            }
            if (UserItems.hasOwnProperty("packE")) {
                ArrayVals[5] = 1
            }
            if (UserItems.hasOwnProperty("packF")) {
                ArrayVals[6] = 1
            }
        }
        JamSystem.SendMetricEvent("StartSession", ArrayVals);
        return NewObject
    };

    function SystemsManager() {}
    SystemsManager.Reset = function ResetFn() {
        GlobalMain.LifetimeStatManager.Reset();
        GlobalMain.ProductManager.Reset();
        GlobalMain.MusicManager.Reset();
        JamSystem.ScriptManager.StopAll()
    };
    SystemsManager.Update = function UpdateFn(TimeDelta) {
        GlobalMain.LifetimeStatManager.Update(TimeDelta);
        GlobalMain.ProductManager.Update(TimeDelta);
        GlobalMain.ShopManager.Update(TimeDelta);
        GlobalMain.MusicManager.Update(TimeDelta);
        JamSystem.ScriptManager.Update(TimeDelta);
        Globals.Update()
    };
    SystemsManager.UpdatePaused = function UpdatePausedFn(TimeDelta) {};
    SystemsManager.Destroy = function DestroyFn() {
        GlobalMain.LifetimeStatManager.Destroy();
        GlobalMain.ProductManager.Destroy();
        GlobalMain.ShopManager.Destroy();
        GlobalMain.MusicManager.Destroy();
        Globals.ShutDown();
        GadgetTree.ShutDown()
    };
    SystemsManager.Init = function InitFn() {
        GlobalMain.ScriptRootTree = Helpers.CreateTree(0, 0, GlobalMain.RootTree);
        JamSystem.ScriptManager.SetRootTree(GlobalMain.ScriptRootTree);
        GlobalMain.MetricsManager = MetricsManager.Create();
        GlobalMain.ProductManager = TurbulenzProducts.Create();
        GlobalMain.MusicManager = MusicManager.Create();
        GadgetTree.Init();
        Globals.Init();
        Globals.Setup()
    };

    function TurbulenzProducts() {}
    TurbulenzProducts.LoadedDataCallback = function LoadedDataCallbackFn(userBadge) {
        Debug.Log("Badge Data Callback");
        var ths = GlobalMain.ProductManager;
        if (!userBadge) {
            Debug.Log("****** Badge data Failed");
            ths.LoadedTurbulenzData = false;
            return
        }
        ths.LoadedTurbulenzData = true;
        var i;
        for (i = 0; i < userBadge.length; i += 1) {
            if (userBadge[i].badge_key === "aBadgeStarPower") {
                Debug.Log("Badge STAR POWER Progress : " + userBadge[i].current + "/" + userBadge[i].total);
                ths.StarPowerLastSize = userBadge[i].current;
                if (userBadge[i].current === userBadge[i].total) {
                    Debug.Log("UNLOCKED STAR POWER BADGE");
                    ths.StarPowerBadgeUnlocked = true
                }
                break
            }
            if (userBadge[i].badge_key === "aBadgeSpecialOne") {
                Debug.Log("Badge SPECIAL ONE Progress : " + userBadge[i].current + "/" + userBadge[i].total);
                ths.SpecialOneLastSize = userBadge[i].current;
                if (userBadge[i].current === userBadge[i].total) {
                    Debug.Log("UNLOCKED SPECIAL ONE BADGE");
                    ths.SpecialOneBadgeUnlocked = true
                }
                break
            }
            if (userBadge[i].badge_key === "aBadgeImIn") {
                Debug.Log("Badge I'M IN Progress : " + userBadge[i].current + "/" + userBadge[i].total);
                ths.ImInLastSize = userBadge[i].current;
                if (userBadge[i].current === userBadge[i].total) {
                    Debug.Log("UNLOCKED I'M IN");
                    ths.ImInBadgeUnlocked = true
                }
                break
            }
            if (userBadge[i].badge_key === "aBadgeMasterClass") {
                Debug.Log("Badge MASTER CLASS Progress : " + userBadge[i].current + "/" + userBadge[i].total);
                ths.MasterClassLastSize = userBadge[i].current;
                if (userBadge[i].current === userBadge[i].total) {
                    Debug.Log("UNLOCKED MASTER CLASS BADGE");
                    ths.MasterClassBadgeUnlocked = true
                }
                break
            }
            if (userBadge[i].badge_key === "aBadgeChipBlock") {
                Debug.Log("Badge CHIP BLOCK Progress : " + userBadge[i].current + "/" + userBadge[i].total);
                ths.ChipBlockLastSize = userBadge[i].current;
                if (userBadge[i].current === userBadge[i].total) {
                    Debug.Log("UNLOCKED CHIP BLOCK BADGE");
                    ths.ChipBlockBadgeUnlocked = true
                }
                break
            }
            if (userBadge[i].badge_key === "aBadgeMagic20") {
                Debug.Log("Badge MAGIC 20 Progress : " + userBadge[i].current + "/" + userBadge[i].total);
                ths.Magic20LastSize = userBadge[i].current;
                if (userBadge[i].current === userBadge[i].total) {
                    Debug.Log("UNLOCKED MAGIC 20 BADGE");
                    ths.Magic20BadgeUnlocked = true
                }
                break
            }
            if (userBadge[i].badge_key === "aBadgeUnderground20") {
                Debug.Log("Badge UNDERGROUND 20 Progress : " + userBadge[i].current + "/" + userBadge[i].total);
                ths.Underground20LastSize = userBadge[i].current;
                if (userBadge[i].current === userBadge[i].total) {
                    Debug.Log("UNLOCKED UNDERGROUND 20 BADGE");
                    ths.Underground20BadgeUnlocked = true
                }
                break
            }
            if (userBadge[i].badge_key === "aBadgeDragonDen20") {
                Debug.Log("Badge DRAGON DEN 20 Progress : " + userBadge[i].current + "/" + userBadge[i].total);
                ths.DragonDen20LastSize = userBadge[i].current;
                if (userBadge[i].current === userBadge[i].total) {
                    Debug.Log("UNLOCKED DRAGON DEN 20 BADGE");
                    ths.DragonDen20BadgeUnlocked = true
                }
                break
            }
        }
    };
    TurbulenzProducts.prototype = {
        SetLeaderboardScore: function SetLeaderboardScoreFn(Score) {
            JamSystem.LeaderboardsManager.Set("aTotalScore", Score)
        },
        Clear: function ClearFn() {},
        Reset: function ResetFn() {},
        Update: function UpdateFn(TimeDelta) {
            if (!this.StarPowerBadgeUnlocked) {
                var Amount = GlobalMain.LifetimeStatManager.GetAllChallengesCompleted(true);
                if (Amount > this.StarPowerLastSize) {
                    JamSystem.AchievementsManager.Update("aBadgeStarPower", Amount);
                    this.StarPowerLastSize = Amount;
                    if (Amount >= 50) {
                        Debug.Log("UNLOCKED STAR POWER");
                        this.StarPowerBadgeUnlocked = true
                    }
                }
            }
            if (!this.SpecialOneBadgeUnlocked) {
                var Amount = GlobalMain.LifetimeStatManager.GetAllSecretPagesOpen();
                if (Amount > this.SpecialOneLastSize) {
                    JamSystem.AchievementsManager.Update("aBadgeSpecialOne", Amount);
                    this.SpecialOneLastSize = Amount;
                    if (Amount >= 6) {
                        Debug.Log("UNLOCKED SPECIAL ONE");
                        this.SpecialOneBadgeUnlocked = true
                    }
                }
            }
            if (!this.ImInBadgeUnlocked) {
                var Amount = GlobalMain.LifetimeStatManager.GetLevelsCompleted(4, false) + GlobalMain.LifetimeStatManager.GetLevelsCompleted(5, false);
                if (Amount > this.ImInLastSize) {
                    JamSystem.AchievementsManager.Update("aBadgeImIn", Amount);
                    this.ImInLastSize = Amount;
                    if (Amount >= 32) {
                        Debug.Log("UNLOCKED I'M IN");
                        this.ImInBadgeUnlocked = true
                    }
                }
            }
            if (!this.MasterClassBadgeUnlocked) {
                var Amount = 0;
                Amount += GlobalMain.LifetimeStatManager.GetAllChallengesCompleted(false);
                if (Amount > this.MasterClassLastSize) {
                    JamSystem.AchievementsManager.Update("aBadgeMasterClass", Amount);
                    this.MasterClassLastSize = Amount;
                    if (Amount >= 120) {
                        Debug.Log("UNLOCKED MASTER CLASS");
                        this.MasterClassBadgeUnlocked = true
                    }
                }
            }
            if (!this.ChipBlockBadgeUnlocked) {
                var Amount = GlobalMain.LifetimeStatManager.GetAllChallengesCompleted(true);
                if (Amount > this.ChipBlockLastSize) {
                    JamSystem.AchievementsManager.Update("aBadgeChipBlock", Amount);
                    this.ChipBlockLastSize = Amount;
                    if (Amount >= 10) {
                        Debug.Log("UNLOCKED CHIP BLOCK");
                        this.ChipBlockBadgeUnlocked = true
                    }
                }
            }
            if (!this.Magic20BadgeUnlocked) {
                var Amount = GlobalMain.LifetimeStatManager.GetLevelsCompleted(0, false) + GlobalMain.LifetimeStatManager.GetLevelsCompleted(1, false);
                Amount += GlobalMain.LifetimeStatManager.GetLevelsCompleted(0, true) + GlobalMain.LifetimeStatManager.GetLevelsCompleted(1, true);
                if (Amount > this.Magic20LastSize) {
                    JamSystem.AchievementsManager.Update("aBadgeMagic20", Amount);
                    this.Magic20LastSize = Amount;
                    if (Amount >= 20) {
                        Debug.Log("UNLOCKED MAGIC 20");
                        this.Magic20BadgeUnlocked = true
                    }
                }
            }
            if (!this.Underground20BadgeUnlocked) {
                var Amount = GlobalMain.LifetimeStatManager.GetLevelsCompleted(2, false) + GlobalMain.LifetimeStatManager.GetLevelsCompleted(3, false);
                Amount += GlobalMain.LifetimeStatManager.GetLevelsCompleted(2, true) + GlobalMain.LifetimeStatManager.GetLevelsCompleted(3, true);
                if (Amount > this.Underground20LastSize) {
                    JamSystem.AchievementsManager.Update("aBadgeUnderground20", Amount);
                    this.Underground20LastSize = Amount;
                    if (Amount >= 20) {
                        Debug.Log("UNLOCKED UNDERGROUND 20");
                        this.Underground20BadgeUnlocked = true
                    }
                }
            }
            if (!this.DragonDen20BadgeUnlocked) {
                var Amount = GlobalMain.LifetimeStatManager.GetLevelsCompleted(4, false) + GlobalMain.LifetimeStatManager.GetLevelsCompleted(5, false);
                Amount += GlobalMain.LifetimeStatManager.GetLevelsCompleted(4, true) + GlobalMain.LifetimeStatManager.GetLevelsCompleted(5, true);
                if (Amount > this.DragonDen20LastSize) {
                    JamSystem.AchievementsManager.Update("aBadgeDragonDen20", Amount);
                    this.DragonDen20LastSize = Amount;
                    if (Amount >= 20) {
                        Debug.Log("UNLOCKED DRAGON 20");
                        this.DragonDen20BadgeUnlocked = true
                    }
                }
            }
        },
        Destroy: function DestroyFn() {}
    };
    TurbulenzProducts.Create = function CreateFn() {
        var NewObject = new TurbulenzProducts;
        GlobalMain.TurbulenzProducts = NewObject;
        NewObject.StarPowerLastSize = 0;
        NewObject.StarPowerBadgeUnlocked = false;
        NewObject.SpecialOneLastSize = 0;
        NewObject.SpecialOneBadgeUnlocked = false;
        NewObject.ImInLastSize = 0;
        NewObject.ImInBadgeUnlocked = false;
        NewObject.MasterClassLastSize = 0;
        NewObject.MasterClassBadgeUnlocked = false;
        NewObject.ChipBlockLastSize = 0;
        NewObject.ChipBlockBadgeUnlocked = false;
        NewObject.Magic20LastSize = 0;
        NewObject.Magic20BadgeUnlocked = false;
        NewObject.Underground20LastSize = 0;
        NewObject.Underground20BadgeUnlocked = false;
        NewObject.DragonDen20LastSize = 0;
        NewObject.DragonDen20BadgeUnlocked = false;
        NewObject.LoadedTurbulenzData = false;
        Debug.Log("Request Badge Unlock Data");
        JamSystem.AchievementsManager.GetAwarded(TurbulenzProducts.LoadedDataCallback);
        return NewObject
    };

    function CameraManager() {}
    CameraManager.ModeFree = 0;
    CameraManager.ModeTrackPlayer = 1;
    CameraManager.ModeTrackEnemy = 2;
    CameraManager.ModeTotal = 3;
    CameraManager.RandomCameraDelay = 4;
    CameraManager.prototype = {
        SetPosition: function SetPositionFn(x, y) {
            this.X = x;
            this.Y = y;
            this.PosTweener.Reset()
        },
        GetPosition: function GetPositionFn() {
            return new Vector2(this.X, this.Y)
        },
        MovePosition: function MovePositionFn(x, y, Time) {
            this.PosTweener.Set(Time, this.X, x, this.Y, y)
        },
        SetZoom: function SetZoomFn(NewZoom) {
            this.Zoom = NewZoom;
            this.ZoomTweener.Reset()
        },
        GetZoom: function GetZoomFn() {
            return this.Zoom
        },
        MoveZoom: function MoveZoomFn(Zoom, Time) {
            this.ZoomTweener.Set(Time, this.Zoom, Zoom, 0, 0)
        },
        SetRotation: function SetRotationFn(NewRotation) {
            this.Rotation = NewRotation;
            this.RotationTweener.Reset()
        },
        GetRotation: function GetRotationFn() {
            return this.Rotation
        },
        MoveRotation: function MoveRotationFn(Rotation, Time) {
            this.RotationTweener.Set(Time, this.Rotation, Rotation, 0, 0)
        },
        SetBounds: function SetBoundsFn(Top, Bottom, Left, Right) {
            this.BoundsTop = Top;
            this.BoundsBottom = Bottom;
            this.BoundsLeft = Left;
            this.BoundsRight = Right
        },
        SetViewDimensions: function SetViewDimensionsFn(x, y) {
            this.ViewWidth = x;
            this.ViewHeight = y
        },
        FinalisePosition: function FinalisePositionFn(x, y) {
            GlobalMain.World.RootTreeTranslate.SetPosition(this.ViewWidth / 2, this.ViewHeight / 2);
            var Zoom = 1 / this.Camera.GetAdjustedZoom();
            var HalfScreenWidth = this.ViewWidth * Zoom / 2;
            var HalfScreenHeight = this.ViewHeight * Zoom / 2;
            if (x < this.BoundsLeft + HalfScreenWidth) {
                x = this.BoundsLeft + HalfScreenWidth
            }
            if (x > this.BoundsRight - HalfScreenWidth) {
                x = this.BoundsRight - HalfScreenWidth
            }
            if (y > this.BoundsBottom - HalfScreenHeight) {
                y = this.BoundsBottom - HalfScreenHeight
            }
            if (y < this.BoundsTop + HalfScreenHeight) {
                y = this.BoundsTop + HalfScreenHeight
            }
            this.Camera.SetPosition(x, y)
        },
        SetMode: function SetModeFn(NewMode) {
            this.Mode = NewMode;
            switch (this.Mode) {
                case CameraManager.ModeFree:
                    this.X = this.TrackPlayerX;
                    this.Y = this.TrackPlayerY;
                    this.PosTweener.Reset();
                    this.ZoomTweener.Reset();
                    break;
                case CameraManager.ModeTrackPlayer:
                    this.LastPlayerX = 0;
                    this.LastPlayerY = 0;
                    this.PlayerDeltaFirstTime = true;
                    break;
                case CameraManager.ModeTrackEnemy:
                    this.LastPlayerX = 0;
                    this.LastPlayerY = 0;
                    this.PlayerDeltaFirstTime = true;
                    break
            }
        },
        StartEffectPlayerExplode: function StartEffectPlayerExplodeFn() {
            this.EffectPlayerExplodeActive = true;
            this.EffectPlayerExplodeTimer = 0
        },
        UpdateEffectPlayerExplode: function UpdateEffectPlayerExplodeFn(TimeDelta) {
            if (this.EffectPlayerExplodeActive) {
                this.EffectPlayerExplodeTimer += TimeDelta;
                if (this.EffectPlayerExplodeTimer >= 1) {
                    this.EffectPlayerExplodeActive = false
                } else {
                    var Zoom = 0;
                    var MaxZoom = .75;
                    if (this.EffectPlayerExplodeTimer < .1) {
                        Zoom = -(this.EffectPlayerExplodeTimer / .1) * MaxZoom
                    } else {
                        Zoom = -(1 - (this.EffectPlayerExplodeTimer - .1) / .9) * MaxZoom
                    }
                    this.Camera.Zoom += Zoom
                }
            }
        },
        StartEffectShake: function StartEffectShakeFn(Intensity, Delay) {
            this.EffectShakeActive = true;
            this.EffectShakeTimer = Delay;
            this.EffectShakeOffset = 0;
            this.EffectShakeIntensity = Intensity
        },
        UpdateEffectShake: function UpdateEffectShakeFn(TimeDelta) {
            this.EffectShakeTimer -= 1;
            if (this.EffectShakeTimer <= 0) {
                this.EffectShakeActive = false
            } else {
                if (this.EffectShakeTimer % 4 < 2) {
                    this.EffectShakeOffset = 0
                } else {
                    this.EffectShakeOffset = this.EffectShakeIntensity
                }
            }
        },
        StartEffectZoomShake: function StartEffectZoomShakeFn(Intensity, Delay) {
            this.EffectZoomShakeActive = true;
            this.EffectZoomShakeTimer = Delay;
            this.EffectZoomShakeOffset = 0;
            this.EffectZoomShakeIntensity = Intensity
        },
        UpdateEffectZoomShake: function UpdateEffectZoomShakeFn(TimeDelta) {
            this.EffectZoomShakeTimer -= 1;
            if (this.EffectZoomShakeTimer <= 0) {
                this.EffectZoomShakeActive = false;
                this.EffectZoomShakeOffset = 0
            } else {
                if (this.EffectZoomShakeTimer % 4 < 2) {
                    this.EffectZoomShakeOffset = 0
                } else {
                    this.EffectZoomShakeOffset = this.EffectZoomShakeIntensity
                }
            }
        },
        UpdateFree: function UpdateFreeFn(TimeDelta) {
            if (this.PosTweener.Update(TimeDelta)) {
                this.X = this.PosTweener.VariableX;
                this.Y = this.PosTweener.VariableY
            }
            if (this.ZoomTweener.Update(TimeDelta)) {
                this.Zoom = this.ZoomTweener.VariableX
            }
            if (this.RotationTweener.Update(TimeDelta)) {
                this.Rotation = this.RotationTweener.VariableX
            }
            this.Camera.SetZoom(this.Zoom / Camera.ZoomAdjuster);
            this.FinalisePosition(this.X, this.Y)
        },
        UpdateTrackPlayer: function UpdateTrackPlayerFn(TimeDelta) {
            if ((GlobalMain.IsPaused || !GlobalMain.EditActive) && GlobalMain.PlayerEntity) {
                var x = GlobalMain.PlayerEntity.x;
                var y = GlobalMain.PlayerEntity.y - 110;
                this.TrackPlayerZoom = this.Camera.Zoom;
                this.TrackPlayerX = x;
                this.TrackPlayerY = y;
                this.Camera.SetPosition(x, y);
                if (this.ZoomTweener.Update(TimeDelta)) {
                    this.Zoom = this.ZoomTweener.VariableX
                }
                this.Camera.SetZoom(this.Zoom / Camera.ZoomAdjuster);
                this.FinalisePosition(x, y)
            }
        },
        UpdateTrackEnemy: function UpdateTrackEnemyFn(TimeDelta) {
            if (GlobalMain.IsPaused || !GlobalMain.EditActive) {
                var x = GlobalMain.Game.GameFlow.GameFlowFight.Monster.x;
                this.TrackPlayerZoom = this.Camera.Zoom;
                this.TrackPlayerX = x;
                this.Camera.SetPosition(x, this.TrackPlayerY);
                if (this.ZoomTweener.Update(TimeDelta)) {
                    this.Zoom = this.ZoomTweener.VariableX
                }
                this.Camera.SetZoom(this.Zoom / Camera.ZoomAdjuster);
                this.FinalisePosition(x, this.TrackPlayerY)
            }
        },
        FinaliseCamera: function FinaliseCameraFn() {
            var Pos = this.Camera.GetPosition();
            if (this.EffectShakeActive) {
                Pos.y += this.EffectShakeOffset
            }
            var Zoom = this.Camera.GetAdjustedZoom();
            if (this.EffectZoomShakeActive) {
                Zoom += this.EffectZoomShakeOffset
            }
            GlobalMain.World.SetViewPosition(-Pos.x, -Pos.y);
            GlobalMain.World.SetViewScale(Zoom);
            GlobalMain.World.SetViewRotation(this.Camera.GetRotation());
            GlobalMain.World.FinaliseView()
        },
        Reset: function ResetFn() {
            this.LastPlayerX = 0;
            this.LastPlayerY = 0;
            this.PlayerDeltaFirstTime = true;
            this.RandomCameraTimer = 0;
            this.CurrentCameraEntity = null;
            this.EffectPlayerExplodeActive = false;
            this.EffectPlayerExplodeTimer = 0;
            this.EffectShakeActive = false;
            this.EffectShakeTimer = 0;
            this.EffectZoomShakeActive = false;
            this.EffectZoomShakeTimer = 0;
            this.SetMode(CameraManager.ModeTrackPlayer);
            this.Camera.Reset();
            this.Update(0);
            this.PosTweener.Reset();
            this.ZoomTweener.Reset();
            this.RotationTweener.Reset()
        },
        Update: function UpdateFn(TimeDelta) {
            this.Camera.Update(TimeDelta);
            switch (this.Mode) {
                case CameraManager.ModeFree:
                    this.UpdateFree(TimeDelta);
                    break;
                case CameraManager.ModeTrackPlayer:
                    this.UpdateTrackPlayer(TimeDelta);
                    break;
                case CameraManager.ModeTrackEnemy:
                    this.UpdateTrackEnemy(TimeDelta);
                    break
            }
            if (this.EffectShakeActive) {
                this.UpdateEffectShake(TimeDelta)
            }
            if (this.EffectZoomShakeActive) {
                this.UpdateEffectZoomShake(TimeDelta)
            }
            this.FinaliseCamera()
        },
        Destroy: function DestroyFn() {
            this.Camera.Destroy()
        }
    };
    CameraManager.Create = function CreateFn() {
        var NewObject = new CameraManager;
        NewObject.Camera = Camera.Create();
        NewObject.LastPlayerX = 0;
        NewObject.LastPlayerY = 0;
        NewObject.PlayerDeltaFirstTime = true;
        NewObject.Mode = CameraManager.ModeTrackPlayer;
        NewObject.TrackPlayerZoom = 1;
        NewObject.TrackPlayerX = 0;
        NewObject.TrackPlayerY = 0;
        NewObject.RandomCameraTimer = 0;
        NewObject.CurrentCameraEntity = null;
        NewObject.EffectPlayerExplodeActive = false;
        NewObject.EffectPlayerExplodeTimer = 0;
        NewObject.EffectShakeActive = false;
        NewObject.EffectShakeTimer = 0;
        NewObject.EffectShakeOffset = 0;
        NewObject.EffectShakeIntensity = 0;
        NewObject.EffectZoomShakeActive = false;
        NewObject.EffectZoomShakeTimer = 0;
        NewObject.EffectZoomShakeOffset = 0;
        NewObject.EffectZoomShakeIntensity = 0;
        NewObject.PosTweener = new Tweener;
        NewObject.ZoomTweener = new Tweener;
        NewObject.RotationTweener = new Tweener;
        NewObject.BoundsTop = 0;
        NewObject.BoundsBottom = 720;
        NewObject.BoundsLeft = 0;
        NewObject.BoundsRight = 1280;
        NewObject.ViewWidth = 1280 / 2;
        NewObject.ViewHeight = 720 / 2;
        return NewObject
    };

    function EffectManager() {}
    EffectManager.PlayerDeadFlashDelay = .5;
    EffectManager.prototype = {
        StartPlayerDeadFlash: function StartPlayerDeadFlashFn() {
            this.PlayerDeadFlashActive = true;
            this.PlayerDeadFlashTimer = 0;
            this.PlayerDeadFlashSprite.SetIsVisible(false);
            this.PlayerDeadFlashSprite.SetColour([1, 1, 1, 1])
        },
        Reset: function ResetFn() {
            this.PlayerDeadFlashActive = false;
            this.PlayerDeadFlashTimer = 0;
            this.PlayerDeadFlashSprite.SetIsVisible(false)
        },
        Update: function UpdateFn(TimeDelta) {
            if (this.PlayerDeadFlashActive) {
                this.PlayerDeadFlashTimer += TimeDelta;
                if (this.PlayerDeadFlashTimer >= EffectManager.PlayerDeadFlashDelay) {
                    this.PlayerDeadFlashSprite.SetIsVisible(false)
                } else {
                    if (this.PlayerDeadFlashTimer > 5 / 60) {
                        this.PlayerDeadFlashSprite.SetIsVisible(true)
                    }
                    var Percent = 1 - this.PlayerDeadFlashTimer / EffectManager.PlayerDeadFlashDelay;
                    this.PlayerDeadFlashSprite.SetColour([1, 1, 1, Percent])
                }
            }
        },
        Render: function RenderFn() {
            this.RootTree.Render()
        },
        Destroy: function DestroyFn() {
            Helpers.DestroySprite(this.PlayerDeadFlashSprite);
            Helpers.DestroyTree(this.RootTree)
        }
    };
    EffectManager.Create = function CreateFn() {
        var NewObject = new EffectManager;
        NewObject.RootTree = Helpers.CreateTree(0, 0, GlobalMain.RootTree);
        NewObject.PlayerDeadFlashActive = false;
        NewObject.PlayerDeadFlashTimer = 0;
        NewObject.PlayerDeadFlashSprite = Helpers.CreateSprite(0, 0, EA.TopLeft, "White", NewObject.RootTree);
        NewObject.PlayerDeadFlashSprite.SetScale(JamSystem.RenderManager.GetScreenWidth(), JamSystem.RenderManager.GetScreenHeight());
        NewObject.PlayerDeadFlashSprite.SetIsVisible(false);
        return NewObject
    };

    function AudioTypeController() {}
    AudioTypeController.prototype = {
        AddVolume: function AddVolumeFn(Volume) {
            if (Volume > this.Volume) {
                this.Volume = Volume
            }
        },
        Reset: function ResetFn() {
            if (this.SoundHandle.Valid) {
                JamSystem.SoundManager.StopSoundHandle(this.SoundHandle)
            }
        },
        Update: function UpdateFn() {
            if (this.Volume) {
                if (!this.SoundHandle.Valid) {
                    JamSystem.SoundManager.PlaySound(this.SampleName, this.SoundHandle)
                }
                JamSystem.SoundManager.SetSoundVolumeHandle(this.SoundHandle, this.Volume)
            } else {
                if (this.SoundHandle.Valid) {
                    JamSystem.SoundManager.StopSoundHandle(this.SoundHandle)
                }
            }
            this.Volume = 0
        }
    };
    AudioTypeController.Create = function AudioTypeControllerCreate(SampleName) {
        var NewObject = new AudioTypeController;
        NewObject.SampleName = SampleName;
        NewObject.Volume = 0;
        NewObject.SoundHandle = SoundManagerHandle.Create();
        return NewObject
    };

    function WorldAudioController() {}
    WorldAudioController.BirdPlayDelay = 75 / 60;
    WorldAudioController.NumBirdSounds = 4;
    WorldAudioController.BirdSounds = ["Birdsong01", "Birdsong02", "Birdsong03", "Birdsong04"];
    WorldAudioController.prototype = {
        SetFocusVolume: function SetFocusVolumeFn(Volume) {
            this.FocusVolume = Volume;
            JamSystem.SoundManager.SetMasterVolume(this.FocusVolume * this.GameVolume)
        },
        SetGameVolume: function SetGameVolumeFn(Volume) {
            this.GameVolume = Volume;
            JamSystem.SoundManager.SetMasterVolume(this.FocusVolume * this.GameVolume)
        },
        AddBirds: function AddBirdsFn(Strength) {
            if (Strength > this.BirdsVolume) {
                this.BirdsVolume = Strength
            }
        },
        AddArea: function AddAreaFn(Name, Strength) {
            if (!this.AreaEffects[Name]) {
                this.AreaEffects[Name] = AudioTypeController.Create(Name)
            }
            this.AreaEffects[Name].AddVolume(Strength)
        },
        Update: function UpdateFn(TimeDelta) {
            if (this.BirdsVolume) {
                this.BirdsTimer += TimeDelta;
                if (this.BirdsTimer > WorldAudioController.BirdPlayDelay) {
                    this.BirdsTimer = 0;
                    var Available = false;
                    for (i = 0; i < WorldAudioController.NumBirdSounds; i += 1) {
                        if (!JamSystem.SoundManager.GetIsSoundPlaying(WorldAudioController.BirdSounds[i])) {
                            Available = true;
                            break
                        }
                    }
                    if (Available) {
                        var Index = -1;
                        do {
                            Index = Math.floor(Math.random() * 4)
                        } while (JamSystem.SoundManager.GetIsSoundPlaying(WorldAudioController.BirdSounds[Index]));
                        JamSystem.SoundManager.PlaySound(WorldAudioController.BirdSounds[Index], null)
                    }
                }
                var Volume = this.BirdsVolume * GlobalMain.WorldRenderer.DayLight;
                for (i = 0; i < WorldAudioController.NumBirdSounds; i += 1) {
                    JamSystem.SoundManager.SetSoundVolume(WorldAudioController.BirdSounds[i], Volume)
                }
                if (!this.CicadaHandle.Valid) {
                    JamSystem.SoundManager.PlaySound("Cicada", this.CicadaHandle)
                }
                Volume = this.BirdsVolume * (1 - GlobalMain.WorldRenderer.DayLight);
                JamSystem.SoundManager.SetSoundVolumeHandle(this.CicadaHandle, Volume)
            } else {
                for (i = 0; i < WorldAudioController.NumBirdSounds; i += 1) {
                    JamSystem.SoundManager.StopSound(WorldAudioController.BirdSounds[i])
                }
                if (this.CicadaHandle.Valid) {
                    JamSystem.SoundManager.StopSoundHandle(this.CicadaHandle)
                }
            }
            this.BirdsVolume = 0;
            for (i in this.AreaEffects) {
                if (this.AreaEffects.hasOwnProperty(i)) {
                    this.AreaEffects[i].Update()
                }
            }
        },
        Reset: function ResetFn() {
            this.BirdsVolume = 0;
            this.BirdsTimer = 0;
            for (i = 0; i < WorldAudioController.NumBirdSounds; i += 1) {
                JamSystem.SoundManager.StopSound(WorldAudioController.BirdSounds[i])
            }
            JamSystem.SoundManager.StopSoundHandle(this.CicadaHandle);
            for (i in this.AreaEffects) {
                if (this.AreaEffects.hasOwnProperty(i)) {
                    this.AreaEffects[i].Reset()
                }
            }
        },
        Destroy: function DestroyFn() {}
    };
    WorldAudioController.Create = function CreateFn() {
        var NewObject = new WorldAudioController;
        NewObject.BirdsVolume = 0;
        NewObject.BirdsTimer = 0;
        NewObject.CicadaHandle = SoundManagerHandle.Create();
        NewObject.AreaEffects = [];
        NewObject.FocusVolume = JamSystem.InputManager.GetIsInFocus() ? 1 : 0;
        NewObject.GameVolume = 1;
        NewObject.FireVolume = 1;
        NewObject.SetFocusVolume(NewObject.FocusVolume);
        return NewObject
    };

    function ParticleManager() {}
    ParticleManager.TypeFireSmoke = 0;
    ParticleManager.TypeExplosionSmoke = 1;
    ParticleManager.TypeGeneral = 2;
    ParticleManager.UpdateExplosionSmoke = function UpdateExplosionSmokeFn(Particle, TimeDelta) {
        Particle.y += Particle.MoveDeltaY;
        var TimerPercent = Particle.Timer / Particle.StartTimer;
        Particle.ScaleTimer += TimeDelta;
        Particle.Rotation += Particle.RotationDelta;
        Particle.ColourArray[3] = Particle.FadeStart;
        var Percent;
        if (Application.BuildTestNewSmoke) {
            if (Particle.ScaleTimer < Particle.ScaleTimerTarget) {
                Percent = .7
            } else {
                Percent = (Particle.ScaleTimer - Particle.ScaleTimerTarget) / (Particle.StartTimer - Particle.ScaleTimerTarget) * .2 + .7
            }
            Particle.ScaleX = Percent * Particle.TargetScale;
            Particle.ScaleY = Particle.ScaleX;
            if (Particle.ScaleTimer < .25) {
                Particle.ColourArray[3] *= Particle.ScaleTimer / .25
            } else if (TimerPercent < .25) {
                Particle.ColourArray[3] *= TimerPercent / .25
            }
            if (Particle.FadeStart === .25) {
                Particle.ColourArray[0] = 1 - TimerPercent
            } else {
                Particle.ColourArray[0] = 0
            }
            Particle.Rotation += Particle.RotationDelta
        } else {
            Particle.ColourArray[3] *= TimerPercent * .75;
            if (Particle.ScaleTimer < Particle.ScaleTimerTarget) {
                Percent = Particle.ScaleTimer / Particle.ScaleTimerTarget;
                Particle.ScaleX = Percent * Particle.TargetScale;
                Particle.ScaleY = Particle.ScaleX
            }
        }
        Particle.LocalMatrixDirty = true
    };
    ParticleManager.UpdateGeneral = function UpdateGeneralFn(Particle, TimeDelta) {
        Particle.x += Particle.MoveDeltaX;
        Particle.y += Particle.MoveDeltaY;
        Particle.MoveDeltaX *= Particle.Decay;
        Particle.MoveDeltaY *= Particle.Decay;
        Particle.MoveDeltaY += Particle.Gravity;
        Particle.ScaleX += Particle.ScaleDecay;
        Particle.ScaleY += Particle.ScaleDecay;
        Particle.Rotation += Particle.RotationDelta;
        if (Particle.FadeDelay) {
            if (Particle.Timer <= Particle.FadeDelay) {
                var AlphaPercent = Particle.Timer / Particle.FadeDelay;
                Particle.ColourArray[3] *= AlphaPercent;
                Particle.ColourNormal = false
            }
        }
        Particle.LocalMatrixDirty = true
    };
    ParticleManager.prototype = {
        CreateNewParticle: function CreateNewParticleFn(Type, x, y, ScaleX, ScaleY, Rotation) {
            var Particle = this.ParticleArray[this.ParticleArrayIndex];
            this.ParticleArray[this.ParticleArrayIndex] = null;
            this.ParticleArrayIndex += 1;
            Particle.LocalMatrixDirty = true;
            Particle.VerticesDirty = true;
            Particle.Type = Type;
            Particle.x = x;
            Particle.y = y;
            Particle.ScaleX = ScaleX;
            Particle.ScaleY = ScaleY;
            Particle.Rotation = Rotation;
            Particle.ColourArray = [1, 1, 1, 1];
            Particle.ColourNormal = true;
            Particle.AnchorX = -.5;
            Particle.AnchorY = .5;
            return Particle
        },
        AddFireSmoke: function AddFireSmokeFn(x, y, LayerIndex, Small, Scaler) {
            var Particle = this.CreateNewParticle(ParticleManager.TypeFireSmoke, x, y, 0, 0, 0);
            Particle.Frame = this.FireSmokeFrame;
            Particle.TargetScale = Scale;
            Particle.ScaleTimer = 0;
            Particle.ScaleTimerTarget = 1;
            Particle.MoveDeltaX = .2;
            Particle.MoveDeltaY = -.4;
            Particle.AnchorX = -.5;
            Particle.AnchorY = .5;
            Particle.ColourNormal = false;
            var Timer = 480 / 60;
            if (Small) {
                Timer /= 3
            }
            Particle.Timer = Math.random() * (Timer / 4) + Timer;
            Particle.StartTimer = Timer;
            Particle.Update = ParticleManager.UpdateFireSmoke;
            var ThisLayer = this.Layers[Layer];
            ThisLayer[ThisLayer.length] = Particle;
            Timer = 600 / 60;
            if (Small) {
                Timer /= 3
            }
            Particle.Timer = Math.random() * (Timer / 4) + Timer;
            Particle.StartTimer = Timer;
            Particle.Rotation = Math.random() * Math.PI * 2;
            Particle.TargetScale /= 2;
            Particle.Frame2 = this.FireSmokeFrame2
        },
        AddExplosionSmoke: function AddExplosionSmokeFn(x, y, Layer, Left, Scale, RotationScale, FadeStart) {
            var Particle = this.CreateNewParticle(ParticleManager.TypeExplosionSmoke, x, y, 0, 0, 0);
            Particle.Frame = this.ExplosionSmokeFrame;
            Particle.Frame2 = this.ExplosionSmokeFrame2;
            Scale = (Math.random() * 9 + 27) / 8 * Scale;
            Particle.TargetScale = Scale / 2;
            Particle.ScaleTimer = 0;
            Particle.ScaleTimerTarget = .25;
            Particle.MoveDeltaY = -.8;
            Particle.AnchorX = -.5;
            Particle.AnchorY = .5;
            Particle.ColourNormal = false;
            var Timer = 60 / 60;
            Particle.Timer = Math.random() * (Timer / 4) + Timer;
            Particle.StartTimer = Timer;
            Particle.FadeStart = FadeStart;
            Particle.Update = ParticleManager.UpdateExplosionSmoke;
            var ThisLayer = this.Layers[Layer];
            ThisLayer[ThisLayer.length] = Particle;
            Particle.Rotation = Math.random() * Math.PI * 2;
            Particle.RotationDelta = (Math.random() * .003 + .007) * RotationScale;
            if (Left) {
                Particle.RotationDelta = -Particle.RotationDelta
            }
        },
        AddGeneral: function AddGeneralFn(x, y, Rotation, ScaleX, ScaleY, vx, vy, Decay, Gravity, LifeTime, ScaleDecay, FadeDelay, Frame, Layer, Colour, RotationDelta) {
            var Particle = this.CreateNewParticle(ParticleManager.TypeGeneral, x, y, ScaleX, ScaleY, Rotation);
            Particle.MoveDeltaX = vx;
            Particle.MoveDeltaY = vy;
            if (Colour !== [1, 1, 1, 1]) {
                var i;
                for (i = 0; i < 4; i += 1) {
                    Particle.ColourArray[i] = Colour[i]
                }
                Particle.ColourNormal = false
            }
            Particle.Frame = Frame;
            Particle.Frame2 = Frame;
            Particle.Timer = LifeTime;
            Particle.StartTimer = LifeTime;
            Particle.Decay = Decay;
            Particle.Gravity = Gravity;
            Particle.ScaleDecay = ScaleDecay;
            Particle.FadeDelay = FadeDelay;
            Particle.RotationDelta = RotationDelta;
            Particle.Update = ParticleManager.UpdateGeneral;
            var ThisLayer = this.Layers[Layer];
            ThisLayer[ThisLayer.length] = Particle
        },
        Update: function UpdateFn(TimeDelta) {
            var TimerPercent;
            var i, Percent;
            for (i = 0; i < this.Layers.length; i += 1) {
                var ThisLayer = this.Layers[i];
                var SpriteList = GlobalMain.World.GetLayer(i).ParticleSpriteList;
                SpriteList.Lock();
                var j;
                for (j = ThisLayer.length - 1; j >= 0; j -= 1) {
                    var Particle = ThisLayer[j];
                    Particle.Timer -= TimeDelta;
                    if (Particle.Timer <= 0) {
                        this.ParticleArrayIndex -= 1;
                        this.ParticleArray[this.ParticleArrayIndex] = Particle;
                        ThisLayer.splice(j, 1)
                    } else {
                        switch (Particle.Type) {
                            case ParticleManager.TypeFireSmoke:
                                Particle.x += Particle.MoveDeltaX;
                                Particle.y += Particle.MoveDeltaY;
                                TimerPercent = Particle.Timer / Particle.StartTimer;
                                Particle.ScaleTimer += TimeDelta;
                                if (Particle.ScaleTimer < Particle.ScaleTimerTarget) {
                                    Percent = Particle.ScaleTimer / Particle.ScaleTimerTarget * .25
                                } else {
                                    Percent = (Particle.ScaleTimer - Particle.ScaleTimerTarget) / (Particle.StartTimer - Particle.ScaleTimerTarget) * .75 + .25
                                }
                                Particle.ScaleX = Percent * Particle.TargetScale;
                                Particle.ScaleY = Particle.ScaleX;
                                if (Particle.ScaleTimer < .5) {
                                    Particle.ColourArray[3] = Particle.ScaleTimer / .5
                                } else if (TimerPercent < .5) {
                                    Particle.ColourArray[3] = TimerPercent / .5
                                } else {
                                    Particle.ColourArray[3] = 1
                                }
                                if (Particle.ScaleTimer < 2.5) {
                                    Particle.ColourArray[0] = 0
                                } else if (Particle.ScaleTimer < 3.5) {
                                    Particle.ColourArray[0] = (Particle.ScaleTimer - 2.5) / 1
                                } else {
                                    Particle.ColourArray[0] = 1
                                }
                                Particle.Rotation += .005;
                                Particle.LocalMatrixDirty = true;
                                break;
                            default:
                                Particle.Update(Particle, TimeDelta);
                                break
                        }
                    }
                }
            }
        },
        GetSpriteList: function GetSpriteListFn(LayerIndex) {
            return GlobalMain.World.GetLayer(LayerIndex).ParticleSpriteList
        },
        RenderReady: function RenderReadyFn() {
            return;
            var Types = [];
            var i;
            for (i = 0; i < 100; i += 1) {
                Types[i] = 0
            }
            for (i = 0; i < this.Layers.length; i += 1) {
                var ThisLayer = this.Layers[i];
                var SpriteList = GlobalMain.World.GetLayer(i).ParticleSpriteList;
                SpriteList.SetShader(this.Texture2Shader);
                SpriteList.SetTexture(this.Texture, 0);
                SpriteList.SetTexture2(this.Texture, 0);
                var j;
                var k = SpriteList.NumSprites;
                for (j = 0; j < ThisLayer.length; j += 1) {
                    var Particle = ThisLayer[j];
                    Types[Particle.Type] += 1;
                    SpriteList.OutputSprite(Particle);
                    if (!Particle.ColourNormal) {
                        SpriteList.SetColour(k, Particle.ColourArray)
                    } else {
                        if (!SpriteList.ColourNormal[k]) {
                            SpriteList.SetColour(k, [1, 1, 1, 1])
                        }
                    }
                    k += 1
                }
                SpriteList.UnLock()
            }
        },
        Reset: function ResetFn() {
            this.Layers = [];
            var i;
            for (i = 0; i < GlobalMain.World.GetLayerAmount(); i += 1) {
                this.Layers[i] = []
            }
            for (i = 0; i < 1e3; i += 1) {
                this.ParticleArray[i] = this.OriginalParticleArray[i]
            }
            this.ParticleArrayIndex = 0
        },
        Destroy: function DestroyFn() {}
    };
    ParticleManager.Create = function CreateFn() {
        var NewObject = new ParticleManager;
        NewObject.Layers = [];
        NewObject.Texture2Shader = JamSystem.RenderManager.CreateShader("vertexColorTextured2Texture2D", {});
        NewObject.ParticleArray = [];
        NewObject.OriginalParticleArray = [];
        NewObject.ParticleArrayIndex = 0;
        var i;
        var Particle;
        for (i = 0; i < 1e3; i += 1) {
            Particle = Helpers.CreateSprite(0, 0, EA.Default, null, null);
            Particle.Type = 0;
            NewObject.ParticleArray[i] = Particle;
            NewObject.OriginalParticleArray[i] = Particle
        }
        return NewObject
    };

    function WorldManager() {}
    WorldManager.prototype = {
        ViewportChanged: function ViewportChangedFn(fDelta) {
            GlobalMain.World.ViewportChanged();
            GlobalMain.CameraManager.FinaliseCamera()
        },
        ReadyForPlay: function ReadyForPlayFn(fDelta) {
            GlobalMain.World.UpdateNewChanges();
            GlobalMain.WorldManager.Update(2 / 60);
            var i;
            for (i = 0; i < 20; i += 1) {
                Physics.Update(1 / 60)
            }
        },
        Update: function UpdateFn(TimeDelta) {
            GlobalMain.ParticleManager.Update(TimeDelta);
            GlobalMain.World.Update(TimeDelta);
            GlobalMain.WorldAudioController.Update(TimeDelta);
            GlobalMain.CameraManager.Update(TimeDelta);
            GlobalMain.EffectManager.Update(TimeDelta);
            GlobalMain.ParticleManager.RenderReady()
        },
        Reset: function ResetFn() {
            GlobalMain.World.ShowEditMode(false);
            GlobalMain.World.UpdateNewChanges();
            GlobalMain.World.Reset();
            GlobalMain.WorldAudioController.Reset();
            GlobalMain.WorldRenderer.Reset();
            GlobalMain.ParticleManager.Reset();
            GlobalMain.CameraManager.Reset();
            GlobalMain.EffectManager.Reset();
            JamSystem.SoundManager.StopAll();
            var Entities = GlobalMain.World.GetAllEntitiesOfType(EntityGame.TypeID);
            GlobalMain.GameEntity = Entities[0]
        },
        Render: function RenderFn() {
            GlobalMain.WorldRenderer.Render();
            GlobalMain.EffectManager.Render();
            GlobalMain.World.RenderDebug();
            if (GlobalMain.PlayerEntity) {
                GlobalMain.PlayerEntity.RenderDebug()
            }
        },
        Destroy: function DestroyFn() {
            GlobalMain.World.Destroy();
            GlobalMain.WorldAudioController.Destroy();
            GlobalMain.ParticleManager.Destroy();
            GlobalMain.WorldRenderer.Destroy();
            GlobalMain.CameraManager.Destroy();
            GlobalMain.EffectManager.Destroy()
        }
    };
    WorldManager.CreateNewCallback = function CreateNewCallbackFn(NewWorld, BaseName) {
        var Index = ObjectPaletteManager.GetPaletteIndexFromName("Game");
        var NewGameEntity = WorldFileManager.CreateEntity(0, 0, 0, 1, 1, null, Index, null);
        NewWorld.GetLayer(0).AddEntity(NewGameEntity);
        var myJSONTextWhiteSpace = "";
        myJSONTextWhiteSpace += "{\n";
        myJSONTextWhiteSpace += '    "Scripts":\n';
        myJSONTextWhiteSpace += "    [\n";
        myJSONTextWhiteSpace += '       {"Name":"Level01GameStart", "Code":\n';
        myJSONTextWhiteSpace += "       [\n";
        myJSONTextWhiteSpace += '			{"Func":"Wait", "Delay":1.0}\n';
        myJSONTextWhiteSpace += "	   ]},\n";
        myJSONTextWhiteSpace += "	   \n";
        myJSONTextWhiteSpace += '       {"Name":"Level01GameGo", "Code":\n';
        myJSONTextWhiteSpace += "       [\n";
        myJSONTextWhiteSpace += '			{"Func":"Wait", "Delay":1.0}\n';
        myJSONTextWhiteSpace += "       ]},\n";
        myJSONTextWhiteSpace += "\n";
        myJSONTextWhiteSpace += '       {"Name":"Level01Start", "Code":\n';
        myJSONTextWhiteSpace += "       [\n";
        myJSONTextWhiteSpace += '			{"Func":"Wait", "Delay":1.0}\n';
        myJSONTextWhiteSpace += "       ]},\n";
        myJSONTextWhiteSpace += "	   \n";
        myJSONTextWhiteSpace += '       {"Name":"Level01TimeHurry", "Code":\n';
        myJSONTextWhiteSpace += "       [\n";
        myJSONTextWhiteSpace += '			{"Func":"Wait", "Delay":1.0}\n';
        myJSONTextWhiteSpace += "       ]},\n";
        myJSONTextWhiteSpace += "	   \n";
        myJSONTextWhiteSpace += '       {"Name":"Level01TimeWarning", "Code":\n';
        myJSONTextWhiteSpace += "       [\n";
        myJSONTextWhiteSpace += '			{"Func":"Wait", "Delay":1.0}\n';
        myJSONTextWhiteSpace += "       ]}\n";
        myJSONTextWhiteSpace += "   ]\n";
        myJSONTextWhiteSpace += "}\n";
        var SaveFile = File.Save("assets/Scripts/" + BaseName + "Scripts.json", myJSONTextWhiteSpace, true)
    };
    WorldManager.Create = function CreateFn() {
        var NewObject = new WorldManager;
        GlobalMain.World = World.Create();
        GlobalMain.WorldAudioController = WorldAudioController.Create();
        GlobalMain.ParticleManager = ParticleManager.Create();
        GlobalMain.WorldRenderer = WorldRenderer.Create(GlobalMain.World);
        GlobalMain.CameraManager = CameraManager.Create();
        GlobalMain.EffectManager = EffectManager.Create();
        GlobalMain.World.CreateDebugStats();
        GlobalMain.CreateNewUserCallback = WorldManager.CreateNewCallback;
        return NewObject
    };

    function WorldRenderer() {}
    WorldRenderer.prototype = {
        SetAmbientLighting: function SetAmbientLightingFn(Colour) {
            this.AmbientLighting = Colour;
            this.NormalShader.Parameters.ambient = this.AmbientLighting;
            this.AmbientSprite.SetColour(Colour)
        },
        Reset: function ResetFn() {
            this.MainLayer = GlobalMain.World.GetLayerByName("Main");
            this.LightingLayer = GlobalMain.World.GetLayerByName("Lighting");
            this.ScoreLayer = GlobalMain.World.GetLayer(GlobalMain.World.GetLayerAmount() - 1);
            var i;
            for (i = GlobalMain.World.GetLayerAmount() - 1; i >= 0; i -= 1) {
                var ThisLayer = GlobalMain.World.GetLayer(i);
                if (ThisLayer.Name !== "Lighting" && ThisLayer.MovementScale.x === 1 && ThisLayer.MovementScale.y === 1) {
                    this.ScoreLayer = ThisLayer;
                    break
                }
            }
            var i, j, k;
            for (i = 0; i < this.World.Layers.length; i += 1) {
                var Layer = this.World.Layers[i];
                if (this.LightingLayer && i === this.LightingLayer.Index) {
                    Layer.DefaultShader = this.LightingShader
                } else {
                    Layer.DefaultShader = this.NormalWithLightingShader
                }
                for (j = 0; j < Layer.Buckets.length; j += 1) {
                    for (k = 0; k < Layer.Buckets[j].StaticSpriteLists.length; k += 1) {
                        if (this.LightingLayer && i === this.LightingLayer.Index) {
                            Layer.Buckets[j].StaticSpriteLists[k].Shader = this.LightingShader
                        } else {
                            if (Layer.Buckets[j].StaticSpriteLists[k].Texture2) {
                                Layer.Buckets[j].StaticSpriteLists[k].Shader = this.NormalWithLighting2PassShader
                            } else {
                                Layer.Buckets[j].StaticSpriteLists[k].Shader = this.NormalWithLightingShader
                            }
                        }
                    }
                }
            }
            this.OldLayer = -1;
            this.OldEditorTime = this.DayLight
        },
        Render: function RenderFn() {
            var Value = this.DayLight;
            this.SetAmbientLighting([Value, Value, Value, 1]);
            if (this.LightingLayer && GlobalMain.StateManager.State === StateManager.StateEdit) {
                if (GlobalMain.Editor.CurrentLayer !== this.OldLayer) {
                    this.OldLayer = GlobalMain.Editor.CurrentLayer;
                    if (GlobalMain.Editor.CurrentLayer === this.LightingLayer.Index) {
                        this.OldEditorTime = this.DayLight;
                        this.DayLight = 0
                    } else {
                        this.DayLight = this.OldEditorTime
                    }
                }
            }
            this.LightingRenderTarget.Begin();
            this.AmbientSprite.SetIsVisible(true);
            this.AmbientSprite.Render();
            this.AmbientSprite.SetIsVisible(false);
            if (this.LightingLayer) {
                this.LightingLayer.Render()
            }
            this.LightingRenderTarget.End();
            if (this.LightingLayer) {
                this.LightingLayer.IsVisible = false
            }
            var ThisWorld = GlobalMain.World;
            ThisWorld.RenderReady();
            for (i = 0; i < ThisWorld.Layers.length; i += 1) {
                var ThisLayer = ThisWorld.Layers[i];
                if (ThisLayer.IsVisible) {
                    ThisLayer.Render();
                    World.DebugPhysicsEntities += ThisLayer.PhysicalEntities.length
                }
            }
        },
        Destroy: function DestroyFn() {
            Helpers.DestroySprite(this.AmbientSprite);
            JamSystem.RenderManager.DestroyRenderTarget(this.LightingRenderTarget);
            JamSystem.RenderManager.DestroyShader(this.ClearShader);
            JamSystem.RenderManager.DestroyShader(this.NormalShader);
            JamSystem.RenderManager.DestroyShader(this.LightingShader);
            JamSystem.RenderManager.DestroyShader(this.NormalWithLightingShader);
            JamSystem.RenderManager.DestroyShader(this.NormalWithLighting2PassShader);
            JamSystem.RenderManager.DestroyShader(this.FireGlowShader)
        }
    };
    WorldRenderer.Create = function CreateFn(ThisWorld) {
        var NewObject = new WorldRenderer;
        NewObject.World = ThisWorld;
        NewObject.LightingLayer = 0;
        NewObject.ScoreLayer = 0;
        NewObject.OldLayer = 0;
        NewObject.OldEditorTime = 0;
        NewObject.DayLight = 1;
        NewObject.LightingRenderTarget = JamSystem.RenderManager.CreateRenderTarget();
        NewObject.ClearShader = JamSystem.RenderManager.CreateShader("vertexColorLightClear2D", {});
        NewObject.NormalShader = JamSystem.RenderManager.CreateShader("vertexColorTextured2D", {});
        NewObject.LightingShader = JamSystem.RenderManager.CreateShader("vertexColorTexturedLight2D", {});
        NewObject.NormalWithLightingShader = JamSystem.RenderManager.CreateShader("vertexColorTexturedMult2D", {
            lighting: null
        });
        NewObject.NormalWithLightingShader.Parameters.lighting = NewObject.LightingRenderTarget.GetRenderTexture();
        NewObject.NormalWithLighting2PassShader = JamSystem.RenderManager.CreateShader("vertexColorTexturedMult22D", {
            lighting: null
        });
        NewObject.NormalWithLighting2PassShader.Parameters.lighting = NewObject.LightingRenderTarget.GetRenderTexture();
        NewObject.FireGlowShader = JamSystem.RenderManager.CreateShader("vertexColorTexturedGlow2D", {});
        NewObject.UnlitShader = JamSystem.RenderManager.CreateShader("vertexColorTextured2D", {});
        NewObject.AmbientSprite = Helpers.CreateSprite(0, 0, EA.TopLeft, "White", GlobalMain.RootTree);
        NewObject.AmbientSprite.SetScale(JamSystem.RenderManager.GetScreenWidth(), JamSystem.RenderManager.GetScreenHeight());
        NewObject.AmbientSprite.SetIsVisible(false);
        NewObject.AmbientSprite.SetColour([1, 1, 1, 1]);
        NewObject.AmbientSprite.SetShader(NewObject.ClearShader);
        return NewObject
    };

    function EntityRegistry() {}
    EntityRegistry.Init = function() {
        EntityTypeManager.Register(EntityGame);
        EntityTypeManager.RegisterCollision()
    };

    function Application() {}
    var GlobalMain = null;
    Application.Distribution = true;
    Application.Cheats = false;
    Application.TouchControls = true;
    Application.AllowPayment = false;
    Application.Version = "sepcu9 0.9.14";
    Application.ScreenWidth = 1022;
    Application.ScreenHeight = 720;
    Application.ResizeCanvas = false;
    if (Application.Distribution) {
        Application.ObjectPaletteFile = "assets/Working/ObjectPalette.json";
        Application.BrushPaletteFile = "assets/Working/BrushPalette.json";
        Application.LevelFile = "assets/Working/Level01.json";
        Application.TextFile = "assets/Working/TextEnglish.json";
        Application.CeremonyScriptFile = "assets/Working/CeremonyScripts.json";
        Application.AudioInfoFile = "assets/Working/AudioInfo.json";
        Application.SettingsFile = "assets/Settings.json"
    } else {
        Application.ObjectPaletteFile = "assets/Levels/ObjectPalette.json";
        Application.BrushPaletteFile = "assets/Levels/BrushPalette.json";
        Application.LevelFile = "assets/Levels/Level01.json";
        Application.TextFile = "assets/Text/TextEnglish.json";
        Application.CeremonyScriptFile = "assets/Scripts/CeremonyScripts.json";
        Application.AudioInfoFile = "assets/Audio/AudioInfo.json";
        Application.SettingsFile = "assets/Settings.json"
    }
    Application.KeyDownCallback = function KeyDownCallbackFn(keycode) {
        if (keycode === 5) {
            if (GlobalMain.StateManager.State !== StateManager.StateEdit && GlobalMain.StateManager.State !== StateManager.StateInitialLoader) {
                GlobalMain.MetricsManager.Fullscreen(JamSystem.RenderManager.GetFullScreen(), false);
                JamSystem.RenderManager.SetFullScreen(!JamSystem.RenderManager.GetFullScreen());
                Helpers.PlaySound("FullScreenToggle");
                return false
            }
        }
        return true
    };
    Application.MouseDownCallback = function MouseDownCallbackFn() {
        var MouseX = JamSystem.InputManager.GetMouseX();
        var MouseY = JamSystem.InputManager.GetMouseY();
        if (GlobalMain.StateManager.State === StateManager.StateMainMenu) {
            if (GlobalMain.StateObject.FullscreenButton.CheckCollision()) {
                if (!JamSystem.RenderManager.GetFullScreen()) {
                    GlobalMain.StateObject.FullscreenButton.AlterGraphic(true, "Windowed")
                } else {
                    GlobalMain.StateObject.FullscreenButton.AlterGraphic(true, "FullScreen")
                }
                GlobalMain.MetricsManager.Fullscreen(JamSystem.RenderManager.GetFullScreen(), true);
                JamSystem.RenderManager.SetFullScreen(!JamSystem.RenderManager.GetFullScreen());
                Helpers.PlaySound("FullScreenToggle");
                return false
            }
        }
        return true
    };
    Application.prototype = {
        FirstTime: function FirstTimeFn() {
            GlobalMain.RootTree = Helpers.CreateTree(0, 0, JamSystem.RenderManager.GetRoot())
        },
        Update: function UpdateFn(TimeDelta) {
            var Process = false;
            this.DesiredTime += TimeDelta;
            var NormalDelay = 1 / 60;
            while (this.CurrentTime < this.DesiredTime) {
                this.CurrentTime += NormalDelay;
                this.StateManager.Update(NormalDelay);
                if (this.StateManager.State === StateManager.StateEdit) {
                    this.CurrentTime = this.DesiredTime
                }
                Process = true
            }
            return Process
        },
        FixCanvas: function FixCanvasFn() {
            Debug.Log("FixCanvas");
            if (!Application.ResizeCanvas) {
                return
            }
            var width, height;
            var Element;
            Element = document.getElementById("turbulenz_game_engine_canvas");
            if (!Element) {
                Element = document.getElementById("turbulenz_game_engine_object")
            }
            if (Element) {
                Debug.Log("Width :" + Element.clientWidth);
                Debug.Log("Height :" + Element.clientHeight);
                Debug.Log("Width :" + Element.width);
                Debug.Log("Height :" + Element.height);
                if (Application.ScreenWidth < Application.ScreenHeight) {
                    height = Element.clientHeight;
                    width = height * (Application.ScreenWidth / Application.ScreenHeight);
                    Element.width = width
                } else {
                    width = Element.clientWidth;
                    height = width * (Application.ScreenHeight / Application.ScreenWidth);
                    if (height > Element.clientHeight) {
                        height = Element.clientHeight;
                        width = height * (Application.ScreenWidth / Application.ScreenHeight);
                        Element.width = width
                    }
                    Element.height = height
                }
            }
        },
        ViewportChanged: function ViewportChangedFn(fDelta) {
            if (GlobalMain.StateManager.RequestedState !== StateManager.StateInitialLoader && GlobalMain.StateManager.RequestedState !== StateManager.StateLoadLevel) {
                GlobalMain.WorldManager.ViewportChanged();
                if (!Application.Distribution) {
                    if (GlobalMain.Editor.GetIsActive()) {
                        GlobalMain.Editor.ViewportChanged()
                    }
                }
            }
            this.FixCanvas()
        },
        Render: function RenderFn(fDelta) {
            if (GlobalMain.StateManager.RequestedState !== StateManager.StateInitialLoader && GlobalMain.StateManager.RequestedState !== StateManager.StateLoadLevel) {
                GlobalMain.WorldManager.Render()
            }
        },
        init: function initFn() {
            System.Create(this, "denki-blocks", Application.ScreenWidth, Application.ScreenHeight, Application.KeyDownCallback, Application.MouseDownCallback);
            this.FixCanvas()
        },
        shutdown: function shutdownFn() {
            if (!this.hasShutdown) {
                Debug.Log("Ending");
                GlobalMain.MetricsManager.EndSession();
                this.hasShutdown = true;
                JamSystem.Stop();
                this.StateManager.Destroy();
                this.WorldManager.Destroy();
                SystemsManager.Destroy();
                this.LoadingAnimation.Destroy();
                JamSystem.Destroy();
                Debug.Log("All done")
            }
        }
    };
    Application.create = function applicationCreateFn(runInEngine) {
        var NewObject = new Application;
        GlobalMain = NewObject;
        NewObject.StateManager = StateManager.Create();
        NewObject.hasShutDown = false;
        NewObject.runInEngine = runInEngine;
        NewObject.IsPaused = false;
        NewObject.CurrentTime = 0;
        NewObject.DesiredTime = 0;
        NewObject.EditActive = false;
        NewObject.GameEntity = null;
        NewObject.PlayerEntity = null;
        return NewObject
    };

    function OutOfFocusManager() {}
    OutOfFocusManager.prototype = {
        Update: function UpdateFn(TimeDelta) {
            if (!this.AppInFocus) {
                this.FlashTimer += 1;
                if (this.FlashTimer % 20 < 6) {
                    this.OutOfFocusTextExtra.SetIsVisible(false)
                } else {
                    this.OutOfFocusTextExtra.SetIsVisible(true)
                }
                if (JamSystem.InputManager.GetIsInFocus()) {
                    JamSystem.InputManager.GetMouseButtonPressed(0);
                    this.OutOfFocusText.SetIsVisible(false);
                    this.OutOfFocusTextExtra.SetIsVisible(false);
                    this.OutOfFocusPanel.SetIsVisible(false);
                    this.AppInFocus = true;
                    this.WaitMouseUp = true;
                    this.WaitMouseUpTimer = 10;
                    if (!GlobalMain.IsPaused) {
                        JamSystem.SoundManager.PauseAll(false);
                        GlobalMain.WorldAudioController.SetFocusVolume(1)
                    }
                }
            } else {
                if (!JamSystem.InputManager.GetIsInFocus()) {
                    this.AppInFocus = false;
                    this.OutOfFocusText.SetIsVisible(true);
                    this.OutOfFocusTextExtra.SetIsVisible(true);
                    this.OutOfFocusPanel.SetIsVisible(true);
                    if (!GlobalMain.IsPaused) {
                        JamSystem.SoundManager.PauseAll(true);
                        GlobalMain.WorldAudioController.SetFocusVolume(0)
                    }
                } else {
                    if (this.WaitMouseUp) {
                        JamSystem.InputManager.GetMouseButtonPressed(0);
                        if (this.WaitMouseUpTimer) {
                            this.WaitMouseUpTimer -= 1;
                            return false
                        } else {
                            if (!JamSystem.InputManager.GetMouseButtonHeld(0)) {
                                this.WaitMouseUp = false
                            }
                        }
                        return true
                    } else {
                        return true
                    }
                }
            }
            return false
        },
        Destroy: function DestroyFn() {
            Helpers.DestroySprite(this.OutOfFocusPanel);
            Helpers.DestroyBitmapText(this.OutOfFocusText);
            Helpers.DestroyBitmapText(this.OutOfFocusTextExtra)
        }
    };
    OutOfFocusManager.Create = function CreateFn() {
        var NewObject = new OutOfFocusManager;
        NewObject.AppInFocus = true;
        NewObject.WaitMouseUp = false;
        NewObject.WaitMouseUpTimer = 0;
        NewObject.OutOfFocusPanel = Helpers.CreateSprite(0, 0, EA.TopLeft, "White", JamSystem.RenderManager.GetRoot());
        NewObject.OutOfFocusPanel.SetScale(JamSystem.RenderManager.GetScreenWidth(), JamSystem.RenderManager.GetScreenHeight());
        NewObject.OutOfFocusPanel.SetColour([0, 0, 0, .7]);
        var Text = JamSystem.TextManager.GetText("HudOutOfFocus");
        NewObject.OutOfFocusText = Helpers.CreateBitmapText(Text, JamSystem.RenderManager.GetScreenWidth() / 2, JamSystem.RenderManager.GetScreenHeight() / 2, EA.MiddleMiddle, "PanelFont", JamSystem.RenderManager.GetRoot());
        NewObject.OutOfFocusText.SetScale(1, 1);
        Text = JamSystem.TextManager.GetText("HudOutOfFocusExtra");
        NewObject.OutOfFocusTextExtra = Helpers.CreateBitmapText(Text, JamSystem.RenderManager.GetScreenWidth() / 2, JamSystem.RenderManager.GetScreenHeight() / 2 + 100, EA.MiddleMiddle, "PanelFont", JamSystem.RenderManager.GetRoot());
        NewObject.OutOfFocusTextExtra.SetScale(.5, .5);
        NewObject.FlashTimer = 0;
        NewObject.OutOfFocusText.SetIsVisible(false);
        NewObject.OutOfFocusTextExtra.SetIsVisible(false);
        NewObject.OutOfFocusPanel.SetIsVisible(false);
        return NewObject
    };

    function ScriptFunctions() {}
    ScriptFunctions.prototype = {};
    ScriptFunctions.CameraSetPosition = function CameraSetPositionFn(ThisScript, Object) {
        if (Object.Name) {
            var ThisEntity = GlobalMain.World.FindSingleEntityByName(Object.Name);
            if (ThisEntity) {
                GlobalMain.CameraManager.SetPosition(ThisEntity.x, ThisEntity.y)
            } else {
                ThisScript.Error = "Couldn't find camera target " + Object.Name
            }
        } else {
            GlobalMain.CameraManager.SetPosition(Object.x, Object.y)
        }
        return true
    };
    ScriptFunctions.CameraMovePosition = function CameraMovePositionFn(ThisScript, Object) {
        if (Object.Name) {
            var ThisEntity = GlobalMain.World.FindSingleEntityByName(Object.Name);
            if (ThisEntity) {
                GlobalMain.CameraManager.MovePosition(ThisEntity.x, ThisEntity.y, Object.Delay)
            } else {
                ThisScript.Error = "Couldn't find camera target " + Object.Name
            }
        } else {
            GlobalMain.CameraManager.MovePosition(Object.x, Object.y, Object.Delay)
        }
        return true
    };
    ScriptFunctions.CameraMoveToPlayer = function CameraMoveToPlayerFn(ThisScript, Object) {
        GlobalMain.CameraManager.MovePosition(GlobalMain.CameraManager.TrackPlayerX, GlobalMain.CameraManager.TrackPlayerY, Object.Delay);
        GlobalMain.CameraManager.MoveZoom(GlobalMain.CameraManager.TrackPlayerZoom, Object.Delay);
        return true
    };
    ScriptFunctions.CameraTrackPlayer = function CameraTrackFn(ThisScript, Object) {
        if (Object.Active) {
            GlobalMain.CameraManager.SetMode(CameraManager.ModeTrackPlayer)
        } else {
            GlobalMain.CameraManager.SetMode(CameraManager.ModeFree)
        }
        return true
    };
    ScriptFunctions.CameraSetZoom = function CameraSetZoomFn(ThisScript, Object) {
        GlobalMain.CameraManager.SetZoom(Object.Zoom);
        return true
    };
    ScriptFunctions.CameraMoveZoom = function CameraMoveZoomFn(ThisScript, Object) {
        GlobalMain.CameraManager.MoveZoom(Object.Zoom, Object.Delay);
        return true
    };
    ScriptFunctions.CameraSetRotation = function CameraSetRotationFn(ThisScript, Object) {
        var Rotation = Maths.DegToRad(Object.Rotation);
        GlobalMain.CameraManager.SetRotation(Rotation);
        return true
    };
    ScriptFunctions.CameraMoveRotation = function CameraMoveRotationFn(ThisScript, Object) {
        var Rotation = Maths.DegToRad(Object.Rotation);
        GlobalMain.CameraManager.MoveRotation(Rotation, Object.Delay);
        return true
    };
    ScriptFunctions.CameraShake = function CameraShakeFn(ThisScript, Object) {
        GlobalMain.CameraManager.StartEffectShake(Object.Intensity, Math.floor(Object.Delay * 60));
        return true
    };
    ScriptFunctions.ChangeMusic = function ChangeMusicFn(ThisScript, Object) {
        if ((Object.Music === "MusicFight" || Object.Music === "MusicChest") && GlobalMain.Game.GameFlow && GlobalMain.Game.GameFlow.GameFlowFight) {
            if (GlobalMain.Game.GameFlow.GameFlowFight.Monster.ActionPoints === 0) {
                return true
            }
        }
        GlobalMain.MusicManager.RequestChangeMusic(Object.Music, Object.Volume);
        return true
    };
    ScriptFunctions.SetMusicVolume = function SetMusicVolumeFn(ThisScript, Object) {
        GlobalMain.MusicManager.SetVolume(Object.Volume);
        return true
    };
    ScriptFunctions.TextSetQuestName = function TextSetQuestNameFn(ThisScript, Object) {
        if (ThisScript.LocalVariables[Object.Name]) {
            var Renderable = ThisScript.LocalVariables[Object.Name].Renderable;
            var NewText;
            if (GlobalMain.SessionManager.ObjectiveType === LifetimeStatManager.TerritoryObjectiveTypeEscape) {
                NewText = JamSystem.TextManager.GetText("CeremonyGamePreviewMystery")
            } else {
                NewText = JamSystem.TextManager.GetText("CeremonyGamePreviewExtra") + GlobalMain.MissionManager.Name
            }
            Renderable.SetText(NewText)
        } else {
            ThisScript.Error = "TextSetQuestName : Couldn't find " + Object.Name
        }
        return true
    };
    ScriptFunctions.TextSetQuestObjective = function TextSetQuestObjectiveFn(ThisScript, Object) {
        if (ThisScript.LocalVariables[Object.Name]) {
            var Renderable = ThisScript.LocalVariables[Object.Name].Renderable;
            Renderable.SetText(GlobalMain.MissionManager.Objective);
            if (GlobalMain.SessionManager.ObjectiveType === LifetimeStatManager.TerritoryObjectiveTypeTreasure) {
                Renderable.SetScale(2, 2)
            }
            if (GlobalMain.SessionManager.ObjectiveType === LifetimeStatManager.TerritoryObjectiveTypeQuest) {
                Renderable.SetScale(2, 2)
            }
        } else {
            ThisScript.Error = "TextSetQuestObjective : Couldn't find " + Object.Name
        }
        return true
    };
    ScriptFunctions.TextSetMonsterName = function TextSetMonsterNameFn(ThisScript, Object) {
        if (ThisScript.LocalVariables[Object.Name]) {
            var Renderable = ThisScript.LocalVariables[Object.Name].Renderable;
            var NewText;
            var FirstChar = GlobalMain.Game.GameFlow.RunToAction.ActionEntity.Name.slice(0, 1);
            if (GlobalMain.Game.GameFlow.RunToAction.ActionEntity.Data.FightVariables.AttackLength) {
                if (FirstChar === "A" || FirstChar === "E" || FirstChar === "I" || FirstChar === "O" || FirstChar === "U") {
                    NewText = JamSystem.TextManager.GetText("CeremonyMonsterStartVowel", [GlobalMain.Game.GameFlow.RunToAction.ActionEntity.Name])
                } else {
                    NewText = JamSystem.TextManager.GetText("CeremonyMonsterStartConsanant", [GlobalMain.Game.GameFlow.RunToAction.ActionEntity.Name])
                }
            } else {
                NewText = GlobalMain.Game.GameFlow.RunToAction.ActionEntity.Name
            }
            Renderable.SetText(NewText)
        } else {
            ThisScript.Error = "TextSetQuestName : Couldn't find " + Object.Name
        }
        return true
    };
    ScriptFunctions.CreateWord = function CreateWordFn(ThisScript, Object) {
        GlobalMain.Game.GameFlow.GameFlowFight.CreateWord(Object.Player, Object.x, Object.y);
        return true
    };
    ScriptFunctions.DestroyWord = function DestroyWordFn(ThisScript, Object) {
        GlobalMain.Game.GameFlow.GameFlowFight.DestroyWord();
        return true
    };
    ScriptFunctions.DoAttack = function DoAttackFn(ThisScript, Object) {
        GlobalMain.Game.GameFlow.GameFlowFight.DoAttack(Object.Player);
        return true
    };
    ScriptFunctions.SetMonsterWarning = function SetMonsterWarningFn(ThisScript, Object) {
        GlobalMain.Game.GameFlow.GameFlowFight.Monster.SetState(EntityCreature.StateBossWarning);
        GlobalMain.CameraManager.StartEffectZoomShake(.05, 90);
        return true
    };
    ScriptFunctions.CreateBigHeart = function CreateBigHeartFn(ThisScript, Object) {
        var CollectableEntity = EntityCollectable.Create(GlobalMain.PlayerEntity.x, GlobalMain.PlayerEntity.y, 0, 1, 1, EntityCollectable.TypeHealthBig, false);
        var Room = GlobalMain.MissionManager.GetCurrentRoom();
        GlobalMain.WorldRenderer.MainLayer.AddEntity(CollectableEntity);
        Entity.SetPosition(CollectableEntity, GlobalMain.PlayerEntity.x, Room.RoomInfo.Bounds.AABB_Top);
        return true
    };
    ScriptFunctions.Init = function ScriptFunctionsInitFn() {
        var Functions = [{
            Name: "CameraTrackPlayer",
            Function: ScriptFunctions.CameraTrackPlayer
        }, {
            Name: "CameraSetPosition",
            Function: ScriptFunctions.CameraSetPosition
        }, {
            Name: "CameraMovePosition",
            Function: ScriptFunctions.CameraMovePosition
        }, {
            Name: "CameraMoveToPlayer",
            Function: ScriptFunctions.CameraMoveToPlayer
        }, {
            Name: "CameraSetZoom",
            Function: ScriptFunctions.CameraSetZoom
        }, {
            Name: "CameraMoveZoom",
            Function: ScriptFunctions.CameraMoveZoom
        }, {
            Name: "CameraSetRotation",
            Function: ScriptFunctions.CameraSetRotation
        }, {
            Name: "CameraMoveRotation",
            Function: ScriptFunctions.CameraMoveRotation
        }, {
            Name: "CameraShake",
            Function: ScriptFunctions.CameraShake
        }, {
            Name: "ChangeMusic",
            Function: ScriptFunctions.ChangeMusic
        }, {
            Name: "SetMusicVolume",
            Function: ScriptFunctions.SetMusicVolume
        }, {
            Name: "TextSetQuestName",
            Function: ScriptFunctions.TextSetQuestName
        }, {
            Name: "TextSetQuestObjective",
            Function: ScriptFunctions.TextSetQuestObjective
        }, {
            Name: "TextSetMonsterName",
            Function: ScriptFunctions.TextSetMonsterName
        }, {
            Name: "CreateWord",
            Function: ScriptFunctions.CreateWord
        }, {
            Name: "DestroyWord",
            Function: ScriptFunctions.DestroyWord
        }, {
            Name: "DoAttack",
            Function: ScriptFunctions.DoAttack
        }, {
            Name: "SetMonsterWarning",
            Function: ScriptFunctions.SetMonsterWarning
        }, {
            Name: "CreateBigHeart",
            Function: ScriptFunctions.CreateBigHeart
        }];
        JamSystem.ScriptManager.AddFunctions(Functions)
    };

    function ScriptEntityFunctions() {}
    ScriptEntityFunctions.prototype = {};
    ScriptEntityFunctions.EntityGet = function EntityGetFn(ThisScript, Name) {
        if (ThisScript.LocalVariables[Name]) {
            return ThisScript.LocalVariables[Name]
        }
        ThisScript.Error = "EntityGet : Couldn't find " + Name;
        return null
    };
    ScriptEntityFunctions.GetCoords = function GetCoordsFn(Object) {
        if (Object.Target) {
            var ThisEntity = GlobalMain.World.FindSingleEntityByName(Object.Target);
            if (ThisEntity) {
                return new Vector2(ThisEntity.x, ThisEntity.y)
            } else {
                ThisScript.Error = "Couldn't find target " + Object.Target;
                return new Vector2(0, 0)
            }
        } else {
            return new Vector2(Object.x, Object.y)
        }
    };
    ScriptEntityFunctions.EntityCreate = function EntityCreateFn(ThisScript, Object) {
        var Coords = ScriptEntityFunctions.GetCoords(Object);
        var NewEntity = EntityScriptable.Create(Coords.x, Coords.y, 0, 1, 1, Object.Image);
        NewEntity.ScriptData = 1;
        ThisScript.LocalVariables[Object.Name] = NewEntity;
        var ThisLayer = GlobalMain.World.GetLayerByName(Object.Layer);
        ThisLayer.AddEntity(NewEntity);
        return true
    };
    ScriptEntityFunctions.EntityDestroy = function EntityDestroyFn(ThisScript, Object) {
        var ThisEntity = ScriptEntityFunctions.EntityGet(ThisScript, Object.Name);
        if (!ThisEntity) {
            return
        }
        return true
    };
    ScriptEntityFunctions.EntitySetAnchor = function EntitySetAnchorFn(ThisScript, Object) {
        var ThisEntity = ScriptEntityFunctions.EntityGet(ThisScript, Object.Name);
        if (!ThisEntity) {
            return
        }
        var Anchor = null;
        if (Object.Anchor === "TopLeft") {
            Anchor = EA.TopLeft
        } else if (Object.Anchor === "TopMiddle") {
            Anchor = EA.TopMiddle
        } else if (Object.Anchor === "TopRight") {
            Anchor = EA.TopRight
        } else if (Object.Anchor === "MiddleLeft") {
            Anchor = EA.MiddleLeft
        } else if (Object.Anchor === "MiddleMiddle") {
            Anchor = EA.MiddleMiddle
        } else if (Object.Anchor === "Middle") {
            Anchor = EA.Middle
        } else if (Object.Anchor === "Default") {
            Anchor = EA.Default
        } else if (Object.Anchor === "MiddleRight") {
            Anchor = EA.MiddleRight
        } else if (Object.Anchor === "BottomLeft") {
            Anchor = EA.BottomLeft
        } else if (Object.Anchor === "BottomMiddle") {
            Anchor = EA.BottomMiddle
        } else if (Object.Anchor === "BottomRight") {
            Anchor = EA.BottomRight
        }
        ThisEntity.Sprite.SetAnchor(Anchor);
        return true
    };
    ScriptEntityFunctions.EntitySetImage = function EntitySetImageFn(ThisScript, Object) {
        var ThisEntity = ScriptEntityFunctions.EntityGet(ThisScript, Object.Name);
        if (!ThisEntity) {
            return
        }
        ThisEntity.SetImage(Object.Image);
        return true
    };
    ScriptEntityFunctions.EntitySetPosition = function EntitySetPositionFn(ThisScript, Object) {
        var ThisEntity = ScriptEntityFunctions.EntityGet(ThisScript, Object.Name);
        if (!ThisEntity) {
            return
        }
        var Coords = ScriptEntityFunctions.GetCoords(Object);
        ThisEntity.SetPosition(Coords.x, Coords.y);
        return true
    };
    ScriptEntityFunctions.EntityMoveTo = function EntityMoveToFn(ThisScript, Object) {
        var ThisEntity = ScriptEntityFunctions.EntityGet(ThisScript, Object.Name);
        if (!ThisEntity) {
            return
        }
        var Coords = ScriptEntityFunctions.GetCoords(Object);
        ThisEntity.MoveTo(Coords.x, Coords.y, Object.Delay);
        return true
    };
    ScriptEntityFunctions.EntityMoveToWait = function EntityMoveToWaitFn(ThisScript, Object) {
        var ThisEntity = ScriptEntityFunctions.EntityGet(ThisScript, Object.Name);
        if (!ThisEntity) {
            return
        }
        if (ThisEntity.IsMoveFinished()) {
            return true
        }
        return false
    };
    ScriptEntityFunctions.EntitySetScale = function EntitySetScaleFn(ThisScript, Object) {
        var ThisEntity = ScriptEntityFunctions.EntityGet(ThisScript, Object.Name);
        if (!ThisEntity) {
            return
        }
        ThisEntity.SetScale(Object.x, Object.y);
        return true
    };
    ScriptEntityFunctions.GameSetCageCoords = function GameSetCageCoordsFn(ThisScript, Object) {
        var ThisEntity = ScriptEntityFunctions.EntityGet(ThisScript, Object.Name);
        if (!ThisEntity) {
            return
        }
        ThisEntity.SetPosition(GlobalMain.PlayerEntity.x, GlobalMain.MissionManager.GetCurrentRoom().RoomInfo.Bounds.AABB_Top);
        return true
    };
    ScriptEntityFunctions.GameMoveCageCoords = function GameMoveCageCoordsFn(ThisScript, Object) {
        var ThisEntity = ScriptEntityFunctions.EntityGet(ThisScript, Object.Name);
        if (!ThisEntity) {
            return
        }
        ThisEntity.MoveTo(GlobalMain.PlayerEntity.x, GlobalMain.PlayerEntity.y, Object.Delay);
        return true
    };
    ScriptEntityFunctions.Init = function ScriptEntityFunctionsInitFn() {
        var Functions = [{
            Name: "EntityCreate",
            Function: ScriptEntityFunctions.EntityCreate
        }, {
            Name: "EntityDestroy",
            Function: ScriptEntityFunctions.EntityDestroy
        }, {
            Name: "EntitySetImage",
            Function: ScriptEntityFunctions.EntitySetImage
        }, {
            Name: "EntitySetAnchor",
            Function: ScriptEntityFunctions.EntitySetAnchor
        }, {
            Name: "EntitySetPosition",
            Function: ScriptEntityFunctions.EntitySetPosition
        }, {
            Name: "EntityMoveTo",
            Function: ScriptEntityFunctions.EntityMoveTo
        }, {
            Name: "EntityMoveToWait",
            Function: ScriptEntityFunctions.EntityMoveToWait
        }, {
            Name: "EntitySetScale",
            Function: ScriptEntityFunctions.EntitySetScale
        }, {
            Name: "GameSetCageCoords",
            Function: ScriptEntityFunctions.GameSetCageCoords
        }, {
            Name: "GameMoveCageCoords",
            Function: ScriptEntityFunctions.GameMoveCageCoords
        }];
        JamSystem.ScriptManager.AddFunctions(Functions)
    };

    function EntityGame() {}
    EntityGame.Name = "Game";
    EntityGame.DayLightID = 0;
    EntityGame.ForestAmbienceID = 1;
    EntityGame.CaveAmbienceID = 2;
    EntityGame.DungeonAmbienceID = 3;
    EntityGame.EditableVariables = [{
        Name: "Day light",
        Type: "Slider",
        Slider: {
            Min: 0,
            Max: 1
        },
        Default: 1,
        Info: "Day light brightness.\nUse this for lighting testing"
    }, {
        Name: "Forest Ambience",
        Type: "Number",
        Default: 1,
        Info: "Lighting ambient level in the forest"
    }, {
        Name: "Cave Ambience",
        Type: "Number",
        Default: 1,
        Info: "Lighting ambient level in the cave"
    }, {
        Name: "Dungeon Ambience",
        Type: "Number",
        Default: 1,
        Info: "Lighting ambient level in the dungeon"
    }];
    EntityGame.prototype = {
        ShowEditMode: function ShowEditModeFn(EditActive) {
            this.SetIsVisible(EditActive)
        },
        UpdateEditableVariable: function UpdateEditableVariableFn(VariableIndex) {
            if (VariableIndex === EntityGame.DayLightID) {
                GlobalMain.WorldRenderer.DayLight = this.EditableVariables[EntityGame.DayLightID]
            }
        }
    };
    EntityGame.Create = function EntityGameFn(x, y, Rotation, ScaleX, ScaleY, Name, Image, Collision) {
        var NewObject = EntityNone.Create(x, y, Rotation, ScaleX, ScaleY, Name, Image, Collision);
        NewObject.ShowEditMode = EntityGame.prototype.ShowEditMode;
        NewObject.UpdateEditableVariable = EntityGame.prototype.UpdateEditableVariable;
        NewObject.TypeID = EntityGame.TypeID;
        return NewObject
    };
    var SCREEN_WIDTH = 1022;
    var SCREEN_HEIGHT = 720;
    var SCREEN_SCALER = 2;
    var BUTTON_NORMAL_SCALE = 1;
    var BUTTON_OVER_SCALE = 1.2;
    var BUTTON_UNDER_SCALE = .9;

    function Globals() {}
    Globals.ButtonIndex = 1e4;
    Globals.achNewMusicFile = 0;
    Globals.achLastMusicFile = 0;
    Globals.dwTimer = 0;
    Globals.bSetup = 0;
    Globals.bFadeOutMusic = 0;
    Globals.bFadeInMusic = 0;
    Globals.bMusicPlaying = 0;
    Globals.bLooped = 0;
    Globals.bWaitToStop = 0;
    Globals.achOldMusicFile = 0;
    Globals.bInterruptMusic = 0;
    Globals.bOldLooped = 0;
    var FADE_DELAY = 30;
    Globals.psBG = 0;
    Globals.psBGShadow = 0;
    Globals.Init = function() {
        Script.SetDefaultObjectParent(GadgetTree.GetLayer(LAYERS_HUD));
        Script.SetUserProcessFunction(ScriptExt.ProcessInstruction);
        AnimationMisc_SetupFrames();
        EntityManager.Init();
        Script.Initialise();
        Touch.Init();
        Records.Init();
        Globals.achNewMusicFile = "";
        Globals.bSetup = false;
        Globals.bFadeOutMusic = false;
        Globals.bFadeInMusic = false;
        Globals.dwTimer = 0;
        Globals.bMusicPlaying = false;
        Globals.bInterruptMusic = false;
        Globals.bLooped = false;
        Globals.bWaitToStop = false
    };
    Globals.ShutDown = function() {
        if (!Globals.bSetup) {
            return
        }
        if (Globals.bSetup) {
            LevelSelect.Destroy();
            LevelGrid.ShutDown()
        }
        Records.ShutDown();
        Touch.ShutDown();
        GlobalMain.MusicManager.RequestChangeMusic("", 1, true)
    };
    Globals.SetBackgroundMusic = function(pszFileName, bFade, bLooped) {
        Globals.bWaitToStop = false;
        if (!Globals.bFadeInMusic && GlobalMain.MusicManager.RequestMusicName) {
            GlobalMain.MusicManager.RequestChangeMusic("", 1, true);
            Globals.bWaitToStop = true;
            Globals.dwTimer = 6
        } else {
            Globals.dwTimer = 6
        }
        Globals.achNewMusicFile = pszFileName;
        Globals.achLastMusicFile = pszFileName;
        Globals.bFadeInMusic = bFade;
        Globals.bMusicPlaying = true;
        Globals.bInterruptMusic = false;
        Globals.bLooped = bLooped
    };
    Globals.WaitBackgroundMusic = function() {
        if (Globals.dwTimer || GlobalMain.MusicManager.RequestMusicName) {
            return true
        }
        return false
    };
    Globals.InterruptBackgroundMusic = function(pszFileName) {
        Globals.achOldMusicFile = Globals.achLastMusicFile;
        Globals.achNewMusicFile = pszFileName;
        Globals.bFadeInMusic = false;
        Globals.bFadeOutMusic = false;
        Globals.bMusicPlaying = true;
        Globals.dwTimer = 4;
        Globals.bInterruptMusic = true;
        Globals.bOldLooped = Globals.bLooped;
        Globals.bLooped = false
    };
    Globals.WaitInterruptBackgroundMusic = function() {
        if (Globals.achOldMusicFile !== "") {
            return true
        }
        return false
    };
    Globals.StopBackgroundMusic = function() {
        GlobalMain.MusicManager.RequestChangeMusic("", 1, true);
        Globals.bFadeInMusic = false;
        Globals.bFadeOutMusic = false;
        Globals.bMusicPlaying = false;
        Globals.dwTimer = 1;
        Globals.achNewMusicFile = "";
        Globals.bInterruptMusic = false
    };
    Globals.FadeBackgroundMusic = function() {
        if (Globals.bFadeInMusic) {
            Globals.bFadeInMusic = false;
            Globals.dwTimer = FADE_DELAY - Globals.dwTimer
        } else {
            Globals.dwTimer = FADE_DELAY
        }
        Globals.bFadeOutMusic = true
    };
    Globals.SetBackgroundMusicVolume = function(fVolume) {
        GlobalMain.MusicManager.SetVolume(fVolume)
    };
    Globals.Setup = function() {
        LevelGrid.Init();
        LevelSelect.Create();
        Globals.bSetup = true
    };
    Globals.Update = function() {
        if (!Globals.bSetup) {
            return
        }
        if (Globals.bFadeOutMusic) {
            Globals.dwTimer -= 1;
            GlobalMain.MusicManager.SetVolume(Globals.dwTimer / FADE_DELAY);
            if (Globals.dwTimer === 0) {
                Globals.bFadeOutMusic = false;
                if (Globals.achNewMusicFile) {
                    Globals.dwTimer = 6
                }
            }
        } else {
            if (Globals.achNewMusicFile !== "") {
                Globals.dwTimer -= 1;
                if (Globals.dwTimer === 1) {
                    GlobalMain.MusicManager.RequestChangeMusic(Globals.achNewMusicFile, 1, Globals.bLooped)
                }
                if (Globals.dwTimer === 0) {
                    Globals.achNewMusicFile = "";
                    if (Globals.bFadeInMusic) {
                        GlobalMain.MusicManager.SetVolume(0);
                        Globals.dwTimer = FADE_DELAY
                    } else {
                        GlobalMain.MusicManager.SetVolume(1)
                    }
                }
            } else {
                if (Globals.bFadeInMusic) {
                    Globals.dwTimer -= 1;
                    GlobalMain.MusicManager.SetVolume(1 - Globals.dwTimer / FADE_DELAY);
                    if (Globals.dwTimer === 0) {
                        Globals.bFadeInMusic = false
                    }
                }
            }
        }
        if (Globals.bInterruptMusic) {
            if (!Globals.dwTimer && !GlobalMain.MusicManager.RequestMusicName) {
                Globals.bInterruptMusic = false;
                Globals.bLooped = Globals.bOldLooped;
                Globals.achNewMusicFile = Globals.achOldMusicFile;
                Globals.achOldMusicFile = "";
                Globals.dwTimer = 4
            }
        }
        LevelGrid.Update();
        ScriptExtInstructions.Update()
    };
    Globals.BounceImage = function(psImage) {
        var dwScript = Script.Add(ScriptData.ScaleBounce);
        Script.SetLocalVariableID(dwScript, SCRIPT_LOCAL_VARIABLE_1, psImage);
        Script.SetLocalVariableID(dwScript, SCRIPT_LOCAL_VARIABLE_2, BUTTON_NORMAL_SCALE * 100);
        Script.SetLocalVariableID(dwScript, SCRIPT_LOCAL_VARIABLE_3, BUTTON_OVER_SCALE * 100);
        Script.SetLocalVariableID(dwScript, SCRIPT_LOCAL_VARIABLE_4, BUTTON_UNDER_SCALE * 100);
        Script.SetLocalVariableID(dwScript, SCRIPT_LOCAL_VARIABLE_5, Globals.ButtonIndex += 1)
    };
    Globals.SetBGSize = function(fTop, fBottom, fLeft, fRight) {
        return;
        Globals.psBG.SetIsVisible(true);
        Globals.psBGShadow.SetIsVisible(true);
        if (fTop) {
            Globals.psBG.SetFrameByName("Background", 0, fTop, SCREEN_WIDTH, SCREEN_HEIGHT - fTop);
            Globals.psBG.SetPosition(0, fTop);
            Globals.psBGShadow.SetRotation(22 / 7);
            Globals.psBGShadow.SetPosition(SCREEN_WIDTH, fTop);
            Globals.psBGShadow.SetAnchor(EA.BottomLeft);
            Globals.psBGShadow.SetScale(SCREEN_WIDTH, 2)
        } else if (fBottom) {
            Globals.psBG.SetFrameByName("Background", 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT - fBottom);
            Globals.psBG.SetPosition(0, 0);
            Globals.psBGShadow.SetRotation(0);
            Globals.psBGShadow.SetPosition(0, SCREEN_HEIGHT - fBottom);
            Globals.psBGShadow.SetAnchor(EA.BottomLeft);
            Globals.psBGShadow.SetScale(SCREEN_WIDTH, 2)
        } else if (fLeft) {
            Globals.psBG.SetFrameByName("Background", fLeft, 0, SCREEN_WIDTH - fLeft, SCREEN_HEIGHT);
            Globals.psBG.SetPosition(fLeft, 0);
            Globals.psBGShadow.SetRotation(11 / 7);
            Globals.psBGShadow.SetPosition(fLeft, 0);
            Globals.psBGShadow.SetAnchor(EA.BottomLeft);
            Globals.psBGShadow.SetScale(2, SCREEN_HEIGHT)
        } else if (fRight) {
            Globals.psBG.SetFrameByName("Background", 0, 0, SCREEN_WIDTH - fRight, SCREEN_HEIGHT);
            Globals.psBG.SetPosition(0, 0);
            Globals.psBGShadow.SetRotation(33 / 7);
            Globals.psBGShadow.SetPosition(SCREEN_WIDTH - fRight, SCREEN_HEIGHT);
            Globals.psBGShadow.SetAnchor(EA.BottomLeft);
            Globals.psBGShadow.SetScale(2, SCREEN_HEIGHT)
        } else {
            Globals.psBG.SetIsVisible(false);
            Globals.psBGShadow.SetIsVisible(false)
        }
    };
    var AnimationMisc_sBlank = {
        Looped: true,
        Frames: [{
            Image: "NewBlank",
            Delay: 100 / 60
        }]
    };
    var AnimationMisc_sSparkle = {
        Looped: true,
        Frames: [{
            Image: "EffectSparkle",
            Delay: 1 / 60
        }, {
            Image: "EffectSparkle02",
            Delay: 1 / 60
        }]
    };
    var AnimationMisc_sEyes = {
        Looped: true,
        Frames: [{
            Image: "Eyes01",
            Delay: 60 / 60
        }, {
            Image: "NewBlank",
            Delay: 5 / 60
        }, {
            Image: "Eyes01",
            Delay: 5 / 60
        }, {
            Image: "NewBlank",
            Delay: 5 / 60
        }]
    };
    var AnimationMisc_sSheen = {
        Looped: false,
        Frames: [{
            Image: "PuzzleOutlineSheen01",
            Delay: 2 / 60
        }, {
            Image: "PuzzleOutlineSheen02",
            Delay: 2 / 60
        }, {
            Image: "PuzzleOutlineSheen03",
            Delay: 2 / 60
        }, {
            Image: "PuzzleOutlineSheen04",
            Delay: 2 / 60
        }, {
            Image: "PuzzleOutlineSheen05",
            Delay: 2 / 60
        }, {
            Image: "PuzzleOutlineSheen06",
            Delay: 2 / 60
        }, {
            Image: "PuzzleOutline",
            Delay: 1 / 60
        }]
    };
    AnimationMisc_Data = [AnimationMisc_sBlank, AnimationMisc_sSparkle, AnimationMisc_sEyes, AnimationMisc_sSheen];
    AnimationMisc_SetupFrames = function SetupFrames() {
        var i, j, k;
        for (i = 0; i < AnimationMisc_Data.length; i += 1) {
            var Animation = AnimationMisc_Data[i];
            var SourceTexture = Helpers.GetTextureInfoFromImageName(Animation.Frames[0].Image);
            var Frame;
            for (k = 0; k < Animation.Frames.length; k += 1) {
                Frame = Animation.Frames[k];
                Frame.FrameIndex = SourceTexture.Texture.GetFrameIndexFromName(Frame.Image);
                Debug.Assert(Frame.FrameIndex !== -1, "Couldn't find image " + Frame.Image)
            }
        }
    };

    function Script() {}
    var SCRIPT_MAX_ARGUMENTS = 20;
    var SCRIPT_ID_NONE = -1;
    var SCRIPT_INSTRUCTION_DEBUG_OUTPUT = 0;
    var SCRIPT_INSTRUCTION_SET_TYPE = 1;
    var SCRIPT_INSTRUCTION_STOP_TYPE = 2;
    var SCRIPT_INSTRUCTION_PAUSE = 3;
    var SCRIPT_INSTRUCTION_PAUSE_ALL = 4;
    var SCRIPT_INSTRUCTION_DISABLE_WAIT = 5;
    var SCRIPT_INSTRUCTION_SCRIPT_ADD = 6;
    var SCRIPT_INSTRUCTION_SCRIPT_WAIT = 7;
    var SCRIPT_INSTRUCTION_SCRIPT_STOP = 8;
    var SCRIPT_INSTRUCTION_SCRIPT_SET_PAUSED = 9;
    var SCRIPT_INSTRUCTION_SET_VARIABLE = 10;
    var SCRIPT_INSTRUCTION_SET_VARIABLE_RAND = 11;
    var SCRIPT_INSTRUCTION_SET_VARIABLE_POINTER = 12;
    var SCRIPT_INSTRUCTION_ADD_VARIABLE = 13;
    var SCRIPT_INSTRUCTION_MARKER = 14;
    var SCRIPT_INSTRUCTION_GOTO = 15;
    var SCRIPT_INSTRUCTION_CMP = 16;
    var SCRIPT_INSTRUCTION_WAIT = 17;
    var SCRIPT_INSTRUCTION_WAIT_OR_KEYPRESS = 18;
    var SCRIPT_INSTRUCTION_WAIT_FRAME = 19;
    var SCRIPT_INSTRUCTION_WAIT_NOT_KEY_PRESS = 20;
    var SCRIPT_INSTRUCTION_WAIT_KEY_PRESS = 21;
    var SCRIPT_INSTRUCTION_CREATE_OBJECT_LAYERS = 22;
    var SCRIPT_INSTRUCTION_DESTROY_OBJECT_LAYERS = 23;
    var SCRIPT_INSTRUCTION_OBJECT_CREATE_SPRITE = 24;
    var SCRIPT_INSTRUCTION_OBJECT_CREATE_TEXT = 25;
    var SCRIPT_INSTRUCTION_OBJECT_CREATE_ANIMATION = 26;
    var SCRIPT_INSTRUCTION_OBJECT_CREATE_MODEL = 27;
    var SCRIPT_INSTRUCTION_OBJECT_CREATE_LIGHT = 28;
    var SCRIPT_INSTRUCTION_OBJECT_SET_SPRITE = 29;
    var SCRIPT_INSTRUCTION_OBJECT_SET_TEXT = 30;
    var SCRIPT_INSTRUCTION_OBJECT_SET_ANIMATION = 31;
    var SCRIPT_INSTRUCTION_OBJECT_SET_MODEL = 32;
    var SCRIPT_INSTRUCTION_OBJECT_SET_PARENT = 33;
    var SCRIPT_INSTRUCTION_OBJECT_SET_LAYER = 34;
    var SCRIPT_INSTRUCTION_OBJECT_SET_ALIGNMENT = 35;
    var SCRIPT_INSTRUCTION_OBJECT_MOVE_SET = 36;
    var SCRIPT_INSTRUCTION_OBJECT_MOVE_SET_3D = 37;
    var SCRIPT_INSTRUCTION_OBJECT_MOVE = 38;
    var SCRIPT_INSTRUCTION_OBJECT_MOVE_TO = 39;
    var SCRIPT_INSTRUCTION_OBJECT_MOVE_TO_EASE = 40;
    var SCRIPT_INSTRUCTION_OBJECT_MOVE_3D = 41;
    var SCRIPT_INSTRUCTION_OBJECT_MOVE_EASE_3D = 42;
    var SCRIPT_INSTRUCTION_OBJECT_MOVE_TO_3D = 43;
    var SCRIPT_INSTRUCTION_OBJECT_MOVE_TO_EASE_3D = 44;
    var SCRIPT_INSTRUCTION_OBJECT_WAIT_MOVED = 45;
    var SCRIPT_INSTRUCTION_OBJECT_LOOK_SET_3D = 46;
    var SCRIPT_INSTRUCTION_OBJECT_LOOK_3D = 47;
    var SCRIPT_INSTRUCTION_OBJECT_LOOK_EASE_3D = 48;
    var SCRIPT_INSTRUCTION_OBJECT_LOOK_TO_3D = 49;
    var SCRIPT_INSTRUCTION_OBJECT_LOOK_TO_EASE_3D = 50;
    var SCRIPT_INSTRUCTION_OBJECT_WAIT_LOOK = 51;
    var SCRIPT_INSTRUCTION_OBJECT_SCALE_SET = 52;
    var SCRIPT_INSTRUCTION_OBJECT_SCALE = 53;
    var SCRIPT_INSTRUCTION_OBJECT_SCALE_TO = 54;
    var SCRIPT_INSTRUCTION_OBJECT_SCALE_TO_EASE = 55;
    var SCRIPT_INSTRUCTION_OBJECT_SCALE_SET_3D = 56;
    var SCRIPT_INSTRUCTION_OBJECT_SCALE_3D = 57;
    var SCRIPT_INSTRUCTION_OBJECT_SCALE_EASE_3D = 58;
    var SCRIPT_INSTRUCTION_OBJECT_SCALE_TO_3D = 59;
    var SCRIPT_INSTRUCTION_OBJECT_SCALE_TO_EASE_3D = 60;
    var SCRIPT_INSTRUCTION_OBJECT_WAIT_SCALE = 61;
    var SCRIPT_INSTRUCTION_OBJECT_ROTATE_SET = 62;
    var SCRIPT_INSTRUCTION_OBJECT_ROTATE = 63;
    var SCRIPT_INSTRUCTION_OBJECT_ROTATE_TO = 64;
    var SCRIPT_INSTRUCTION_OBJECT_ROTATE_TO_EASE = 65;
    var SCRIPT_INSTRUCTION_OBJECT_ROTATE_SET_3D = 66;
    var SCRIPT_INSTRUCTION_OBJECT_ROTATE_3D = 67;
    var SCRIPT_INSTRUCTION_OBJECT_ROTATE_EASE_3D = 68;
    var SCRIPT_INSTRUCTION_OBJECT_ROTATE_TO_3D = 69;
    var SCRIPT_INSTRUCTION_OBJECT_ROTATE_TO_EASE_3D = 70;
    var SCRIPT_INSTRUCTION_OBJECT_WAIT_ROTATE = 71;
    var SCRIPT_INSTRUCTION_OBJECT_TRANSFORM_SET = 72;
    var SCRIPT_INSTRUCTION_OBJECT_ALPHA_SET = 73;
    var SCRIPT_INSTRUCTION_OBJECT_ALPHA = 74;
    var SCRIPT_INSTRUCTION_OBJECT_ALPHA_TO = 75;
    var SCRIPT_INSTRUCTION_OBJECT_WAIT_ALPHA = 76;
    var SCRIPT_INSTRUCTION_OBJECT_SET_COLOUR = 77;
    var SCRIPT_INSTRUCTION_OBJECT_VISIBLE = 78;
    var SCRIPT_INSTRUCTION_OBJECT_DESTROY = 79;
    var SCRIPT_INSTRUCTION_PLAY_AUDIO = 80;
    var SCRIPT_INSTRUCTION_IS_AUDIO_PLAYING = 81;
    var SCRIPT_INSTRUCTION_STOP_AUDIO = 82;
    var SCRIPT_INSTRUCTION_WAIT_AUDIO = 83;
    var SCRIPT_INSTRUCTION_PITCH_AUDIO = 84;
    var SCRIPT_INSTRUCTION_SET_MUSIC = 85;
    var SCRIPT_INSTRUCTION_FADE_MUSIC = 86;
    var SCRIPT_INSTRUCTION_SEND_USER_INPUT = 87;
    var SCRIPT_INSTRUCTION_SET_MENU_OPTION_STATE = 88;
    var SCRIPT_INSTRUCTION_LOAD_MENU_OPTION_STATE = 89;
    var SCRIPT_INSTRUCTION_END = 90;
    var SCRIPT_INSTRUCTION_TOTAL = 91;
    var SCRIPT_CMPTYPE_EQUAL = 0;
    var SCRIPT_CMPTYPE_LESS = 1;
    var SCRIPT_CMPTYPE_GREATER = 2;
    var SCRIPT_CMPTYPE_LESS_EQUAL = 3;
    var SCRIPT_CMPTYPE_GREATER_EQUAL = 4;
    var SCRIPT_CMPTYPE_NOT = 5;
    var SCRIPT_CMPTYPE_TOTAL = 6;
    var SCRIPT_GLOBAL_NUM_VARIABLES = 16;
    var SCRIPT_GLOBAL_VARIABLE_1 = 2147483392;
    var SCRIPT_GLOBAL_VARIABLE_2 = SCRIPT_GLOBAL_VARIABLE_1 + 1;
    var SCRIPT_GLOBAL_VARIABLE_3 = SCRIPT_GLOBAL_VARIABLE_2 + 1;
    var SCRIPT_GLOBAL_VARIABLE_4 = SCRIPT_GLOBAL_VARIABLE_3 + 1;
    var SCRIPT_GLOBAL_VARIABLE_5 = SCRIPT_GLOBAL_VARIABLE_4 + 1;
    var SCRIPT_GLOBAL_VARIABLE_6 = SCRIPT_GLOBAL_VARIABLE_5 + 1;
    var SCRIPT_GLOBAL_VARIABLE_7 = SCRIPT_GLOBAL_VARIABLE_6 + 1;
    var SCRIPT_GLOBAL_VARIABLE_8 = SCRIPT_GLOBAL_VARIABLE_7 + 1;
    var SCRIPT_GLOBAL_VARIABLE_9 = SCRIPT_GLOBAL_VARIABLE_8 + 1;
    var SCRIPT_GLOBAL_VARIABLE_10 = SCRIPT_GLOBAL_VARIABLE_9 + 1;
    var SCRIPT_GLOBAL_VARIABLE_11 = SCRIPT_GLOBAL_VARIABLE_10 + 1;
    var SCRIPT_GLOBAL_VARIABLE_12 = SCRIPT_GLOBAL_VARIABLE_11 + 1;
    var SCRIPT_GLOBAL_VARIABLE_13 = SCRIPT_GLOBAL_VARIABLE_12 + 1;
    var SCRIPT_GLOBAL_VARIABLE_14 = SCRIPT_GLOBAL_VARIABLE_13 + 1;
    var SCRIPT_GLOBAL_VARIABLE_15 = SCRIPT_GLOBAL_VARIABLE_14 + 1;
    var SCRIPT_GLOBAL_VARIABLE_16 = SCRIPT_GLOBAL_VARIABLE_15 + 1;
    var SCRIPT_LOCAL_NUM_VARIABLES = 17;
    var SCRIPT_LOCAL_VARIABLE_1 = SCRIPT_GLOBAL_VARIABLE_16 + 1;
    var SCRIPT_LOCAL_VARIABLE_2 = SCRIPT_LOCAL_VARIABLE_1 + 1;
    var SCRIPT_LOCAL_VARIABLE_3 = SCRIPT_LOCAL_VARIABLE_2 + 1;
    var SCRIPT_LOCAL_VARIABLE_4 = SCRIPT_LOCAL_VARIABLE_3 + 1;
    var SCRIPT_LOCAL_VARIABLE_5 = SCRIPT_LOCAL_VARIABLE_4 + 1;
    var SCRIPT_LOCAL_VARIABLE_6 = SCRIPT_LOCAL_VARIABLE_5 + 1;
    var SCRIPT_LOCAL_VARIABLE_7 = SCRIPT_LOCAL_VARIABLE_6 + 1;
    var SCRIPT_LOCAL_VARIABLE_8 = SCRIPT_LOCAL_VARIABLE_7 + 1;
    var SCRIPT_LOCAL_VARIABLE_9 = SCRIPT_LOCAL_VARIABLE_8 + 1;
    var SCRIPT_LOCAL_VARIABLE_10 = SCRIPT_LOCAL_VARIABLE_9 + 1;
    var SCRIPT_LOCAL_VARIABLE_11 = SCRIPT_LOCAL_VARIABLE_10 + 1;
    var SCRIPT_LOCAL_VARIABLE_12 = SCRIPT_LOCAL_VARIABLE_11 + 1;
    var SCRIPT_LOCAL_VARIABLE_13 = SCRIPT_LOCAL_VARIABLE_12 + 1;
    var SCRIPT_LOCAL_VARIABLE_14 = SCRIPT_LOCAL_VARIABLE_13 + 1;
    var SCRIPT_LOCAL_VARIABLE_15 = SCRIPT_LOCAL_VARIABLE_14 + 1;
    var SCRIPT_LOCAL_VARIABLE_16 = SCRIPT_LOCAL_VARIABLE_15 + 1;
    var SCRIPT_LOCAL_VARIABLE_POINTER = SCRIPT_LOCAL_VARIABLE_16 + 1;
    Script.dwGlobalVariables = [];
    Script.bInputEnabled = 0;
    Script.psDefaultParent = 0;
    Script.psCurrentParent = 0;
    Script.bAddNew = 0;
    Script.dwCurrentlyProcessedId = 0;
    Script.psUserProcessFunction = 0;
    Script.bPaused = 0;
    Script.bDisableWait = 0;
    Script.psList = 0;
    Script.bButtonPressed = false;
    Script.Initialise = function() {
        ScriptObjects.Initialise();
        Script.psList = [];
        Script.bAddNew = true;
        Script.bPaused = false;
        Script.bInputEnabled = true;
        Script.dwCurrentlyProcessedId = -1;
        var i;
        for (i = 0; i < SCRIPT_GLOBAL_NUM_VARIABLES; i += 1) {
            Script.dwGlobalVariables[i] = 0
        }
    };
    Script.ShutDown = function() {
        Script.StopAll(true);
        ScriptObjects.ShutDown();
        Script.psList = []
    };
    Script.FindWithID = function(dwID) {
        var i;
        for (i = 0; i < Script.psList.length; i += 1) {
            if (Script.psList[i].dwID === dwID) {
                return Script.psList[i]
            }
        }
        return null
    };
    Script.FindNodeWithID = function(dwID) {
        var i;
        for (i = 0; i < Script.psList.length; i += 1) {
            if (Script.psList[i].dwID === dwID) {
                return i
            }
        }
        return -1
    };
    Script.SetUserProcessFunction = function(psFn) {
        Script.psUserProcessFunction = psFn
    };
    Script.EnableAddNew = function(bAddNew) {
        Script.bAddNew = bAddNew
    };
    Script.AddMarkers = function(psScript) {
        var i, j, k;
        var dwNumMarkers = 0;
        var adwTempMarkers = [];
        var adwTempMarkerOffsets = [];
        var adwTempMarkerFrames = [];
        var pdwScriptData;
        var dwFrame = 0;
        pdwScriptData = psScript.pdwScriptData;
        j = 0;
        while (pdwScriptData[j] !== SCRIPT_INSTRUCTION_END) {
            if (pdwScriptData[j] === SCRIPT_INSTRUCTION_WAIT_FRAME) {
                dwFrame = pdwScriptData[j + 2]
            } else if (pdwScriptData[j] === SCRIPT_INSTRUCTION_MARKER) {
                adwTempMarkerOffsets[dwNumMarkers] = j;
                adwTempMarkers[dwNumMarkers] = pdwScriptData[j + 2];
                adwTempMarkerFrames[dwNumMarkers] = dwFrame;
                dwNumMarkers += 1
            }
            j += pdwScriptData[j + 1] + 2
        }
        if (dwNumMarkers) {
            psScript.paMarkerOffsets = [];
            psScript.paMarkers = [];
            psScript.paMarkerFrames = [];
            for (i = 0; i < dwNumMarkers; i += 1) {
                psScript.paMarkerOffsets[i] = adwTempMarkerOffsets[i];
                psScript.paMarkers[i] = adwTempMarkers[i];
                psScript.paMarkerFrames[i] = adwTempMarkerFrames[i]
            }
        } else {
            psScript.paMarkers = null;
            psScript.paMarkerOffsets = null;
            psScript.paMarkerFrames = null
        }
        psScript.dwNumMarkers = dwNumMarkers
    };
    Script.RemoveMarkers = function(psScript) {
        if (psScript.paMarkers) {
            psScript.paMarkers = []
        }
        if (psScript.paMarkerOffsets) {
            psScript.paMarkerOffsets = []
        }
        if (psScript.paMarkerFrames) {
            psScript.paMarkerFrames = []
        }
    };
    Script.New = function(pdwScriptData) {
        var psScript = {};
        psScript.dwID = 0;
        psScript.dwType = -1;
        psScript.dwCurrentInstruction = 0;
        psScript.pdwScriptData = pdwScriptData;
        psScript.dwFrameNum = 0;
        psScript.dwTargetFrameNum = 0;
        psScript.bPause = false;
        psScript.bTargetWaiting = false;
        psScript.pdwScriptData = pdwScriptData;
        psScript.psParent = null;
        psScript.dwTriggerID = -1;
        psScript.dwLocalVariables = [];
        Script.AddMarkers(psScript);
        return psScript
    };
    Script.Delete = function(psScript) {
        Script.RemoveMarkers(psScript)
    };
    Script.AddWithID = function(pdwScriptData, dwScriptID) {
        var psScript;
        if (!Script.bAddNew) {
            return
        }
        psScript = Script.New(pdwScriptData);
        psScript.dwID = dwScriptID;
        Script.psList[Script.psList.length] = psScript
    };
    Script.Add = function(psScriptData) {
        var psScript;
        var dwID = -1;
        var i;
        for (i = 0; i < Script.psList.length; i += 1) {
            if (Script.psList[i].dwID > dwID) {
                dwID = Script.psList[i].dwID
            }
        }
        Script.AddWithID(psScriptData, dwID + 1);
        return dwID + 1
    };
    Script.Stop = function(dwScriptIndex, bRemoveObjects) {
        var NodeIndex = Script.FindNodeWithID(dwScriptIndex);
        if (NodeIndex === -1) {
            return
        }
        var psScript = Script.psList[NodeIndex];
        if (bRemoveObjects) {
            ScriptObjects.EndScript(dwScriptIndex)
        }
        Script.psList.splice(NodeIndex, 1);
        Script.Delete(psScript);
        var i;
        for (i = 0; i < Script.psList.length; i += 1) {
            if (Script.psList[i].dwTriggerID === dwScriptIndex) {
                Script.Stop(Script.psList[i].dwID, bRemoveObjects);
                i -= 1
            }
        }
    };
    Script.DestroyObjects = function() {
        ScriptObjects.DestroyAll()
    };
    Script.StopAll = function(bRemoveObjects) {
        var i;
        for (i = 0; i < Script.psList.length; i += 1) {
            Script.Stop(Script.psList[i].dwID, bRemoveObjects);
            i -= 1
        }
    };
    Script.GetFrameNumber = function(dwScriptID) {
        var psScript = Script.FindWithID(dwScriptID);
        return psScript.dwFrameNum
    };
    Script.GetCurrentlyProcessed = function() {
        return Script.dwCurrentlyProcessedId
    };
    Script.SetGlobalVariable = function(dwVariable, dwValue) {
        Script.dwGlobalVariables[dwVariable - SCRIPT_GLOBAL_VARIABLE_1] = dwValue
    };
    Script.GetGlobalVariable = function(dwVariable) {
        return Script.dwGlobalVariables[dwVariable - SCRIPT_GLOBAL_VARIABLE_1]
    };
    Script.SetLocalVariableID = function(dwScriptID, dwVariable, dwValue) {
        var i = dwVariable - SCRIPT_LOCAL_VARIABLE_1;
        var psScript = Script.FindWithID(dwScriptID);
        psScript.dwLocalVariables[i] = dwValue
    };
    Script.SetLocalVariable = function(psScript, dwVariable, dwValue) {
        var i = dwVariable - SCRIPT_LOCAL_VARIABLE_1;
        psScript.dwLocalVariables[i] = dwValue
    };
    Script.GetLocalVariable = function(dwScriptID, dwVariable) {
        var psScript = Script.FindWithID(dwScriptID);
        return psScript.dwLocalVariables[dwVariable - SCRIPT_LOCAL_VARIABLE_1]
    };
    Script.DisableWait = function(bDisable) {
        Script.bDisableWait = bDisable
    };
    Script.GetMarkerOffset = function(psScript, dwMarker, pdwFrameNum) {
        var i;
        for (i = 0; i < psScript.dwNumMarkers; i += 1) {
            if (psScript.paMarkers[i] === dwMarker) {
                pdwFrameNum[0] = psScript.paMarkerFrames[i];
                return psScript.paMarkerOffsets[i]
            }
        }
        return 0
    };
    Script.ProcessInstruction = function(psScript) {
        var pdwData;
        var i, j;
        var dwArgs = [];
        var bNextInstruction;
        var bUpdateOffset = true;
        var bTrue;
        var psNode, psTempNode;
        var psTempScript;
        pdwData = psScript.pdwScriptData;
        do {
            bNextInstruction = true;
            i = psScript.dwCurrentInstruction;
            if (pdwData[i + 1]) {
                for (j = 0; j < pdwData[i + 1]; j += 1) {
                    dwArgs[j] = pdwData[i + 2 + j]
                }
                for (j = 0; j < pdwData[i + 1]; j += 1) {
                    if (dwArgs[j] >= SCRIPT_GLOBAL_VARIABLE_1) {
                        if (dwArgs[j] < SCRIPT_LOCAL_VARIABLE_1) {
                            dwArgs[j] = Script.dwGlobalVariables[dwArgs[j] - SCRIPT_GLOBAL_VARIABLE_1]
                        } else {
                            dwArgs[j] = psScript.dwLocalVariables[dwArgs[j] - SCRIPT_LOCAL_VARIABLE_1]
                        }
                    }
                }
            }
            if (pdwData[i] >= SCRIPT_INSTRUCTION_TOTAL) {
                bNextInstruction = Script.psUserProcessFunction(pdwData[i], dwArgs)
            } else {
                switch (pdwData[i]) {
                    case SCRIPT_INSTRUCTION_DEBUG_OUTPUT:
                        Debug.Log(pdwData[i]);
                        break;
                    case SCRIPT_INSTRUCTION_SET_TYPE:
                        psScript.dwType = dwArgs[0];
                        break;
                    case SCRIPT_INSTRUCTION_STOP_TYPE:
                        for (j = 0; j < Script.psList.length; j += 1) {
                            if (Script.psList[j].dwType === dwArgs[0]) {
                                Script.Stop(Script.psList[j].dwID, true);
                                j -= 1
                            }
                        }
                        break;
                    case SCRIPT_INSTRUCTION_PAUSE:
                        psScript.bPause = true;
                        bNextInstruction = false;
                        break;
                    case SCRIPT_INSTRUCTION_PAUSE_ALL:
                        for (j = 0; j < Script.psList.length; j += 1) {
                            if (Script.psList[j] !== psScript) {
                                Script.bPause = dwArgs[0]
                            }
                        }
                        break;
                    case SCRIPT_INSTRUCTION_DISABLE_WAIT:
                        Script.DisableWait(dwArgs[0]);
                        break;
                    case SCRIPT_INSTRUCTION_SCRIPT_ADD:
                        Script.AddWithID(dwArgs[1], dwArgs[0]);
                        var Index = Script.FindNodeWithID(dwArgs[0]).pData;
                        var psNewScript = Script.psList[Index];
                        psNewScript.dwTriggerID = psScript.dwID;
                        break;
                    case SCRIPT_INSTRUCTION_SCRIPT_WAIT:
                        if (Script.FindWithID(dwArgs[0])) {
                            bNextInstruction = false
                        }
                        break;
                    case SCRIPT_INSTRUCTION_SCRIPT_STOP:
                        psTempScript = Script.FindWithID(dwArgs[0]);
                        Script.Stop(psTempScript.dwID, false);
                        break;
                    case SCRIPT_INSTRUCTION_SCRIPT_SET_PAUSED:
                        psTempScript = Script.FindWithID(dwArgs[0]);
                        psTempScript.bPause = dwArgs[1];
                        break;
                    case SCRIPT_INSTRUCTION_SET_VARIABLE:
                        if (pdwData[i + 2] < SCRIPT_LOCAL_VARIABLE_1) {
                            Script.dwGlobalVariables[pdwData[i + 2] - SCRIPT_GLOBAL_VARIABLE_1] = dwArgs[1]
                        } else {
                            psScript.dwLocalVariables[pdwData[i + 2] - SCRIPT_LOCAL_VARIABLE_1] = dwArgs[1]
                        }
                        break;
                    case SCRIPT_INSTRUCTION_SET_VARIABLE_RAND:
                        if (pdwData[i + 2] < SCRIPT_LOCAL_VARIABLE_1) {
                            Script.dwGlobalVariables[pdwData[i + 2] - SCRIPT_GLOBAL_VARIABLE_1] = Math.random() * dwArgs[1]
                        } else {
                            psScript.dwLocalVariables[pdwData[i + 2] - SCRIPT_LOCAL_VARIABLE_1] = Math.random() * dwArgs[1]
                        }
                        break;
                    case SCRIPT_INSTRUCTION_SET_VARIABLE_POINTER:
                        if (pdwData[i + 2] < SCRIPT_LOCAL_VARIABLE_1) {
                            Script.dwGlobalVariables[pdwData[i + 2] - SCRIPT_GLOBAL_VARIABLE_1] = dwArgs[1]
                        } else {
                            psScript.dwLocalVariables[pdwData[i + 2] - SCRIPT_LOCAL_VARIABLE_1] = dwArgs[1]
                        }
                        break;
                    case SCRIPT_INSTRUCTION_ADD_VARIABLE:
                        if (pdwData[i + 2] < SCRIPT_LOCAL_VARIABLE_1) {
                            Script.dwGlobalVariables[pdwData[i + 2] - SCRIPT_GLOBAL_VARIABLE_1] += dwArgs[1]
                        } else {
                            psScript.dwLocalVariables[pdwData[i + 2] - SCRIPT_LOCAL_VARIABLE_1] += dwArgs[1]
                        }
                        break;
                    case SCRIPT_INSTRUCTION_MARKER:
                        break;
                    case SCRIPT_INSTRUCTION_GOTO:
                        psScript.dwCurrentInstruction = Script.GetMarkerOffset(psScript, dwArgs[0], psScript.dwFrameNum);
                        bUpdateOffset = false;
                        break;
                    case SCRIPT_INSTRUCTION_CMP:
                        bTrue = false;
                        if (dwArgs[0] === false) {
                            dwArgs[0] = 0
                        }
                        if (dwArgs[0] === true) {
                            dwArgs[0] = 1
                        }
                        if (dwArgs[1] === false) {
                            dwArgs[1] = 0
                        }
                        if (dwArgs[1] === true) {
                            dwArgs[1] = 1
                        }
                        switch (dwArgs[2]) {
                            case SCRIPT_CMPTYPE_EQUAL:
                                if (dwArgs[0] === dwArgs[1]) {
                                    bTrue = true
                                }
                                break;
                            case SCRIPT_CMPTYPE_LESS:
                                if (dwArgs[0] < dwArgs[1]) {
                                    bTrue = true
                                }
                                break;
                            case SCRIPT_CMPTYPE_GREATER:
                                if (dwArgs[0] > dwArgs[1]) {
                                    bTrue = true
                                }
                                break;
                            case SCRIPT_CMPTYPE_LESS_EQUAL:
                                if (dwArgs[0] <= dwArgs[1]) {
                                    bTrue = true
                                }
                                break;
                            case SCRIPT_CMPTYPE_GREATER_EQUAL:
                                if (dwArgs[0] >= dwArgs[1]) {
                                    bTrue = true
                                }
                                break;
                            case SCRIPT_CMPTYPE_NOT:
                                if (dwArgs[0] !== dwArgs[1]) {
                                    bTrue = true
                                }
                                break;
                            default:
                                break
                        }
                        if (bTrue) {
                            psScript.dwCurrentInstruction = Script.GetMarkerOffset(psScript, dwArgs[3], psScript.dwFrameNum);
                            bUpdateOffset = false
                        }
                        break;
                    case SCRIPT_INSTRUCTION_WAIT:
                        if (Script.bDisableWait) {
                            break
                        }
                        bNextInstruction = false;
                        if (!psScript.bTargetWaiting) {
                            psScript.dwTargetFrameNum = dwArgs[0];
                            psScript.bTargetWaiting = true
                        } else {
                            psScript.dwTargetFrameNum -= 1
                        }
                        if (psScript.dwTargetFrameNum <= 0) {
                            bNextInstruction = true;
                            psScript.bTargetWaiting = false
                        }
                        break;
                    case SCRIPT_INSTRUCTION_WAIT_OR_KEYPRESS:
                        if (Script.bDisableWait) {
                            break
                        }
                        bNextInstruction = false;
                        if (!psScript.bTargetWaiting) {
                            psScript.dwTargetFrameNum = dwArgs[0];
                            psScript.bTargetWaiting = true
                        } else {
                            psScript.dwTargetFrameNum -= 1
                        }
                        if (!psScript.dwTargetFrameNum || Script.bButtonPressed) {
                            bNextInstruction = true;
                            psScript.bTargetWaiting = false
                        }
                        break;
                    case SCRIPT_INSTRUCTION_WAIT_FRAME:
                        if (Script.bDisableWait) {
                            break
                        }
                        if (psScript.dwFrameNum < dwArgs[0]) {
                            psScript.dwFrameNum += 1;
                            bNextInstruction = false
                        }
                        break;
                    case SCRIPT_INSTRUCTION_WAIT_NOT_KEY_PRESS:
                        if (Script.bButtonPressed) {
                            bNextInstruction = false
                        } else {
                            bNextInstruction = true
                        }
                        break;
                    case SCRIPT_INSTRUCTION_WAIT_KEY_PRESS:
                        if (!Script.bButtonPressed) {
                            bNextInstruction = false
                        }
                        break;
                    case SCRIPT_INSTRUCTION_CREATE_OBJECT_LAYERS:
                        ScriptObjects.CreateLayers(dwArgs[0]);
                        break;
                    case SCRIPT_INSTRUCTION_DESTROY_OBJECT_LAYERS:
                        ScriptObjects.DestroyLayers();
                        break;
                    case SCRIPT_INSTRUCTION_OBJECT_CREATE_SPRITE:
                        ScriptObjects.CreateSprite(dwArgs[0], dwArgs[1], dwArgs[2], dwArgs[3], dwArgs[4]);
                        break;
                    case SCRIPT_INSTRUCTION_OBJECT_CREATE_TEXT:
                        ScriptObjects.CreateText(dwArgs[0], dwArgs[1], dwArgs[2], dwArgs[3], dwArgs[4], dwArgs[5]);
                        break;
                    case SCRIPT_INSTRUCTION_OBJECT_CREATE_ANIMATION:
                        ScriptObjects.CreateAnimation(dwArgs[0], dwArgs[1], dwArgs[2], dwArgs[3], dwArgs[4]);
                        break;
                    case SCRIPT_INSTRUCTION_OBJECT_SET_SPRITE:
                        ScriptObjects.SetSprite(dwArgs[0], dwArgs[1]);
                        break;
                    case SCRIPT_INSTRUCTION_OBJECT_SET_TEXT:
                        ScriptObjects.SetText(dwArgs[0], dwArgs[1]);
                        break;
                    case SCRIPT_INSTRUCTION_OBJECT_SET_ANIMATION:
                        ScriptObjects.SetAnimation(dwArgs[0], dwArgs[1]);
                        break;
                    case SCRIPT_INSTRUCTION_OBJECT_SET_PARENT:
                        ScriptObjects.SetParent(dwArgs[0], dwArgs[1]);
                        break;
                    case SCRIPT_INSTRUCTION_OBJECT_SET_LAYER:
                        ScriptObjects.SetLayer(dwArgs[0], dwArgs[1]);
                        break;
                    case SCRIPT_INSTRUCTION_OBJECT_SET_ALIGNMENT:
                        ScriptObjects.SetAlignment(dwArgs[0], dwArgs[1]);
                        break;
                    case SCRIPT_INSTRUCTION_OBJECT_MOVE_SET:
                        ScriptObjects.MoveSet(dwArgs[0], dwArgs[1], dwArgs[2]);
                        break;
                    case SCRIPT_INSTRUCTION_OBJECT_MOVE:
                        ScriptObjects.Move(dwArgs[0], dwArgs[1], dwArgs[2], dwArgs[3]);
                        break;
                    case SCRIPT_INSTRUCTION_OBJECT_MOVE_TO:
                        ScriptObjects.MoveTo(dwArgs[0], dwArgs[1], dwArgs[2], dwArgs[3]);
                        break;
                    case SCRIPT_INSTRUCTION_OBJECT_MOVE_TO_EASE:
                        ScriptObjects.MoveToEase(dwArgs[0], dwArgs[1], dwArgs[2], dwArgs[3], dwArgs[4], dwArgs[5]);
                        break;
                    case SCRIPT_INSTRUCTION_OBJECT_WAIT_MOVED:
                        if (Script.bDisableWait) {
                            break
                        }
                        if (!ScriptObjects.WaitMoved(dwArgs[0])) {
                            bNextInstruction = false
                        }
                        break;
                    case SCRIPT_INSTRUCTION_OBJECT_WAIT_LOOK:
                        if (Script.bDisableWait) {
                            break
                        }
                        if (!ScriptObjects.WaitLook(dwArgs[0])) {
                            bNextInstruction = false
                        }
                        break;
                    case SCRIPT_INSTRUCTION_OBJECT_SCALE_SET:
                        ScriptObjects.ScaleSet(dwArgs[0], dwArgs[1] / 100, dwArgs[2] / 100);
                        break;
                    case SCRIPT_INSTRUCTION_OBJECT_SCALE:
                        ScriptObjects.Scale(dwArgs[0], dwArgs[1] / 100, dwArgs[2] / 100, dwArgs[3]);
                        break;
                    case SCRIPT_INSTRUCTION_OBJECT_SCALE_TO:
                        ScriptObjects.ScaleTo(dwArgs[0], dwArgs[1] / 100, dwArgs[2] / 100, dwArgs[3]);
                        break;
                    case SCRIPT_INSTRUCTION_OBJECT_SCALE_TO_EASE:
                        ScriptObjects.ScaleToEase(dwArgs[0], dwArgs[1] / 100, dwArgs[2] / 100, dwArgs[3], dwArgs[4], dwArgs[5]);
                        break;
                    case SCRIPT_INSTRUCTION_OBJECT_WAIT_SCALE:
                        if (Script.bDisableWait) {
                            break
                        }
                        if (!ScriptObjects.WaitScale(dwArgs[0])) {
                            bNextInstruction = false
                        }
                        break;
                    case SCRIPT_INSTRUCTION_OBJECT_ROTATE_SET:
                        ScriptObjects.RotateSet(dwArgs[0], dwArgs[1] * Maths.DegToRad());
                        break;
                    case SCRIPT_INSTRUCTION_OBJECT_ROTATE:
                        ScriptObjects.Rotate(dwArgs[0], dwArgs[1] * Maths.DegToRad(), dwArgs[2]);
                        break;
                    case SCRIPT_INSTRUCTION_OBJECT_ROTATE_TO:
                        ScriptObjects.RotateTo(dwArgs[0], dwArgs[1] * Maths.DegToRad(), dwArgs[2]);
                        break;
                    case SCRIPT_INSTRUCTION_OBJECT_ROTATE_TO_EASE:
                        ScriptObjects.RotateToEase(dwArgs[0], dwArgs[1] * Maths.DegToRad(), dwArgs[2], dwArgs[3], dwArgs[4]);
                        break;
                    case SCRIPT_INSTRUCTION_OBJECT_WAIT_ROTATE:
                        if (Script.bDisableWait) {
                            break
                        }
                        if (!ScriptObjects.WaitRotate(dwArgs[0])) {
                            bNextInstruction = false
                        }
                        break;
                    case SCRIPT_INSTRUCTION_OBJECT_TRANSFORM_SET:
                        ScriptObjects.MoveSet(dwArgs[0], dwArgs[1], dwArgs[2]);
                        ScriptObjects.ScaleSet(dwArgs[0], dwArgs[3] / 100, dwArgs[4] / 100);
                        ScriptObjects.RotateSet(dwArgs[0], dwArgs[5] * Maths.DegToRad());
                        break;
                    case SCRIPT_INSTRUCTION_OBJECT_ALPHA_SET:
                        ScriptObjects.AlphaSet(dwArgs[0], dwArgs[1]);
                        break;
                    case SCRIPT_INSTRUCTION_OBJECT_ALPHA:
                        ScriptObjects.Alpha(dwArgs[0], dwArgs[1], dwArgs[2]);
                        break;
                    case SCRIPT_INSTRUCTION_OBJECT_ALPHA_TO:
                        ScriptObjects.AlphaTo(dwArgs[0], dwArgs[1], dwArgs[2]);
                        break;
                    case SCRIPT_INSTRUCTION_OBJECT_WAIT_ALPHA:
                        if (Script.bDisableWait) {
                            break
                        }
                        if (!ScriptObjects.WaitAlpha(dwArgs[0])) {
                            bNextInstruction = false
                        }
                        break;
                    case SCRIPT_INSTRUCTION_OBJECT_SET_COLOUR:
                        ScriptObjects.SetColour(dwArgs[0], dwArgs[1], dwArgs[2], dwArgs[3]);
                        break;
                    case SCRIPT_INSTRUCTION_OBJECT_VISIBLE:
                        ScriptObjects.Visible(dwArgs[0], dwArgs[1]);
                        break;
                    case SCRIPT_INSTRUCTION_OBJECT_DESTROY:
                        ScriptObjects.Destroy(dwArgs[0]);
                        break;
                    case SCRIPT_INSTRUCTION_PLAY_AUDIO:
                        Helpers.PlaySound(dwArgs[0]);
                        break;
                    case SCRIPT_INSTRUCTION_IS_AUDIO_PLAYING:
                        Script.dwGlobalVariables[SCRIPT_GLOBAL_VARIABLE_11 - SCRIPT_GLOBAL_VARIABLE_1] = Helpers.GetIsSoundPlaying(dwArgs[0]);
                        break;
                    case SCRIPT_INSTRUCTION_STOP_AUDIO:
                        Helpers.StopSound(dwArgs[0]);
                        break;
                    case SCRIPT_INSTRUCTION_WAIT_AUDIO:
                        if (Helpers.GetIsSoundPlaying(dwArgs[0])) {
                            bNextInstruction = false
                        }
                        break;
                    case SCRIPT_INSTRUCTION_PITCH_AUDIO:
                        Helpers.SetSoundPitch(dwArgs[0], dwArgs[1] / 256);
                        break;
                    case SCRIPT_INSTRUCTION_SET_MUSIC:
                        break;
                    case SCRIPT_INSTRUCTION_FADE_MUSIC:
                        break;
                    case SCRIPT_INSTRUCTION_SEND_USER_INPUT:
                        break;
                    case SCRIPT_INSTRUCTION_SET_MENU_OPTION_STATE:
                        break;
                    case SCRIPT_INSTRUCTION_LOAD_MENU_OPTION_STATE:
                        break;
                    case SCRIPT_INSTRUCTION_END:
                        return false;
                    default:
                        break
                }
            }
            if (bNextInstruction && bUpdateOffset) {
                psScript.dwCurrentInstruction += pdwData[i + 1] + 2
            } else {
                bUpdateOffset = true
            }
        } while (bNextInstruction);
        return true
    };
    Script.GetIsFinished = function(dwScriptID) {
        if (Script.FindWithID(dwScriptID)) {
            return false
        }
        return true
    };
    Script.GetIsAllFinished = function() {
        if (Script.psList.psFirst) {
            return false
        }
        return true
    };
    Script.GetIsAnyPaused = function() {
        var i;
        for (i = 0; i < Script.psList; i += 1) {
            if (Script.psList[i].bPause) {
                return true
            }
        }
        return false
    };
    Script.EnableInput = function(bEnabled) {
        Script.bInputEnabled = bEnabled
    };
    Script.Update = function() {
        if (Script.bPaused) {
            return
        }
        ScriptObjects.ProcessList(null);
        var i;
        for (i = 0; i < Script.psList.length; i += 1) {
            var psScript = Script.psList[i];
            if (!psScript.bPause) {
                Script.dwCurrentlyProcessedId = psScript.dwID;
                if (psScript.psParent) {
                    Script.psCurrentParent = psScript.psParent
                } else {
                    Script.psCurrentParent = Script.psDefaultParent
                }
                if (!Script.ProcessInstruction(psScript)) {
                    Script.psList.splice(i, 1);
                    i -= 1
                }
            }
        }
        ScriptObjects.Update();
        Script.dwCurrentlyProcessedId = -1
    };
    Script.Process = function(psScript, psScriptObjectsList, psParent) {
        var bContinue = true;
        if (psScriptObjectsList) {
            Script.psCurrentParent = psParent;
            ScriptObjects.ProcessList(psScriptObjectsList)
        }
        if (!Script.ProcessInstruction(psScript)) {
            bContinue = false
        }
        if (psScriptObjectsList) {
            ScriptObjects.Update()
        }
        return bContinue
    };
    Script.PauseSystem = function(bPause) {
        Script.bPaused = bPause
    };
    Script.Pause = function(dwScriptID, bPause) {
        var psScript = Script.FindWithID(dwScriptID);
        psScript.bPause = bPause;
        ScriptObjects.PauseScript(dwScriptID, bPause)
    };
    Script.SetObjectParent = function(dwScriptID, psParent) {
        var psScript = Script.FindWithID(dwScriptID);
        psScript.psParent = psParent
    };
    Script.PauseAll = function(bPause) {
        var i;
        for (i = 0; i < Script.psList; i += 1) {
            Script.psList[i].bPause = bPause
        }
    };
    Script.SetDefaultObjectParent = function(psParent) {
        Script.psDefaultParent = psParent;
        Script.psCurrentParent = psParent
    };
    Script.SetButtonPressed = function(bPressed) {
        Script.bButtonPressed = bPressed
    };
    var SCRIPTEXT_INSTRUCTION_CREATE_TEXT = 91;
    var SCRIPTEXT_INSTRUCTION_DESTROY_TEXT = 92;
    var SCRIPTEXT_INSTRUCTION_SET_MUSIC = 93;
    var SCRIPTEXT_INSTRUCTION_START_COUNTER = 94;
    var SCRIPTEXT_INSTRUCTION_WAIT_COUNTER = 95;
    var SCRIPTEXT_INSTRUCTION_MOVE_BOARD_TO = 96;
    var SCRIPTEXT_INSTRUCTION_BOARD_OPACITY = 97;
    var SCRIPTEXT_INSTRUCTION_COVER_OPACITY = 98;
    var SCRIPTEXT_INSTRUCTION_HELP_OPACITY = 99;
    var SCRIPTEXT_INSTRUCTION_NAME_OPACITY = 100;
    var SCRIPTEXT_INSTRUCTION_INFO_OPACITY = 101;
    var SCRIPTEXT_INSTRUCTION_HUD_OPACITY = 102;
    var SCRIPTEXT_INSTRUCTION_REVIEW_OPACITY = 103;
    var SCRIPTEXT_INSTRUCTION_MAKE_OPACITY = 104;
    var SCRIPTEXT_INSTRUCTION_MAKE_SHAPE_OPACITY = 105;
    var SCRIPTEXT_INSTRUCTION_OBJECTIVE_PERCENT = 106;
    var SCRIPTEXT_INSTRUCTION_FLIP_LEVEL = 107;
    var SCRIPTEXT_INSTRUCTION_FLIP_TOGGLE = 108;
    var SCRIPTEXT_INSTRUCTION_HIDE_LEVEL = 109;
    var SCRIPTEXT_INSTRUCTION_COMPLETE_LEVEL = 110;
    var SCRIPTEXT_INSTRUCTION_WAIT_COMPLETE_LEVEL = 111;
    var SCRIPTEXT_INSTRUCTION_GAME_OPACITY = 112;
    var SCRIPTEXT_INSTRUCTION_NEW_PAGE = 113;
    var SCRIPTEXT_INSTRUCTION_SECRET_PAGE = 114;
    var SCRIPTEXT_INSTRUCTION_RETURN_PAGE = 115;
    var SCRIPTEXT_INSTRUCTION_NO_SECRET_PAGE = 116;
    var SCRIPTEXT_INSTRUCTION_END_PAGE = 117;
    var SCRIPTEXT_INSTRUCTION_FIRST_PAGE = 118;
    var SCRIPTEXT_INSTRUCTION_START_PAN = 119;
    var SCRIPTEXT_INSTRUCTION_WAIT_PAGE_ENDED = 120;
    var SCRIPTEXT_INSTRUCTION_CREATE_EFFECT = 121;
    var SCRIPTEXT_INSTRUCTION_CREATE_LIGHT_RAYS = 122;
    var SCRIPTEXT_INSTRUCTION_DISABLE_LIGHT_RAYS = 123;
    var SCRIPTEXT_INSTRUCTION_DESTROY_LIGHT_RAYS = 124;
    var SCRIPTEXT_INSTRUCTION_FLASH_SCREEN = 125;
    var SCRIPTEXT_INSTRUCTION_PLAY_MUSIC = 126;
    var SCRIPTEXT_INSTRUCTION_WAIT_MUSIC_PLAYING = 127;
    var SCRIPTEXT_INSTRUCTION_INTERRUPT_MUSIC = 128;
    var SCRIPTEXT_INSTRUCTION_WAIT_INTERRUPT_MUSIC = 129;
    var SCRIPTEXT_INSTRUCTION_IS_INTERRUPT_MUSIC_PLAYING = 130;
    var SCRIPTEXT_INSTRUCTION_TOTAL = 132;

    function ScriptExt() {}
    ScriptExt.ProcessInstruction = function(dwInstruction, padwArgs) {
        var bNextInstruction;
        bNextInstruction = true;
        switch (dwInstruction) {
            case SCRIPTEXT_INSTRUCTION_CREATE_TEXT:
                var bJitter = false;
                if (padwArgs[7]) {
                    bJitter = true
                }
                var bScaleIn = false;
                if (padwArgs[8]) {
                    bScaleIn = true
                }
                ScriptExtInstructions.CreateText(padwArgs[0], padwArgs[1], padwArgs[2], padwArgs[3], padwArgs[4], padwArgs[5], padwArgs[6], bJitter, bScaleIn);
                break;
            case SCRIPTEXT_INSTRUCTION_DESTROY_TEXT:
                ScriptExtInstructions.DestroyText();
                break;
            case SCRIPTEXT_INSTRUCTION_SET_MUSIC:
                break;
            case SCRIPTEXT_INSTRUCTION_START_COUNTER:
                ScriptExtInstructions.StartCounter(padwArgs[0], padwArgs[1], padwArgs[2]);
                break;
            case SCRIPTEXT_INSTRUCTION_WAIT_COUNTER:
                bNextInstruction = ScriptExtInstructions.WaitCounter(padwArgs[0]);
                break;
            case SCRIPTEXT_INSTRUCTION_MOVE_BOARD_TO:
                ScriptExtInstructions.MoveBoardTo(padwArgs[0], padwArgs[1], padwArgs[2], padwArgs[3], padwArgs[4]);
                break;
            case SCRIPTEXT_INSTRUCTION_BOARD_OPACITY:
                LevelGrid.SetOpacity(padwArgs[0] / 256);
                break;
            case SCRIPTEXT_INSTRUCTION_COVER_OPACITY:
                Cover.SetOpacity(padwArgs[0] / 256);
                break;
            case SCRIPTEXT_INSTRUCTION_HELP_OPACITY:
                Help.SetOpacity(padwArgs[0] / 256);
                break;
            case SCRIPTEXT_INSTRUCTION_NAME_OPACITY:
                LevelGrid.SetNameOpacity(padwArgs[0] / 256);
                break;
            case SCRIPTEXT_INSTRUCTION_INFO_OPACITY:
                LevelSelect.SetInfoOpacity(padwArgs[0] / 256);
                break;
            case SCRIPTEXT_INSTRUCTION_HUD_OPACITY:
                Game.psBoard.m_psHud.SetOpacity(padwArgs[0] / 256);
                break;
            case SCRIPTEXT_INSTRUCTION_REVIEW_OPACITY:
                Review.SetOpacity(padwArgs[0] / 256);
                break;
            case SCRIPTEXT_INSTRUCTION_MAKE_OPACITY:
                Game.psBoard.m_psHud.SetMakeOpacity(padwArgs[0] / 256);
                break;
            case SCRIPTEXT_INSTRUCTION_MAKE_SHAPE_OPACITY:
                Game.psBoard.m_psHud.SetBonusPercent(padwArgs[0] / 256);
                Game.psBoard.m_psHud.SetMakeShapeOpacity(padwArgs[0] / 100);
                if (padwArgs[0] === 0) {
                    Game.psBoard.m_psHud.SetMakeShapeVisible(false)
                } else {
                    Game.psBoard.m_psHud.SetMakeShapeVisible(true)
                }
                break;
            case SCRIPTEXT_INSTRUCTION_OBJECTIVE_PERCENT:
                if (Records.GetScore(LevelSelect.GetLevelNumber()) === 0) {
                    Game.psBoard.m_psHud.SetObjectivePercent(padwArgs[0] / 256)
                } else {
                    Game.psBoard.m_psHud.SetBonusPercent(padwArgs[0] / 256)
                }
                break;
            case SCRIPTEXT_INSTRUCTION_FLIP_LEVEL:
                var psLevel = padwArgs[0];
                psLevel.UpdateFlip();
                break;
            case SCRIPTEXT_INSTRUCTION_FLIP_TOGGLE:
                var psLevel = padwArgs[0];
                psLevel.ScriptFlip();
                break;
            case SCRIPTEXT_INSTRUCTION_HIDE_LEVEL:
                var psLevel = padwArgs[0];
                var bHide = false;
                if (padwArgs[1]) {
                    bHide = true
                }
                psLevel.ScriptHide(bHide);
                break;
            case SCRIPTEXT_INSTRUCTION_COMPLETE_LEVEL:
                LevelSelect.ScriptCompleteLevel();
                break;
            case SCRIPTEXT_INSTRUCTION_WAIT_COMPLETE_LEVEL:
                if (!LevelGrid.IsLevelFlipped()) {
                    bNextInstruction = false
                }
                break;
            case SCRIPTEXT_INSTRUCTION_GAME_OPACITY:
                Game.SetOpacity(padwArgs[0] / 256);
                break;
            case SCRIPTEXT_INSTRUCTION_NEW_PAGE:
                LevelSelect.ScriptNewPage();
                break;
            case SCRIPTEXT_INSTRUCTION_SECRET_PAGE:
                LevelSelect.ScriptSecretPage();
                break;
            case SCRIPTEXT_INSTRUCTION_RETURN_PAGE:
                LevelSelect.ScriptReturnPage();
                break;
            case SCRIPTEXT_INSTRUCTION_NO_SECRET_PAGE:
                LevelSelect.ScriptNoSecretPage();
                break;
            case SCRIPTEXT_INSTRUCTION_END_PAGE:
                LevelSelect.ScriptEndPage();
                break;
            case SCRIPTEXT_INSTRUCTION_FIRST_PAGE:
                LevelSelect.ScriptFirstPage();
                break;
            case SCRIPTEXT_INSTRUCTION_START_PAN:
                LevelSelect.ScriptStartPan();
                break;
            case SCRIPTEXT_INSTRUCTION_WAIT_PAGE_ENDED:
                if (!LevelSelect.ScriptIsPageEnded()) {
                    bNextInstruction = false
                }
                break;
            case SCRIPTEXT_INSTRUCTION_CREATE_EFFECT:
                var i;
                for (i = 0; i < padwArgs[0]; i += 1) {
                    var fWidth = padwArgs[3] / 256;
                    var fHeight = padwArgs[4] / 256;
                    var x = padwArgs[1] / 256 - fWidth / 2 + Math.random() * fWidth;
                    var y = padwArgs[2] / 256 - fHeight / 2 + Math.random() * fHeight;
                    var dwColour = Math.floor(LevelSelect.GetLevelNumber() / (NORMAL_LEVELS_WIDTH * NORMAL_LEVELS_HEIGHT));
                    var psEffect = EntityEffect.Create(x, y, ENTITYEFFECT_TYPE_STATIC_SPARKLE, GadgetTree.GetLayer(LAYERS_EFFECTS));
                    EntityManager.Add(psEffect)
                }
                break;
            case SCRIPTEXT_INSTRUCTION_CREATE_LIGHT_RAYS:
                ScriptExtInstructions.CreateLightRays(padwArgs[0], padwArgs[1], padwArgs[2]);
                break;
            case SCRIPTEXT_INSTRUCTION_DISABLE_LIGHT_RAYS:
                ScriptExtInstructions.DisableLightRays();
                break;
            case SCRIPTEXT_INSTRUCTION_DESTROY_LIGHT_RAYS:
                ScriptExtInstructions.DestroyLightRays();
                break;
            case SCRIPTEXT_INSTRUCTION_FLASH_SCREEN:
                var psEffect = EntityEffect.Create(0, 0, ENTITYEFFECT_TYPE_SCREEN_FLASH, GadgetTree.GetLayer(LAYERS_HUD));
                EntityManager.Add(psEffect);
                break;
            case SCRIPTEXT_INSTRUCTION_PLAY_MUSIC:
                if (padwArgs[1]) {
                    Globals.SetBackgroundMusic(padwArgs[0], false, true)
                } else {
                    Globals.SetBackgroundMusic(padwArgs[0], false, false)
                }
                break;
            case SCRIPTEXT_INSTRUCTION_WAIT_MUSIC_PLAYING:
                if (Globals.WaitBackgroundMusic()) {
                    bNextInstruction = false
                }
                break;
            case SCRIPTEXT_INSTRUCTION_INTERRUPT_MUSIC:
                Globals.InterruptBackgroundMusic(padwArgs[0]);
                break;
            case SCRIPTEXT_INSTRUCTION_WAIT_INTERRUPT_MUSIC:
                if (Globals.WaitInterruptBackgroundMusic()) {
                    bNextInstruction = false
                }
                break;
            case SCRIPTEXT_INSTRUCTION_IS_INTERRUPT_MUSIC_PLAYING:
                if (Globals.WaitInterruptBackgroundMusic()) {
                    Script.SetGlobalVariable(SCRIPT_GLOBAL_VARIABLE_11, 1)
                } else {
                    Script.SetGlobalVariable(SCRIPT_GLOBAL_VARIABLE_11, 0)
                }
                break;
            default:
                break
        }
        return bNextInstruction
    };

    function ScriptExtInstructions() {}
    ScriptExtInstructions.psLightRays = null;
    ScriptExtInstructions.CreateText = function(dwTextID, psFont, x, y, dwScaleX, dwScaleY, eAlign, bJitter, bScaleIn) {};
    ScriptExtInstructions.DestroyText = function() {};
    ScriptExtInstructions.StartCounter = function(psCounter, dwEnd, dwDelay) {
        psCounter.Start(dwEnd, dwDelay)
    };
    ScriptExtInstructions.WaitCounter = function(psCounter) {
        if (psCounter.GetIsFinished()) {
            return true
        }
        return false
    };
    ScriptExtInstructions.MoveBoardTo = function(x, y, dwScaleX, dwScaleY, dwFrames) {
        Game.psBoard.MoveTo(x, y, dwScaleX / 100, dwScaleY / 100, dwFrames)
    };
    ScriptExtInstructions.CreateLightRays = function(x, y, dwScale) {
        ScriptExtInstructions.psLightRays = EntityLightRays.Create(x / 256, y / 256, dwScale / 100, GadgetTree.GetLayer(LAYERS_HUD))
    };
    ScriptExtInstructions.DisableLightRays = function() {
        ScriptExtInstructions.psLightRays.FadeOut()
    };
    ScriptExtInstructions.DestroyLightRays = function() {
        ScriptExtInstructions.psLightRays.Destroy();
        ScriptExtInstructions.psLightRays = null
    };
    ScriptExtInstructions.Update = function() {
        if (ScriptExtInstructions.psLightRays) {
            ScriptExtInstructions.psLightRays.Update()
        }
    };

    function ScriptObjects() {}
    var SCRIPTOBJECTS_TYPE_SPRITE = 0;
    var SCRIPTOBJECTS_TYPE_TEXT = 1;
    var SCRIPTOBJECTS_TYPE_ANIMATION = 2;
    var SCRIPTOBJECTS_TYPE_TOTAL = 3;
    ScriptObjects.psMainList = [];
    ScriptObjects.psList = [];
    ScriptObjects.psLayers = [];
    ScriptObjects.Initialise = function() {
        ScriptObjects.psMainList = [];
        ScriptObjects.psList = ScriptObjects.psMainList;
        ScriptObjects.psLayers = null
    };
    ScriptObjects.InitList = function() {
        var Object = [];
        return Object
    };
    ScriptObjects.ShutDown = function() {
        ScriptObjects.psList = ScriptObjects.psMainList;
        ScriptObjects.DestroyAll();
        ScriptObjects.psList = [];
        if (ScriptObjects.psLayers) {
            ScriptObjects.psLayers = []
        }
    };
    ScriptObjects.ShutDownList = function(psList) {
        ScriptObjects.psList = psList;
        ScriptObjects.DestroyAll();
        ScriptObjects.psList = [];
        ScriptObjects.psList = ScriptObjects.psMainList
    };
    ScriptObjects.DestroyAll = function() {
        var i;
        for (i = 0; i < ScriptObjects.psList.length; i += 1) {
            ScriptObjects.Destroy(ScriptObjects.psList[i].dwID);
            i -= 1
        }
    };
    ScriptObjects.EndScript = function(dwScriptID) {
        var i;
        for (i = 0; i < ScriptObjects.psList.length; i += 1) {
            if (ScriptObjects.psList[i].dwScriptID === dwScriptID) {
                ScriptObjects.Destroy(ScriptObjects.psList[i].dwID);
                i -= 1
            }
        }
    };
    ScriptObjects.PauseScript = function(dwScriptID, bPause) {
        var i;
        for (i = 0; i < ScriptObjects.psList.length; i += 1) {
            if (ScriptObjects.psList[i].dwScriptID === dwScriptID) {
                ScriptObjects.psList[i].bPaused = bPause
            }
        }
    };
    ScriptObjects.FindObject = function(dwObjectNum) {
        var i;
        for (i = 0; i < ScriptObjects.psList.length; i += 1) {
            if (ScriptObjects.psList[i].dwID === dwObjectNum) {
                return ScriptObjects.psList[i]
            }
        }
        return null
    };
    ScriptObjects.GetSprite = function(dwObjectNum) {
        var psObject = ScriptObjects.FindObject(dwObjectNum);
        return psObject.psSprite
    };
    ScriptObjects.CreateLayers = function(dwNumLayers) {
        ScriptObjects.psLayers = new Layers(dwNumLayers, Script.psCurrentParent)
    };
    ScriptObjects.DestroyLayers = function() {
        ScriptObjects.psLayers = null
    };
    ScriptObjects.CreateSprite = function(dwObjectNum, dwImage, dwPosX, dwPosY, dwAlignment) {
        var psObject = {};
        ScriptObjects.psList[ScriptObjects.psList.length] = psObject;
        var x = dwPosX / 256;
        var y = dwPosY / 256;
        var fScaleX = 1;
        var fScaleY = 1;
        var fRotation = 0;
        var dwType = SCRIPTOBJECTS_TYPE_SPRITE;
        var psSprite;
        if (typeof dwImage !== "string") {
            psSprite = dwImage;
            x = dwImage.x;
            y = dwImage.y;
            fScaleX = dwImage.ScaleX;
            fScaleY = dwImage.ScaleY;
            fRotation = dwImage.Rotation
        } else {
            psSprite = Helpers.CreateSprite(x, y, dwAlignment, dwImage, Script.psCurrentParent)
        }
        psObject.dwID = dwObjectNum;
        psObject.psSprite = psSprite;
        psObject.dwPosX = x;
        psObject.dwPosY = y;
        psObject.dwTargetX = x;
        psObject.dwTargetY = y;
        psObject.dwTargetFrames = 0;
        psObject.dwVelocityX = 0;
        psObject.dwVelocityY = 0;
        psObject.fScaleX = fScaleX;
        psObject.fScaleY = fScaleY;
        psObject.dwTargetScaleFrames = 0;
        psObject.fRotationX = fRotation;
        psObject.dwTargetRotationFrames = 0;
        psObject.dwAlpha = 255 << 8;
        psObject.dwTargetAlphaFrames = 0;
        psObject.eType = dwType;
        psObject.dwScriptID = Script.GetCurrentlyProcessed();
        psObject.bPaused = false;
        psObject.dwTotalFrames = 0;
        psObject.bEaseIn = 0;
        psObject.bEaseOut = 0;
        psObject.dwTotalScaleFrames = 0;
        psObject.bScaleEaseIn = 0;
        psObject.bScaleEaseOut = 0;
        psObject.dwTotalRotationFrames = 0;
        psObject.bRotationEaseIn = 0;
        psObject.bRotationEaseOut = 0;
        psObject.dwTargetLookFrames = 0;
        if (typeof dwImage === "string") {
            psObject.Created = true
        }
    };
    ScriptObjects.CreateText = function(dwObjectNum, dwText, psFont, dwPosX, dwPosY, dwAlignment) {
        var x = dwPosX / 256;
        var y = dwPosY / 256;
        var psText;
        if (typeof dwText !== "string") {
            psText = dwText;
            x = dwText.x;
            y = dwText.y
        } else {
            if (dwText.substring(0, 8) === "DATATEXT") {
                dwText = JamSystem.TextManager.GetText(dwText)
            }
            psText = Helpers.CreateBitmapText(dwText, x, y, dwAlignment, psFont, Script.psCurrentParent)
        }
        var psObject = {};
        ScriptObjects.psList[ScriptObjects.psList.length] = psObject;
        psObject.dwID = dwObjectNum;
        psObject.psText = psText;
        psObject.dwPosX = x;
        psObject.dwPosY = y;
        psObject.dwTargetX = x;
        psObject.dwTargetY = y;
        psObject.dwTargetFrames = 0;
        psObject.dwVelocityX = 0;
        psObject.dwVelocityY = 0;
        psObject.fScaleX = 1;
        psObject.fScaleY = 1;
        psObject.dwTargetScaleFrames = 0;
        psObject.fRotationX = 0;
        psObject.dwTargetRotationFrames = 0;
        psObject.dwAlpha = 255 << 8;
        psObject.dwTargetAlphaFrames = 0;
        psObject.eType = SCRIPTOBJECTS_TYPE_TEXT;
        psObject.dwScriptID = Script.GetCurrentlyProcessed();
        psObject.bPaused = false;
        psObject.dwTotalFrames = 0;
        psObject.bEaseIn = 0;
        psObject.bEaseOut = 0;
        psObject.dwTotalScaleFrames = 0;
        psObject.bScaleEaseIn = 0;
        psObject.bScaleEaseOut = 0;
        psObject.dwTotalRotationFrames = 0;
        psObject.bRotationEaseIn = 0;
        psObject.bRotationEaseOut = 0;
        psObject.dwTargetLookFrames = 0;
        if (typeof dwText === "string") {
            psObject.Created = true
        }
    };
    ScriptObjects.CreateAnimation = function(dwObjectNum, psAnimation, dwPosX, dwPosY, dwAlignment) {
        var x = dwPosX / 256;
        var y = dwPosY / 256;
        var psSprite = Helpers.CreateSprite(x, y, dwAlignment, "Blank", psAnimation);
        Script.psCurrentParent.AddChild(psSprite);
        var psObject = {};
        ScriptObjects.psList[ScriptObjects.psList.length] = psObject;
        psObject.dwID = dwObjectNum;
        psObject.psSprite = psSprite;
        psObject.psSpriteAnimation = JamSystem.RenderManager.CreateSpriteAnimation(psSprite, 0);
        psObject.dwPosX = x;
        psObject.dwPosY = y;
        psObject.dwTargetX = x;
        psObject.dwTargetY = y;
        psObject.dwTargetFrames = 0;
        psObject.dwVelocityX = 0;
        psObject.dwVelocityY = 0;
        psObject.fScaleX = 1;
        psObject.fScaleY = 1;
        psObject.dwTargetScaleFrames = 0;
        psObject.fRotationX = 0;
        psObject.dwTargetRotationFrames = 0;
        psObject.dwAlpha = 255 << 8;
        psObject.dwTargetAlphaFrames = 0;
        psObject.eType = SCRIPTOBJECTS_TYPE_ANIMATION;
        psObject.dwScriptID = Script.GetCurrentlyProcessed();
        psObject.bPaused = false;
        psObject.dwTotalFrames = 0;
        psObject.bEaseIn = 0;
        psObject.bEaseOut = 0;
        psObject.dwTotalScaleFrames = 0;
        psObject.bScaleEaseIn = 0;
        psObject.bScaleEaseOut = 0;
        psObject.dwTotalRotationFrames = 0;
        psObject.bRotationEaseIn = 0;
        psObject.bRotationEaseOut = 0;
        psObject.dwTargetLookFrames = 0
    };
    ScriptObjects.SetSprite = function(dwObjectNum, dwImage) {
        var psObject = ScriptObjects.FindObject(dwObjectNum);
        if (!psObject) {
            return
        }
        psObject.psSprite.SetFrameByName(dwImage)
    };
    ScriptObjects.SetText = function(dwObjectNum, psString) {
        var psObject = ScriptObjects.FindObject(dwObjectNum);
        if (!psObject) {
            return
        }
        psObject.psText.SetText(psString)
    };
    ScriptObjects.SetAnimation = function(dwObjectNum, psAnimation) {
        var psObject = ScriptObjects.FindObject(dwObjectNum);
        if (!psObject) {
            return
        }
        psObject.psSpriteAnimation.SetData(psAnimation)
    };
    ScriptObjects.SetParent = function(dwObjectNum, psParent) {
        var psObject = ScriptObjects.FindObject(dwObjectNum);
        if (!psObject) {
            return
        }
        psObject.psSprite.RemoveFromParent();
        psParent.AddChild(psObject.psSprite)
    };
    ScriptObjects.SetLayer = function(dwObjectNum, dwLayer) {
        var psObject = ScriptObjects.FindObject(dwObjectNum);
        if (!psObject) {
            return
        }
        if (psObject.psSprite) {
            psObject.psSprite.RemoveFromParent();
            ScriptObjects.psLayers.GetLayer(dwLayer).AddChild(psObject.psSprite)
        } else {
            psObject.psText.RemoveFromParent();
            ScriptObjects.psLayers.GetLayer(dwLayer).AddChild(psObject.psText)
        }
    };
    ScriptObjects.SetAlignment = function(dwObjectNum, dwAlignment) {
        var psObject = ScriptObjects.FindObject(dwObjectNum);
        if (!psObject) {
            return
        }
        if (psObject.eType === SCRIPTOBJECTS_TYPE_SPRITE) {
            psObject.psSprite.SetAnchor(dwAlignment)
        } else {
            psObject.psText.SetAnchor(dwAlignment)
        }
    };
    ScriptObjects.Move = function(dwObjectNum, dwPosX, dwPosY, dwFrames) {
        var psObject = ScriptObjects.FindObject(dwObjectNum);
        if (!psObject) {
            return
        }
        var dwVX = dwPosX / 256 / dwFrames;
        var dwVY = dwPosY / 256 / dwFrames;
        psObject.dwVelocityX = dwVX;
        psObject.dwVelocityY = dwVY;
        psObject.dwTargetX = psObject.dwPosX + dwPosX / 256;
        psObject.dwTargetY = psObject.dwPosY + dwPosY / 256;
        psObject.dwTargetFrames = dwFrames;
        psObject.bEaseIn = false;
        psObject.bEaseOut = false
    };
    ScriptObjects.MoveSet = function(dwObjectNum, dwPosX, dwPosY) {
        var psObject = ScriptObjects.FindObject(dwObjectNum);
        if (!psObject) {
            return
        }
        psObject.dwPosX = dwPosX / 256;
        psObject.dwPosY = dwPosY / 256;
        if (psObject.psSprite) {
            psObject.psSprite.SetPosition(psObject.dwPosX, psObject.dwPosY)
        } else {
            psObject.psText.SetPosition(psObject.dwPosX, psObject.dwPosY)
        }
        psObject.dwTargetFrames = 0
    };
    ScriptObjects.MoveTo = function(dwObjectNum, dwPosX, dwPosY, dwFrames) {
        var psObject = ScriptObjects.FindObject(dwObjectNum);
        if (!psObject) {
            return
        }
        var dwVX = (dwPosX / 256 - psObject.dwPosX) / dwFrames;
        var dwVY = (dwPosY / 256 - psObject.dwPosY) / dwFrames;
        psObject.dwVelocityX = dwVX;
        psObject.dwVelocityY = dwVY;
        psObject.dwTargetX = dwPosX / 256;
        psObject.dwTargetY = dwPosY / 256;
        psObject.dwTargetFrames = dwFrames;
        psObject.bEaseIn = false;
        psObject.bEaseOut = false
    };
    ScriptObjects.MoveToEase = function(dwObjectNum, dwPosX, dwPosY, bEaseIn, bEaseOut, dwFrames) {
        var psObject = ScriptObjects.FindObject(dwObjectNum);
        if (!psObject) {
            return
        }
        psObject.dwTargetX = dwPosX / 256;
        psObject.dwTargetY = dwPosY / 256;
        psObject.dwVelocityX = psObject.dwTargetX - psObject.dwPosX;
        psObject.dwVelocityY = psObject.dwTargetY - psObject.dwPosY;
        psObject.dwTargetFrames = dwFrames;
        psObject.dwTotalFrames = dwFrames;
        psObject.bEaseIn = bEaseIn;
        psObject.bEaseOut = bEaseOut
    };
    ScriptObjects.WaitMoved = function(dwObjectNum) {
        var psObject = ScriptObjects.FindObject(dwObjectNum);
        if (!psObject) {
            return
        }
        if (psObject.dwTargetFrames) {
            return false
        }
        return true
    };
    ScriptObjects.WaitLook = function(dwObjectNum) {
        var psObject = ScriptObjects.FindObject(dwObjectNum);
        if (!psObject) {
            return
        }
        if (psObject.dwTargetLookFrames) {
            return false
        }
        return true
    };
    ScriptObjects.ScaleSet = function(dwObjectNum, fScaleX, fScaleY) {
        var psObject = ScriptObjects.FindObject(dwObjectNum);
        if (!psObject) {
            return
        }
        psObject.fScaleX = fScaleX;
        psObject.fScaleY = fScaleY;
        if (psObject.eType === SCRIPTOBJECTS_TYPE_TEXT) {
            psObject.psText.ScaleX = psObject.fScaleX;
            psObject.psText.ScaleY = psObject.fScaleY;
            psObject.psText.SetScale(psObject.psText.ScaleX, psObject.psText.ScaleY)
        } else {
            psObject.psSprite.ScaleX = psObject.fScaleX;
            psObject.psSprite.ScaleY = psObject.fScaleY;
            psObject.psSprite.SetScale(psObject.psSprite.ScaleX, psObject.psSprite.ScaleY)
        }
        psObject.dwTargetScaleFrames = 0;
        psObject.dwTargetLookFrames = 0
    };
    ScriptObjects.Scale = function(dwObjectNum, fScaleX, fScaleY, dwFrames) {
        var psObject = ScriptObjects.FindObject(dwObjectNum);
        if (!psObject) {
            return
        }
        var fVX = fScaleX / dwFrames;
        var fVY = fScaleY / dwFrames;
        psObject.fVelocityScaleX = fVX;
        psObject.fVelocityScaleY = fVY;
        psObject.fTargetScaleX = psObject.fScaleX + fScaleX;
        psObject.fTargetScaleY = psObject.fScaleY + fScaleY;
        psObject.dwTargetScaleFrames = dwFrames;
        psObject.bScaleEaseIn = false;
        psObject.bScaleEaseOut = false;
        psObject.dwTargetLookFrames = 0
    };
    ScriptObjects.ScaleTo = function(dwObjectNum, fScaleX, fScaleY, dwFrames) {
        var psObject = ScriptObjects.FindObject(dwObjectNum);
        if (!psObject) {
            return
        }
        var fVX = (fScaleX - psObject.fScaleX) / dwFrames;
        var fVY = (fScaleY - psObject.fScaleY) / dwFrames;
        psObject.fVelocityScaleX = fVX;
        psObject.fVelocityScaleY = fVY;
        psObject.fTargetScaleX = fScaleX;
        psObject.fTargetScaleY = fScaleY;
        psObject.dwTargetScaleFrames = dwFrames;
        psObject.bScaleEaseIn = false;
        psObject.bScaleEaseOut = false;
        psObject.dwTargetLookFrames = 0
    };
    ScriptObjects.ScaleToEase = function(dwObjectNum, fScaleX, fScaleY, bEaseIn, bEaseOut, dwFrames) {
        var psObject = ScriptObjects.FindObject(dwObjectNum);
        if (!psObject) {
            return
        }
        psObject.fTargetScaleX = fScaleX;
        psObject.fTargetScaleY = fScaleY;
        psObject.fVelocityScaleX = psObject.fTargetScaleX - psObject.fScaleX;
        psObject.fVelocityScaleY = psObject.fTargetScaleY - psObject.fScaleY;
        psObject.dwTargetScaleFrames = dwFrames;
        psObject.dwTotalScaleFrames = dwFrames;
        psObject.bScaleEaseIn = bEaseIn;
        psObject.bScaleEaseOut = bEaseOut;
        psObject.dwTargetLookFrames = 0
    };
    ScriptObjects.WaitScale = function(dwObjectNum) {
        var psObject = ScriptObjects.FindObject(dwObjectNum);
        if (!psObject) {
            return
        }
        if (psObject.dwTargetScaleFrames) {
            return false
        }
        return true
    };
    ScriptObjects.RotateSet = function(dwObjectNum, fRotation) {
        var psObject = ScriptObjects.FindObject(dwObjectNum);
        if (!psObject) {
            return
        }
        psObject.fRotationX = fRotation;
        if (psObject.eType === SCRIPTOBJECTS_TYPE_TEXT) {
            psObject.psText.Rotation = fRotation;
            psObject.psText.SetRotation(psObject.psText.Rotation)
        } else {
            psObject.psSprite.Rotation = fRotation;
            psObject.psSprite.SetRotation(psObject.psSprite.Rotation)
        }
        psObject.dwTargetRotationFrames = 0
    };
    ScriptObjects.Rotate = function(dwObjectNum, fRotation, dwFrames) {
        var psObject = ScriptObjects.FindObject(dwObjectNum);
        if (!psObject) {
            return
        }
        var fV = fRotation / dwFrames;
        psObject.fVelocityRotationX = fV;
        psObject.fTargetRotationX = psObject.fRotationX + fRotation;
        psObject.dwTargetRotationFrames = dwFrames;
        psObject.bRotationEaseIn = false;
        psObject.bRotationEaseOut = false
    };
    ScriptObjects.RotateTo = function(dwObjectNum, fRotation, dwFrames) {
        var psObject = ScriptObjects.FindObject(dwObjectNum);
        if (!psObject) {
            return
        }
        var fV = (fRotation - psObject.fRotationX) / dwFrames;
        psObject.fVelocityRotationX = fV;
        psObject.fTargetRotationX = fRotation;
        psObject.dwTargetRotationFrames = dwFrames;
        psObject.bRotationEaseIn = false;
        psObject.bRotationEaseOut = false
    };
    ScriptObjects.RotateToEase = function(dwObjectNum, fRotation, bEaseIn, bEaseOut, dwFrames) {
        var psObject = ScriptObjects.FindObject(dwObjectNum);
        if (!psObject) {
            return
        }
        psObject.fTargetRotationX = fRotation;
        psObject.fVelocityRotationX = psObject.fTargetRotationX - psObject.fRotationX;
        psObject.dwTargetRotationFrames = dwFrames;
        psObject.dwTotalRotationFrames = dwFrames;
        psObject.bRotationEaseIn = bEaseIn;
        psObject.bRotationEaseOut = bEaseOut
    };
    ScriptObjects.WaitRotate = function(dwObjectNum) {
        var psObject = ScriptObjects.FindObject(dwObjectNum);
        if (!psObject) {
            return
        }
        if (psObject.dwTargetRotationFrames) {
            return false
        }
        return true
    };
    ScriptObjects.AlphaSet = function(dwObjectNum, dwAlpha) {
        dwAlpha <<= 8;
        var psObject = ScriptObjects.FindObject(dwObjectNum);
        if (!psObject) {
            return
        }
        psObject.dwAlpha = dwAlpha;
        if (psObject.eType === SCRIPTOBJECTS_TYPE_TEXT) {
            psObject.psText.SetOpacity((psObject.dwAlpha >> 8) / 256)
        } else {
            if (psObject.psSprite.SetOpacity) {
                psObject.psSprite.SetOpacity((psObject.dwAlpha >> 8) / 256)
            }
        }
    };
    ScriptObjects.Alpha = function(dwObjectNum, dwAlpha, dwFrames) {
        dwAlpha <<= 8;
        var psObject = ScriptObjects.FindObject(dwObjectNum);
        if (!psObject) {
            return
        }
        var dwVX = dwAlpha / dwFrames;
        psObject.dwVelocityAlpha = dwVX;
        psObject.dwTargetAlpha = psObject.dwAlpha + dwAlpha;
        psObject.dwTargetAlphaFrames = dwFrames
    };
    ScriptObjects.AlphaTo = function(dwObjectNum, dwAlpha, dwFrames) {
        dwAlpha <<= 8;
        var psObject = ScriptObjects.FindObject(dwObjectNum);
        if (!psObject) {
            return
        }
        var dwVX = (dwAlpha - psObject.dwAlpha) / dwFrames;
        psObject.dwVelocityAlpha = dwVX;
        psObject.dwTargetAlpha = dwAlpha;
        psObject.dwTargetAlphaFrames = dwFrames
    };
    ScriptObjects.WaitAlpha = function(dwObjectNum) {
        var psObject = ScriptObjects.FindObject(dwObjectNum);
        if (!psObject) {
            return
        }
        if (psObject.dwTargetAlphaFrames) {
            return false
        }
        return true
    };
    ScriptObjects.SetColour = function(dwObjectNum, dwRed, dwGreen, dwBlue) {
        var psObject = ScriptObjects.FindObject(dwObjectNum);
        if (!psObject) {
            return
        }
        switch (psObject.eType) {
            case SCRIPTOBJECTS_TYPE_SPRITE:
            case SCRIPTOBJECTS_TYPE_ANIMATION:
                if (psObject.psSprite.SetColour) {
                    psObject.psSprite.SetColour([dwRed / 256, dwGreen / 256, dwBlue / 256, psObject.psSprite.GetOpacity()])
                }
                break;
            case SCRIPTOBJECTS_TYPE_TEXT:
                psObject.psText.SetColour([dwRed / 256, dwGreen / 256, dwBlue / 256, psObject.psText.GetOpacity()]);
                break;
            default:
                break
        }
    };
    ScriptObjects.Visible = function(dwObjectNum, bVisible) {
        var psObject = ScriptObjects.FindObject(dwObjectNum);
        if (!psObject) {
            return
        }
        switch (psObject.eType) {
            case SCRIPTOBJECTS_TYPE_SPRITE:
            case SCRIPTOBJECTS_TYPE_ANIMATION:
                psObject.psSprite.SetIsVisible(bVisible);
                break;
            case SCRIPTOBJECTS_TYPE_TEXT:
                psObject.psText.SetIsVisible(bVisible);
                break;
            default:
                break
        }
    };
    ScriptObjects.Destroy = function(dwObjectNum) {
        var psObject = ScriptObjects.FindObject(dwObjectNum);
        if (!psObject) {
            return
        }
        switch (psObject.eType) {
            case SCRIPTOBJECTS_TYPE_ANIMATION:
                JamSystem.RenderManager.DestroySpriteAnimation(psObject.psSpriteAnimation);
                Helpers.DestroySprite(psObject.psSprite);
                psObject.psSprite = null;
                psObject.psSpriteAnimation = null;
                break;
            case SCRIPTOBJECTS_TYPE_SPRITE:
                if (psObject.Created) {
                    Helpers.DestroySprite(psObject.psSprite)
                }
                psObject.psSprite = null;
                break;
            case SCRIPTOBJECTS_TYPE_TEXT:
                if (psObject.Created) {
                    Helpers.DestroyBitmapText(psObject.psText)
                }
                psObject.psText = null;
                break;
            default:
                break
        }
        var Index = ScriptObjects.psList.indexOf(psObject);
        ScriptObjects.psList.splice(Index, 1)
    };
    ScriptObjects.CalcEase = function(bEaseIn, bEaseOut, dwFrames, dwTotalFrames) {
        var fCos;
        if (bEaseIn) {
            if (bEaseOut) {
                fCos = Math.cos(dwFrames / dwTotalFrames * (22 / 7));
                fCos = (fCos + 1) / 2
            } else {
                fCos = Math.cos(dwFrames / dwTotalFrames * (11 / 7))
            }
        } else {
            fCos = Math.cos(dwFrames / dwTotalFrames * (11 / 7) + 11 / 7);
            fCos = fCos + 1
        }
        fCos = 1 - fCos;
        return fCos
    };
    ScriptObjects.UpdateSingle = function(psObject) {
        var fCos;
        if (psObject.dwTargetFrames) {
            if (psObject.bEaseIn || psObject.bEaseOut) {
                fCos = ScriptObjects.CalcEase(psObject.bEaseIn, psObject.bEaseOut, psObject.dwTargetFrames, psObject.dwTotalFrames);
                psObject.dwPosX = psObject.dwTargetX - psObject.dwVelocityX * fCos;
                psObject.dwPosY = psObject.dwTargetY - psObject.dwVelocityY * fCos;
                psObject.dwPosZ = psObject.dwTargetZ - psObject.dwVelocityZ * fCos
            } else {
                psObject.dwPosX += psObject.dwVelocityX;
                psObject.dwPosY += psObject.dwVelocityY;
                psObject.dwPosZ += psObject.dwVelocityZ
            }
            psObject.dwTargetFrames -= 1;
            if (!psObject.dwTargetFrames) {
                psObject.dwVelocityX = 0;
                psObject.dwVelocityY = 0;
                psObject.dwVelocityZ = 0;
                psObject.dwPosX = psObject.dwTargetX;
                psObject.dwPosY = psObject.dwTargetY;
                psObject.dwPosZ = psObject.dwTargetZ
            }
            switch (psObject.eType) {
                case SCRIPTOBJECTS_TYPE_ANIMATION:
                case SCRIPTOBJECTS_TYPE_SPRITE:
                    psObject.psSprite.SetPosition(psObject.dwPosX, psObject.dwPosY);
                    break;
                case SCRIPTOBJECTS_TYPE_TEXT:
                    psObject.psText.SetPosition(psObject.dwPosX, psObject.dwPosY);
                    break;
                default:
                    break
            }
        }
        if (psObject.dwTargetScaleFrames) {
            if (psObject.bScaleEaseIn || psObject.bScaleEaseOut) {
                fCos = ScriptObjects.CalcEase(psObject.bScaleEaseIn, psObject.bScaleEaseOut, psObject.dwTargetScaleFrames, psObject.dwTotalScaleFrames);
                psObject.fScaleX = psObject.fTargetScaleX - psObject.fVelocityScaleX * fCos;
                psObject.fScaleY = psObject.fTargetScaleY - psObject.fVelocityScaleY * fCos;
                psObject.fScaleZ = psObject.fTargetScaleZ - psObject.fVelocityScaleZ * fCos
            } else {
                psObject.fScaleX += psObject.fVelocityScaleX;
                psObject.fScaleY += psObject.fVelocityScaleY;
                psObject.fScaleZ += psObject.fVelocityScaleZ
            }
            psObject.dwTargetScaleFrames -= 1;
            if (!psObject.dwTargetScaleFrames) {
                psObject.fVelocityScaleX = 0;
                psObject.fVelocityScaleY = 0;
                psObject.fVelocityScaleZ = 0;
                psObject.fScaleX = psObject.fTargetScaleX;
                psObject.fScaleY = psObject.fTargetScaleY;
                psObject.fScaleZ = psObject.fTargetScaleZ
            }
            switch (psObject.eType) {
                case SCRIPTOBJECTS_TYPE_ANIMATION:
                case SCRIPTOBJECTS_TYPE_SPRITE:
                    psObject.psSprite.ScaleX = psObject.fScaleX;
                    psObject.psSprite.ScaleY = psObject.fScaleY;
                    psObject.psSprite.SetScale(psObject.psSprite.ScaleX, psObject.psSprite.ScaleY);
                    break;
                case SCRIPTOBJECTS_TYPE_TEXT:
                    psObject.psText.ScaleX = psObject.fScaleX;
                    psObject.psText.ScaleY = psObject.fScaleY;
                    psObject.psText.SetScale(psObject.psText.ScaleX, psObject.psText.ScaleY);
                    break;
                default:
                    break
            }
        }
        if (psObject.dwTargetLookFrames) {
            if (psObject.bLookEaseIn || psObject.bLookEaseOut) {
                fCos = ScriptObjects.CalcEase(psObject.bLookEaseIn, psObject.bLookEaseOut, psObject.dwTargetLookFrames, psObject.dwTotalLookFrames);
                psObject.fLookX = psObject.fTargetLookX - psObject.fVelocityLookX * fCos;
                psObject.fLookY = psObject.fTargetLookY - psObject.fVelocityLookY * fCos;
                psObject.fLookZ = psObject.fTargetLookZ - psObject.fVelocityLookZ * fCos
            } else {
                psObject.fLookX += psObject.fVelocityLookX;
                psObject.fLookY += psObject.fVelocityLookY;
                psObject.fLookZ += psObject.fVelocityLookZ
            }
            psObject.dwTargetLookFrames -= 1;
            if (!psObject.dwTargetLookFrames) {
                psObject.fVelocityLookX = 0;
                psObject.fVelocityLookY = 0;
                psObject.fVelocityLookZ = 0;
                psObject.fLookX = psObject.fTargetLookX;
                psObject.fLookY = psObject.fTargetLookY;
                psObject.fLookZ = psObject.fTargetLookZ
            }
        }
        if (psObject.dwTargetRotationFrames) {
            if (psObject.bRotationEaseIn || psObject.bRotationEaseOut) {
                fCos = ScriptObjects.CalcEase(psObject.bRotationEaseIn, psObject.bRotationEaseOut, psObject.dwTargetRotationFrames, psObject.dwTotalRotationFrames);
                psObject.fRotationX = psObject.fTargetRotationX - psObject.fVelocityRotationX * fCos;
                psObject.fRotationY = psObject.fTargetRotationY - psObject.fVelocityRotationY * fCos;
                psObject.fRotationZ = psObject.fTargetRotationZ - psObject.fVelocityRotationZ * fCos
            } else {
                psObject.fRotationX += psObject.fVelocityRotationX;
                psObject.fRotationY += psObject.fVelocityRotationY;
                psObject.fRotationZ += psObject.fVelocityRotationZ
            }
            psObject.dwTargetRotationFrames -= 1;
            if (!psObject.dwTargetRotationFrames) {
                psObject.fVelocityRotationX = 0;
                psObject.fVelocityRotationY = 0;
                psObject.fVelocityRotationZ = 0;
                psObject.fRotationX = psObject.fTargetRotationX;
                psObject.fRotationY = psObject.fTargetRotationY;
                psObject.fRotationZ = psObject.fTargetRotationZ
            }
            switch (psObject.eType) {
                case SCRIPTOBJECTS_TYPE_ANIMATION:
                case SCRIPTOBJECTS_TYPE_SPRITE:
                    psObject.psSprite.Rotation = psObject.fRotationX;
                    psObject.psSprite.SetRotation(psObject.psSprite.Rotation);
                    break;
                case SCRIPTOBJECTS_TYPE_TEXT:
                    psObject.psText.Rotation = psObject.fRotationX;
                    psObject.psText.SetRotation(psObject.psText.Rotation);
                    break;
                default:
                    break
            }
        }
        if (psObject.dwTargetAlphaFrames) {
            psObject.dwAlpha += psObject.dwVelocityAlpha;
            psObject.dwTargetAlphaFrames -= 1;
            if (!psObject.dwTargetAlphaFrames) {
                psObject.dwVelocityAlpha = 0;
                psObject.dwAlpha = psObject.dwTargetAlpha
            }
            if (psObject.eType === SCRIPTOBJECTS_TYPE_TEXT) {
                psObject.psText.SetOpacity((psObject.dwAlpha >> 8) / 256)
            } else {
                if (psObject.psSprite.SetOpacity) {
                    psObject.psSprite.SetOpacity((psObject.dwAlpha >> 8) / 256)
                }
            }
        }
        switch (psObject.eType) {
            case SCRIPTOBJECTS_TYPE_ANIMATION:
                if (psObject.psSpriteAnimation.Playing) {
                    psObject.psSpriteAnimation.Update(1 / 60)
                }
                break;
            case SCRIPTOBJECTS_TYPE_SPRITE:
            case SCRIPTOBJECTS_TYPE_TEXT:
                break;
            default:
                break
        }
    };
    ScriptObjects.Update = function() {
        var i;
        for (i = 0; i < ScriptObjects.psList.length; i += 1) {
            ScriptObjects.UpdateSingle(ScriptObjects.psList[i])
        }
    };
    ScriptObjects.ProcessList = function(psList) {
        if (psList) {
            ScriptObjects.psList = psList
        } else {
            ScriptObjects.psList = ScriptObjects.psMainList
        }
    };
    var DEFAULT_FADE = 10;
    var START_FADE = 20;

    function ScriptData() {}
    ScriptData.Test = [SCRIPT_INSTRUCTION_OBJECT_CREATE_SPRITE, 5, 0, "NewBlank", 50 << 8, 50 << 8, EA.TopLeft, SCRIPT_INSTRUCTION_MARKER, 1, 0, SCRIPT_INSTRUCTION_OBJECT_MOVE, 4, 0, 100 << 8, 0 << 8, 75, SCRIPT_INSTRUCTION_WAIT, 1, 75, SCRIPT_INSTRUCTION_OBJECT_MOVE, 4, 0, -100 << 8, 0 << 8, 75, SCRIPT_INSTRUCTION_WAIT, 1, 75, SCRIPT_INSTRUCTION_GOTO, 1, 0, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 0, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.CoverStart = [SCRIPT_INSTRUCTION_END, 0];
    ScriptData.CoverEnd = [SCRIPT_INSTRUCTION_SET_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_1, DEFAULT_FADE, SCRIPT_INSTRUCTION_SET_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_2, 255 << 8, SCRIPT_INSTRUCTION_SET_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_3, 0 << 8, SCRIPT_INSTRUCTION_MARKER, 1, 0, SCRIPT_INSTRUCTION_ADD_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_2, -(255 << 8) / DEFAULT_FADE, SCRIPTEXT_INSTRUCTION_COVER_OPACITY, 1, SCRIPT_LOCAL_VARIABLE_2, SCRIPT_INSTRUCTION_ADD_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_3, (255 << 8) / DEFAULT_FADE, SCRIPTEXT_INSTRUCTION_NAME_OPACITY, 1, SCRIPT_LOCAL_VARIABLE_3, SCRIPTEXT_INSTRUCTION_INFO_OPACITY, 1, SCRIPT_LOCAL_VARIABLE_3, SCRIPT_INSTRUCTION_WAIT, 1, 1, SCRIPT_INSTRUCTION_ADD_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_1, -1, SCRIPT_INSTRUCTION_CMP, 4, SCRIPT_LOCAL_VARIABLE_1, 0, SCRIPT_CMPTYPE_NOT, 0, SCRIPTEXT_INSTRUCTION_BOARD_OPACITY, 1, 255 << 8, SCRIPTEXT_INSTRUCTION_NAME_OPACITY, 1, 255 << 8, SCRIPTEXT_INSTRUCTION_INFO_OPACITY, 1, 255 << 8, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.CoverInterrupt = [SCRIPT_INSTRUCTION_WAIT, 1, DEFAULT_FADE, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.HelpStart = [SCRIPT_INSTRUCTION_SET_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_1, DEFAULT_FADE, SCRIPT_INSTRUCTION_SET_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_2, 255 << 8, SCRIPT_INSTRUCTION_SET_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_3, 0 << 8, SCRIPTEXT_INSTRUCTION_COVER_OPACITY, 1, SCRIPT_LOCAL_VARIABLE_2, SCRIPTEXT_INSTRUCTION_BOARD_OPACITY, 1, SCRIPT_LOCAL_VARIABLE_2, SCRIPTEXT_INSTRUCTION_INFO_OPACITY, 1, SCRIPT_LOCAL_VARIABLE_2, SCRIPTEXT_INSTRUCTION_HELP_OPACITY, 1, SCRIPT_LOCAL_VARIABLE_3, SCRIPT_INSTRUCTION_WAIT, 1, 10, SCRIPT_INSTRUCTION_MARKER, 1, 0, SCRIPT_INSTRUCTION_ADD_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_2, -(255 << 8) / DEFAULT_FADE, SCRIPTEXT_INSTRUCTION_COVER_OPACITY, 1, SCRIPT_LOCAL_VARIABLE_2, SCRIPTEXT_INSTRUCTION_BOARD_OPACITY, 1, SCRIPT_LOCAL_VARIABLE_2, SCRIPTEXT_INSTRUCTION_INFO_OPACITY, 1, SCRIPT_LOCAL_VARIABLE_2, SCRIPT_INSTRUCTION_ADD_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_3, (255 << 8) / DEFAULT_FADE, SCRIPTEXT_INSTRUCTION_HELP_OPACITY, 1, SCRIPT_LOCAL_VARIABLE_3, SCRIPT_INSTRUCTION_WAIT, 1, 1, SCRIPT_INSTRUCTION_ADD_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_1, -1, SCRIPT_INSTRUCTION_CMP, 4, SCRIPT_LOCAL_VARIABLE_1, 0, SCRIPT_CMPTYPE_NOT, 0, SCRIPTEXT_INSTRUCTION_COVER_OPACITY, 1, 0, SCRIPTEXT_INSTRUCTION_BOARD_OPACITY, 1, 0, SCRIPTEXT_INSTRUCTION_INFO_OPACITY, 1, 0, SCRIPTEXT_INSTRUCTION_HELP_OPACITY, 1, 255 << 8, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.HelpEnd = [SCRIPT_INSTRUCTION_SET_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_1, DEFAULT_FADE, SCRIPT_INSTRUCTION_SET_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_2, 255 << 8, SCRIPT_INSTRUCTION_SET_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_3, 0 << 8, SCRIPTEXT_INSTRUCTION_HELP_OPACITY, 1, SCRIPT_LOCAL_VARIABLE_2, SCRIPTEXT_INSTRUCTION_COVER_OPACITY, 1, SCRIPT_LOCAL_VARIABLE_3, SCRIPTEXT_INSTRUCTION_BOARD_OPACITY, 1, SCRIPT_LOCAL_VARIABLE_3, SCRIPTEXT_INSTRUCTION_INFO_OPACITY, 1, SCRIPT_LOCAL_VARIABLE_3, SCRIPT_INSTRUCTION_WAIT, 1, 10, SCRIPT_INSTRUCTION_MARKER, 1, 0, SCRIPT_INSTRUCTION_ADD_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_2, -(255 << 8) / DEFAULT_FADE, SCRIPTEXT_INSTRUCTION_HELP_OPACITY, 1, SCRIPT_LOCAL_VARIABLE_2, SCRIPT_INSTRUCTION_ADD_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_3, (255 << 8) / DEFAULT_FADE, SCRIPTEXT_INSTRUCTION_COVER_OPACITY, 1, SCRIPT_LOCAL_VARIABLE_3, SCRIPTEXT_INSTRUCTION_BOARD_OPACITY, 1, SCRIPT_LOCAL_VARIABLE_3, SCRIPTEXT_INSTRUCTION_INFO_OPACITY, 1, SCRIPT_LOCAL_VARIABLE_3, SCRIPT_INSTRUCTION_WAIT, 1, 1, SCRIPT_INSTRUCTION_ADD_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_1, -1, SCRIPT_INSTRUCTION_CMP, 4, SCRIPT_LOCAL_VARIABLE_1, 0, SCRIPT_CMPTYPE_NOT, 0, SCRIPTEXT_INSTRUCTION_HELP_OPACITY, 1, 0, SCRIPTEXT_INSTRUCTION_COVER_OPACITY, 1, 255 << 8, SCRIPTEXT_INSTRUCTION_BOARD_OPACITY, 1, 255 << 8, SCRIPTEXT_INSTRUCTION_INFO_OPACITY, 1, 255 << 8, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.ColourComplete = [SCRIPT_INSTRUCTION_WAIT_AUDIO, 1, "ColourComplete01", SCRIPT_INSTRUCTION_WAIT_AUDIO, 1, "ColourComplete02", SCRIPT_INSTRUCTION_WAIT_AUDIO, 1, "ColourComplete03", SCRIPT_INSTRUCTION_END, 0];
    var MiddleX = 322;
    var OffsetY = -50;
    ScriptData.Complete = [SCRIPT_INSTRUCTION_WAIT_AUDIO, 1, "ColourComplete01", SCRIPT_INSTRUCTION_WAIT_AUDIO, 1, "ColourComplete02", SCRIPT_INSTRUCTION_WAIT_AUDIO, 1, "ColourComplete03", SCRIPT_INSTRUCTION_PLAY_AUDIO, 1, "PuzzleComplete", SCRIPT_INSTRUCTION_OBJECT_CREATE_TEXT, 6, 0, "DATATEXT_ID_COMPLETE", "PanelFont", MiddleX << 8, 188 * SCREEN_SCALER + 32 + OffsetY << 8, EA.Default, SCRIPT_INSTRUCTION_OBJECT_ALPHA_SET, 2, 0, 0, SCRIPT_INSTRUCTION_OBJECT_ALPHA_TO, 3, 0, 255, DEFAULT_FADE, SCRIPT_INSTRUCTION_CMP, 4, SCRIPT_LOCAL_VARIABLE_1, 0, SCRIPT_CMPTYPE_NOT, 0, SCRIPT_INSTRUCTION_MARKER, 1, 2, SCRIPTEXT_INSTRUCTION_CREATE_EFFECT, 5, 1, MiddleX << 8, 240 * SCREEN_SCALER + 32 + OffsetY << 8, 200 * SCREEN_SCALER << 8, 75 * SCREEN_SCALER << 8, SCRIPT_INSTRUCTION_WAIT, 1, 1, SCRIPT_INSTRUCTION_IS_AUDIO_PLAYING, 1, "PuzzleComplete", SCRIPT_INSTRUCTION_CMP, 4, SCRIPT_GLOBAL_VARIABLE_11, 0, SCRIPT_CMPTYPE_NOT, 2, SCRIPT_INSTRUCTION_GOTO, 1, 1, SCRIPT_INSTRUCTION_MARKER, 1, 0, SCRIPT_INSTRUCTION_WAIT, 1, 75, SCRIPT_INSTRUCTION_MARKER, 1, 1, SCRIPT_INSTRUCTION_OBJECT_ALPHA_TO, 3, 0, 0, DEFAULT_FADE, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 0, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.ChallengeComplete = [SCRIPT_INSTRUCTION_WAIT_AUDIO, 1, "ColourComplete01", SCRIPT_INSTRUCTION_WAIT_AUDIO, 1, "ColourComplete02", SCRIPT_INSTRUCTION_WAIT_AUDIO, 1, "ColourComplete03", SCRIPTEXT_INSTRUCTION_CREATE_LIGHT_RAYS, 3, MiddleX << 8, 138 * SCREEN_SCALER + OffsetY << 8, 150, SCRIPT_INSTRUCTION_OBJECT_CREATE_SPRITE, 5, 4, SCRIPT_LOCAL_VARIABLE_1, MiddleX << 8, 138 * SCREEN_SCALER + 32 + OffsetY << 8, EA.BottomRight, SCRIPT_INSTRUCTION_OBJECT_CREATE_SPRITE, 5, 5, SCRIPT_LOCAL_VARIABLE_2, MiddleX << 8, 138 * SCREEN_SCALER + 32 + OffsetY << 8, EA.BottomLeft, SCRIPT_INSTRUCTION_OBJECT_CREATE_SPRITE, 5, 6, SCRIPT_LOCAL_VARIABLE_3, MiddleX << 8, 138 * SCREEN_SCALER + 32 + OffsetY << 8, EA.TopRight, SCRIPT_INSTRUCTION_OBJECT_CREATE_SPRITE, 5, 7, SCRIPT_LOCAL_VARIABLE_4, MiddleX << 8, 138 * SCREEN_SCALER + 32 + OffsetY << 8, EA.TopLeft, SCRIPT_INSTRUCTION_OBJECT_CREATE_TEXT, 6, 2, "DATATEXT_ID_CHALLENGE_COMPLETE", "PanelFont", MiddleX << 8, 138 * SCREEN_SCALER + 32 + OffsetY << 8, EA.Default, SCRIPT_INSTRUCTION_OBJECT_CREATE_TEXT, 6, 0, SCRIPT_GLOBAL_VARIABLE_4, "PanelFont", MiddleX << 8, 278 * SCREEN_SCALER + 32 + OffsetY << 8, EA.Default, SCRIPT_INSTRUCTION_OBJECT_SCALE_SET, 3, 4, 0, 0, SCRIPT_INSTRUCTION_OBJECT_SCALE_SET, 3, 5, 0, 0, SCRIPT_INSTRUCTION_OBJECT_SCALE_SET, 3, 6, 0, 0, SCRIPT_INSTRUCTION_OBJECT_SCALE_SET, 3, 7, 0, 0, SCRIPT_INSTRUCTION_OBJECT_ROTATE_SET, 2, 4, -45, SCRIPT_INSTRUCTION_OBJECT_ROTATE_SET, 2, 5, -45, SCRIPT_INSTRUCTION_OBJECT_ROTATE_SET, 2, 6, -45, SCRIPT_INSTRUCTION_OBJECT_ROTATE_SET, 2, 7, -45, SCRIPT_INSTRUCTION_OBJECT_SCALE_SET, 3, 2, 95, 100, SCRIPT_INSTRUCTION_OBJECT_SCALE_SET, 3, 0, 75, 75, SCRIPT_INSTRUCTION_PLAY_AUDIO, 1, "BonusComplete", SCRIPT_INSTRUCTION_OBJECT_ALPHA_SET, 2, 0, 0, SCRIPT_INSTRUCTION_OBJECT_ALPHA_SET, 2, 2, 0, SCRIPT_INSTRUCTION_OBJECT_ALPHA_TO, 3, 0, 255, DEFAULT_FADE, SCRIPT_INSTRUCTION_OBJECT_ALPHA_TO, 3, 2, 255, DEFAULT_FADE, SCRIPT_INSTRUCTION_WAIT, 1, 10, SCRIPT_INSTRUCTION_OBJECT_ROTATE_TO_EASE, 5, 4, 0, true, true, 10, SCRIPT_INSTRUCTION_OBJECT_ROTATE_TO_EASE, 5, 5, 0, true, true, 10, SCRIPT_INSTRUCTION_OBJECT_ROTATE_TO_EASE, 5, 6, 0, true, true, 10, SCRIPT_INSTRUCTION_OBJECT_ROTATE_TO_EASE, 5, 7, 0, true, true, 10, SCRIPT_INSTRUCTION_OBJECT_SCALE_TO_EASE, 6, 4, 125, 125, true, true, 10, SCRIPT_INSTRUCTION_OBJECT_SCALE_TO_EASE, 6, 5, 125, 125, true, true, 10, SCRIPT_INSTRUCTION_OBJECT_SCALE_TO_EASE, 6, 6, 125, 125, true, true, 10, SCRIPT_INSTRUCTION_OBJECT_SCALE_TO_EASE, 6, 7, 125, 125, true, true, 10, SCRIPT_INSTRUCTION_WAIT, 1, 10, SCRIPT_INSTRUCTION_OBJECT_SCALE_TO_EASE, 6, 4, 100, 100, true, true, 10, SCRIPT_INSTRUCTION_OBJECT_SCALE_TO_EASE, 6, 5, 100, 100, true, true, 10, SCRIPT_INSTRUCTION_OBJECT_SCALE_TO_EASE, 6, 6, 100, 100, true, true, 10, SCRIPT_INSTRUCTION_OBJECT_SCALE_TO_EASE, 6, 7, 100, 100, true, true, 10, SCRIPT_INSTRUCTION_WAIT, 1, 10, SCRIPT_INSTRUCTION_SET_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_14, 150, SCRIPT_INSTRUCTION_MARKER, 1, 0, SCRIPTEXT_INSTRUCTION_CREATE_EFFECT, 5, 1, MiddleX << 8, 278 * SCREEN_SCALER + OffsetY << 8, 150 * SCREEN_SCALER << 8, 90 * SCREEN_SCALER << 8, SCRIPT_INSTRUCTION_WAIT, 1, 1, SCRIPT_INSTRUCTION_ADD_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_14, -1, SCRIPT_INSTRUCTION_CMP, 4, SCRIPT_LOCAL_VARIABLE_14, 0, SCRIPT_CMPTYPE_NOT, 0, SCRIPT_INSTRUCTION_OBJECT_ALPHA_TO, 3, 0, 0, DEFAULT_FADE, SCRIPT_INSTRUCTION_OBJECT_ALPHA_TO, 3, 2, 0, DEFAULT_FADE, SCRIPT_INSTRUCTION_OBJECT_ALPHA_TO, 3, 4, 0, DEFAULT_FADE, SCRIPT_INSTRUCTION_OBJECT_ALPHA_TO, 3, 5, 0, DEFAULT_FADE, SCRIPT_INSTRUCTION_OBJECT_ALPHA_TO, 3, 6, 0, DEFAULT_FADE, SCRIPT_INSTRUCTION_OBJECT_ALPHA_TO, 3, 7, 0, DEFAULT_FADE, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 0, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 2, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 4, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 5, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 6, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 7, SCRIPTEXT_INSTRUCTION_DESTROY_LIGHT_RAYS, 0, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.Review = [SCRIPTEXT_INSTRUCTION_MOVE_BOARD_TO, 5, 844, 168, 43, 43, START_FADE, SCRIPT_INSTRUCTION_SET_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_14, START_FADE, SCRIPT_INSTRUCTION_SET_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_12, 0 << 8, SCRIPT_INSTRUCTION_SET_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_13, 255 << 8, SCRIPT_INSTRUCTION_MARKER, 1, 0, SCRIPT_INSTRUCTION_ADD_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_12, (255 << 8) / START_FADE, SCRIPTEXT_INSTRUCTION_REVIEW_OPACITY, 1, SCRIPT_LOCAL_VARIABLE_12, SCRIPT_INSTRUCTION_ADD_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_13, (-255 << 8) / START_FADE, SCRIPTEXT_INSTRUCTION_MAKE_OPACITY, 1, SCRIPT_LOCAL_VARIABLE_13, SCRIPT_INSTRUCTION_WAIT, 1, 1, SCRIPT_INSTRUCTION_ADD_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_14, -1, SCRIPT_INSTRUCTION_CMP, 4, SCRIPT_LOCAL_VARIABLE_14, 0, SCRIPT_CMPTYPE_NOT, 0, SCRIPTEXT_INSTRUCTION_REVIEW_OPACITY, 1, 255 << 8, SCRIPTEXT_INSTRUCTION_MAKE_OPACITY, 1, 0 << 8, SCRIPT_INSTRUCTION_WAIT, 1, 60, SCRIPTEXT_INSTRUCTION_START_COUNTER, 3, SCRIPT_LOCAL_VARIABLE_1, SCRIPT_LOCAL_VARIABLE_2, 60, SCRIPTEXT_INSTRUCTION_WAIT_COUNTER, 1, SCRIPT_LOCAL_VARIABLE_1, SCRIPT_INSTRUCTION_WAIT, 1, 30, SCRIPT_INSTRUCTION_CMP, 4, SCRIPT_LOCAL_VARIABLE_11, 0, SCRIPT_CMPTYPE_EQUAL, 1, SCRIPTEXT_INSTRUCTION_START_COUNTER, 3, SCRIPT_LOCAL_VARIABLE_9, SCRIPT_LOCAL_VARIABLE_10, 60, SCRIPTEXT_INSTRUCTION_WAIT_COUNTER, 1, SCRIPT_LOCAL_VARIABLE_9, SCRIPT_INSTRUCTION_WAIT, 1, 30, SCRIPT_INSTRUCTION_MARKER, 1, 1, SCRIPTEXT_INSTRUCTION_START_COUNTER, 3, SCRIPT_LOCAL_VARIABLE_3, SCRIPT_LOCAL_VARIABLE_4, 60, SCRIPTEXT_INSTRUCTION_WAIT_COUNTER, 1, SCRIPT_LOCAL_VARIABLE_3, SCRIPT_INSTRUCTION_WAIT, 1, 30, SCRIPTEXT_INSTRUCTION_START_COUNTER, 3, SCRIPT_LOCAL_VARIABLE_5, SCRIPT_LOCAL_VARIABLE_6, 60, SCRIPTEXT_INSTRUCTION_WAIT_COUNTER, 1, SCRIPT_LOCAL_VARIABLE_5, SCRIPT_INSTRUCTION_WAIT, 1, 30, SCRIPTEXT_INSTRUCTION_START_COUNTER, 3, SCRIPT_LOCAL_VARIABLE_7, SCRIPT_LOCAL_VARIABLE_8, 60, SCRIPTEXT_INSTRUCTION_WAIT_COUNTER, 1, SCRIPT_LOCAL_VARIABLE_7, SCRIPT_INSTRUCTION_WAIT, 1, 30, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.ReviewChallenge = [SCRIPT_INSTRUCTION_PLAY_AUDIO, 1, "LevelUnwrapped", SCRIPT_INSTRUCTION_OBJECT_CREATE_TEXT, 6, 0, "DATATEXT_ID_BONUS_CHALLENGE", "PanelFont", MiddleX << 8, (188 - 120) * SCREEN_SCALER + 32 + OffsetY << 8, EA.Default, SCRIPT_INSTRUCTION_OBJECT_SCALE_SET, 3, 0, 90, 90, SCRIPT_INSTRUCTION_OBJECT_ALPHA_SET, 2, 0, 0, SCRIPT_INSTRUCTION_OBJECT_ALPHA_TO, 3, 0, 255, DEFAULT_FADE, SCRIPT_INSTRUCTION_SET_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_2, DEFAULT_FADE, SCRIPT_INSTRUCTION_SET_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_3, 255 << 8, SCRIPT_INSTRUCTION_MARKER, 1, 0, SCRIPT_INSTRUCTION_ADD_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_3, -((255 << 8) * 2) / DEFAULT_FADE, SCRIPTEXT_INSTRUCTION_REVIEW_OPACITY, 1, SCRIPT_LOCAL_VARIABLE_3, SCRIPT_INSTRUCTION_WAIT, 1, 1, SCRIPT_INSTRUCTION_ADD_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_2, -1, SCRIPT_INSTRUCTION_CMP, 4, SCRIPT_LOCAL_VARIABLE_2, 0, SCRIPT_CMPTYPE_NOT, 0, SCRIPTEXT_INSTRUCTION_REVIEW_OPACITY, 1, 0 << 8, SCRIPT_INSTRUCTION_SET_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_13, 0 << 8, SCRIPT_INSTRUCTION_SET_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_2, DEFAULT_FADE, SCRIPTEXT_INSTRUCTION_MAKE_SHAPE_OPACITY, 1, 0, SCRIPT_INSTRUCTION_MARKER, 1, 1, SCRIPT_INSTRUCTION_ADD_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_13, (99 << 8) / DEFAULT_FADE, SCRIPTEXT_INSTRUCTION_MAKE_SHAPE_OPACITY, 1, SCRIPT_LOCAL_VARIABLE_13, SCRIPT_INSTRUCTION_WAIT, 1, 1, SCRIPT_INSTRUCTION_ADD_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_2, -1, SCRIPT_INSTRUCTION_CMP, 4, SCRIPT_LOCAL_VARIABLE_2, 0, SCRIPT_CMPTYPE_NOT, 1, SCRIPT_INSTRUCTION_OBJECT_CREATE_TEXT, 6, 1, SCRIPT_LOCAL_VARIABLE_1, "PanelFont", MiddleX << 8, (208 + 75 + 10) * SCREEN_SCALER + 32 + OffsetY << 8, EA.Default, SCRIPT_INSTRUCTION_OBJECT_SCALE_SET, 3, 1, 90, 90, SCRIPT_INSTRUCTION_OBJECT_ALPHA_SET, 2, 1, 0, SCRIPT_INSTRUCTION_OBJECT_ALPHA_TO, 3, 1, 255, DEFAULT_FADE, SCRIPT_INSTRUCTION_WAIT, 1, 120, SCRIPT_INSTRUCTION_OBJECT_ALPHA_TO, 3, 1, 0, DEFAULT_FADE, SCRIPT_INSTRUCTION_OBJECT_ALPHA_TO, 3, 0, 0, DEFAULT_FADE, SCRIPT_INSTRUCTION_SET_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_13, 99 << 8, SCRIPT_INSTRUCTION_SET_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_2, DEFAULT_FADE, SCRIPT_INSTRUCTION_MARKER, 1, 2, SCRIPT_INSTRUCTION_ADD_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_13, (-99 << 8) / DEFAULT_FADE, SCRIPTEXT_INSTRUCTION_MAKE_SHAPE_OPACITY, 1, SCRIPT_LOCAL_VARIABLE_13, SCRIPT_INSTRUCTION_WAIT, 1, 1, SCRIPT_INSTRUCTION_ADD_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_2, -1, SCRIPT_INSTRUCTION_CMP, 4, SCRIPT_LOCAL_VARIABLE_2, 0, SCRIPT_CMPTYPE_NOT, 2, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 0, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 1, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.Start = [SCRIPTEXT_INSTRUCTION_HIDE_LEVEL, 2, SCRIPT_LOCAL_VARIABLE_6, true, SCRIPTEXT_INSTRUCTION_MOVE_BOARD_TO, 5, 322, 328, 100, 100, START_FADE, SCRIPT_INSTRUCTION_SET_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_1, START_FADE, SCRIPT_INSTRUCTION_SET_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_2, 255 << 8, SCRIPT_INSTRUCTION_SET_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_3, -255 << 8, SCRIPT_INSTRUCTION_MARKER, 1, 0, SCRIPT_INSTRUCTION_ADD_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_2, -(255 << 8) / START_FADE, SCRIPTEXT_INSTRUCTION_BOARD_OPACITY, 1, SCRIPT_LOCAL_VARIABLE_2, SCRIPTEXT_INSTRUCTION_NAME_OPACITY, 1, SCRIPT_LOCAL_VARIABLE_2, SCRIPTEXT_INSTRUCTION_INFO_OPACITY, 1, SCRIPT_LOCAL_VARIABLE_2, SCRIPT_INSTRUCTION_ADD_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_3, 2 * (255 << 8) / START_FADE, SCRIPTEXT_INSTRUCTION_HUD_OPACITY, 1, SCRIPT_LOCAL_VARIABLE_3, SCRIPTEXT_INSTRUCTION_GAME_OPACITY, 1, SCRIPT_LOCAL_VARIABLE_3, SCRIPT_INSTRUCTION_WAIT, 1, 1, SCRIPT_INSTRUCTION_ADD_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_1, -1, SCRIPT_INSTRUCTION_CMP, 4, SCRIPT_LOCAL_VARIABLE_1, 0, SCRIPT_CMPTYPE_NOT, 0, SCRIPTEXT_INSTRUCTION_BOARD_OPACITY, 1, 0 << 8, SCRIPTEXT_INSTRUCTION_NAME_OPACITY, 1, 0 << 8, SCRIPTEXT_INSTRUCTION_INFO_OPACITY, 1, 0 << 8, SCRIPTEXT_INSTRUCTION_HUD_OPACITY, 1, 255 << 8, SCRIPTEXT_INSTRUCTION_GAME_OPACITY, 1, 255 << 8, SCRIPT_INSTRUCTION_PLAY_AUDIO, 1, "Start", SCRIPT_INSTRUCTION_WAIT, 1, 20, SCRIPT_INSTRUCTION_SET_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_1, DEFAULT_FADE, SCRIPT_INSTRUCTION_SET_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_2, 0 << 8, SCRIPT_INSTRUCTION_MARKER, 1, 1, SCRIPT_INSTRUCTION_ADD_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_2, (100 << 8) / DEFAULT_FADE, SCRIPTEXT_INSTRUCTION_OBJECTIVE_PERCENT, 1, SCRIPT_LOCAL_VARIABLE_2, SCRIPT_INSTRUCTION_WAIT, 1, 1, SCRIPT_INSTRUCTION_ADD_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_1, -1, SCRIPT_INSTRUCTION_CMP, 4, SCRIPT_LOCAL_VARIABLE_1, 0, SCRIPT_CMPTYPE_NOT, 1, SCRIPTEXT_INSTRUCTION_OBJECTIVE_PERCENT, 1, 100 << 8, SCRIPT_INSTRUCTION_WAIT, 1, 60, SCRIPT_INSTRUCTION_SET_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_1, DEFAULT_FADE, SCRIPT_INSTRUCTION_SET_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_2, 100 << 8, SCRIPT_INSTRUCTION_MARKER, 1, 2, SCRIPT_INSTRUCTION_ADD_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_2, -(100 << 8) / DEFAULT_FADE, SCRIPTEXT_INSTRUCTION_OBJECTIVE_PERCENT, 1, SCRIPT_LOCAL_VARIABLE_2, SCRIPT_INSTRUCTION_WAIT, 1, 1, SCRIPT_INSTRUCTION_ADD_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_1, -1, SCRIPT_INSTRUCTION_CMP, 4, SCRIPT_LOCAL_VARIABLE_1, 0, SCRIPT_CMPTYPE_NOT, 2, SCRIPTEXT_INSTRUCTION_OBJECTIVE_PERCENT, 1, 0 << 8, SCRIPTEXT_INSTRUCTION_HIDE_LEVEL, 2, SCRIPT_LOCAL_VARIABLE_6, false, SCRIPT_INSTRUCTION_WAIT_AUDIO, 1, "Start", SCRIPT_INSTRUCTION_END, 0];
    ScriptData.StartImmediate = [SCRIPTEXT_INSTRUCTION_BOARD_OPACITY, 1, 0 << 8, SCRIPTEXT_INSTRUCTION_NAME_OPACITY, 1, 0 << 8, SCRIPTEXT_INSTRUCTION_INFO_OPACITY, 1, 0 << 8, SCRIPTEXT_INSTRUCTION_HUD_OPACITY, 1, 255 << 8, SCRIPTEXT_INSTRUCTION_GAME_OPACITY, 1, 255 << 8, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.Go = [SCRIPT_INSTRUCTION_PLAY_AUDIO, 1, "Go", SCRIPT_INSTRUCTION_OBJECT_CREATE_SPRITE, 5, 1, "GlowRound", MiddleX << 8, 188 * SCREEN_SCALER + 32 + OffsetY << 8, EA.Default, SCRIPT_INSTRUCTION_OBJECT_CREATE_TEXT, 6, 0, "DATATEXT_ID_GAME_START", "PanelFont", MiddleX << 8, 188 * SCREEN_SCALER + 32 + OffsetY << 8, EA.Default, SCRIPT_INSTRUCTION_OBJECT_SCALE_SET, 3, 1, 155, 100, SCRIPT_INSTRUCTION_OBJECT_SET_COLOUR, 4, 1, SCRIPT_GLOBAL_VARIABLE_1, SCRIPT_GLOBAL_VARIABLE_2, SCRIPT_GLOBAL_VARIABLE_3, SCRIPT_INSTRUCTION_OBJECT_SCALE_SET, 3, 0, 150, 150, SCRIPT_INSTRUCTION_OBJECT_ALPHA_SET, 2, 0, 0, SCRIPT_INSTRUCTION_OBJECT_ALPHA_SET, 2, 0, 1, SCRIPT_INSTRUCTION_OBJECT_ALPHA_TO, 3, 0, 255, DEFAULT_FADE, SCRIPT_INSTRUCTION_OBJECT_ALPHA_TO, 3, 1, 255, DEFAULT_FADE, SCRIPT_INSTRUCTION_WAIT, 1, 60, SCRIPT_INSTRUCTION_OBJECT_ALPHA_TO, 3, 0, 0, DEFAULT_FADE, SCRIPT_INSTRUCTION_OBJECT_ALPHA_TO, 3, 1, 0, DEFAULT_FADE, SCRIPT_INSTRUCTION_WAIT, 1, 10, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 0, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 1, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.End = [SCRIPTEXT_INSTRUCTION_HIDE_LEVEL, 2, SCRIPT_LOCAL_VARIABLE_6, true, SCRIPTEXT_INSTRUCTION_MOVE_BOARD_TO, 5, SCRIPT_LOCAL_VARIABLE_1, SCRIPT_LOCAL_VARIABLE_2, SCRIPT_LOCAL_VARIABLE_3, SCRIPT_LOCAL_VARIABLE_4, START_FADE, SCRIPT_INSTRUCTION_SET_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_1, START_FADE, SCRIPT_INSTRUCTION_SET_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_2, 0 << 8, SCRIPT_INSTRUCTION_SET_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_3, 255 << 8, SCRIPT_INSTRUCTION_MARKER, 1, 0, SCRIPT_INSTRUCTION_ADD_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_2, (255 << 8) / START_FADE, SCRIPTEXT_INSTRUCTION_BOARD_OPACITY, 1, SCRIPT_LOCAL_VARIABLE_2, SCRIPTEXT_INSTRUCTION_NAME_OPACITY, 1, SCRIPT_LOCAL_VARIABLE_2, SCRIPTEXT_INSTRUCTION_INFO_OPACITY, 1, SCRIPT_LOCAL_VARIABLE_2, SCRIPT_INSTRUCTION_ADD_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_3, -((255 << 8) * 2) / START_FADE, SCRIPTEXT_INSTRUCTION_HUD_OPACITY, 1, SCRIPT_LOCAL_VARIABLE_3, SCRIPTEXT_INSTRUCTION_GAME_OPACITY, 1, SCRIPT_LOCAL_VARIABLE_3, SCRIPT_INSTRUCTION_CMP, 4, SCRIPT_LOCAL_VARIABLE_5, 0, SCRIPT_CMPTYPE_EQUAL, 1, SCRIPTEXT_INSTRUCTION_REVIEW_OPACITY, 1, SCRIPT_LOCAL_VARIABLE_3, SCRIPT_INSTRUCTION_MARKER, 1, 1, SCRIPT_INSTRUCTION_WAIT, 1, 1, SCRIPT_INSTRUCTION_ADD_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_1, -1, SCRIPT_INSTRUCTION_CMP, 4, SCRIPT_LOCAL_VARIABLE_1, 0, SCRIPT_CMPTYPE_NOT, 0, SCRIPTEXT_INSTRUCTION_HIDE_LEVEL, 2, SCRIPT_LOCAL_VARIABLE_6, false, SCRIPT_INSTRUCTION_PLAY_AUDIO, 1, "Impact", SCRIPTEXT_INSTRUCTION_BOARD_OPACITY, 1, 255 << 8, SCRIPTEXT_INSTRUCTION_NAME_OPACITY, 1, 255 << 8, SCRIPTEXT_INSTRUCTION_INFO_OPACITY, 1, 255 << 8, SCRIPTEXT_INSTRUCTION_HUD_OPACITY, 1, 0 << 8, SCRIPTEXT_INSTRUCTION_GAME_OPACITY, 1, 0 << 8, SCRIPT_INSTRUCTION_CMP, 4, SCRIPT_LOCAL_VARIABLE_5, 0, SCRIPT_CMPTYPE_EQUAL, 2, SCRIPTEXT_INSTRUCTION_REVIEW_OPACITY, 1, 0, SCRIPT_INSTRUCTION_MARKER, 1, 2, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.SecretUnlocked = [SCRIPTEXT_INSTRUCTION_FLASH_SCREEN, 0, SCRIPT_INSTRUCTION_SET_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_1, START_FADE, SCRIPT_INSTRUCTION_SET_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_2, 255 << 8, SCRIPT_INSTRUCTION_MARKER, 1, 0, SCRIPT_INSTRUCTION_ADD_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_2, -(255 << 8) / START_FADE, SCRIPTEXT_INSTRUCTION_INFO_OPACITY, 1, SCRIPT_LOCAL_VARIABLE_2, SCRIPT_INSTRUCTION_WAIT, 1, 1, SCRIPT_INSTRUCTION_ADD_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_1, -1, SCRIPT_INSTRUCTION_CMP, 4, SCRIPT_LOCAL_VARIABLE_1, 0, SCRIPT_CMPTYPE_NOT, 0, SCRIPTEXT_INSTRUCTION_INFO_OPACITY, 1, 0 << 8, SCRIPT_INSTRUCTION_PLAY_AUDIO, 1, "ThemeComplete", SCRIPT_INSTRUCTION_OBJECT_CREATE_TEXT, 6, 0, "DATATEXT_ID_THEME_COMPLETE", "PanelFont", SCREEN_WIDTH / 2 << 8, 168 * SCREEN_SCALER + 32 << 8, EA.Default, SCRIPTEXT_INSTRUCTION_SECRET_PAGE, 0, SCRIPT_INSTRUCTION_SET_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_1, 180, SCRIPT_INSTRUCTION_MARKER, 1, 2, SCRIPTEXT_INSTRUCTION_CREATE_EFFECT, 5, 1, SCREEN_WIDTH / 2 << 8, 98 * SCREEN_SCALER << 8, 200 * SCREEN_SCALER + 32 << 8, 75 * SCREEN_SCALER << 8, SCRIPT_INSTRUCTION_WAIT, 1, 1, SCRIPT_INSTRUCTION_ADD_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_1, -1, SCRIPT_INSTRUCTION_CMP, 4, SCRIPT_LOCAL_VARIABLE_1, 0, SCRIPT_CMPTYPE_NOT, 2, SCRIPTEXT_INSTRUCTION_RETURN_PAGE, 0, SCRIPT_INSTRUCTION_SET_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_1, START_FADE, SCRIPT_INSTRUCTION_SET_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_2, 0 << 8, SCRIPT_INSTRUCTION_MARKER, 1, 1, SCRIPT_INSTRUCTION_ADD_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_2, (255 << 8) / START_FADE, SCRIPTEXT_INSTRUCTION_INFO_OPACITY, 1, SCRIPT_LOCAL_VARIABLE_2, SCRIPT_INSTRUCTION_WAIT, 1, 1, SCRIPT_INSTRUCTION_ADD_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_1, -1, SCRIPT_INSTRUCTION_CMP, 4, SCRIPT_LOCAL_VARIABLE_1, 0, SCRIPT_CMPTYPE_NOT, 1, SCRIPTEXT_INSTRUCTION_INFO_OPACITY, 1, 255 << 8, SCRIPT_INSTRUCTION_WAIT, 1, 10, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 0, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.SecretComplete = [SCRIPTEXT_INSTRUCTION_FLASH_SCREEN, 0, SCRIPT_INSTRUCTION_PLAY_AUDIO, 1, "ThemeComplete", SCRIPT_INSTRUCTION_OBJECT_CREATE_TEXT, 6, 0, "DATATEXT_ID_SECRET_COMPLETE", "PanelFont", SCREEN_WIDTH / 2 << 8, 168 * SCREEN_SCALER + 32 << 8, EA.Default, SCRIPT_INSTRUCTION_WAIT, 1, 180, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 0, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.HalfWayUpSell = [SCRIPTEXT_INSTRUCTION_FLASH_SCREEN, 0, SCRIPT_INSTRUCTION_PLAY_AUDIO, 1, "ThemeComplete", SCRIPT_INSTRUCTION_OBJECT_CREATE_TEXT, 6, 0, "DATATEXT_ID_HALF_WAY", "PanelFont", SCREEN_WIDTH / 2 << 8, 168 * SCREEN_SCALER + 32 << 8, EA.Default, SCRIPT_INSTRUCTION_WAIT, 1, 180, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 0, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.SetComplete = [SCRIPTEXT_INSTRUCTION_FLASH_SCREEN, 0, SCRIPT_INSTRUCTION_PLAY_AUDIO, 1, "ThemeComplete", SCRIPT_INSTRUCTION_OBJECT_CREATE_TEXT, 6, 0, "DATATEXT_ID_SET_COMPLETE", "PanelFont", SCREEN_WIDTH / 2 << 8, 168 * SCREEN_SCALER + 32 << 8, EA.Default, SCRIPT_INSTRUCTION_WAIT, 1, 180, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 0, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.SetCompleteUpSell = [SCRIPTEXT_INSTRUCTION_FLASH_SCREEN, 0, SCRIPT_INSTRUCTION_PLAY_AUDIO, 1, "ThemeComplete", SCRIPT_INSTRUCTION_OBJECT_CREATE_TEXT, 6, 0, "DATATEXT_ID_SET_COMPLETE", "PanelFont", SCREEN_WIDTH / 2 << 8, 168 * SCREEN_SCALER + 32 << 8, EA.Default, SCRIPT_INSTRUCTION_WAIT, 1, 180, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 0, SCRIPTEXT_INSTRUCTION_NEW_PAGE, 0, SCRIPT_INSTRUCTION_WAIT, 1, 180, SCRIPTEXT_INSTRUCTION_RETURN_PAGE, 0, SCRIPT_INSTRUCTION_WAIT, 1, 30, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.SetBonusComplete = [SCRIPTEXT_INSTRUCTION_FLASH_SCREEN, 0, SCRIPT_INSTRUCTION_PLAY_AUDIO, 1, "ThemeComplete", SCRIPT_INSTRUCTION_OBJECT_CREATE_TEXT, 6, 0, "DATATEXT_ID_SET_BONUS_COMPLETE", "PanelFont", SCREEN_WIDTH / 2 << 8, 168 * SCREEN_SCALER + 32 << 8, EA.Default, SCRIPT_INSTRUCTION_WAIT, 1, 180, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 0, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.SetBonusCompleteUpSell = [SCRIPTEXT_INSTRUCTION_FLASH_SCREEN, 0, SCRIPT_INSTRUCTION_PLAY_AUDIO, 1, "ThemeComplete", SCRIPT_INSTRUCTION_OBJECT_CREATE_TEXT, 6, 0, "DATATEXT_ID_SET_BONUS_COMPLETE", "PanelFont", SCREEN_WIDTH / 2 << 8, 168 * SCREEN_SCALER + 32 << 8, EA.Default, SCRIPT_INSTRUCTION_WAIT, 1, 180, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 0, SCRIPTEXT_INSTRUCTION_NEW_PAGE, 0, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.AllNormalComplete = [SCRIPTEXT_INSTRUCTION_FIRST_PAGE, 0, SCRIPTEXT_INSTRUCTION_WAIT_PAGE_ENDED, 0, SCRIPT_INSTRUCTION_PLAY_AUDIO, 1, "ThemeComplete", SCRIPT_INSTRUCTION_OBJECT_CREATE_TEXT, 6, 0, "DATATEXT_ID_ALL_NORMAL_COMPLETE", "PanelFont", SCREEN_WIDTH / 2 << 8, 168 * SCREEN_SCALER + 32 << 8, EA.Default, SCRIPTEXT_INSTRUCTION_START_PAN, 0, SCRIPTEXT_INSTRUCTION_WAIT_PAGE_ENDED, 0, SCRIPTEXT_INSTRUCTION_RETURN_PAGE, 0, SCRIPTEXT_INSTRUCTION_WAIT_PAGE_ENDED, 0, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 0, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.FirstPageComplete = [SCRIPTEXT_INSTRUCTION_FIRST_PAGE, 0, SCRIPTEXT_INSTRUCTION_WAIT_PAGE_ENDED, 0, SCRIPT_INSTRUCTION_PLAY_AUDIO, 1, "ThemeComplete", SCRIPT_INSTRUCTION_OBJECT_CREATE_TEXT, 6, 0, "DATATEXT_ID_ALL_FIRST_SET_COMPLETE", "PanelFont", SCREEN_WIDTH / 2 << 8, 168 * SCREEN_SCALER + 32 << 8, EA.Default, SCRIPTEXT_INSTRUCTION_START_PAN, 0, SCRIPTEXT_INSTRUCTION_WAIT_PAGE_ENDED, 0, SCRIPTEXT_INSTRUCTION_RETURN_PAGE, 0, SCRIPTEXT_INSTRUCTION_WAIT_PAGE_ENDED, 0, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 0, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.AllNormalBonusComplete = [SCRIPTEXT_INSTRUCTION_FIRST_PAGE, 0, SCRIPTEXT_INSTRUCTION_WAIT_PAGE_ENDED, 0, SCRIPT_INSTRUCTION_PLAY_AUDIO, 1, "ThemeComplete", SCRIPT_INSTRUCTION_OBJECT_CREATE_TEXT, 6, 0, "DATATEXT_ID_ALL_NORMAL_BONUS_COMPLETE", "PanelFont", SCREEN_WIDTH / 2 << 8, 168 * SCREEN_SCALER + 32 << 8, EA.Default, SCRIPTEXT_INSTRUCTION_START_PAN, 0, SCRIPTEXT_INSTRUCTION_WAIT_PAGE_ENDED, 0, SCRIPTEXT_INSTRUCTION_RETURN_PAGE, 0, SCRIPTEXT_INSTRUCTION_WAIT_PAGE_ENDED, 0, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 0, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.AllSecretComplete = [SCRIPTEXT_INSTRUCTION_FIRST_PAGE, 0, SCRIPTEXT_INSTRUCTION_WAIT_PAGE_ENDED, 0, SCRIPT_INSTRUCTION_PLAY_AUDIO, 1, "ThemeComplete", SCRIPT_INSTRUCTION_OBJECT_CREATE_TEXT, 6, 0, "DATATEXT_ID_ALL_SECRET_COMPLETE", "PanelFont", SCREEN_WIDTH / 2 << 8, 168 * SCREEN_SCALER + 32 << 8, EA.Default, SCRIPTEXT_INSTRUCTION_START_PAN, 0, SCRIPTEXT_INSTRUCTION_WAIT_PAGE_ENDED, 0, SCRIPTEXT_INSTRUCTION_RETURN_PAGE, 0, SCRIPTEXT_INSTRUCTION_WAIT_PAGE_ENDED, 0, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 0, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.AllChallenge = [SCRIPTEXT_INSTRUCTION_NO_SECRET_PAGE, 0, SCRIPTEXT_INSTRUCTION_WAIT_PAGE_ENDED, 0, SCRIPTEXT_INSTRUCTION_END_PAGE, 0, SCRIPTEXT_INSTRUCTION_WAIT_PAGE_ENDED, 0, SCRIPTEXT_INSTRUCTION_INTERRUPT_MUSIC, 1, "EverythingComplete", SCRIPTEXT_INSTRUCTION_WAIT_INTERRUPT_MUSIC, 0, SCRIPT_INSTRUCTION_WAIT, 1, 10, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.BoughtAll = [SCRIPTEXT_INSTRUCTION_FIRST_PAGE, 0, SCRIPTEXT_INSTRUCTION_WAIT_PAGE_ENDED, 0, SCRIPTEXT_INSTRUCTION_START_PAN, 0, SCRIPTEXT_INSTRUCTION_WAIT_PAGE_ENDED, 0, SCRIPTEXT_INSTRUCTION_RETURN_PAGE, 0, SCRIPTEXT_INSTRUCTION_WAIT_PAGE_ENDED, 0, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 0, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.OpenLevel = [SCRIPT_INSTRUCTION_WAIT, 1, 30, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.LevelComplete = [SCRIPT_INSTRUCTION_WAIT, 1, 10, SCRIPTEXT_INSTRUCTION_COMPLETE_LEVEL, 0, SCRIPTEXT_INSTRUCTION_WAIT_COMPLETE_LEVEL, 0, SCRIPT_INSTRUCTION_WAIT, 1, 30, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.ChallengeLevelComplete = [SCRIPT_INSTRUCTION_WAIT, 1, 10, SCRIPTEXT_INSTRUCTION_COMPLETE_LEVEL, 0, SCRIPTEXT_INSTRUCTION_WAIT_COMPLETE_LEVEL, 0, SCRIPT_INSTRUCTION_WAIT, 1, 30, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.PageUnlocked = [SCRIPT_INSTRUCTION_SET_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_1, START_FADE, SCRIPT_INSTRUCTION_SET_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_2, 255 << 8, SCRIPT_INSTRUCTION_MARKER, 1, 0, SCRIPT_INSTRUCTION_ADD_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_2, -(255 << 8) / START_FADE, SCRIPTEXT_INSTRUCTION_INFO_OPACITY, 1, SCRIPT_LOCAL_VARIABLE_2, SCRIPT_INSTRUCTION_WAIT, 1, 1, SCRIPT_INSTRUCTION_ADD_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_1, -1, SCRIPT_INSTRUCTION_CMP, 4, SCRIPT_LOCAL_VARIABLE_1, 0, SCRIPT_CMPTYPE_NOT, 0, SCRIPTEXT_INSTRUCTION_INFO_OPACITY, 1, 0 << 8, SCRIPTEXT_INSTRUCTION_NEW_PAGE, 0, SCRIPTEXT_INSTRUCTION_CREATE_LIGHT_RAYS, 3, SCREEN_WIDTH / 2 << 8, 188 * SCREEN_SCALER + 32 << 8, 200, SCRIPT_INSTRUCTION_OBJECT_CREATE_TEXT, 6, 0, "DATATEXT_ID_PAGE_UNLOCKED", "PanelFont", SCREEN_WIDTH / 2 << 8, 188 * SCREEN_SCALER + 32 << 8, EA.Default, SCRIPT_INSTRUCTION_OBJECT_ALPHA_SET, 2, 0, 0, SCRIPT_INSTRUCTION_OBJECT_ALPHA_TO, 3, 0, 255, DEFAULT_FADE, SCRIPT_INSTRUCTION_PLAY_AUDIO, 1, "NewPuzzlesUnlocked", SCRIPT_INSTRUCTION_WAIT, 1, 180, SCRIPTEXT_INSTRUCTION_RETURN_PAGE, 0, SCRIPTEXT_INSTRUCTION_DISABLE_LIGHT_RAYS, 0, SCRIPT_INSTRUCTION_OBJECT_ALPHA_TO, 3, 0, 0, DEFAULT_FADE, SCRIPT_INSTRUCTION_SET_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_1, START_FADE, SCRIPT_INSTRUCTION_SET_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_2, 0 << 8, SCRIPT_INSTRUCTION_MARKER, 1, 1, SCRIPT_INSTRUCTION_ADD_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_2, (255 << 8) / START_FADE, SCRIPTEXT_INSTRUCTION_INFO_OPACITY, 1, SCRIPT_LOCAL_VARIABLE_2, SCRIPT_INSTRUCTION_WAIT, 1, 1, SCRIPT_INSTRUCTION_ADD_VARIABLE, 2, SCRIPT_LOCAL_VARIABLE_1, -1, SCRIPT_INSTRUCTION_CMP, 4, SCRIPT_LOCAL_VARIABLE_1, 0, SCRIPT_CMPTYPE_NOT, 1, SCRIPTEXT_INSTRUCTION_INFO_OPACITY, 1, 255 << 8, SCRIPT_INSTRUCTION_WAIT, 1, 10, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 0, SCRIPTEXT_INSTRUCTION_DESTROY_LIGHT_RAYS, 0, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.ScaleBounce = [SCRIPT_INSTRUCTION_OBJECT_CREATE_SPRITE, 5, SCRIPT_LOCAL_VARIABLE_5, SCRIPT_LOCAL_VARIABLE_1, 0, 0, EA.Default, SCRIPT_INSTRUCTION_OBJECT_SCALE_SET, 3, SCRIPT_LOCAL_VARIABLE_5, SCRIPT_LOCAL_VARIABLE_2, SCRIPT_LOCAL_VARIABLE_2, SCRIPT_INSTRUCTION_OBJECT_SCALE_TO_EASE, 6, SCRIPT_LOCAL_VARIABLE_5, SCRIPT_LOCAL_VARIABLE_3, SCRIPT_LOCAL_VARIABLE_3, true, false, 4, SCRIPT_INSTRUCTION_WAIT, 1, 4, SCRIPT_INSTRUCTION_OBJECT_SCALE_TO_EASE, 6, SCRIPT_LOCAL_VARIABLE_5, SCRIPT_LOCAL_VARIABLE_4, SCRIPT_LOCAL_VARIABLE_4, true, true, 4, SCRIPT_INSTRUCTION_WAIT, 1, 4, SCRIPT_INSTRUCTION_OBJECT_SCALE_TO_EASE, 6, SCRIPT_LOCAL_VARIABLE_5, SCRIPT_LOCAL_VARIABLE_2, SCRIPT_LOCAL_VARIABLE_2, false, true, 4, SCRIPT_INSTRUCTION_WAIT, 1, 4, SCRIPT_INSTRUCTION_OBJECT_SCALE_SET, 3, SCRIPT_LOCAL_VARIABLE_5, SCRIPT_LOCAL_VARIABLE_2, SCRIPT_LOCAL_VARIABLE_2, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, SCRIPT_LOCAL_VARIABLE_5, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.ScaleToBounce = [SCRIPT_INSTRUCTION_OBJECT_CREATE_SPRITE, 5, SCRIPT_LOCAL_VARIABLE_5, SCRIPT_LOCAL_VARIABLE_1, 0, 0, EA.Default, SCRIPT_INSTRUCTION_OBJECT_SCALE_SET, 3, SCRIPT_LOCAL_VARIABLE_5, SCRIPT_LOCAL_VARIABLE_2, SCRIPT_LOCAL_VARIABLE_2, SCRIPT_INSTRUCTION_OBJECT_SCALE_TO_EASE, 6, SCRIPT_LOCAL_VARIABLE_5, SCRIPT_LOCAL_VARIABLE_3, SCRIPT_LOCAL_VARIABLE_3, true, false, 6, SCRIPT_INSTRUCTION_WAIT, 1, 6, SCRIPT_INSTRUCTION_OBJECT_SCALE_TO_EASE, 6, SCRIPT_LOCAL_VARIABLE_5, SCRIPT_LOCAL_VARIABLE_4, SCRIPT_LOCAL_VARIABLE_4, true, true, 6, SCRIPT_INSTRUCTION_WAIT, 1, 6, SCRIPT_INSTRUCTION_OBJECT_SCALE_SET, 3, SCRIPT_LOCAL_VARIABLE_5, SCRIPT_LOCAL_VARIABLE_4, SCRIPT_LOCAL_VARIABLE_4, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, SCRIPT_LOCAL_VARIABLE_5, SCRIPT_INSTRUCTION_END, 0];
    var VERSION = "v 1";
    var COVER_ERASE_X = SCREEN_WIDTH / 2;
    var COVER_ERASE_Y = SCREEN_HEIGHT - 34 * SCREEN_SCALER;
    var COVER_AUDIO_X = SCREEN_WIDTH - 30 * SCREEN_SCALER;
    var COVER_AUDIO_Y = 30 * SCREEN_SCALER;
    var COVER_HELP_X = 30 * SCREEN_SCALER;
    var COVER_HELP_Y = SCREEN_HEIGHT - 34 * SCREEN_SCALER;
    var COVER_VERSION_X = 60;
    var COVER_VERSION_Y = SCREEN_HEIGHT - 15;
    var COVER_OVER_SCALE = 1.6;
    var COVER_BIG_SCALE = 1.5;
    var COVER_NORMAL_SCALE = 1;
    var COVER_UNDER_SCALE = .8;
    var ERASE_FLASH_DELAY = 20;
    var HELP_SCALE_DELAY = 8;
    var HELP_PULSE_DELAY = 30;
    var FADE_DELAY = 30;
    var COVER_YES_X = 143 * SCREEN_SCALER;
    var COVER_YES_Y = SCREEN_HEIGHT - 34 * SCREEN_SCALER;
    var COVER_NO_X = SCREEN_WIDTH - 145 * SCREEN_SCALER;
    var COVER_NO_Y = SCREEN_HEIGHT - 34 * SCREEN_SCALER;

    function Cover() {}
    Cover.psRoot = 0;
    Cover.psHudRoot = 0;
    Cover.psSceneRoot = 0;
    Cover.psEraseButton = {};
    Cover.psErase = 0;
    Cover.sEraseButton = {};
    Cover.psYesButton = 0;
    Cover.sYesButton = {};
    Cover.psNoButton = 0;
    Cover.sNoButton = {};
    Cover.psPrompt = 0;
    Cover.psVersion = 0;
    Cover.psLogo = 0;
    Cover.psLogoTrial = 0;
    Cover.sStartButton = {
        x: 0,
        y: 0,
        x2: SCREEN_WIDTH,
        y2: SCREEN_HEIGHT
    };
    Cover.psHelp = 0;
    Cover.sHelpArea = {};
    Cover.psButtonPlayGame = [];
    Cover.sButtonPlayGame = {};
    Cover.psTest = 0;
    Cover.dwFadeDelay = 0;
    Cover.dwTiltControls = 1;
    Cover.dwScript = 0;
    Cover.dwState = 0;
    Cover.dwPromptTimer = 0;
    Cover.bEraseSelected = 0;
    Cover.dwHelpPulseTimer = 0;
    Cover.dwHelpScaleTimer = 0;
    Cover.fOffsetX = 0;
    Cover.fOffsetY = 0;
    Cover.psSky = 0;
    Cover.psSky01 = 0;
    Cover.psIsland = 0;
    Cover.psFairies = [];
    Cover.dwFairyTimer = [];
    Cover.psEyes = 0;
    Cover.dwSparkleTimer = 0;
    Cover.dwSmokeDelay = 0;
    var CLOUD_NORMAL_SPEED = .3;
    Cover.asClouds = [{
        dwImage: "CloudForeground1",
        x: 221,
        y: 35,
        fScale: .55,
        fSpeed: CLOUD_NORMAL_SPEED
    }, {
        dwImage: "CloudForeground2",
        x: 188,
        y: 59,
        fScale: .45,
        fSpeed: CLOUD_NORMAL_SPEED
    }, {
        dwImage: "CloudForeground2",
        x: -100,
        y: 60,
        fScale: .45,
        fSpeed: CLOUD_NORMAL_SPEED
    }, {
        dwImage: "CloudForeground1",
        x: -70,
        y: 65,
        fScale: .35,
        fSpeed: CLOUD_NORMAL_SPEED
    }, {
        dwImage: "CloudForeground1",
        x: 73,
        y: 122,
        fScale: .35,
        fSpeed: CLOUD_NORMAL_SPEED
    }, {
        dwImage: "CloudBackground2",
        x: 50,
        y: 203,
        fScale: .6,
        fSpeed: CLOUD_NORMAL_SPEED
    }, {
        dwImage: "CloudBackground1",
        x: 235,
        y: 205,
        fScale: .65,
        fSpeed: CLOUD_NORMAL_SPEED
    }, {
        dwImage: "CloudBackground2",
        x: 274,
        y: 210,
        fScale: .65,
        fSpeed: CLOUD_NORMAL_SPEED
    }];
    Cover.papClouds = [];
    Cover.dwNumClouds = 0;
    Cover.ResetScene = function() {
        EntityManager.DeleteAll();
        for (var i = 0; i < 3; i += 1) {
            Cover.psFairies[i].m_psSprite.SetIsVisible(false)
        }
        Cover.psEyes.SetIsVisible(false)
    };
    Cover.CreateScene = function() {
        Cover.psSceneRoot = Helpers.CreateTree(0, 0, Cover.psRoot);
        Cover.psSky = Helpers.CreateSprite(0, 0, EA.TopLeft, "SkyBackground", Cover.psSceneRoot);
        Cover.psSky.SetScale(SCREEN_WIDTH, 31);
        Cover.psSky01 = Helpers.CreateSprite(SCREEN_WIDTH, 0, EA.TopLeft, "SkyBackground", Cover.psSceneRoot);
        Cover.psSky01.SetScale(72 * 2 + 20, 31);
        Cover.dwNumClouds = Cover.asClouds.length;
        Cover.papClouds = [];
        for (var i = 0; i < Cover.dwNumClouds; i += 1) {
            Cover.papClouds[i] = Helpers.CreateSprite(Cover.asClouds[i].x * 2, Cover.asClouds[i].y * 2, EA.BottomMiddle, Cover.asClouds[i].dwImage, Cover.psSceneRoot);
            Cover.papClouds[i].SetScale(Cover.asClouds[i].fScale, Cover.asClouds[i].fScale)
        }
        Cover.psIsland = Helpers.CreateSprite(0, SCREEN_HEIGHT, EA.BottomLeft, "Island", Cover.psSceneRoot);
        Cover.psFairies[0] = EntityEffect.Create(120 * 2 + 64 + 100, 300 * 2 + 32 - 230, ENTITYEFFECT_TYPE_FAIRY, Cover.psSceneRoot);
        Cover.psFairies[0].m_psSprite.SetFrameByName("Fairy01");
        Cover.psFairies[1] = EntityEffect.Create(75 * 2 + 64 + 100, 321 * 2 + 32 - 230, ENTITYEFFECT_TYPE_FAIRY, Cover.psSceneRoot);
        Cover.psFairies[1].m_psSprite.SetFrameByName("Fairy02");
        Cover.psFairies[2] = EntityEffect.Create(130 * 2 + 64 + 100, 340 * 2 + 32 - 230, ENTITYEFFECT_TYPE_FAIRY, Cover.psSceneRoot);
        Cover.psFairies[2].m_psSprite.SetFrameByName("Fairy03");
        Cover.psEyes = Helpers.CreateSprite(568, 429, EA.Default, "NewBlank", Cover.psSceneRoot);
        Cover.psEyesAnimation = JamSystem.RenderManager.CreateSpriteAnimation(Cover.psEyes, 0);
        Cover.psEyesAnimation.SetData(AnimationMisc_sEyes);
        Cover.dwSparkleTimer = 0;
        Cover.dwSmokeDelay = 0;
        Cover.dwHelpPulseTimer = 0;
        Cover.ResetScene()
    };
    Cover.DestroyScene = function() {
        var i;
        for (i = 0; i < Cover.dwNumClouds; i += 1) {
            Helpers.DestroySprite(Cover.papClouds[i])
        }
        Helpers.DestroySprite(Cover.psEyes);
        JamSystem.RenderManager.DestroySpriteAnimation(Cover.psEyesAnimation);
        for (i = 0; i < 3; i += 1) {
            Cover.psFairies[i].Destroy
        }
        Helpers.DestroySprite(Cover.psSky);
        Helpers.DestroySprite(Cover.psSky01);
        Helpers.DestroySprite(Cover.psIsland);
        Helpers.DestroySprite(Cover.psSceneRoot)
    };
    Cover.UpdateScene = function() {
        var i;
        for (i = 0; i < Cover.dwNumClouds; i += 1) {
            Cover.papClouds[i].x += Cover.asClouds[i].fSpeed;
            var xLeft = Cover.papClouds[i].x;
            if (xLeft > SCREEN_WIDTH * 1.3) {
                Cover.papClouds[i].x -= SCREEN_WIDTH * 1.6
            }
            Cover.papClouds[i].SetPosition(Cover.papClouds[i].x, Cover.papClouds[i].y)
        }
        var dwMaxPage = LevelSelect.CalcMaxPage();
        Cover.dwSparkleTimer += 1;
        var psEffect;
        if (Cover.dwSparkleTimer % 4 === 0) {
            var x, y;
            var dwBox = Math.floor(Math.random() * 5);
            if (dwBox === 0) {
                x = Math.random() * 100;
                y = SCREEN_HEIGHT - 180 - Math.random() * 90
            } else if (dwBox === 1) {
                x = SCREEN_WIDTH - Math.random() * 100;
                y = SCREEN_HEIGHT - 180 - Math.random() * 90
            } else {
                x = Math.random() * SCREEN_WIDTH;
                y = SCREEN_HEIGHT - Math.random() * 180
            }
            var fPercent = .35 + (y - (192 + 45) * 2) / (238 * 2) * .35;
            psEffect = EntityEffect.Create(x, y, ENTITYEFFECT_TYPE_STATIC_SPARKLE, Cover.psSceneRoot);
            psEffect.m_psSprite.SetScale(fPercent, fPercent);
            psEffect.SetScale(fPercent);
            EntityManager.Add(psEffect)
        }
        if (dwMaxPage >= 1) {
            for (i = 0; i < 3; i += 1) {
                Cover.psFairies[i].m_psSprite.SetIsVisible(true);
                Cover.psFairies[i].Update()
            }
        }
        if (dwMaxPage >= 3) {
            Cover.psEyes.SetIsVisible(true);
            Cover.psEyesAnimation.Update(1 / 60)
        }
        if (dwMaxPage >= 5) {
            Cover.dwSmokeDelay += 1;
            if (Cover.dwSmokeDelay % 120 === 1) {
                psEffect = EntityEffect.Create(536, 238, ENTITYEFFECT_TYPE_SMOKE, Cover.psSceneRoot);
                EntityManager.Add(psEffect)
            }
        }
    };
    Cover.Create = function() {
        Cover.dwState = 0;
        Cover.fOffsetX = 0;
        Cover.fOffsetY = 0;
        Cover.psRoot = Helpers.CreateTree(0, 0, GadgetTree.GetLayer(LAYERS_COVER));
        Cover.CreateScene();
        Cover.psHudRoot = Helpers.CreateTree(0, 0, Cover.psRoot);
        Debug.Log("CREATE");
        var achTemp = Application.Version;
        if (JamSystem.GetCanvasMode()) {
            achTemp += " c"
        }
        Cover.psVersion = Helpers.CreateBitmapText(achTemp, COVER_VERSION_X, COVER_VERSION_Y, EA.Default, "PanelFontSmall", Cover.psHudRoot);
        Cover.psVersion.SetScale(.5, .5);
        Cover.psEraseRoot = Helpers.CreateTree(COVER_ERASE_X, COVER_ERASE_Y, Cover.psHudRoot);
        Cover.psEraseButton = Helpers.CreateSprite(0, 0, EA.Default, "ButtonDelete", Cover.psEraseRoot);
        Cover.psErase = Helpers.CreateBitmapText(JamSystem.TextManager.GetText("DATATEXT_ID_HUD_ERASE_DATA"), 0, -3, EA.Default, "PanelFontSmall", Cover.psEraseRoot);
        var dwWidth = Cover.psEraseButton.GetWidth();
        var dwHeight = Cover.psEraseButton.GetHeight();
        Cover.sEraseButton.x = COVER_ERASE_X - dwWidth / 2;
        Cover.sEraseButton.y = COVER_ERASE_Y - dwHeight / 2;
        Cover.sEraseButton.x2 = COVER_ERASE_X + dwWidth / 2;
        Cover.sEraseButton.y2 = COVER_ERASE_Y + dwHeight / 2;
        Cover.psEraseRoot.SetIsVisible(Records.Exists());
        Cover.psLogo = Helpers.CreateSprite(SCREEN_WIDTH / 2, 100, EA.Default, "Logo", Cover.psHudRoot);
        Cover.psLogo.SetScale(.75, .75);
        Cover.psHelp = Helpers.CreateSprite(COVER_HELP_X, COVER_HELP_Y, EA.Default, "ButtonHelp", Cover.psHudRoot);
        dwWidth = Cover.psHelp.GetWidth();
        dwHeight = Cover.psHelp.GetHeight();
        Cover.sHelpArea.x = COVER_HELP_X - dwWidth / 2;
        Cover.sHelpArea.y = COVER_HELP_Y - dwHeight / 2;
        Cover.sHelpArea.x2 = COVER_HELP_X + dwWidth / 2;
        Cover.sHelpArea.y2 = COVER_HELP_Y + dwHeight / 2;
        Cover.psButtonPlayGame = Helpers.CreateSprite(BUTTON_X + 190, BUTTON_Y - 120, EA.Default, "ButtonCoverPlay", Cover.psHudRoot);
        dwWidth = Cover.psButtonPlayGame.GetWidth();
        dwHeight = Cover.psButtonPlayGame.GetHeight();
        Cover.sButtonPlayGame.x = Cover.psButtonPlayGame.GetPositionX() - dwWidth * .5;
        Cover.sButtonPlayGame.y = Cover.psButtonPlayGame.GetPositionY() - dwHeight * .5;
        Cover.sButtonPlayGame.x2 = Cover.psButtonPlayGame.GetPositionX() + dwWidth * .5;
        Cover.sButtonPlayGame.y2 = Cover.psButtonPlayGame.GetPositionY() + dwHeight * .5;
        Cover.psYesButton = Helpers.CreateSprite(COVER_YES_X, COVER_YES_Y, EA.Default, "ButtonYes", Cover.psHudRoot);
        Cover.psYesButton.SetIsVisible(false);
        dwWidth = Cover.psYesButton.GetWidth();
        dwHeight = Cover.psYesButton.GetHeight();
        Cover.sYesButton.x = COVER_YES_X - dwWidth / 2;
        Cover.sYesButton.y = COVER_YES_Y - dwHeight / 2;
        Cover.sYesButton.x2 = COVER_YES_X + dwWidth / 2;
        Cover.sYesButton.y2 = COVER_YES_Y + dwHeight / 2;
        Cover.psNoButton = Helpers.CreateSprite(COVER_NO_X, COVER_NO_Y, EA.Default, "ButtonNo", Cover.psHudRoot);
        Cover.psNoButton.SetIsVisible(false);
        dwWidth = Cover.psNoButton.GetWidth();
        dwHeight = Cover.psNoButton.GetHeight();
        Cover.sNoButton.x = COVER_NO_X - dwWidth / 2;
        Cover.sNoButton.y = COVER_NO_Y - dwHeight / 2;
        Cover.sNoButton.x2 = COVER_NO_X + dwWidth / 2;
        Cover.sNoButton.y2 = COVER_NO_Y + dwHeight / 2;
        Cover.bEraseSelected = false
    };
    Cover.Destroy = function() {
        Globals.FadeBackgroundMusic();
        Helpers.DestroySprite(Cover.psYesButton);
        Helpers.DestroySprite(Cover.psNoButton);
        Helpers.DestroySprite(Cover.psErase);
        Helpers.DestroySprite(Cover.psEraseButton);
        Helpers.DestroyTree(Cover.psEraseRoot);
        Helpers.DestroySprite(Cover.psHelp);
        Helpers.DestroySprite(Cover.psButtonPlayGame);
        Debug.Log("DESTROY");
        Helpers.DestroySprite(Cover.psVersion);
        Cover.DestroyScene();
        Helpers.DestroySprite(Cover.psHudRoot);
        Helpers.DestroySprite(Cover.psRoot)
    };
    Cover.Init = function() {
        if (Records.Exists()) {
            Touch.Add(Cover.sEraseButton)
        }
        Touch.Add(Cover.sHelpArea);
        Touch.Add(Cover.sButtonPlayGame);
        Touch.Add(Cover.sYesButton);
        Touch.Add(Cover.sNoButton)
    };
    Cover.ShutDown = function() {
        Touch.Remove(Cover.sEraseButton);
        Touch.Remove(Cover.sHelpArea);
        Touch.Remove(Cover.sButtonPlayGame);
        Touch.Remove(Cover.sYesButton);
        Touch.Remove(Cover.sNoButton)
    };
    Cover.ConfirmActive = function(bActive) {
        Cover.psYesButton.SetIsVisible(bActive);
        Cover.psNoButton.SetIsVisible(bActive)
    };
    Cover.Update = function() {
        Cover.UpdateScene();
        if (!Records.GetHelpSeen()) {
            Cover.dwHelpPulseTimer += 1;
            if (Cover.dwHelpScaleTimer) {
                Cover.dwHelpScaleTimer -= 1;
                if (Cover.dwHelpScaleTimer === 0) {
                    Cover.psHelp.SetScale(1, 1)
                } else {
                    var fScale = Cover.dwHelpScaleTimer / HELP_SCALE_DELAY * .2 + 1;
                    Cover.psHelp.SetScale(fScale, fScale)
                }
            } else {
                if (Cover.dwHelpPulseTimer % HELP_PULSE_DELAY === 0) {
                    Cover.dwHelpScaleTimer = HELP_SCALE_DELAY
                }
            }
        }
    };
    Cover.Touch = function(psArea) {
        if (Cover.bEraseSelected) {
            if (psArea) {
                Cover.bEraseSelected = false;
                if (psArea === Cover.sYesButton) {
                    Globals.BounceImage(Cover.psYesButton);
                    Cover.ResetScene();
                    EndScreen.SetActive(false);
                    Helpers.PlaySound("Reset");
                    Records.Erase();
                    LevelSelect.Reset();
                    LevelGrid.ShutDown();
                    LevelGrid.Init();
                    Cover.psEraseRoot.SetIsVisible(false);
                    Cover.psEraseRoot.SetScale(1, 1);
                    GlobalMain.MetricsManager.ClearData();
                    var psEffect = EntityEffect.Create(0, 0, ENTITYEFFECT_TYPE_SCREEN_FLASH_LONG, GadgetTree.GetLayer(LAYERS_HUD));
                    EntityManager.Add(psEffect)
                } else if (psArea === Cover.sNoButton) {
                    Globals.BounceImage(Cover.psNoButton)
                }
                Cover.ConfirmActive(false)
            }
        } else {
            if (psArea === Cover.sEraseButton && Cover.psEraseRoot.GetIsVisible()) {
                Cover.bEraseSelected = true;
                Globals.BounceImage(Cover.psEraseButton);
                Helpers.PlaySound("OptionIndicated");
                Cover.ConfirmActive(true)
            }
            if (psArea === Cover.sHelpArea) {
                LevelSelect.CheckMusic();
                var i;
                for (i = 0; i < EntityManager.apEntities.length; i += 1) {
                    EntityManager.apEntities[i].Update();
                    var psTempEntity = EntityManager.apEntities[i];
                    if (psTempEntity.m_dwType === ENTITYMANAGER_TYPE_EFFECT && psTempEntity.m_eType === ENTITYEFFECT_TYPE_SMOKE) {
                        psTempEntity.FadeOut()
                    }
                }
                Globals.BounceImage(Cover.psHelp);
                Helpers.PlaySound("OptionSelected");
                Records.SetHelpSeen();
                GlobalMain.MetricsManager.ViewHelp();
                GlobalMain.StateManager.RequestChangeState(StateManager.StateHelp)
            }
        }
    };
    Cover.SetOpacity = function(fOpacity) {
        Cover.psRoot.RemoveFromParent();
        var i;
        if (fOpacity !== 0) {
            Cover.psSky.SetOpacity(fOpacity / 255);
            Cover.psSky01.SetOpacity(fOpacity / 255);
            Cover.psIsland.SetOpacity(fOpacity / 255);
            for (i = 0; i < 3; i += 1) {
                Cover.psFairies[i].m_psSprite.SetOpacity(fOpacity / 255)
            }
            Cover.psEyes.SetOpacity(fOpacity / 255);
            Cover.psVersion.SetOpacity(fOpacity / 255);
            Cover.psLogo.SetOpacity(fOpacity / 255);
            Cover.psErase.SetOpacity(fOpacity / 255);
            Cover.psEraseButton.SetOpacity(fOpacity / 255);
            Cover.psHelp.SetOpacity(fOpacity / 255);
            Cover.psButtonPlayGame.SetOpacity(fOpacity / 255);
            for (i = 0; i < Cover.dwNumClouds; i += 1) {
                Cover.papClouds[i].SetOpacity(fOpacity / 255)
            }
            GadgetTree.GetLayer(LAYERS_COVER).AddChild(Cover.psRoot)
        }
    };
    Cover.UpdateOffset = function() {
        if (Cover.fOffsetX !== 0) {
            Records.SetFirstPlaySeen()
        }
        Cover.psRoot.x = Cover.fOffsetX;
        Cover.psRoot.y = Cover.fOffsetY;
        Cover.psRoot.SetPosition(Cover.psRoot.x, Cover.psRoot.y);
        Cover.sStartButton.x = 0 + Cover.fOffsetX;
        Cover.sStartButton.y = 0 + Cover.fOffsetY;
        Cover.sStartButton.x2 = SCREEN_WIDTH + Cover.fOffsetX;
        Cover.sStartButton.y2 = SCREEN_HEIGHT + Cover.fOffsetY;
        var dwWidth = Cover.psEraseButton.GetWidth();
        var dwHeight = Cover.psEraseButton.GetHeight();
        Cover.sEraseButton.x = COVER_ERASE_X - dwWidth / 2 + Cover.fOffsetX;
        Cover.sEraseButton.y = COVER_ERASE_Y - dwHeight / 2 + Cover.fOffsetY;
        Cover.sEraseButton.x2 = COVER_ERASE_X + dwWidth / 2 + Cover.fOffsetX;
        Cover.sEraseButton.y2 = COVER_ERASE_Y + dwHeight / 2 + Cover.fOffsetY;
        dwWidth = Cover.psHelp.GetWidth();
        dwHeight = Cover.psHelp.GetHeight();
        Cover.sHelpArea.x = COVER_HELP_X - dwWidth / 2 + Cover.fOffsetX;
        Cover.sHelpArea.y = COVER_HELP_Y - dwHeight / 2 + Cover.fOffsetY;
        Cover.sHelpArea.x2 = COVER_HELP_X + dwWidth / 2 + Cover.fOffsetX;
        Cover.sHelpArea.y2 = COVER_HELP_Y + dwHeight / 2 + Cover.fOffsetY;
        dwWidth = Cover.psYesButton.GetWidth();
        dwHeight = Cover.psYesButton.GetHeight();
        Cover.sYesButton.x = COVER_YES_X - dwWidth / 2 + Cover.fOffsetX;
        Cover.sYesButton.y = COVER_YES_Y - dwHeight / 2 + Cover.fOffsetY;
        Cover.sYesButton.x2 = COVER_YES_X + dwWidth / 2 + Cover.fOffsetX;
        Cover.sYesButton.y2 = COVER_YES_Y + dwHeight / 2 + Cover.fOffsetY;
        dwWidth = Cover.psNoButton.GetWidth();
        dwHeight = Cover.psNoButton.GetHeight();
        Cover.sNoButton.x = COVER_NO_X - dwWidth / 2 + Cover.fOffsetX;
        Cover.sNoButton.y = COVER_NO_Y - dwHeight / 2 + Cover.fOffsetY;
        Cover.sNoButton.x2 = COVER_NO_X + dwWidth / 2 + Cover.fOffsetX;
        Cover.sNoButton.y2 = COVER_NO_Y + dwHeight / 2 + Cover.fOffsetY
    };
    Cover.SetOffsetX = function(fOffset) {
        Cover.fOffsetX = fOffset;
        Cover.fOffsetX -= SCREEN_WIDTH;
        Cover.UpdateOffset()
    };
    Cover.SetOffsetY = function(fOffset) {
        Cover.fOffsetY = fOffset;
        Cover.UpdateOffset()
    };
    Cover.ActivateErase = function() {
        Cover.psEraseRoot.SetIsVisible(true)
    };
    Cover.UpdateAudioIcon = function() {};

    function EndScreen() {}
    var END_TREASURE_X = SCREEN_WIDTH / 2;
    var END_TREASURE_Y = 208;
    EndScreen.psRoot = 0;
    EndScreen.psBG = 0;
    EndScreen.psTreasure = 0;
    EndScreen.psLightRays = 0;
    EndScreen.psText = 0;
    EndScreen.psText2 = 0;
    EndScreen.psText3 = 0;
    EndScreen.fOffsetX = 0;
    EndScreen.fOffsetY = 0;
    EndScreen.bActive = 0;
    EndScreen.Create = function() {
        EndScreen.psRoot = Helpers.CreateTree(0, 0, GadgetTree.GetLayer(LAYERS_HUD));
        EndScreen.psRoot.SetPosition(LevelData_asData.length * SCREEN_WIDTH, 0);
        EndScreen.psBG = Helpers.CreateSprite(0, 0, EA.TopLeft, "EndScreenBackground", EndScreen.psRoot);
        EndScreen.psBG.SetFrameByName("EndScreenBackground", 4, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
        EndScreen.psTreasure = null;
        EndScreen.psLightRays = null;
        EndScreen.psText = false;
        EndScreen.psText2 = false;
        EndScreen.psText3 = false;
        EndScreen.bActive = false;
        if (Records.GetAllChallenge()) {
            EndScreen.SetActive(true)
        }
    };
    EndScreen.Destroy = function() {
        if (EndScreen.psTreasure) {
            EndScreen.psTreasure.RemoveFromParent();
            Helpers.DestroySprite(EndScreen.psTreasure)
        }
        if (EndScreen.psText) {
            Helpers.DestroyBitmapText(EndScreen.psText)
        }
        if (EndScreen.psText2) {
            Helpers.DestroyBitmapText(EndScreen.psText2)
        }
        if (EndScreen.psText3) {
            Helpers.DestroyBitmapText(EndScreen.psText3)
        }
        Helpers.DestroySprite(EndScreen.psBG);
        if (EndScreen.psLightRays) {
            EndScreen.psLightRays.Destroy();
            EndScreen.psLightRays = null
        }
        Helpers.DestroyTree(EndScreen.psRoot)
    };
    EndScreen.Init = function() {};
    EndScreen.ShutDown = function() {};
    EndScreen.Update = function() {
        if (EndScreen.bActive) {
            EndScreen.psLightRays.Update();
            if (Math.random() * 100 <= 10) {
                var x = Math.random() * 160 - 80 + END_TREASURE_X;
                var y = Math.random() * 160 - 80 + END_TREASURE_Y;
                var psEffect = EntityEffect.Create(x, y, ENTITYEFFECT_TYPE_STATIC_SPARKLE, EndScreen.psRoot);
                EntityManager.Add(psEffect)
            }
        }
    };
    EndScreen.Touch = function(psArea) {};
    EndScreen.UpdateOffset = function() {
        EndScreen.psRoot.x = NUM_PAGES * SCREEN_WIDTH + EndScreen.fOffsetX;
        EndScreen.psRoot.y = EndScreen.fOffsetY;
        EndScreen.psRoot.SetPosition(EndScreen.psRoot.x, EndScreen.psRoot.y)
    };
    EndScreen.SetOffsetX = function(fOffset) {
        EndScreen.fOffsetX = fOffset;
        EndScreen.UpdateOffset()
    };
    EndScreen.SetOffsetY = function(fOffset) {
        EndScreen.fOffsetY = fOffset;
        EndScreen.UpdateOffset()
    };
    EndScreen.SetActive = function(bActive) {
        if (EndScreen.bActive !== bActive) {
            if (bActive) {
                var Scaler = .8;
                EndScreen.psLightRays = EntityLightRays.Create(END_TREASURE_X, END_TREASURE_Y - 30, 2 * Scaler, EndScreen.psRoot);
                EndScreen.psTreasure = Helpers.CreateSprite(END_TREASURE_X, END_TREASURE_Y - 30, EA.Default, "EndTreasure", EndScreen.psRoot);
                EndScreen.psTreasure.SetScale(Scaler, Scaler);
                EndScreen.psText = Helpers.CreateBitmapText(JamSystem.TextManager.GetText("DATATEXT_ID_ALL_CHALLENGE_1"), SCREEN_WIDTH / 2, 400 + 20, EA.Default, "PanelFont", EndScreen.psRoot);
                EndScreen.psText2 = Helpers.CreateBitmapText(JamSystem.TextManager.GetText("DATATEXT_ID_ALL_CHALLENGE_2"), SCREEN_WIDTH / 2, 525 + 20, EA.Default, "PanelFont", EndScreen.psRoot);
                EndScreen.psText3 = Helpers.CreateBitmapText(JamSystem.TextManager.GetText("DATATEXT_ID_ALL_CHALLENGE_3"), SCREEN_WIDTH / 2, 675, EA.Default, "PanelFont", EndScreen.psRoot);
                EndScreen.psText.SetScale(.9 * Scaler, .9 * Scaler);
                EndScreen.psText2.SetScale(.9 * Scaler, .9 * Scaler);
                EndScreen.psText3.SetScale(.6, .6)
            }
            EndScreen.bActive = bActive
        }
    };

    function EntityBase() {}
    EntityBase.prototype = {
        Destroy: function() {
            EntityBase.Destroy(this)
        },
        SetSprite: function(dwImage) {
            if (this.m_psSprite) {
                Helpers.DestroySprite(this.m_psSprite)
            }
            this.m_psSprite = Helpers.CreateSprite(this.xPos, this.yPos, EA.Default, dwImage, null)
        },
        MoveTo: function(x, y, dwDelay) {
            this.m_fMoveTargetX = x;
            this.m_fMoveTargetY = y;
            this.m_fMoveDeltaX = (x - this.m_psSprite.x) / dwDelay;
            this.m_fMoveDeltaY = (y - this.m_psSprite.y) / dwDelay;
            this.m_dwMoveTimer = dwDelay
        },
        ScaleTo: function(fScaleX, fScaleY, dwDelay) {
            this.m_fScaleTargetX = fScaleX;
            this.m_fScaleTargetY = fScaleY;
            this.m_fScaleDeltaX = (fScaleX - this.m_psSprite.ScaleX) / dwDelay;
            this.m_fScaleDeltaY = (fScaleY - this.m_psSprite.ScaleY) / dwDelay;
            this.m_dwScaleTimer = dwDelay
        },
        AlphaTo: function(fAlpha, dwDelay) {
            this.m_fAlphaTarget = fAlpha;
            this.m_fAlphaDelta = (fAlpha - this.m_psSprite.GetOpacity() * 255) / dwDelay;
            this.m_dwAlphaTimer = dwDelay
        },
        UpdateMove: function() {
            if (this.m_dwMoveTimer) {
                this.m_psSprite.x += this.m_fMoveDeltaX;
                this.m_psSprite.y += this.m_fMoveDeltaY;
                this.m_dwMoveTimer -= 1;
                if (this.m_dwMoveTimer === 0) {
                    this.m_psSprite.x = this.m_fMoveTargetX;
                    this.m_psSprite.y = this.m_fMoveTargetY
                }
                this.m_psSprite.SetPosition(this.m_psSprite.x, this.m_psSprite.y)
            }
        },
        UpdateScale: function() {
            if (this.m_dwScaleTimer) {
                this.m_psSprite.ScaleX += this.m_fScaleDeltaX;
                this.m_psSprite.ScaleY += this.m_fScaleDeltaY;
                this.m_dwScaleTimer -= 1;
                if (this.m_dwScaleTimer === 0) {
                    this.m_psSprite.ScaleX = this.m_fScaleTargetX;
                    this.m_psSprite.ScaleY = this.m_fScaleTargetY
                }
                this.m_psSprite.SetScale(this.m_psSprite.ScaleX, this.m_psSprite.ScaleY)
            }
        },
        UpdateAlpha: function() {
            if (this.m_dwAlphaTimer) {
                this.m_psSprite.SetOpacity(this.m_psSprite.GetOpacity() * 255 + this.m_fAlphaDelta);
                this.m_dwAlphaTimer -= 1;
                if (this.m_dwAlphaTimer === 0) {
                    this.m_psSprite.SetOpacity(this.m_fAlphaTarget / 255)
                }
            }
        },
        SetScript: function() {
            this.EndScript();
            this.m_psScript = Script.New(this.psScript);
            Script.SetLocalVariable(this.m_psScript, SCRIPT_LOCAL_VARIABLE_1, this.m_psSprite)
        },
        EndScript: function() {
            this.m_psScriptList = [];
            this.m_psScript = null
        },
        Update: function() {
            EntityBase.Update(this)
        },
        GetState: function() {
            return this.dwState
        }
    };
    EntityBase.Destroy = function(ThisEntity) {
        if (ThisEntity.m_psSprite) {
            Helpers.DestroySprite(ThisEntity.m_psSprite)
        }
        if (ThisEntity.m_psScript) {
            Script.Delete(ThisEntity.m_psScript)
        }
        ScriptObjects.ShutDownList(ThisEntity.m_psScriptList)
    };
    EntityBase.Update = function(ThisEntity) {
        ThisEntity.UpdateMove();
        if (ThisEntity.m_psScript) {
            Script.Process(ThisEntity.m_psScript, ThisEntity.m_psScriptList, ThisEntity.m_psSprite.Parent)
        }
    };
    EntityBase.CreateMin = function(x, y, dwType) {
        var NewObject = new EntityBase;
        NewObject.xPos = x;
        NewObject.yPos = y;
        NewObject.xDelta = 0;
        NewObject.yDelta = 0;
        NewObject.m_psSprite = null;
        NewObject.dwState = 0;
        NewObject.dwStateTimer = 0;
        NewObject.bRemove = false;
        NewObject.m_dwType = dwType;
        NewObject.m_fMoveTargetX = 0;
        NewObject.m_fMoveTargetY = 0;
        NewObject.m_fMoveDeltaX = 0;
        NewObject.m_fMoveDeltaY = 0;
        NewObject.m_dwMoveTimer = 0;
        NewObject.m_fScaleTargetX = 0;
        NewObject.m_fScaleTargetY = 0;
        NewObject.m_fScaleDeltaX = 0;
        NewObject.m_fScaleDeltaY = 0;
        NewObject.m_dwScaleTimer = 0;
        NewObject.m_fAlphaTarget = 0;
        NewObject.m_fAlphaDelta = 0;
        NewObject.m_dwAlphaTimer = 0;
        NewObject.m_psScript = null;
        NewObject.m_psScriptList = ScriptObjects.InitList();
        return NewObject
    };
    EntityBase.Create = function(x, y, dwImage, eAlignment, pParent) {
        var NewObject = new EntityBase;
        NewObject.xPos = x;
        NewObject.yPos = y;
        NewObject.xDelta = 0;
        NewObject.yDelta = 0;
        NewObject.m_psSprite = null;
        NewObject.dwState = 0;
        NewObject.dwStateTimer = 0;
        NewObject.bRemove = false;
        NewObject.m_dwType = 0;
        NewObject.m_fMoveTargetX = 0;
        NewObject.m_fMoveTargetY = 0;
        NewObject.m_fMoveDeltaX = 0;
        NewObject.m_fMoveDeltaY = 0;
        NewObject.m_dwMoveTimer = 0;
        NewObject.m_fScaleTargetX = 0;
        NewObject.m_fScaleTargetY = 0;
        NewObject.m_fScaleDeltaX = 0;
        NewObject.m_fScaleDeltaY = 0;
        NewObject.m_dwScaleTimer = 0;
        NewObject.m_fAlphaTarget = 0;
        NewObject.m_fAlphaDelta = 0;
        NewObject.m_dwAlphaTimer = 0;
        NewObject.m_psScript = null;
        NewObject.m_psScriptList = ScriptObjects.InitList();
        NewObject.SetSprite(dwImage);
        NewObject.m_psSprite.SetAnchor(eAlignment);
        if (pParent) {
            pParent.AddChild(NewObject.m_psSprite)
        }
        return NewObject
    };
    var ENTITYBLOCK_COLOUR_RED = 0;
    var ENTITYBLOCK_COLOUR_GREEN = 1;
    var ENTITYBLOCK_COLOUR_BLUE = 2;
    var ENTITYBLOCK_COLOUR_YELLOW = 3;
    var ENTITYBLOCK_COLOUR_WHITE_A = 4;
    var ENTITYBLOCK_COLOUR_WHITE_B = 5;
    var ENTITYBLOCK_COLOUR_WHITE_D = 6;
    var ENTITYBLOCK_COLOUR_TOTAL = 7;
    var ENTITYBLOCK_MOVE_UP = 0;
    var ENTITYBLOCK_MOVE_DOWN = 1;
    var ENTITYBLOCK_MOVE_LEFT = 2;
    var ENTITYBLOCK_MOVE_RIGHT = 3;
    var ENTITYBLOCK_MOVE_TOTAL = 4;
    var ENTITYBLOCK_STATE_HIDE = 0;
    var ENTITYBLOCK_STATE_ENTER = 1;
    var ENTITYBLOCK_STATE_WAIT = 2;
    var ENTITYBLOCK_STATE_MOVE = 3;
    var ENTITYBLOCK_STATE_IMPACT = 4;
    var ENTITYBLOCK_STATE_IMPACT_MOVE = 5;
    var ENTITYBLOCK_STATE_JOIN = 6;
    var ENTITYBLOCK_STATE_COMPLETE_CEREMONY = 7;
    var ENTITYBLOCK_STATE_COMPLETE = 8;
    var ENTITYBLOCK_STATE_COMPLETE_HIDDEN = 9;
    var ENTITYBLOCK_STATE_TOTAL = 10;
    var ENTITYBLOCK_MOVE_DELAY = 3;
    var ENTITYBLOCK_IMPACT_DELAY = 3;
    var ENTITYBLOCK_JOIN_DELAY = 3;
    var ENTITYBLOCK_SHWEEN_DELAY = 6;
    var ENTITYBLOCK_IMPACT_PERCENT = 20;
    var ENTITYBLOCK_ENTER_DELAY = 5;
    var ENTITYBLOCK_WHITE_DELAY = 10;
    var ENTITYBLOCK_COMPLETE_OPACITY = 80;

    function EntityBlock() {}
    ScriptData.Move = [SCRIPT_INSTRUCTION_OBJECT_CREATE_SPRITE, 5, 0, SCRIPT_LOCAL_VARIABLE_1, 0, 0, EA.TopLeft, SCRIPT_INSTRUCTION_OBJECT_MOVE_TO, 4, 0, SCRIPT_LOCAL_VARIABLE_2, SCRIPT_LOCAL_VARIABLE_3, ENTITYBLOCK_MOVE_DELAY, SCRIPT_INSTRUCTION_WAIT, 1, ENTITYBLOCK_MOVE_DELAY, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 0, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.Impact = [SCRIPT_INSTRUCTION_OBJECT_CREATE_SPRITE, 5, 0, SCRIPT_LOCAL_VARIABLE_1, 0, 0, EA.TopLeft, SCRIPT_INSTRUCTION_OBJECT_SCALE_SET, 3, 0, SCRIPT_LOCAL_VARIABLE_6, SCRIPT_LOCAL_VARIABLE_7, SCRIPT_INSTRUCTION_OBJECT_MOVE, 4, 0, SCRIPT_LOCAL_VARIABLE_2, SCRIPT_LOCAL_VARIABLE_3, 1, SCRIPT_INSTRUCTION_WAIT, 1, ENTITYBLOCK_IMPACT_DELAY - 1, SCRIPT_INSTRUCTION_OBJECT_SCALE_SET, 3, 0, 100, 100, SCRIPT_INSTRUCTION_OBJECT_MOVE, 4, 0, SCRIPT_LOCAL_VARIABLE_4, SCRIPT_LOCAL_VARIABLE_5, 1, SCRIPT_INSTRUCTION_WAIT, 1, 1, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 0, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.ImpactMove = [SCRIPT_INSTRUCTION_OBJECT_CREATE_SPRITE, 5, 0, SCRIPT_LOCAL_VARIABLE_1, 0, 0, EA.TopLeft, SCRIPT_INSTRUCTION_OBJECT_MOVE, 4, 0, SCRIPT_LOCAL_VARIABLE_2, SCRIPT_LOCAL_VARIABLE_3, 1, SCRIPT_INSTRUCTION_WAIT, 1, ENTITYBLOCK_IMPACT_DELAY - 1, SCRIPT_INSTRUCTION_OBJECT_MOVE, 4, 0, SCRIPT_LOCAL_VARIABLE_4, SCRIPT_LOCAL_VARIABLE_5, 1, SCRIPT_INSTRUCTION_WAIT, 1, 1, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 0, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.Join = [SCRIPT_INSTRUCTION_WAIT, 1, ENTITYBLOCK_JOIN_DELAY, SCRIPT_INSTRUCTION_END, 0];
    var EntityBlock_asOffset = [{
        dwX: 0,
        dwY: -1
    }, {
        dwX: 0,
        dwY: 1
    }, {
        dwX: -1,
        dwY: 0
    }, {
        dwX: 1,
        dwY: 0
    }];
    var EntityBlock_bImpact = 0;
    var EntityBlock_adwColourConvert = [2, 1, 0, 3];
    var EntityBlock_adwColours = [
        [169, 255, 180],
        [255, 168, 0],
        [0, 255, 246],
        [255, 255, 192]
    ];
    var EntityBlock_adwImages = [
        ["BlockRedNone", "BlockRedUp", "BlockRedDown", "BlockRedUpDown", "BlockRedLeft", "BlockRedUpLeft", "BlockRedDownLeft", "BlockRedUpDownLeft", "BlockRedRight", "BlockRedUpRight", "BlockRedDownRight", "BlockRedUpDownRight", "BlockRedLeftRight", "BlockRedUpLeftRight", "BlockRedDownLeftRight", "BlockRedUpDownLeftRight"],
        ["BlockGreenNone", "BlockGreenUp", "BlockGreenDown", "BlockGreenUpDown", "BlockGreenLeft", "BlockGreenUpLeft", "BlockGreenDownLeft", "BlockGreenUpDownLeft", "BlockGreenRight", "BlockGreenUpRight", "BlockGreenDownRight", "BlockGreenUpDownRight", "BlockGreenLeftRight", "BlockGreenUpLeftRight", "BlockGreenDownLeftRight", "BlockGreenUpDownLeftRight"],
        ["BlockBlueNone", "BlockBlueUp", "BlockBlueDown", "BlockBlueUpDown", "BlockBlueLeft", "BlockBlueUpLeft", "BlockBlueDownLeft", "BlockBlueUpDownLeft", "BlockBlueRight", "BlockBlueUpRight", "BlockBlueDownRight", "BlockBlueUpDownRight", "BlockBlueLeftRight", "BlockBlueUpLeftRight", "BlockBlueDownLeftRight", "BlockBlueUpDownLeftRight"],
        ["BlockYellowNone", "BlockYellowUp", "BlockYellowDown", "BlockYellowUpDown", "BlockYellowLeft", "BlockYellowUpLeft", "BlockYellowDownLeft", "BlockYellowUpDownLeft", "BlockYellowRight", "BlockYellowUpRight", "BlockYellowDownRight", "BlockYellowUpDownRight", "BlockYellowLeftRight", "BlockYellowUpLeftRight", "BlockYellowDownLeftRight", "BlockYellowUpDownLeftRight"]
    ];
    var EntityBlock_padwBlockerImages = 0;
    var EntityBlock_SetBlockerImages = function(padwBlockerImages) {
        EntityBlock_padwBlockerImages = padwBlockerImages
    };
    EntityBlock.prototype = {
        Destroy: function() {
            this.m_psScriptList = [];
            Helpers.DestroySprite(this.m_psShadow);
            EntityBase.Destroy(this)
        },
        MarkMove: function(bMark, bRecursive) {
            this.m_bMove = bMark;
            if (bRecursive) {
                if (this.m_psUp && this.m_psUp.GetMark() !== bMark) {
                    this.m_psUp.MarkMove(bMark, bRecursive)
                }
                if (this.m_psDown && this.m_psDown.GetMark() !== bMark) {
                    this.m_psDown.MarkMove(bMark, bRecursive)
                }
                if (this.m_psLeft && this.m_psLeft.GetMark() !== bMark) {
                    this.m_psLeft.MarkMove(bMark, bRecursive)
                }
                if (this.m_psRight && this.m_psRight.GetMark() !== bMark) {
                    this.m_psRight.MarkMove(bMark, bRecursive)
                }
            }
        },
        Move: function(eDirection) {
            this.m_eMoveDirection = eDirection;
            this.SetState(ENTITYBLOCK_STATE_MOVE)
        },
        SetState: function(dwNewState) {
            this.m_psScriptList = [];
            this.m_psScript = null;
            switch (this.dwState) {
                case ENTITYBLOCK_STATE_IMPACT:
                case ENTITYBLOCK_STATE_JOIN:
                    this.CalcImage();
                    this.TestShween();
                    break;
                case ENTITYBLOCK_STATE_COMPLETE_CEREMONY:
                    this.m_psSprite.SetOpacity(128 / 255);
                    break;
                case ENTITYBLOCK_STATE_HIDE:
                    if (this.m_eColour !== ENTITYBLOCK_COLOUR_WHITE_A && this.m_eColour !== ENTITYBLOCK_COLOUR_WHITE_B && this.m_eColour !== ENTITYBLOCK_COLOUR_WHITE_D) {
                        this.SetVisible(true)
                    }
                    break;
                default:
                    break
            }
            this.dwState = dwNewState;
            var dwMoveX = EntityBlock_asOffset[this.m_eMoveDirection].dwX;
            var dwMoveY = EntityBlock_asOffset[this.m_eMoveDirection].dwY;
            switch (this.dwState) {
                case ENTITYBLOCK_STATE_MOVE:
                    this.m_psScript = Script.New(ScriptData.Move);
                    Script.SetLocalVariable(this.m_psScript, SCRIPT_LOCAL_VARIABLE_1, this.m_psSprite);
                    var x = this.m_dwTileX * this.m_fWidth + dwMoveX * this.m_fWidth;
                    var y = this.m_dwTileY * this.m_fWidth + dwMoveY * this.m_fWidth;
                    Script.SetLocalVariable(this.m_psScript, SCRIPT_LOCAL_VARIABLE_2, x * 256);
                    Script.SetLocalVariable(this.m_psScript, SCRIPT_LOCAL_VARIABLE_3, y * 256);
                    this.m_dwTileX += dwMoveX;
                    this.m_dwTileY += dwMoveY;
                    break;
                case ENTITYBLOCK_STATE_IMPACT:
                    this.m_psScript = Script.New(ScriptData.Impact);
                    Script.SetLocalVariable(this.m_psScript, SCRIPT_LOCAL_VARIABLE_1, this.m_psSprite);
                    if (dwMoveX) {
                        Script.SetLocalVariable(this.m_psScript, SCRIPT_LOCAL_VARIABLE_6, 100 - ENTITYBLOCK_IMPACT_PERCENT);
                        Script.SetLocalVariable(this.m_psScript, SCRIPT_LOCAL_VARIABLE_7, 100)
                    } else {
                        Script.SetLocalVariable(this.m_psScript, SCRIPT_LOCAL_VARIABLE_6, 100);
                        Script.SetLocalVariable(this.m_psScript, SCRIPT_LOCAL_VARIABLE_7, 100 - ENTITYBLOCK_IMPACT_PERCENT)
                    }
                    if (dwMoveX < 0) {
                        dwMoveX = 0
                    }
                    if (dwMoveY < 0) {
                        dwMoveY = 0
                    }
                    Script.SetLocalVariable(this.m_psScript, SCRIPT_LOCAL_VARIABLE_2, dwMoveX * (this.m_fWidth * ENTITYBLOCK_IMPACT_PERCENT / 100) * 256);
                    Script.SetLocalVariable(this.m_psScript, SCRIPT_LOCAL_VARIABLE_3, dwMoveY * (this.m_fWidth * ENTITYBLOCK_IMPACT_PERCENT / 100) * 256);
                    Script.SetLocalVariable(this.m_psScript, SCRIPT_LOCAL_VARIABLE_4, -dwMoveX * (this.m_fWidth * ENTITYBLOCK_IMPACT_PERCENT / 100) * 256);
                    Script.SetLocalVariable(this.m_psScript, SCRIPT_LOCAL_VARIABLE_5, -dwMoveY * (this.m_fWidth * ENTITYBLOCK_IMPACT_PERCENT / 100) * 256);
                    break;
                case ENTITYBLOCK_STATE_IMPACT_MOVE:
                    this.m_psScript = Script.New(ScriptData.ImpactMove);
                    Script.SetLocalVariable(this.m_psScript, SCRIPT_LOCAL_VARIABLE_1, this.m_psSprite);
                    Script.SetLocalVariable(this.m_psScript, SCRIPT_LOCAL_VARIABLE_2, dwMoveX * (this.m_fWidth * ENTITYBLOCK_IMPACT_PERCENT / 100) * 256);
                    Script.SetLocalVariable(this.m_psScript, SCRIPT_LOCAL_VARIABLE_3, dwMoveY * (this.m_fWidth * ENTITYBLOCK_IMPACT_PERCENT / 100) * 256);
                    Script.SetLocalVariable(this.m_psScript, SCRIPT_LOCAL_VARIABLE_4, -dwMoveX * (this.m_fWidth * ENTITYBLOCK_IMPACT_PERCENT / 100) * 256);
                    Script.SetLocalVariable(this.m_psScript, SCRIPT_LOCAL_VARIABLE_5, -dwMoveY * (this.m_fWidth * ENTITYBLOCK_IMPACT_PERCENT / 100) * 256);
                    break;
                case ENTITYBLOCK_STATE_JOIN:
                    this.m_psScript = Script.New(ScriptData.Join);
                    Script.SetLocalVariable(this.m_psScript, SCRIPT_LOCAL_VARIABLE_1, this);
                    Helpers.PlaySound("Join");
                    break;
                case ENTITYBLOCK_STATE_COMPLETE_CEREMONY:
                    for (var i = 0; i < 2; i += 1) {
                        var x = this.m_psSprite.x + this.m_fWidth / 2,
                            y = this.m_psSprite.y + this.m_fWidth / 2;
                        x += Math.random() * 20 - 10;
                        y += Math.random() * 20 - 10;
                        var psEffect = EntityEffect.Create(x, y, ENTITYEFFECT_TYPE_SPARKLE, this.m_psSprite.m_pRenderParent);
                        var dwColour = EntityBlock_adwColourConvert[this.m_eColour];
                        EntityManager.Add(psEffect)
                    }
                    this.dwStateTimer = 0;
                    break;
                case ENTITYBLOCK_STATE_COMPLETE:
                    this.SetComplete(true, true);
                    break;
                case ENTITYBLOCK_STATE_COMPLETE_HIDDEN:
                    this.SetComplete(true, false);
                    break;
                case ENTITYBLOCK_STATE_HIDE:
                    if (this.m_eColour !== ENTITYBLOCK_COLOUR_WHITE_A && this.m_eColour !== ENTITYBLOCK_COLOUR_WHITE_B && this.m_eColour !== ENTITYBLOCK_COLOUR_WHITE_D) {
                        this.m_psSprite.SetIsVisible(false)
                    }
                    break;
                case ENTITYBLOCK_STATE_ENTER:
                    break;
                default:
                    break
            }
        },
        ClumpState: function(dwNewState, dwTestState) {
            if (this.dwState !== dwTestState && this.dwState !== dwNewState) {
                this.SetState(dwNewState)
            }
            if (this.m_psUp && this.m_psUp.dwState !== dwNewState && this.m_psUp.dwState !== dwTestState) {
                this.m_psUp.ClumpState(dwNewState, dwTestState)
            }
            if (this.m_psDown && this.m_psDown.dwState !== dwNewState && this.m_psDown.dwState !== dwTestState) {
                this.m_psDown.ClumpState(dwNewState, dwTestState)
            }
            if (this.m_psLeft && this.m_psLeft.dwState !== dwNewState && this.m_psLeft.dwState !== dwTestState) {
                this.m_psLeft.ClumpState(dwNewState, dwTestState)
            }
            if (this.m_psRight && this.m_psRight.dwState !== dwNewState && this.m_psRight.dwState !== dwTestState) {
                this.m_psRight.ClumpState(dwNewState, dwTestState)
            }
        },
        CalcImage: function() {
            var bUp = 0,
                bDown = 0,
                bLeft = 0,
                bRight = 0;
            if (this.m_psUp) {
                bUp = 1
            }
            if (this.m_psDown) {
                bDown = 1
            }
            if (this.m_psLeft) {
                bLeft = 1
            }
            if (this.m_psRight) {
                bRight = 1
            }
            var padwImages;
            if (this.m_eColour <= ENTITYBLOCK_COLOUR_YELLOW) {
                padwImages = EntityBlock_adwImages[this.m_eColour]
            } else {
                padwImages = EntityBlock_padwBlockerImages
            }
            this.m_psSprite.SetFrameByName(padwImages[bUp + (bDown << 1) + (bLeft << 2) + (bRight << 3)])
        },
        Join: function(psJoinBlock, bShow) {
            var bJoinUp = false,
                bJoinDown = false,
                bJoinLeft = false,
                bJoinRight = false;
            var x = this.m_psSprite.x + this.m_fWidth / 2,
                y = this.m_psSprite.y + this.m_fWidth / 2;
            if (psJoinBlock.m_dwTileX < this.m_dwTileX) {
                this.m_psLeft = psJoinBlock;
                bJoinLeft = true;
                x -= this.m_fWidth / 2
            } else if (psJoinBlock.m_dwTileX > this.m_dwTileX) {
                this.m_psRight = psJoinBlock;
                bJoinRight = true;
                x += this.m_fWidth / 2
            } else if (psJoinBlock.m_dwTileY < this.m_dwTileY) {
                this.m_psUp = psJoinBlock;
                bJoinUp = true;
                y -= this.m_fWidth / 2
            } else {
                this.m_psDown = psJoinBlock;
                bJoinDown = true;
                y += this.m_fWidth / 2
            }
            this.CalcImage();
            psJoinBlock.CalcImage();
            if (bShow) {
                var psEffect;
                if (bJoinLeft || bJoinRight) {
                    psEffect = EntityEffect.Create(x, y, ENTITYEFFECT_TYPE_JOIN_H, this.m_psSprite.Parent)
                } else {
                    psEffect = EntityEffect.Create(x, y, ENTITYEFFECT_TYPE_JOIN_V, this.m_psSprite.Parent)
                }
                var dwColour = EntityBlock_adwColourConvert[this.m_eColour];
                EntityManager.Add(psEffect);
                this.SetState(ENTITYBLOCK_STATE_JOIN);
                this.MarkShween()
            }
        },
        MarkShween: function() {
            this.m_bJoined = true;
            if (this.m_psUp && !this.m_psUp.m_bJoined) {
                this.m_psUp.MarkShween()
            }
            if (this.m_psDown && !this.m_psDown.m_bJoined) {
                this.m_psDown.MarkShween()
            }
            if (this.m_psLeft && !this.m_psLeft.m_bJoined) {
                this.m_psLeft.MarkShween()
            }
            if (this.m_psRight && !this.m_psRight.m_bJoined) {
                this.m_psRight.MarkShween()
            }
        },
        TestShween: function() {
            if (this.m_bJoined) {
                this.m_bJoined = false;
                var dwAnimation = 0;
                if (!this.m_psUp) {
                    dwAnimation |= 1
                }
                if (!this.m_psDown) {
                    dwAnimation |= 2
                }
                if (!this.m_psLeft) {
                    dwAnimation |= 4
                }
                if (!this.m_psRight) {
                    dwAnimation |= 8
                }
            }
            if (this.m_psUp && this.m_psUp.m_bJoined) {
                this.m_psUp.TestShween()
            }
            if (this.m_psDown && this.m_psDown.m_bJoined) {
                this.m_psDown.TestShween()
            }
            if (this.m_psLeft && this.m_psLeft.m_bJoined) {
                this.m_psLeft.TestShween()
            }
            if (this.m_psRight && this.m_psRight.m_bJoined) {
                this.m_psRight.TestShween()
            }
        },
        SetComplete: function(bComplete, bVisible) {
            this.m_dwOpaqueTimer = 0;
            if (bComplete) {
                if (bVisible) {
                    this.m_dwOpaqueTimer = 30
                } else {
                    this.m_psSprite.SetOpacity(ENTITYBLOCK_COMPLETE_OPACITY / 255)
                }
            } else {
                this.m_psSprite.SetOpacity(255 / 255)
            }
        },
        Update: function() {
            if (this.dwState === ENTITYBLOCK_STATE_COMPLETE_CEREMONY) {
                this.dwStateTimer += 1;
                if (this.dwStateTimer % 10 < 7) {
                    this.m_psSprite.SetOpacity(128 / 255)
                } else {
                    this.m_psSprite.SetOpacity(255 / 255)
                }
            } else if (this.dwState === ENTITYBLOCK_STATE_ENTER) {
                this.UpdateMove();
                if (this.m_dwMoveTimer === 0) {
                    this.SetState(ENTITYBLOCK_STATE_WAIT)
                }
            } else if (this.dwState === ENTITYBLOCK_STATE_WAIT) {
                this.UpdateMove()
            } else if (this.m_psScript) {
                if (!Script.Process(this.m_psScript, this.m_psScriptList, null)) {
                    this.m_psScript = null;
                    switch (this.dwState) {
                        case ENTITYBLOCK_STATE_MOVE:
                        case ENTITYBLOCK_STATE_IMPACT:
                        case ENTITYBLOCK_STATE_IMPACT_MOVE:
                        case ENTITYBLOCK_STATE_JOIN:
                            this.SetState(ENTITYBLOCK_STATE_WAIT);
                            break
                    }
                }
            }
            this.m_psShadow.SetPosition(this.m_psSprite.x + 12 * 2, this.m_psSprite.y + 12 * 2);
            if (this.m_dwOpaqueTimer) {
                this.m_dwOpaqueTimer -= 1;
                var fOpaque = this.m_dwOpaqueTimer / 30 * (255 - ENTITYBLOCK_COMPLETE_OPACITY) + ENTITYBLOCK_COMPLETE_OPACITY;
                this.m_psSprite.SetOpacity(fOpaque / 255);
                this.m_psShadow.SetOpacity(fOpaque / 255)
            }
        },
        GetColour: function() {
            return this.m_eColour
        },
        GetMark: function() {
            return this.m_bMove
        }
    };
    EntityBlock.Create = function(x, y, dwTileX, dwTileY, fWidth, eColour, papsBoard, psParent, psShadowParent) {
        var NewObject = EntityBase.Create(x, y, "NewBlank", EA.TopLeft, psParent);
        NewObject.GetMark = EntityBlock.prototype.GetMark;
        NewObject.MarkMove = EntityBlock.prototype.MarkMove;
        NewObject.Move = EntityBlock.prototype.Move;
        NewObject.SetState = EntityBlock.prototype.SetState;
        NewObject.ClumpState = EntityBlock.prototype.ClumpState;
        NewObject.CalcImage = EntityBlock.prototype.CalcImage;
        NewObject.Join = EntityBlock.prototype.Join;
        NewObject.MarkShween = EntityBlock.prototype.MarkShween;
        NewObject.TestShween = EntityBlock.prototype.TestShween;
        NewObject.SetComplete = EntityBlock.prototype.SetComplete;
        NewObject.GetColour = EntityBlock.prototype.GetColour;
        NewObject.Destroy = EntityBlock.prototype.Destroy;
        NewObject.Update = EntityBlock.prototype.Update;
        NewObject.m_psShadow = Helpers.CreateSprite(x + 12 * 2, y + 12 * 2, EA.Default, "Shadow2", psShadowParent);
        NewObject.m_dwType = ENTITYMANAGER_TYPE_BLOCK;
        NewObject.m_eColour = eColour;
        NewObject.m_fWidth = fWidth;
        NewObject.m_bMove = false;
        NewObject.m_dwStartTileX = dwTileX;
        NewObject.m_dwTileX = dwTileX;
        NewObject.m_dwStartTileY = dwTileY;
        NewObject.m_dwTileY = dwTileY;
        NewObject.m_papsBoard = papsBoard;
        NewObject.m_psUp = null;
        NewObject.m_psDown = null;
        NewObject.m_psLeft = null;
        NewObject.m_psRight = null;
        NewObject.m_bImpact = false;
        NewObject.m_bJoined = false;
        NewObject.m_eMoveDirection = ENTITYBLOCK_MOVE_UP;
        NewObject.dwState = ENTITYBLOCK_STATE_WAIT;
        NewObject.m_dwOpaqueTimer = 0;
        NewObject.CalcImage();
        return NewObject
    };
    var ENTITYBOARD_NUM_UNDO = 256;
    var ENTITYBOARD_STATE_MOVE_TO = 0;
    var ENTITYBOARD_STATE_HOLD = 1;
    var ENTITYBOARD_STATE_WAIT = 2;
    var ENTITYBOARD_STATE_MOVE_1 = 3;
    var ENTITYBOARD_STATE_MOVE_2 = 4;
    var ENTITYBOARD_STATE_IMPACT = 5;
    var ENTITYBOARD_STATE_TOTAL = 6;
    var ENTITYBOARD_BOARD_WIDTH = 16;
    var ENTITYBOARD_BOARD_HEIGHT = 16;
    var ENTITYBOARD_MAKE_WIDTH = 6;
    var ENTITYBOARD_MAKE_HEIGHT = 16;
    var ENTITYBOARD_MOVE_1_DELAY = 4;
    var ENTITYBOARD_MOVE_1_WHEEL_DELAY = 4;
    var ENTITYBOARD_MOVE_2_DELAY = 8;
    var ENTITYBOARD_MOVE_2_WHEEL_DELAY = 8;
    var ENTITYBOARD_IMPACT_DELAY = 9;
    var ENTITYBOARD_JOIN_RED = 1 << 0;
    var ENTITYBOARD_JOIN_GREEN = 1 << 1;
    var ENTITYBOARD_JOIN_BLUE = 1 << 2;
    var ENTITYBOARD_JOIN_YELLOW = 1 << 3;
    var ENTITYBOARD_UNUSED_1 = 1 << 4;
    var ENTITYBOARD_MAKE_SHAPE = 1 << 5;
    var ENTITYBOARD_UNUSED_2 = 1 << 6;
    var ENTITYBOARD_UNUSED_3 = 1 << 7;
    var ENTITYBOARD_TILETYPE_EMPTY = 0;
    var ENTITYBOARD_TILETYPE_1 = 1;
    var ENTITYBOARD_TILETYPE_2 = 2;
    var ENTITYBOARD_TILETYPE_3 = 3;
    var ENTITYBOARD_TILETYPE_4 = 4;
    var ENTITYBOARD_TILETYPE_5 = 5;
    var ENTITYBOARD_TILETYPE_6 = 6;
    var ENTITYBOARD_TILETYPE_7 = 7;
    var ENTITYBOARD_TILETYPE_8 = 8;
    var ENTITYBOARD_TILETYPE_RED = 9;
    var ENTITYBOARD_TILETYPE_GREEN = 10;
    var ENTITYBOARD_TILETYPE_BLUE = 11;
    var ENTITYBOARD_TILETYPE_YELLOW = 12;
    var ENTITYBOARD_TILETYPE_WHITE = 13;
    var ENTITYBOARD_TILETYPE_14 = 14;
    var ENTITYBOARD_TILETYPE_15 = 15;
    var ENTITYBOARD_TILETYPE_16 = 16;
    var ENTITYBOARD_TILETYPE_17 = 17;
    var ENTITYBOARD_TILETYPE_18 = 18;
    var ENTITYBOARD_TILETYPE_19 = 19;
    var ENTITYBOARD_TILETYPE_20 = 20;
    var ENTITYBOARD_TILETYPE_21 = 21;
    var ENTITYBOARD_TILETYPE_22 = 22;
    var ENTITYBOARD_TILETYPE_TOTAL = 23;

    function EntityBoard() {}
    var EntityBoard_adwMoveOffset = [];
    ScriptData.MoveBoard = [SCRIPT_INSTRUCTION_OBJECT_CREATE_SPRITE, 5, 0, SCRIPT_LOCAL_VARIABLE_1, 0, 0, EA.Default, SCRIPT_INSTRUCTION_OBJECT_MOVE_TO_EASE, 6, 0, SCRIPT_LOCAL_VARIABLE_2, SCRIPT_LOCAL_VARIABLE_3, true, true, SCRIPT_LOCAL_VARIABLE_6, SCRIPT_INSTRUCTION_OBJECT_SCALE_TO_EASE, 6, 0, SCRIPT_LOCAL_VARIABLE_4, SCRIPT_LOCAL_VARIABLE_5, true, true, SCRIPT_LOCAL_VARIABLE_6, SCRIPT_INSTRUCTION_WAIT, 1, SCRIPT_LOCAL_VARIABLE_6, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 0, SCRIPT_INSTRUCTION_END, 0];
    var EntityBoard_adwColourSchemes = [
        [0, 1, 2, 3],
        [0, 1, 3, 1],
        [1, 2, 3, 0]
    ];
    EntityBoard.prototype = {
        Destroy: function() {
            this.m_psScriptList = [];
            this.m_psScript = null;
            EntityManager.Remove(this.m_psHud);
            this.m_psHud.Destroy();
            this.m_psHud = null;
            var i;
            for (i = 0; i < this.m_dwTilesWide * this.m_dwTilesHigh; i += 1) {
                var psBlock = this.m_papsBlocks[i];
                if (psBlock) {
                    if (psBlock.GetColour() !== ENTITYBLOCK_COLOUR_WHITE_A && psBlock.GetColour() !== ENTITYBLOCK_COLOUR_WHITE_B && psBlock.GetColour() !== ENTITYBLOCK_COLOUR_WHITE_D) {
                        EntityManager.Remove(psBlock);
                        psBlock.Destroy()
                    }
                }
            }
            this.m_papsBlocks = [];
            this.m_papsUndoBlocks = [];
            this.m_padwMakeShape = [];
            this.m_apBlocks = [];
            Helpers.DestroySprite(this.m_psBackground);
            this.m_psBackground = null;
            Helpers.DestroyTree(this.m_psBlockRoot);
            this.m_psBlockRoot = null;
            Helpers.DestroyTree(this.m_psShadowRoot);
            this.m_psShadowRoot = null;
            Helpers.DestroyTree(this.m_psRoot);
            this.m_psRoot = null;
            Helpers.DestroyTree(this.m_psSprite);
            this.m_psSprite = this.OldSprite;
            EntityBase.Destroy(this)
        },
        RemoveColouredBlocks: function() {
            for (var i = 0; i < this.m_dwTilesWide * this.m_dwTilesHigh; i += 1) {
                var psBlock = this.m_papsBlocks[i];
                if (psBlock) {
                    if (psBlock.GetColour() !== ENTITYBLOCK_COLOUR_WHITE_A && psBlock.GetColour() !== ENTITYBLOCK_COLOUR_WHITE_B && psBlock.GetColour() !== ENTITYBLOCK_COLOUR_WHITE_D) {
                        EntityManager.Remove(psBlock);
                        psBlock.Destroy();
                        this.m_papsBlocks[i] = 0
                    }
                }
            }
            this.m_apBlocks = []
        },
        AddColouredBlock: function(eColour, x, y, dwColour) {
            if (dwColour === -1) {
                dwColour = eColour
            } else {
                dwColour = EntityBoard_adwColourSchemes[dwColour][eColour]
            }
            var psBlock = EntityBlock.Create(x * this.m_fTileWidth, y * this.m_fTileHeight, x, y, this.m_fTileWidth, dwColour, this, this.m_psBlockRoot, this.m_psShadowRoot);
            var l = y * this.m_dwTilesWide + x;
            this.m_papsBlocks[l] = psBlock;
            EntityManager.Add(psBlock);
            this.m_apBlocks[this.m_apBlocks.length] = psBlock
        },
        AddWhiteBlock: function(x, y, dwColour) {
            var eWhiteBlock = ENTITYBLOCK_COLOUR_WHITE_A + dwColour;
            var psBlock = EntityBlock.Create(x * this.m_fTileWidth, y * this.m_fTileHeight, x, y, this.m_fTileWidth, eWhiteBlock, this, this.m_psBlockRoot, this.m_psShadowRoot);
            this.m_papsBlocks[y * this.m_dwTilesWide + x] = psBlock
        },
        RenderWhiteBlockShadows: function() {},
        LoadLevelByData: function(pachData, psScheme, dwWidth, dwHeight) {
            this.m_psBackground.SetFrameByName(psScheme.dwGameBoardImage);
            this.m_psHud.SetScheme(psScheme);
            var bSeenBefore = false;
            var dwLevel = LevelSelect.GetLevelNumber();
            bSeenBefore = true;
            if (Records.GetScore(dwLevel) !== 0) {
                this.m_psHud.SetBonus(LevelData_asData[dwLevel].dwBonusType, false)
            } else {
                this.m_psHud.SetBonus(LevelData_asData[dwLevel].dwBonusType, true)
            }
            if (parseInt(pachData.Flags) & ENTITYBOARD_JOIN_RED) {
                this.m_abJoinColour[EntityBoard_adwColourSchemes[psScheme.dwBaseColour][ENTITYBLOCK_COLOUR_RED]] = true
            }
            if (parseInt(pachData.Flags) & ENTITYBOARD_JOIN_GREEN) {
                this.m_abJoinColour[EntityBoard_adwColourSchemes[psScheme.dwBaseColour][ENTITYBLOCK_COLOUR_GREEN]] = true
            }
            if (parseInt(pachData.Flags) & ENTITYBOARD_JOIN_BLUE) {
                this.m_abJoinColour[EntityBoard_adwColourSchemes[psScheme.dwBaseColour][ENTITYBLOCK_COLOUR_BLUE]] = true
            }
            if (parseInt(pachData.Flags) & ENTITYBOARD_JOIN_YELLOW) {
                this.m_abJoinColour[EntityBoard_adwColourSchemes[psScheme.dwBaseColour][ENTITYBLOCK_COLOUR_YELLOW]] = true
            }
            var i, j;
            for (i = 0; i < 4; i += 1) {
                if (this.m_abJoinColour[i]) {
                    this.m_psHud.JoinActive(i)
                }
            }
            if (parseInt(pachData.Flags) & ENTITYBOARD_MAKE_SHAPE) {
                this.m_bMakeShape = true
            }
            for (j = 0; j < this.m_dwTilesWide * this.m_dwTilesHigh; j += 1) {
                this.m_papsBlocks[j] = null
            }
            for (i = 0; i < this.m_dwTilesWide; i += 1) {
                this.AddWhiteBlock(i, 0, psScheme.dwBaseColour);
                this.AddWhiteBlock(i, this.m_dwTilesHigh - 1, psScheme.dwBaseColour)
            }
            for (i = 1; i < this.m_dwTilesHigh - 1; i += 1) {
                this.AddWhiteBlock(0, i, psScheme.dwBaseColour);
                this.AddWhiteBlock(this.m_dwTilesWide - 1, i, psScheme.dwBaseColour)
            }
            var dwStartX = Math.floor((this.m_dwTilesWide - dwWidth) / 2);
            var dwStartY = Math.floor((this.m_dwTilesHigh - dwHeight) / 2);
            if (this.m_dwTilesHigh - 2 !== dwHeight && dwStartY !== 1) {
                for (i = dwStartX - 1; i < dwStartX + dwWidth + 1; i += 1) {
                    if (i !== 0 && i !== this.m_dwTilesWide - 1) {
                        this.AddWhiteBlock(i, dwStartY - 1, psScheme.dwBaseColour);
                        this.AddWhiteBlock(i, dwStartY + dwHeight, psScheme.dwBaseColour)
                    }
                }
            }
            if (this.m_dwTilesWide - 2 !== dwWidth && dwStartX !== 1) {
                for (i = dwStartY; i < dwStartY + dwHeight; i += 1) {
                    if (i !== 0 && i !== this.m_dwTilesHigh - 1) {
                        this.AddWhiteBlock(dwStartX - 1, i, psScheme.dwBaseColour);
                        this.AddWhiteBlock(dwStartX + dwWidth, i, psScheme.dwBaseColour)
                    }
                }
            }
            for (j = 0; j < dwHeight; j += 1) {
                for (i = 0; i < dwWidth; i += 1) {
                    var chTile = pachData.Tiles[j * dwWidth + i];
                    var l = (j + dwStartX) * this.m_dwTilesWide + (i + dwStartY);
                    switch (chTile) {
                        case ENTITYBOARD_TILETYPE_EMPTY:
                            this.m_papsBlocks[l] = null;
                            break;
                        case ENTITYBOARD_TILETYPE_RED:
                        case ENTITYBOARD_TILETYPE_GREEN:
                        case ENTITYBOARD_TILETYPE_BLUE:
                        case ENTITYBOARD_TILETYPE_YELLOW:
                            var eColour = chTile - ENTITYBOARD_TILETYPE_RED + ENTITYBLOCK_COLOUR_RED;
                            this.AddColouredBlock(eColour, i + dwStartX, j + dwStartY, psScheme.dwBaseColour);
                            break;
                        case ENTITYBOARD_TILETYPE_WHITE:
                            this.AddWhiteBlock(i + dwStartX, j + dwStartY, psScheme.dwBaseColour);
                            break;
                        default:
                            break
                    }
                }
            }
            if (this.m_bMakeShape) {
                this.m_padwMakeShape = [];
                for (i = 0; i < ENTITYBOARD_MAKE_WIDTH * ENTITYBOARD_MAKE_HEIGHT; i += 1) {
                    this.m_padwMakeShape[i] = ENTITYBLOCK_COLOUR_TOTAL
                }
                var dwLeft = ENTITYBOARD_MAKE_WIDTH,
                    dwRight = 0,
                    dwTop = ENTITYBOARD_MAKE_HEIGHT,
                    dwBottom = 0;
                for (j = 0; j < ENTITYBOARD_MAKE_HEIGHT; j += 1) {
                    for (i = 0; i < ENTITYBOARD_MAKE_WIDTH; i += 1) {
                        var k = j * ENTITYBOARD_MAKE_WIDTH + i;
                        if (pachData.Make[k]) {
                            if (i < dwLeft) {
                                dwLeft = i
                            }
                            if (i > dwRight) {
                                dwRight = i
                            }
                            if (j < dwTop) {
                                dwTop = j
                            }
                            if (j > dwBottom) {
                                dwBottom = j
                            }
                        }
                    }
                }
                var dwX = Math.floor(ENTITYBOARD_MAKE_WIDTH / 2 - (dwRight - dwLeft + 1) / 2 - dwLeft);
                var dwY = Math.floor(6 / 2 - (dwBottom - dwTop + 1) / 2 - dwTop);
                if (dwBottom - dwTop === 5) {
                    dwY += 1
                }
                var ModX = 0;
                var ModY = 0;
                if (this.FileName === "L_084") {
                    ModX -= 10;
                    ModY += 20
                }
                if (this.FileName === "O_004") {
                    ModX -= 10
                }
                if (this.FileName === "L_040") {
                    ModY += 10
                }
                if (this.FileName === "L_046C") {
                    ModX -= 10;
                    ModY += 10
                }
                if (this.FileName === "O_322") {
                    ModY += 10
                }
                if (this.FileName === "L_378") {
                    ModY += 30
                }
                if (this.FileName === "L_110") {
                    ModX -= 10;
                    ModY += 15
                }
                if (this.FileName === "L_333s") {
                    ModY += 15
                }
                if (this.FileName === "L_025") {
                    ModY -= 10
                }
                if (this.FileName === "L_377") {
                    ModX -= 10
                }
                if (this.FileName === "S_010s") {
                    ModX -= 10
                }
                if (this.FileName === "L_092") {
                    ModX -= 10
                }
                if (this.FileName === "L_043") {
                    ModX += 10
                }
                if (this.FileName === "T_Bonus") {
                    ModX += 10
                }
                if (this.FileName === "L_042") {
                    ModX -= 10;
                    ModY += 40
                }
                if (this.FileName === "L_260b") {
                    ModY += 40
                }
                if (this.FileName === "L_109") {
                    ModY += 10
                }
                if (this.FileName === "P_008") {
                    ModX -= 10
                }
                if (this.FileName === "L_102C") {
                    ModX -= 10
                }
                if (this.FileName === "L_002") {
                    ModX -= 10
                }
                if (this.FileName === "S_003s") {
                    ModY += 30
                }
                for (j = 0; j < ENTITYBOARD_MAKE_HEIGHT; j += 1) {
                    for (i = 0; i < ENTITYBOARD_MAKE_WIDTH; i += 1) {
                        var k = j * ENTITYBOARD_MAKE_WIDTH + i;
                        switch (pachData.Make[k]) {
                            case ENTITYBOARD_TILETYPE_RED:
                            case ENTITYBOARD_TILETYPE_GREEN:
                            case ENTITYBOARD_TILETYPE_BLUE:
                                var dwTempColour = pachData.Make[k] - ENTITYBOARD_TILETYPE_RED + ENTITYBLOCK_COLOUR_RED;
                                dwTempColour = EntityBoard_adwColourSchemes[psScheme.dwBaseColour][dwTempColour];
                                this.m_padwMakeShape[k] = dwTempColour;
                                this.m_psHud.AddMakeBlock(i + dwX, j + dwY, dwTempColour, ModX, ModY);
                                this.m_abJoinColour[dwTempColour] = true;
                                break;
                            default:
                                break
                        }
                    }
                }
                this.m_psHud.FinishMakeShape()
            }
            this.m_psHud.SetMakeShapeVisible(bSeenBefore);
            this.TestJoin(false)
        },
        LoadLevelByName: function(pszFileName, psScheme) {
            var i;
            var pachData = GlobalMain.LevelsData.Levels[0];
            for (i = 0; i < GlobalMain.LevelsData.Levels.length; i += 1) {
                if (GlobalMain.LevelsData.Levels[i].Name === pszFileName) {
                    pachData = GlobalMain.LevelsData.Levels[i];
                    break
                }
            }
            var dwExpectedSize = 256;
            this.FileName = pszFileName;
            var dwWidth = 16;
            var dwHeight = 16;
            var dwDiff = dwExpectedSize - pachData.Tiles.length;
            if (dwDiff) {
                var dwBlocks = dwWidth * dwHeight - dwDiff;
                dwWidth = Math.sqrt(dwBlocks);
                dwHeight = Math.sqrt(dwBlocks)
            }
            this.LoadLevelByData(pachData, psScheme, dwWidth, dwHeight)
        },
        LoadLevelByID: function(dwLevel) {
            var Name = "Level" + (dwLevel + 1);
            this.LoadLevelByName(Name, 0)
        },
        SetState: function(dwNewState) {
            if (this.dwState === ENTITYBOARD_STATE_MOVE_TO) {
                this.m_psScriptList = [];
                this.m_psScript = null
            }
            this.dwState = dwNewState;
            switch (this.dwState) {
                case ENTITYBOARD_STATE_MOVE_1:
                    if (Cover.dwTiltControls === 1) {
                        this.dwStateTimer = ENTITYBOARD_MOVE_1_WHEEL_DELAY
                    } else {
                        this.dwStateTimer = ENTITYBOARD_MOVE_1_DELAY
                    }
                    break;
                case ENTITYBOARD_STATE_MOVE_2:
                    if (this.m_bRepeat) {
                        this.dwStateTimer = 2
                    } else {
                        if (Cover.dwTiltControls === 1) {
                            this.dwStateTimer = ENTITYBOARD_MOVE_2_WHEEL_DELAY
                        } else {
                            this.dwStateTimer = ENTITYBOARD_MOVE_2_DELAY
                        }
                    }
                    break;
                case ENTITYBOARD_STATE_IMPACT:
                    this.dwStateTimer = ENTITYBOARD_IMPACT_DELAY;
                    break
            }
        },
        TestJoin: function(bUpdateModel) {
            for (var j = 0; j < this.m_dwTilesHigh; j += 1) {
                for (var i = 0; i < this.m_dwTilesWide; i += 1) {
                    var psBlock = this.m_papsBlocks[i + j * this.m_dwTilesWide];
                    if (psBlock) {
                        var l = psBlock.m_dwTileY * this.m_dwTilesWide + psBlock.m_dwTileX;
                        if (j > 0) {
                            var psTestBlock = this.m_papsBlocks[l + EntityBoard_adwMoveOffset[0]];
                            if (psBlock.m_psUp === null && psTestBlock && psTestBlock.GetColour() === psBlock.GetColour()) {
                                psBlock.Join(psTestBlock, bUpdateModel)
                            }
                        }
                        if (j < this.m_dwTilesHigh - 1) {
                            var psTestBlock = this.m_papsBlocks[l + EntityBoard_adwMoveOffset[1]];
                            if (psBlock.m_psDown === null && psTestBlock && psTestBlock.GetColour() === psBlock.GetColour()) {
                                psBlock.Join(psTestBlock, bUpdateModel)
                            }
                        }
                        if (i > 0) {
                            var psTestBlock = this.m_papsBlocks[l + EntityBoard_adwMoveOffset[2]];
                            if (psBlock.m_psLeft === null && psTestBlock && psTestBlock.GetColour() === psBlock.GetColour()) {
                                psBlock.Join(psTestBlock, bUpdateModel)
                            }
                        }
                        if (i < this.m_dwTilesWide - 1) {
                            var psTestBlock = this.m_papsBlocks[l + EntityBoard_adwMoveOffset[3]];
                            if (psBlock.m_psRight === null && psTestBlock && psTestBlock.GetColour() === psBlock.GetColour()) {
                                psBlock.Join(psTestBlock, bUpdateModel)
                            }
                        }
                    }
                }
            }
        },
        TestObjective: function(bCeremony) {
            var i, psBlock;
            for (i = 0; i < this.m_apBlocks.length; i += 1) {
                psBlock = this.m_apBlocks[i];
                psBlock.MarkMove(true, false)
            }
            var dwClumpCount = [];
            for (i = 0; i < 4; i += 1) {
                dwClumpCount[i] = 0
            }
            for (i = 0; i < this.m_apBlocks.length; i += 1) {
                psBlock = this.m_apBlocks[i];
                if (psBlock.GetMark()) {
                    psBlock.MarkMove(false, true);
                    dwClumpCount[psBlock.GetColour()] += 1
                }
            }
            for (i = 0; i < ENTITYBLOCK_COLOUR_WHITE_A; i += 1) {
                if (this.m_abJoinColour[i] && !this.m_abColourJoined[i] && dwClumpCount[i] === 1) {
                    this.m_abColourJoined[i] = true;
                    this.m_psHud.JoinComplete(i, bCeremony);
                    for (var j = 0; j < this.m_apBlocks.length; j += 1) {
                        psBlock = this.m_apBlocks[j];
                        if (psBlock.GetColour() === i) {
                            if (bCeremony) {
                                psBlock.SetState(ENTITYBLOCK_STATE_COMPLETE_CEREMONY)
                            } else {
                                psBlock.SetState(ENTITYBLOCK_STATE_COMPLETE_HIDDEN)
                            }
                        }
                    }
                    if (this.m_psColourSolvedCallBack) {
                        this.m_psColourSolvedCallBack(i, false, bCeremony)
                    }
                    if (bCeremony) {
                        this.m_bLastMoveObjectiveComplete = true
                    }
                }
            }
            if (this.m_bMakeShape && !this.m_bShapeMade) {
                var bNoShape = false;
                var x = 0,
                    y = 0;
                for (y = 1 - ENTITYBOARD_MAKE_HEIGHT; y < this.m_dwTilesHigh - 1; y += 1) {
                    for (x = 1 - ENTITYBOARD_MAKE_WIDTH; x < this.m_dwTilesWide - 1; x += 1) {
                        bNoShape = false;
                        for (var j = 0; j < ENTITYBOARD_MAKE_HEIGHT; j += 1) {
                            for (var i = 0; i < ENTITYBOARD_MAKE_WIDTH; i += 1) {
                                var k = j * ENTITYBOARD_MAKE_WIDTH + i;
                                if (this.m_padwMakeShape[k] !== ENTITYBLOCK_COLOUR_TOTAL) {
                                    if (x + i >= 0 && y + j >= 0 && x + i < this.m_dwTilesWide && y + j < this.m_dwTilesHigh) {
                                        var l = (y + j) * this.m_dwTilesWide + (x + i);
                                        if (!this.m_papsBlocks[l] || this.m_papsBlocks[l].GetColour() !== this.m_padwMakeShape[k]) {
                                            bNoShape = true;
                                            break
                                        }
                                    } else {
                                        bNoShape = true;
                                        break
                                    }
                                }
                            }
                            if (bNoShape) {
                                break
                            }
                        }
                        if (!bNoShape) {
                            break
                        }
                    }
                    if (!bNoShape) {
                        break
                    }
                }
                if (!bNoShape) {
                    for (var j = 0; j < ENTITYBOARD_MAKE_HEIGHT; j += 1) {
                        for (var i = 0; i < ENTITYBOARD_MAKE_WIDTH; i += 1) {
                            if (x + i >= 0 && y + j >= 0 && x + i < this.m_dwTilesWide && y + j < this.m_dwTilesHigh) {
                                var k = j * ENTITYBOARD_MAKE_WIDTH + i;
                                var l = (y + j) * this.m_dwTilesWide + (x + i);
                                if (this.m_padwMakeShape[k] !== ENTITYBLOCK_COLOUR_TOTAL) {
                                    if (this.m_papsBlocks[l] && this.m_papsBlocks[l].GetColour() === this.m_padwMakeShape[k]) {
                                        if (bCeremony) {
                                            this.m_papsBlocks[l].SetState(ENTITYBLOCK_STATE_COMPLETE_CEREMONY)
                                        } else {
                                            this.m_papsBlocks[l].SetState(ENTITYBLOCK_STATE_COMPLETE_HIDDEN)
                                        }
                                    }
                                }
                            }
                        }
                    }
                    this.m_bShapeMade = true;
                    this.m_psHud.ShapeComplete(bCeremony);
                    if (this.m_psColourSolvedCallBack) {
                        this.m_psColourSolvedCallBack(-1, false, bCeremony)
                    }
                    if (bCeremony) {
                        this.m_bLastMoveObjectiveComplete = true
                    }
                }
            }
        },
        EndCompleteCeremony: function() {
            for (var j = 0; j < this.m_apBlocks.length; j += 1) {
                var psBlock = this.m_apBlocks[j];
                if (psBlock.GetState() === ENTITYBLOCK_STATE_COMPLETE_CEREMONY) {
                    psBlock.SetState(ENTITYBLOCK_STATE_COMPLETE)
                }
            }
        },
        GetComplete: function() {
            for (var i = 0; i < ENTITYBLOCK_COLOUR_WHITE_A; i += 1) {
                if (this.m_abJoinColour[i] && !this.m_abColourJoined[i]) {
                    return false
                }
            }
            return true
        },
        GetColourComplete: function() {
            var bComplete = this.m_bLastMoveObjectiveComplete;
            this.m_bLastMoveObjectiveComplete = false;
            return bComplete
        },
        TestSameShape: function(psShape1, psShape2) {
            var dwWidth = psShape1.x2 - psShape1.x + 1;
            var dwHeight = psShape1.y2 - psShape1.y + 1;
            if (dwWidth !== psShape2.x2 - psShape2.x + 1 || dwHeight !== psShape2.y2 - psShape2.y + 1) {
                return false
            }
            for (var y = 0; y < dwHeight; y += 1) {
                for (var x = 0; x < dwWidth; x += 1) {
                    var psBlock = this.m_papsBlocks[(y + psShape1.y) * this.m_dwTilesWide + (x + psShape1.x)];
                    if (psBlock && psBlock.GetColour() === psShape1.dwColour) {
                        psBlock = this.m_papsBlocks[(y + psShape2.y) * this.m_dwTilesWide + (x + psShape2.x)];
                        if (psBlock === null || psBlock.GetColour() !== psShape2.dwColour) {
                            return false
                        }
                    }
                }
            }
            return true
        },
        GetNumSameShapes: function() {
            var asShapes = [{
                x: this.m_dwTilesWide,
                y: this.m_dwTilesHigh,
                x2: 0,
                y2: 0,
                dwColour: 0
            }, {
                x: this.m_dwTilesWide,
                y: this.m_dwTilesHigh,
                x2: 0,
                y2: 0,
                dwColour: 1
            }, {
                x: this.m_dwTilesWide,
                y: this.m_dwTilesHigh,
                x2: 0,
                y2: 0,
                dwColour: 2
            }, {
                x: this.m_dwTilesWide,
                y: this.m_dwTilesHigh,
                x2: 0,
                y2: 0,
                dwColour: 3
            }];
            for (var y = 1; y < this.m_dwTilesHigh - 1; y += 1) {
                for (var x = 1; x < this.m_dwTilesWide - 1; x += 1) {
                    var psBlock = this.m_papsBlocks[y * this.m_dwTilesWide + x];
                    if (psBlock && psBlock.GetColour() < ENTITYBLOCK_COLOUR_WHITE_A) {
                        var dwColour = psBlock.GetColour();
                        if (psBlock.m_dwTileX < asShapes[dwColour].x) {
                            asShapes[dwColour].x = psBlock.m_dwTileX
                        }
                        if (psBlock.m_dwTileX > asShapes[dwColour].x2) {
                            asShapes[dwColour].x2 = psBlock.m_dwTileX
                        }
                        if (psBlock.m_dwTileY < asShapes[dwColour].y) {
                            asShapes[dwColour].y = psBlock.m_dwTileY
                        }
                        if (psBlock.m_dwTileY > asShapes[dwColour].y2) {
                            asShapes[dwColour].y2 = psBlock.m_dwTileY
                        }
                    }
                }
            }
            var dwNumSame = 1;
            for (var i = 0; i < 4 - 1; i += 1) {
                for (var j = i + 1; j < 4; j += 1) {
                    if (asShapes[i].x !== this.m_dwTilesWide && asShapes[j].x !== this.m_dwTilesWide && this.TestSameShape(asShapes[i], asShapes[j])) {
                        dwNumSame += 1
                    }
                }
            }
            if (dwNumSame === 4) {
                dwNumSame = 3
            }
            return dwNumSame
        },
        Move: function(eDirection) {
            if (this.dwState !== ENTITYBOARD_STATE_WAIT) {
                return false
            }
            if (eDirection === ENTITYBLOCK_MOVE_TOTAL) {
                this.m_bAttemptMove = false;
                this.m_bRepeat = false;
                for (var i = 0; i < this.m_apBlocks.length; i += 1) {
                    if (this.m_apBlocks[i] && this.m_apBlocks[i].GetColour() !== ENTITYBLOCK_COLOUR_WHITE_A && this.m_apBlocks[i].GetColour() !== ENTITYBLOCK_COLOUR_WHITE_B && this.m_apBlocks[i].GetColour() !== ENTITYBLOCK_COLOUR_WHITE_D) {
                        this.m_apBlocks[i].m_bImpact = false
                    }
                }
                return false
            }
            var bBlocksMoved = false;
            if (this.dwState === ENTITYBOARD_STATE_WAIT) {
                for (var i = 0; i < this.m_apBlocks.length; i += 1) {
                    var psBlock = this.m_apBlocks[i];
                    psBlock.MarkMove(true, false)
                }
                var bBlocked;
                do {
                    bBlocked = false;
                    for (var i = 0; i < this.m_apBlocks.length; i += 1) {
                        var psBlock = this.m_apBlocks[i];
                        if (psBlock.GetMark()) {
                            var l = psBlock.m_dwTileY * this.m_dwTilesWide + psBlock.m_dwTileX;
                            var psTestBlock = this.m_papsBlocks[l + EntityBoard_adwMoveOffset[eDirection]];
                            if (psTestBlock && !psTestBlock.GetMark()) {
                                psBlock.MarkMove(false, true);
                                bBlocked = true
                            }
                        }
                    }
                } while (bBlocked);
                for (var i = 0; i < this.m_apBlocks.length; i += 1) {
                    var psBlock = this.m_apBlocks[i];
                    if (psBlock.GetMark()) {
                        bBlocksMoved = true;
                        break
                    }
                }
                if (bBlocksMoved) {
                    for (var j = ENTITYBOARD_NUM_UNDO - 1; j > 0; j -= 1) {
                        for (var i = 0; i < this.m_dwTilesWide * this.m_dwTilesHigh; i += 1) {
                            this.m_papsUndoBlocks[j][i] = this.m_papsUndoBlocks[j - 1][i]
                        }
                    }
                    for (var i = 0; i < this.m_dwTilesWide * this.m_dwTilesHigh; i += 1) {
                        this.m_papsUndoBlocks[0][i] = this.m_papsBlocks[i]
                    }
                    if (this.m_dwNumUndoLeft < ENTITYBOARD_NUM_UNDO) {
                        this.m_dwNumUndoLeft += 1
                    }
                }
                for (var i = 0; i < this.m_apBlocks.length; i += 1) {
                    var psBlock = this.m_apBlocks[i];
                    if (psBlock.GetMark()) {
                        var l = psBlock.m_dwTileY * this.m_dwTilesWide + psBlock.m_dwTileX;
                        this.m_papsBlocks[l] = null
                    }
                }
                var bImpact = false;
                for (var i = 0; i < this.m_apBlocks.length; i += 1) {
                    var psBlock = this.m_apBlocks[i];
                    if (psBlock.GetMark()) {
                        psBlock.Move(eDirection);
                        var l = psBlock.m_dwTileY * this.m_dwTilesWide + psBlock.m_dwTileX;
                        this.m_papsBlocks[l] = psBlock
                    } else {
                        if (!psBlock.m_bImpact) {
                            bImpact = true;
                            var l = psBlock.m_dwTileY * this.m_dwTilesWide + psBlock.m_dwTileX;
                            var psTestBlock = this.m_papsBlocks[l + EntityBoard_adwMoveOffset[eDirection]];
                            psBlock.m_eMoveDirection = eDirection;
                            if (psTestBlock && psTestBlock.GetColour() >= ENTITYBLOCK_COLOUR_WHITE_A) {
                                psBlock.SetState(ENTITYBLOCK_STATE_IMPACT)
                            } else {
                                psBlock.SetState(ENTITYBLOCK_STATE_IMPACT_MOVE)
                            }
                            psBlock.m_bImpact = true
                        }
                    }
                }
                if (bBlocksMoved) {
                    this.m_eMoveDirection = eDirection;
                    if (this.m_bAttemptMove) {
                        this.m_bRepeat = true
                    }
                    this.m_dwMoves += 1;
                    if (this.m_dwMoves > 999) {
                        this.m_dwMoves = 999
                    }
                    this.m_psHud.SetMoves(this.m_dwMoves);
                    this.SetState(ENTITYBOARD_STATE_MOVE_1);
                    if (!this.m_bRepeat) {
                        Helpers.PlaySound("Motion")
                    } else {
                        Helpers.PlaySound("MotionRepeat")
                    }
                    if (bImpact) {
                        Helpers.PlaySoundDetailed("Impact", 0, 1, 3 / 4, false, null)
                    }
                } else {
                    this.SetState(ENTITYBOARD_STATE_IMPACT);
                    if (bImpact) {
                        Helpers.PlaySound("Impact")
                    }
                }
            }
            this.m_bAttemptMove = true;
            return bBlocksMoved
        },
        Complete: function() {
            for (var i = 0; i < ENTITYBLOCK_COLOUR_WHITE_A; i += 1) {
                if (this.m_abJoinColour[i] && !this.m_abColourJoined[i]) {
                    this.m_abColourJoined[i] = true;
                    if (this.m_psColourSolvedCallBack) {
                        this.m_psColourSolvedCallBack(i, false, true)
                    }
                }
            }
            if (this.m_bMakeShape) {
                if (!this.m_bShapeMade) {
                    this.m_bShapeMade = true;
                    if (this.m_psColourSolvedCallBack) {
                        this.m_psColourSolvedCallBack(-1, false, true)
                    }
                }
            }
        },
        Update: function() {
            if (this.dwState !== ENTITYBOARD_STATE_MOVE_TO && this.dwState !== ENTITYBOARD_STATE_HOLD) {
                this.m_dwTime += 1;
                if (this.m_dwTime > 359999) {
                    this.m_dwTime = 359999
                }
                this.m_psHud.SetTime(this.m_dwTime)
            }
            switch (this.dwState) {
                case ENTITYBOARD_STATE_MOVE_TO:
                    if (!Script.Process(this.m_psScript, this.m_psScriptList, null)) {
                        this.m_psScript = null;
                        this.SetState(ENTITYBOARD_STATE_HOLD)
                    }
                    break;
                case ENTITYBOARD_STATE_MOVE_1:
                    this.dwStateTimer -= 1;
                    if (this.dwStateTimer === 0) {
                        this.TestJoin(true);
                        this.SetState(ENTITYBOARD_STATE_MOVE_2)
                    }
                    break;
                case ENTITYBOARD_STATE_MOVE_2:
                    this.dwStateTimer -= 1;
                    if (this.dwStateTimer === 0) {
                        this.TestObjective(true);
                        this.SetState(ENTITYBOARD_STATE_WAIT)
                    }
                    break;
                case ENTITYBOARD_STATE_IMPACT:
                    this.dwStateTimer -= 1;
                    if (this.dwStateTimer === 0) {
                        this.SetState(ENTITYBOARD_STATE_WAIT)
                    }
                    break
            }
        },
        Undo: function() {
            if (this.m_dwNumUndoLeft) {
                for (var j = 0; j < this.m_dwTilesHigh; j += 1) {
                    for (var i = 0; i < this.m_dwTilesWide; i += 1) {
                        var k = j * this.m_dwTilesWide + i;
                        this.m_papsBlocks[k] = this.m_papsUndoBlocks[0][k];
                        if (this.m_papsBlocks[k] && this.m_papsBlocks[k].GetColour() !== ENTITYBLOCK_COLOUR_WHITE_A && this.m_papsBlocks[k].GetColour() !== ENTITYBLOCK_COLOUR_WHITE_B && this.m_papsBlocks[k].GetColour() !== ENTITYBLOCK_COLOUR_WHITE_D) {
                            this.m_papsBlocks[k].m_psSprite.SetPosition(i * this.m_fTileWidth, j * this.m_fTileHeight);
                            this.m_papsBlocks[k].m_dwTileX = i;
                            this.m_papsBlocks[k].m_dwTileY = j;
                            this.m_papsBlocks[k].m_psUp = null;
                            this.m_papsBlocks[k].m_psDown = null;
                            this.m_papsBlocks[k].m_psLeft = null;
                            this.m_papsBlocks[k].m_psRight = null;
                            this.m_papsBlocks[k].SetComplete(false, false);
                            this.m_papsBlocks[k].CalcImage()
                        }
                    }
                }
                for (i = 0; i < 4; i += 1) {
                    this.m_abColourJoined[i] = 0
                }
                this.m_bShapeMade = false;
                this.m_psHud.ResetObjective();
                this.TestJoin(false);
                this.TestObjective(false);
                for (var j = 0; j < ENTITYBOARD_NUM_UNDO - 1; j += 1) {
                    for (var i = 0; i < this.m_dwTilesWide * this.m_dwTilesHigh; i += 1) {
                        this.m_papsUndoBlocks[j][i] = this.m_papsUndoBlocks[j + 1][i]
                    }
                }
                Helpers.PlaySound("Undo");
                this.m_dwNumUndoLeft -= 1;
                this.m_dwMoves += 1;
                if (this.m_dwMoves > 999) {
                    this.m_dwMoves = 999
                }
                this.m_psHud.SetMoves(this.m_dwMoves)
            }
        },
        Reset: function() {
            for (var j = 0; j < this.m_dwTilesHigh; j += 1) {
                for (var i = 0; i < this.m_dwTilesWide; i += 1) {
                    var k = j * this.m_dwTilesWide + i;
                    if (this.m_papsBlocks[k] && this.m_papsBlocks[k].GetColour() !== ENTITYBLOCK_COLOUR_WHITE_A && this.m_papsBlocks[k].GetColour() !== ENTITYBLOCK_COLOUR_WHITE_B && this.m_papsBlocks[k].GetColour() !== ENTITYBLOCK_COLOUR_WHITE_D) {
                        this.m_papsBlocks[k] = null
                    }
                }
            }
            for (var i = 0; i < this.m_apBlocks.length; i += 1) {
                var psBlock = this.m_apBlocks[i];
                psBlock.m_psSprite.SetPosition(psBlock.m_dwStartTileX * this.m_fTileWidth, psBlock.m_dwStartTileY * this.m_fTileHeight);
                psBlock.m_dwTileX = psBlock.m_dwStartTileX;
                psBlock.m_dwTileY = psBlock.m_dwStartTileY;
                psBlock.m_psUp = null;
                psBlock.m_psDown = null;
                psBlock.m_psLeft = null;
                psBlock.m_psRight = null;
                psBlock.SetComplete(false, false);
                psBlock.CalcImage();
                psBlock.m_psShadow.SetOpacity(255 / 255);
                var k = psBlock.m_dwStartTileY * this.m_dwTilesWide + psBlock.m_dwStartTileX;
                this.m_papsBlocks[k] = psBlock
            }
            for (i = 0; i < 4; i += 1) {
                this.m_abColourJoined[i] = 0
            }
            this.m_bShapeMade = false;
            this.m_psHud.ResetObjective();
            this.m_dwMoves = 0;
            this.m_psHud.SetMoves(this.m_dwMoves);
            this.m_dwTime = 0;
            this.m_psHud.SetTime(this.m_dwTime);
            this.TestJoin(false);
            this.TestObjective(false);
            Helpers.PlaySound("Reset");
            this.m_dwNumUndoLeft = 0
        },
        MoveTo: function(x, y, fScaleX, fScaleY, dwFrames) {
            this.SetState(ENTITYBOARD_STATE_MOVE_TO);
            this.m_psScript = Script.New(ScriptData.MoveBoard);
            Script.SetLocalVariable(this.m_psScript, SCRIPT_LOCAL_VARIABLE_1, this.m_psRoot);
            Script.SetLocalVariable(this.m_psScript, SCRIPT_LOCAL_VARIABLE_2, x * 256);
            Script.SetLocalVariable(this.m_psScript, SCRIPT_LOCAL_VARIABLE_3, y * 256);
            Script.SetLocalVariable(this.m_psScript, SCRIPT_LOCAL_VARIABLE_4, fScaleX * 100);
            Script.SetLocalVariable(this.m_psScript, SCRIPT_LOCAL_VARIABLE_5, fScaleY * 100);
            Script.SetLocalVariable(this.m_psScript, SCRIPT_LOCAL_VARIABLE_6, dwFrames)
        },
        SetPosition: function(x, y, fScaleX, fScaleY) {
            this.m_psRoot.SetPosition(x, y);
            this.m_psRoot.SetScale(fScaleX, fScaleY)
        },
        ShowHud: function(bShow) {
            this.m_psHud.SetActive(bShow)
        },
        CalcChallengeComplete: function() {
            var dwLevel = LevelSelect.GetLevelNumber();
            switch (LevelData_asData[dwLevel].dwBonusType) {
                case BONUS_TYPE_TWO:
                    if (this.GetNumSameShapes() === 2) {
                        this.m_bChallengeDone = true
                    }
                    break;
                case BONUS_TYPE_THREE:
                    if (this.GetNumSameShapes() === 3) {
                        this.m_bChallengeDone = true
                    }
                    break;
                case BONUS_TYPE_TIME:
                    if (this.GetTime() / 60 <= LevelData_asData[dwLevel].dwParTime) {
                        this.m_bChallengeDone = true
                    }
                    break;
                case BONUS_TYPE_MOVES:
                    if (this.GetMoves() <= LevelData_asData[dwLevel].dwParMoves) {
                        this.m_bChallengeDone = true
                    }
                    break;
                case BONUS_TYPE_SHAPE:
                    if (this.m_bShapeMade) {
                        this.m_bChallengeDone = true
                    }
                    break
            }
        },
        GetMakeShapeInfo: function() {
            var Object = {};
            if (this.m_bMakeShape) {
                var x1 = ENTITYBOARD_MAKE_WIDTH,
                    x2 = 0;
                var y1 = ENTITYBOARD_MAKE_HEIGHT,
                    y2 = 0;
                for (var j = 0; j < ENTITYBOARD_MAKE_HEIGHT; j += 1) {
                    for (var i = 0; i < ENTITYBOARD_MAKE_WIDTH; i += 1) {
                        if (this.m_padwMakeShape[j * ENTITYBOARD_MAKE_WIDTH + i] !== ENTITYBLOCK_COLOUR_TOTAL) {
                            if (i < x1) {
                                x1 = i
                            }
                            if (i > x2) {
                                x2 = i
                            }
                            if (j < y1) {
                                y1 = j
                            }
                            if (j > y2) {
                                y2 = j
                            }
                        }
                    }
                }
                Object.x = x1;
                Object.y = y1;
                Object.dwWidth = x2 - x1 + 1;
                Object.dwHeight = y2 - y1 + 1
            } else {
                Object.x = 0;
                Object.y = 0;
                Object.dwWidth = 0;
                Object.dwHeight = 0
            }
            return Object
        },
        GetNumUndos: function() {
            return this.m_dwNumUndoLeft
        },
        GetMoves: function() {
            return this.m_dwMoves
        },
        GetTime: function() {
            return this.m_dwTime
        },
        SetChallengeComplete: function() {
            this.m_bChallengeDone = true
        },
        GetChallengeComplete: function() {
            return this.m_bChallengeDone
        }
    };
    EntityBoard.Create = function(x, y, dwTilesWide, dwTilesHigh, fTileWidth, fTileHeight, psParent) {
        var NewObject = EntityBase.Create(x, y, "NewBlank", EA.Default, psParent);
        NewObject.GetNumUndos = EntityBoard.prototype.GetNumUndos;
        NewObject.GetMoves = EntityBoard.prototype.GetMoves;
        NewObject.GetTime = EntityBoard.prototype.GetTime;
        NewObject.SetChallengeComplete = EntityBoard.prototype.SetChallengeComplete;
        NewObject.GetChallengeComplete = EntityBoard.prototype.GetChallengeComplete;
        NewObject.RemoveColouredBlocks = EntityBoard.prototype.RemoveColouredBlocks;
        NewObject.AddColouredBlock = EntityBoard.prototype.AddColouredBlock;
        NewObject.AddWhiteBlock = EntityBoard.prototype.AddWhiteBlock;
        NewObject.RenderWhiteBlockShadows = EntityBoard.prototype.RenderWhiteBlockShadows;
        NewObject.LoadLevelByData = EntityBoard.prototype.LoadLevelByData;
        NewObject.LoadLevelByName = EntityBoard.prototype.LoadLevelByName;
        NewObject.LoadLevelByID = EntityBoard.prototype.LoadLevelByID;
        NewObject.SetState = EntityBoard.prototype.SetState;
        NewObject.TestJoin = EntityBoard.prototype.TestJoin;
        NewObject.TestObjective = EntityBoard.prototype.TestObjective;
        NewObject.EndCompleteCeremony = EntityBoard.prototype.EndCompleteCeremony;
        NewObject.GetComplete = EntityBoard.prototype.GetComplete;
        NewObject.GetColourComplete = EntityBoard.prototype.GetColourComplete;
        NewObject.TestSameShape = EntityBoard.prototype.TestSameShape;
        NewObject.GetNumSameShapes = EntityBoard.prototype.GetNumSameShapes;
        NewObject.Move = EntityBoard.prototype.Move;
        NewObject.Complete = EntityBoard.prototype.Complete;
        NewObject.Undo = EntityBoard.prototype.Undo;
        NewObject.Reset = EntityBoard.prototype.Reset;
        NewObject.MoveTo = EntityBoard.prototype.MoveTo;
        NewObject.SetPosition = EntityBoard.prototype.SetPosition;
        NewObject.ShowHud = EntityBoard.prototype.ShowHud;
        NewObject.CalcChallengeComplete = EntityBoard.prototype.CalcChallengeComplete;
        NewObject.GetMakeShapeInfo = EntityBoard.prototype.GetMakeShapeInfo;
        NewObject.Destroy = EntityBoard.prototype.Destroy;
        NewObject.Update = EntityBoard.prototype.Update;
        NewObject.m_dwType = ENTITYMANAGER_TYPE_BOARD;
        NewObject.m_dwTilesWide = dwTilesWide;
        NewObject.m_dwTilesHigh = dwTilesHigh;
        NewObject.m_fTileWidth = fTileWidth;
        NewObject.m_fTileHeight = fTileHeight;
        EntityBoard_adwMoveOffset[0] = -dwTilesWide;
        EntityBoard_adwMoveOffset[1] = dwTilesWide;
        EntityBoard_adwMoveOffset[2] = -1;
        EntityBoard_adwMoveOffset[3] = 1;
        NewObject.m_dwNumUndoLeft = 0;
        NewObject.m_abJoinColour = [];
        NewObject.m_abColourJoined = [];
        var i;
        for (i = 0; i < 4; i += 1) {
            NewObject.m_abJoinColour[i] = 0;
            NewObject.m_abColourJoined[i] = 0
        }
        NewObject.m_bMakeShape = false;
        NewObject.m_bShapeMade = false;
        NewObject.m_padwMakeShape = null;
        NewObject.m_bMoved = false;
        NewObject.m_bAttemptMove = false;
        NewObject.m_bRepeat = false;
        NewObject.m_dwMoves = 0;
        NewObject.m_dwTime = 0;
        NewObject.m_bLastMoveObjectiveComplete = false;
        NewObject.OldSprite = NewObject.m_psSprite;
        NewObject.m_psSprite = Helpers.CreateTree(0, 0, psParent);
        NewObject.m_psRoot = Helpers.CreateTree(0, 0, NewObject.m_psSprite);
        NewObject.m_psBackground = Helpers.CreateSprite(0, 0, EA.Default, "NewBlank", NewObject.m_psRoot);
        NewObject.m_apBlocks = [];
        NewObject.m_papsBlocks = [];
        NewObject.m_papsUndoBlocks = [];
        for (i = 0; i < ENTITYBOARD_NUM_UNDO; i += 1) {
            NewObject.m_papsUndoBlocks[i] = []
        }
        NewObject.m_psShadowRoot = Helpers.CreateTree(0, 0, NewObject.m_psRoot);
        NewObject.m_psShadowRoot.SetPosition(-(dwTilesWide * fTileWidth) / 2, -(dwTilesHigh * fTileHeight) / 2);
        NewObject.m_psBlockRoot = Helpers.CreateTree(0, 0, NewObject.m_psRoot);
        NewObject.m_psBlockRoot.SetPosition(-(dwTilesWide * fTileWidth) / 2, -(dwTilesHigh * fTileHeight) / 2);
        NewObject.m_psHud = EntityHud.Create(NewObject, NewObject.m_psSprite);
        EntityManager.Add(NewObject.m_psHud);
        NewObject.dwState = ENTITYBOARD_STATE_WAIT;
        NewObject.m_psColourSolvedCallBack = null;
        NewObject.m_bChallengeDone = false;
        return NewObject
    };

    function EntityCounter() {}
    EntityCounter.prototype = {
        Destroy: function() {
            Helpers.DestroyBitmapText(this.m_psText);
            this.m_psText = null;
            EntityBase.Destroy(this)
        },
        Start: function(dwEnd, dwDelay) {
            this.m_fEnd = dwEnd;
            if (this.m_fEnd === this.m_fStart) {
                this.m_dwDelay = 0
            } else {
                this.m_dwDelay = dwDelay;
                this.m_fDelta = (this.m_fEnd - this.m_fStart) / dwDelay
            }
        },
        SetValue: function(dwValue, bStop, bStart) {
            var achTemp = "" + Math.floor(dwValue);
            achTemp = Misc.InsertCommasIntoNumberString(achTemp);
            this.m_psText.SetText(achTemp);
            if (bStart) {
                this.m_fStart = dwValue
            }
            this.m_fCurrent = dwValue;
            if (bStop) {
                this.m_dwDelay = 0
            }
        },
        Update: function() {
            if (this.m_dwDelay) {
                if (!Helpers.GetIsSoundPlaying("ScoreCount")) {
                    Helpers.PlaySound("ScoreCount")
                }
                var fPitch = (this.m_fCurrent - this.m_fStart) / (this.m_fEnd - this.m_fStart);
                Helpers.SetSoundPitch("ScoreCount", fPitch);
                this.m_fCurrent += this.m_fDelta;
                this.m_dwDelay -= 1;
                if (this.m_dwDelay === 0) {
                    this.m_fCurrent = this.m_fEnd
                }
                this.SetValue(this.m_fCurrent, false, false)
            }
        },
        GetIsFinished: function() {
            if (this.m_dwDelay) {
                return false
            } else {
                return true
            }
        }
    };
    EntityCounter.Create = function(x, y, dwStart, psParent) {
        var NewObject = EntityBase.Create(x, y, "NewBlank", EA.TopLeft, psParent);
        NewObject.Start = EntityCounter.prototype.Start;
        NewObject.SetValue = EntityCounter.prototype.SetValue;
        NewObject.GetIsFinished = EntityCounter.prototype.GetIsFinished;
        NewObject.Destroy = EntityCounter.prototype.Destroy;
        NewObject.Update = EntityCounter.prototype.Update;
        NewObject.m_dwType = ENTITYMANAGER_TYPE_COUNTER;
        NewObject.m_dwDelay = 0;
        NewObject.m_psText = Helpers.CreateBitmapText("0", x, y, EA.MiddleLeft, "PanelFont", psParent);
        NewObject.m_psText.SetScale(.75, .75);
        NewObject.SetValue(dwStart, true, true);
        return NewObject
    };
    var ENTITYEFFECT_TYPE_COVER_1 = 0;
    var ENTITYEFFECT_TYPE_COVER_2 = 1;
    var ENTITYEFFECT_TYPE_COVER_3 = 2;
    var ENTITYEFFECT_TYPE_COVER_4 = 3;
    var ENTITYEFFECT_TYPE_JOIN_H = 4;
    var ENTITYEFFECT_TYPE_JOIN_V = 5;
    var ENTITYEFFECT_TYPE_SPARKLE = 6;
    var ENTITYEFFECT_TYPE_STATIC_SPARKLE = 7;
    var ENTITYEFFECT_TYPE_SCREEN_FLASH = 8;
    var ENTITYEFFECT_TYPE_SCREEN_FLASH_LONG = 9;
    var ENTITYEFFECT_TYPE_SCREEN_FLASH_LONGER = 10;
    var ENTITYEFFECT_TYPE_SMOKE = 11;
    var ENTITYEFFECT_TYPE_FAIRY = 12;
    var ENTITYEFFECT_TYPE_TOTAL = 13;
    var COVER_DELAY = 30;
    var JOIN_DELAY = 10;
    var SPARKLE_DELAY = 30;

    function EntityEffect() {}
    var EntityEffect_adwImages = ["NewBlank", "NewBlank", "NewBlank", "NewBlank", "EffectJoin", "EffectJoin", "EffectSparkle", "EffectSparkle", "NewWhite", "NewWhite", "NewWhite", "Smoke", "Fairy01"];
    ScriptData.Cover = [SCRIPT_INSTRUCTION_OBJECT_CREATE_SPRITE, 5, 0, SCRIPT_LOCAL_VARIABLE_1, 0, 0, EA.Default, SCRIPT_INSTRUCTION_WAIT, 1, 30, SCRIPT_INSTRUCTION_OBJECT_ALPHA_TO, 3, 0, 0, 20, SCRIPT_INSTRUCTION_WAIT, 1, 20, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 0, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.JoinH = [SCRIPT_INSTRUCTION_OBJECT_CREATE_SPRITE, 5, 0, SCRIPT_LOCAL_VARIABLE_1, 0, 0, EA.Default, SCRIPT_INSTRUCTION_OBJECT_SCALE_SET, 3, 0, 120, 120, SCRIPT_INSTRUCTION_WAIT, 1, 5, SCRIPT_INSTRUCTION_OBJECT_ALPHA_TO, 3, 0, 0, JOIN_DELAY - 5, SCRIPT_INSTRUCTION_WAIT, 1, JOIN_DELAY - 5, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 0, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.JoinV = [SCRIPT_INSTRUCTION_OBJECT_CREATE_SPRITE, 5, 0, SCRIPT_LOCAL_VARIABLE_1, 0, 0, EA.Default, SCRIPT_INSTRUCTION_OBJECT_SCALE_SET, 3, 0, 120, 120, SCRIPT_INSTRUCTION_OBJECT_ROTATE_SET, 2, 0, 90, SCRIPT_INSTRUCTION_WAIT, 1, 5, SCRIPT_INSTRUCTION_OBJECT_ALPHA_TO, 3, 0, 0, JOIN_DELAY - 5, SCRIPT_INSTRUCTION_WAIT, 1, JOIN_DELAY - 5, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 0, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.Sparkle = [SCRIPT_INSTRUCTION_OBJECT_CREATE_SPRITE, 5, 0, SCRIPT_LOCAL_VARIABLE_1, 0, 0, EA.Default, SCRIPT_INSTRUCTION_OBJECT_SCALE_SET, 3, 0, SCRIPT_LOCAL_VARIABLE_3, SCRIPT_LOCAL_VARIABLE_3, SCRIPT_INSTRUCTION_OBJECT_SCALE_TO, 4, 0, 0, 0, SPARKLE_DELAY, SCRIPT_INSTRUCTION_WAIT, 1, SPARKLE_DELAY, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 0, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.StaticSparkle = [SCRIPT_INSTRUCTION_OBJECT_CREATE_SPRITE, 5, 0, SCRIPT_LOCAL_VARIABLE_1, 0, 0, EA.Default, SCRIPT_INSTRUCTION_OBJECT_SCALE_SET, 3, 0, SCRIPT_LOCAL_VARIABLE_3, SCRIPT_LOCAL_VARIABLE_3, SCRIPT_INSTRUCTION_OBJECT_SCALE_TO, 4, 0, 0, 0, 5, SCRIPT_INSTRUCTION_WAIT, 1, 5, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 0, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.ScreenFlash = [SCRIPT_INSTRUCTION_OBJECT_CREATE_SPRITE, 5, 0, SCRIPT_LOCAL_VARIABLE_1, 0, 0, EA.Default, SCRIPT_INSTRUCTION_OBJECT_SCALE_SET, 3, 0, SCREEN_WIDTH << 8, SCREEN_HEIGHT << 8, SCRIPT_INSTRUCTION_OBJECT_ALPHA_SET, 2, 0, 255, SCRIPT_INSTRUCTION_OBJECT_ALPHA_TO, 3, 0, 0, 20, SCRIPT_INSTRUCTION_WAIT, 1, 20, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 0, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.ScreenFlashLong = [SCRIPT_INSTRUCTION_OBJECT_CREATE_SPRITE, 5, 0, SCRIPT_LOCAL_VARIABLE_1, 0, 0, EA.Default, SCRIPT_INSTRUCTION_OBJECT_SCALE_SET, 3, 0, SCREEN_WIDTH << 8, SCREEN_HEIGHT << 8, SCRIPT_INSTRUCTION_OBJECT_ALPHA_SET, 2, 0, 255, SCRIPT_INSTRUCTION_OBJECT_ALPHA_TO, 3, 0, 0, 40, SCRIPT_INSTRUCTION_WAIT, 1, 60, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 0, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.ScreenFlashLonger = [SCRIPT_INSTRUCTION_OBJECT_CREATE_SPRITE, 5, 0, SCRIPT_LOCAL_VARIABLE_1, 0, 0, EA.Default, SCRIPT_INSTRUCTION_OBJECT_SCALE_SET, 3, 0, SCREEN_WIDTH << 8, SCREEN_HEIGHT << 8, SCRIPT_INSTRUCTION_OBJECT_ALPHA_SET, 2, 0, 255, SCRIPT_INSTRUCTION_OBJECT_ALPHA_TO, 3, 0, 0, 120, SCRIPT_INSTRUCTION_WAIT, 1, 600, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 0, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.Smoke = [SCRIPT_INSTRUCTION_OBJECT_CREATE_SPRITE, 5, 0, SCRIPT_LOCAL_VARIABLE_1, 0, 0, EA.Default, SCRIPT_INSTRUCTION_OBJECT_SCALE_SET, 3, 0, 0, 0, SCRIPT_INSTRUCTION_OBJECT_ALPHA_SET, 2, 0, 200, SCRIPT_INSTRUCTION_OBJECT_SCALE_TO_EASE, 6, 0, SCRIPT_LOCAL_VARIABLE_2, SCRIPT_LOCAL_VARIABLE_2, true, false, 10, SCRIPT_INSTRUCTION_WAIT, 1, 10, SCRIPT_INSTRUCTION_OBJECT_SCALE_TO, 4, 0, SCRIPT_LOCAL_VARIABLE_3, SCRIPT_LOCAL_VARIABLE_3, 1, SCRIPT_INSTRUCTION_WAIT, 1, 5, SCRIPT_INSTRUCTION_OBJECT_SCALE_TO, 4, 0, SCRIPT_LOCAL_VARIABLE_4, SCRIPT_LOCAL_VARIABLE_4, 1, SCRIPT_INSTRUCTION_WAIT, 1, 5, SCRIPT_INSTRUCTION_WAIT, 1, 210, SCRIPT_INSTRUCTION_OBJECT_ALPHA_TO, 3, 0, 0, 90, SCRIPT_INSTRUCTION_WAIT, 1, 90, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 0, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.SmokeInterrupt = [SCRIPT_INSTRUCTION_OBJECT_CREATE_SPRITE, 5, 0, SCRIPT_LOCAL_VARIABLE_1, 0, 0, EA.Default, SCRIPT_INSTRUCTION_OBJECT_ALPHA_TO, 3, 0, 0, 10, SCRIPT_INSTRUCTION_WAIT, 1, 10, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 0, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.Scripts = [ScriptData.Cover, ScriptData.Cover, ScriptData.Cover, ScriptData.Cover, ScriptData.JoinH, ScriptData.JoinV, ScriptData.Sparkle, ScriptData.StaticSparkle, ScriptData.ScreenFlash, ScriptData.ScreenFlashLong, ScriptData.ScreenFlashLonger, ScriptData.Smoke, null];
    EntityEffect.prototype = {
        Destroy: function() {
            this.m_psScriptList = [];
            EntityBase.Destroy(this)
        },
        SetFrameByName: function(dwImage) {
            this.m_psSprite.SetFrameByName(dwImage)
        },
        SetColour: function(r, g, b) {
            this.m_psSprite.SetColour([r / 255, g / 255, b / 255, this.m_psSprite.GetOpacity()])
        },
        FadeOut: function() {
            this.m_psScriptList = [];
            this.m_psScript = Script.New(ScriptData.SmokeInterrupt);
            Script.SetLocalVariable(this.m_psScript, SCRIPT_LOCAL_VARIABLE_1, this.m_psSprite)
        },
        SetScale: function(fScale) {
            this.m_fScale = fScale
        },
        Update: function() {
            switch (this.m_eType) {
                case ENTITYEFFECT_TYPE_COVER_1:
                case ENTITYEFFECT_TYPE_COVER_2:
                case ENTITYEFFECT_TYPE_COVER_3:
                case ENTITYEFFECT_TYPE_COVER_4:
                    this.m_psSprite.x += this.xDelta;
                    this.m_psSprite.y += this.yDelta;
                    this.m_psSprite.Rotation += this.m_fRotationDelta;
                    this.yDelta += 1.5;
                    break;
                case ENTITYEFFECT_TYPE_SPARKLE:
                    this.m_psSprite.x += this.xDelta;
                    this.m_psSprite.y += this.yDelta;
                    this.xDelta *= .6;
                    this.yDelta *= .6;
                    this.m_psSprite.y -= 2;
                    this.m_psSprite.Rotation += this.m_fRotationDelta;
                    break;
                case ENTITYEFFECT_TYPE_STATIC_SPARKLE:
                    this.m_psSprite.Rotation += this.m_fRotationDelta;
                    break;
                case ENTITYEFFECT_TYPE_SMOKE:
                    if (this.yDelta < this.m_fSmokeLimit) {
                        this.yDelta *= .92
                    }
                    this.m_psSprite.y += this.yDelta;
                    this.m_psSprite.x += this.xDelta;
                    break;
                case ENTITYEFFECT_TYPE_FAIRY:
                    this.dwStateTimer -= 1;
                    if (this.dwStateTimer === 0) {
                        if (this.m_psSprite.GetOpacity() === 1) {
                            this.m_psSprite.SetOpacity(128 / 255)
                        } else {
                            this.m_psSprite.SetOpacity(255 / 255)
                        }
                        this.dwStateTimer = Math.random() * 10 + 2
                    }
                    this.m_fExtraTimer += this.m_fExtraTimerDelta;
                    var fOffset = Math.sin(this.m_fExtraTimer / 30 * (22 / 7)) * 5;
                    this.m_psSprite.y = fOffset + this.yPos;
                    break
            }
            if (this.m_psScript) {
                if (!Script.Process(this.m_psScript, this.m_psScriptList, null)) {
                    this.m_psScript = null;
                    this.bRemove = true
                }
            }
            if (this.m_eType === ENTITYEFFECT_TYPE_STATIC_SPARKLE) {
                this.m_psSprite.ScaleX = this.m_psSprite.ScaleX * this.m_fScale;
                this.m_psSprite.ScaleY = this.m_psSprite.ScaleY * this.m_fScale
            }
            this.m_psSprite.SetPosition(this.m_psSprite.x, this.m_psSprite.y);
            this.m_psSprite.SetRotation(this.m_psSprite.Rotation);
            this.m_psSprite.SetScale(this.m_psSprite.ScaleX, this.m_psSprite.ScaleY);
            EntityBase.Update(this)
        }
    };
    EntityEffect.Create = function(x, y, eType, psParent) {
        var NewObject = EntityBase.Create(x, y, EntityEffect_adwImages[eType], EA.Default, psParent);
        NewObject.SetFrameByName = EntityEffect.prototype.SetFrameByName;
        NewObject.SetColour = EntityEffect.prototype.SetColour;
        NewObject.FadeOut = EntityEffect.prototype.FadeOut;
        NewObject.SetScale = EntityEffect.prototype.SetScale;
        NewObject.Destroy = EntityEffect.prototype.Destroy;
        NewObject.Update = EntityEffect.prototype.Update;
        NewObject.m_dwType = ENTITYMANAGER_TYPE_EFFECT;
        NewObject.m_fScale = 1;
        if (ScriptData.Scripts[eType]) {
            NewObject.m_psScript = Script.New(ScriptData.Scripts[eType]);
            Script.SetLocalVariable(NewObject.m_psScript, SCRIPT_LOCAL_VARIABLE_1, NewObject.m_psSprite)
        }
        NewObject.m_eType = eType;
        switch (eType) {
            case ENTITYEFFECT_TYPE_COVER_1:
                NewObject.xDelta = Math.random() * -4 - 2;
                NewObject.yDelta = Math.random() * -12 - 16;
                if (Math.random() < .5) {
                    NewObject.m_fRotationDelta = -.6
                } else {
                    NewObject.m_fRotationDelta = .6
                }
                break;
            case ENTITYEFFECT_TYPE_COVER_2:
                NewObject.xDelta = Math.random() * 4 + 2;
                NewObject.yDelta = Math.random() * -12 - 16;
                if (Math.random() < .5) {
                    NewObject.m_fRotationDelta = -.6
                } else {
                    NewObject.m_fRotationDelta = .6
                }
                break;
            case ENTITYEFFECT_TYPE_COVER_3:
                NewObject.xDelta = Math.random() * -4 - 2;
                NewObject.yDelta = Math.random() * -8 - 8;
                if (Math.random() < .5) {
                    NewObject.m_fRotationDelta = -.6
                } else {
                    NewObject.m_fRotationDelta = .6
                }
                break;
            case ENTITYEFFECT_TYPE_COVER_4:
                NewObject.xDelta = Math.random() * 4 + 2;
                NewObject.yDelta = Math.random() * -8 - 8;
                if (Math.random() < .5) {
                    NewObject.m_fRotationDelta = -.6
                } else {
                    NewObject.m_fRotationDelta = .6
                }
                break;
            case ENTITYEFFECT_TYPE_JOIN_H:
            case ENTITYEFFECT_TYPE_JOIN_V:
                break;
            case ENTITYEFFECT_TYPE_SPARKLE:
                Script.SetLocalVariable(NewObject.m_psScript, SCRIPT_LOCAL_VARIABLE_3, Math.random() * 40 + 90);
                Script.SetLocalVariable(NewObject.m_psScript, SCRIPT_LOCAL_VARIABLE_4, Math.random() * 720 - 360);
                NewObject.xDelta = Math.random() * 32 - 16;
                NewObject.yDelta = Math.random() * 32 - 16;
                if (Math.random() < .5) {
                    NewObject.m_fRotationDelta = -.6
                } else {
                    NewObject.m_fRotationDelta = .6
                }
                break;
            case ENTITYEFFECT_TYPE_STATIC_SPARKLE:
                Script.SetLocalVariable(NewObject.m_psScript, SCRIPT_LOCAL_VARIABLE_3, Math.random() * 40 + 90);
                if (Math.random() < .5) {
                    NewObject.m_fRotationDelta = -.6
                } else {
                    NewObject.m_fRotationDelta = .6
                }
                break;
            case ENTITYEFFECT_TYPE_SCREEN_FLASH:
            case ENTITYEFFECT_TYPE_SCREEN_FLASH_LONG:
            case ENTITYEFFECT_TYPE_SCREEN_FLASH_LONGER:
                break;
            case ENTITYEFFECT_TYPE_SMOKE:
                NewObject.yDelta = -5 - Math.random() * 2;
                NewObject.xDelta = .1 + Math.random() * .05;
                NewObject.m_fSmokeLimit = -1.2;
                NewObject.m_psSprite.SetScale(0, 0);
                NewObject.m_psSprite.SetRotation(Math.random() * (44 / 7));
                var fPercent = Math.random() * 30 + 90;
                Script.SetLocalVariable(NewObject.m_psScript, SCRIPT_LOCAL_VARIABLE_2, fPercent * 1.2);
                Script.SetLocalVariable(NewObject.m_psScript, SCRIPT_LOCAL_VARIABLE_3, fPercent * .9);
                Script.SetLocalVariable(NewObject.m_psScript, SCRIPT_LOCAL_VARIABLE_4, fPercent * 1);
                break;
            case ENTITYEFFECT_TYPE_FAIRY:
                NewObject.dwStateTimer = Math.random() * 10 + 2;
                NewObject.m_fExtraTimer = Math.random() * 30;
                NewObject.m_fExtraTimerDelta = Math.random() * .5 + .5;
                break
        }
        NewObject.xDelta *= SCREEN_SCALER;
        NewObject.yDelta *= SCREEN_SCALER;
        return NewObject
    };

    function EntityHud() {}
    var JOIN_SPACING = 80;
    var EntityHud_JoinLightImages = ["BlockRedNone", "BlockGreenNone", "BlockBlueNone", "BlockYellowNone"];
    var EntityHud_JoinedLightImages = ["RedComplete", "GreenComplete", "BlueComplete", "YellowComplete"];
    var EntityHud_adwBonusImages = ["TwoOfAKind", "ThreeOfAKind", "BeatTime", "BeatMoves", "NewBlank"];
    EntityHud.prototype = {
        Destroy: function() {
            Helpers.DestroyBitmapText(this.m_psMoves);
            Helpers.DestroyBitmapText(this.m_psTime);
            Helpers.DestroyBitmapText(this.m_psBonusTitle);
            Helpers.DestroyBitmapText(this.m_psTimeTitle);
            Helpers.DestroyBitmapText(this.m_psMovesTitle);
            Helpers.DestroyBitmapText(this.m_psJoinTitle);
            Helpers.DestroySprite(this.m_psObjectiveGlow);
            Helpers.DestroySprite(this.m_psBonusGlow);
            Helpers.DestroySprite(this.m_psBonusImage);
            Helpers.DestroySprite(this.m_psBonusExtra);
            for (var i = 0; i < 4; i += 1) {
                Helpers.DestroySprite(this.m_pasJoinLights[i])
            }
            for (i = 0; i < this.m_apMakeBlocks.length; i += 1) {
                EntityManager.Remove(this.m_apMakeBlocks[i]);
                this.m_apMakeBlocks[i].Destroy()
            }
            Helpers.DestroySprite(this.m_psBoardFade);
            Helpers.DestroySprite(this.m_psShapeGlow);
            Helpers.DestroyTree(this.m_psBonusShapeRoot);
            Helpers.DestroyTree(this.m_psBonusRoot);
            Helpers.DestroyTree(this.m_psObjectiveRoot);
            Helpers.DestroyTree(this.m_psRoot);
            Helpers.DestroyTree(this.m_psShadowRoot);
            Helpers.DestroyTree(this.m_psSprite);
            this.m_psSprite = this.OldSprite;
            EntityBase.Destroy(this)
        },
        SetScheme: function(psScheme) {
            this.m_psScheme = psScheme;
            var fRed = psScheme.fRed;
            var fGreen = psScheme.fGreen;
            var fBlue = psScheme.fBlue;
            this.m_psJoinTitle.SetColour([fRed / 255, fGreen / 255, fBlue / 255, this.m_psJoinTitle.GetOpacity()]);
            this.m_psMovesTitle.SetColour([fRed / 255, fGreen / 255, fBlue / 255, this.m_psJoinTitle.GetOpacity()]);
            this.m_psTimeTitle.SetColour([fRed / 255, fGreen / 255, fBlue / 255, this.m_psJoinTitle.GetOpacity()]);
            this.m_psBonusTitle.SetColour([fRed / 255, fGreen / 255, fBlue / 255, this.m_psJoinTitle.GetOpacity()]);
            this.m_psObjectiveGlow.SetColour([fRed / 255, fGreen / 255, fBlue / 255, this.m_psJoinTitle.GetOpacity()]);
            this.m_psBonusGlow.SetColour([fRed / 255, fGreen / 255, fBlue / 255, this.m_psJoinTitle.GetOpacity()])
        },
        AddMakeBlock: function(x, y, eColour, ModX, ModY) {
            var psBlock = EntityBlock.Create(x * 32 + 760 + ModX, y * 32 + 64 + 10 + ModY, x, y, 16, eColour, this.m_psBoard, this.m_psBonusShapeRoot, this.m_psShadowRoot);
            this.m_papsBlocks[y * ENTITYBOARD_MAKE_WIDTH + x] = psBlock;
            EntityManager.Add(psBlock);
            this.m_apMakeBlocks[this.m_apMakeBlocks.length] = psBlock
        },
        FinishMakeShape: function() {
            for (var y = 0; y < ENTITYBOARD_MAKE_HEIGHT; y += 1) {
                for (var x = 0; x < ENTITYBOARD_MAKE_WIDTH; x += 1) {
                    var l = y * ENTITYBOARD_MAKE_WIDTH + x;
                    var psBlock = this.m_papsBlocks[l];
                    var psTestBlock;
                    if (psBlock) {
                        if (y > 0) {
                            psTestBlock = this.m_papsBlocks[l - ENTITYBOARD_MAKE_WIDTH];
                            if (psBlock.m_psUp === null && psTestBlock && psTestBlock.GetColour() === psBlock.GetColour()) {
                                psBlock.Join(psTestBlock, false)
                            }
                        }
                        if (y < ENTITYBOARD_MAKE_HEIGHT - 1) {
                            psTestBlock = this.m_papsBlocks[l + ENTITYBOARD_MAKE_WIDTH];
                            if (psBlock.m_psDown === null && psTestBlock && psTestBlock.GetColour() === psBlock.GetColour()) {
                                psBlock.Join(psTestBlock, false)
                            }
                        }
                        if (x > 0) {
                            psTestBlock = this.m_papsBlocks[l - 1];
                            if (psBlock.m_psLeft === null && psTestBlock && psTestBlock.GetColour() === psBlock.GetColour()) {
                                psBlock.Join(psTestBlock, false)
                            }
                        }
                        if (x < ENTITYBOARD_MAKE_WIDTH - 1) {
                            psTestBlock = this.m_papsBlocks[l + 1];
                            if (psBlock.m_psRight === null && psTestBlock && psTestBlock.GetColour() === psBlock.GetColour()) {
                                psBlock.Join(psTestBlock, false)
                            }
                        }
                    }
                }
            }
        },
        SetBonus: function(eType, bFudgeIcon) {
            this.m_bFudgeIcon = bFudgeIcon;
            this.m_psBonusTitle.SetIsVisible(true);
            this.m_bBonusImageActive = true;
            this.m_psBonusImage.SetFrameByName(EntityHud_adwBonusImages[eType]);
            this.m_psBonusImage.SetIsVisible(true);
            var achTemp;
            if (eType === BONUS_TYPE_TIME) {
                achTemp = JamSystem.TextManager.GetText("DATATEXT_ID_CHALLENGE_BEAT_TIME", [LevelData_asData[LevelSelect.GetLevelNumber()].dwParTime]);
                this.m_psBonusExtra.SetText(achTemp)
            }
            if (eType === BONUS_TYPE_MOVES) {
                achTemp = JamSystem.TextManager.GetText("DATATEXT_ID_CHALLENGE_BEAT_MOVES", [LevelData_asData[LevelSelect.GetLevelNumber()].dwParMoves]);
                this.m_psBonusExtra.SetText(achTemp)
            }
            this.m_psBonusExtra.SetIsVisible(true)
        },
        JoinActive: function(dwColour) {
            this.m_pasJoinLights[dwColour].SetIsVisible(true);
            this.m_pasJoinLights[dwColour].SetPosition(this.m_fJoinX, 392);
            this.m_fJoinX += JOIN_SPACING
        },
        JoinComplete: function(dwColour, bCeremony) {
            if (bCeremony) {
                Helpers.StopSound("ColourComplete01");
                Helpers.StopSound("ColourComplete02");
                Helpers.StopSound("ColourComplete03");
                if (this.m_dwNumColoursJoined === 0) {
                    Helpers.PlaySound("ColourComplete01")
                } else if (this.m_dwNumColoursJoined === 1) {
                    Helpers.PlaySound("ColourComplete02")
                } else {
                    Helpers.PlaySound("ColourComplete03")
                }
                this.m_bCompleteCeremony = true;
                this.m_bFlashColour[dwColour] = true;
                this.m_dwFlashTimer = 0
            }
            this.m_dwNumColoursJoined += 1;
            this.m_pasJoinLights[dwColour].SetFrameByName(EntityHud_JoinedLightImages[dwColour])
        },
        ShapeComplete: function(bCeremony) {
            if (this.m_bMakeShapeFadedOut) {
                return
            }
            if (this.m_apMakeBlocks.length) {
                var dwLeft = 768,
                    dwRight = 0,
                    dwTop = 1024,
                    dwBottom = 0;
                for (var i = 0; i < this.m_apMakeBlocks.length; i += 1) {
                    if (this.m_apMakeBlocks[i].m_psSprite.x < dwLeft) {
                        dwLeft = this.m_apMakeBlocks[i].m_psSprite.x
                    }
                    if (this.m_apMakeBlocks[i].m_psSprite.x > dwRight) {
                        dwRight = this.m_apMakeBlocks[i].m_psSprite.x
                    }
                    if (this.m_apMakeBlocks[i].m_psSprite.y < dwTop) {
                        dwTop = this.m_apMakeBlocks[i].m_psSprite.y
                    }
                    if (this.m_apMakeBlocks[i].m_psSprite.y > dwBottom) {
                        dwBottom = this.m_apMakeBlocks[i].m_psSprite.y
                    }
                }
                var x = (dwRight + dwLeft) / 2 + 8 * SCREEN_SCALER;
                var y = (dwBottom + dwTop) / 2 + 8 * SCREEN_SCALER;
                var fWidth = (dwRight - dwLeft + 24 * SCREEN_SCALER) / (64 * SCREEN_SCALER);
                var fHeight = (dwBottom - dwTop + 24 * SCREEN_SCALER) / (64 * SCREEN_SCALER);
                this.m_psShapeGlow.SetPosition(x, y);
                this.m_psShapeGlow.SetScale(fWidth, fHeight);
                this.m_psShapeGlow.SetIsVisible(true);
                this.m_psShapeGlow.SetColour([this.m_psScheme.fRed / 255, this.m_psScheme.fGreen / 255, this.m_psScheme.fBlue / 255, this.m_psShapeGlow.GetOpacity()])
            }
            if (bCeremony) {
                this.m_bCompleteCeremony = true;
                this.m_bFlashShape = true;
                this.m_dwFlashTimer = 0
            }
        },
        EndCompleteCeremony: function() {
            this.m_bCompleteCeremony = false;
            for (var i = 0; i < 4; i += 1) {
                if (this.m_bFlashColour[i]) {
                    this.m_pasJoinLights[i].SetFrameByName(EntityHud_JoinedLightImages[i]);
                    this.m_bFlashColour[i] = false
                }
            }
            if (this.m_bFlashShape) {
                this.m_bFlashShape = false;
                for (var i = 0; i < this.m_apMakeBlocks.length; i += 1) {
                    this.m_apMakeBlocks[i].m_psSprite.SetOpacity(255 / 255)
                }
            }
        },
        ObjectiveComplete: function() {
            this.m_psShapeGlow.SetPosition(224 * SCREEN_SCALER, 80 * SCREEN_SCALER);
            this.m_psShapeGlow.SetScale(1, 1);
            this.m_psShapeGlow.SetIsVisible(true);
            var psScheme = LevelSelect.GetColourScheme();
            this.m_psShapeGlow.SetColour([psScheme.fRed / 255, psScheme.fGreen / 255, psScheme.fBlue / 255, this.m_psShapeGlow.GetOpacity()])
        },
        UpdateIcon: function() {
            if (this.m_bFudgeIcon) {
                this.m_bBonusImageActive = false;
                this.m_psBonusExtra.SetIsVisible(false)
            }
        },
        ResetObjective: function() {
            var i;
            for (i = 0; i < 4; i += 1) {
                this.m_pasJoinLights[i].SetFrameByName(EntityHud_JoinLightImages[i]);
                this.m_pasJoinLights[i].SetColour([1, 1, 1, this.m_pasJoinLights[i].GetOpacity()])
            }
            for (i = 0; i < this.m_apMakeBlocks.length; i += 1) {
                this.m_apMakeBlocks[i].m_psSprite.SetColour([1, 1, 1, this.m_apMakeBlocks[i].m_psSprite.GetOpacity()])
            }
            this.m_dwNumColoursJoined = 0
        },
        SetMoves: function(dwMoves) {
            var achTemp = "" + dwMoves;
            this.m_psMoves.SetText(achTemp)
        },
        SetTime: function(dwTime) {
            dwTime = dwTime / 6;
            var achTemp = "" + Math.floor(dwTime / 6e3) % 10 + "" + Math.floor(dwTime / 600) % 10 + ":" + Math.floor(dwTime / 100) % 6 + "" + Math.floor(dwTime / 10) % 10;
            this.m_psTime.SetText(achTemp)
        },
        Update: function() {
            if (this.m_bCompleteCeremony) {
                this.m_dwFlashTimer += 1;
                for (var i = 0; i < 4; i += 1) {
                    if (this.m_bFlashColour[i]) {
                        if (this.m_dwFlashTimer % 10 < 7) {
                            this.m_pasJoinLights[i].SetFrameByName(EntityHud_JoinedLightImages[i])
                        } else {
                            this.m_pasJoinLights[i].SetFrameByName(EntityHud_JoinLightImages[i])
                        }
                    }
                }
                if (this.m_bFlashShape) {
                    for (var i = 0; i < this.m_apMakeBlocks.length; i += 1) {
                        if (this.m_dwFlashTimer % 10 < 7) {
                            this.m_apMakeBlocks[i].m_psSprite.SetOpacity(128 / 255)
                        } else {
                            this.m_apMakeBlocks[i].m_psSprite.SetOpacity(255 / 255)
                        }
                    }
                }
            }
        },
        SetActive: function(bActive) {
            this.m_psRoot.RemoveFromParent();
            this.m_psShadowRoot.RemoveFromParent();
            if (bActive) {
                this.m_psSprite.AddChild(this.m_psShadowRoot);
                this.m_psSprite.AddChild(this.m_psRoot)
            }
        },
        SetOpacity: function(fOpacity) {
            if (fOpacity < 0) {
                fOpacity = 0
            }
            var i;
            if (fOpacity !== 0) {
                if (!this.m_bMakeFadedOut) {
                    this.m_psShapeGlow.SetOpacity(fOpacity);
                    for (i = 0; i < this.m_apMakeBlocks.length; i += 1) {
                        this.m_apMakeBlocks[i].m_psShadow.SetOpacity(fOpacity / 255);
                        this.m_apMakeBlocks[i].m_psSprite.SetOpacity(fOpacity / 255)
                    }
                    if (this.m_bBonusImageActive) {
                        this.m_psBonusImage.SetOpacity(fOpacity / 255);
                        this.m_psBonusExtra.SetOpacity(fOpacity / 255)
                    }
                    this.m_psBonusTitle.SetOpacity(fOpacity / 255)
                }
                for (i = 0; i < 4; i += 1) {
                    this.m_pasJoinLights[i].SetOpacity(fOpacity / 255)
                }
                this.m_psTime.SetOpacity(fOpacity / 255);
                this.m_psMoves.SetOpacity(fOpacity / 255);
                this.m_psJoinTitle.SetOpacity(fOpacity / 255);
                this.m_psMovesTitle.SetOpacity(fOpacity / 255);
                this.m_psTimeTitle.SetOpacity(fOpacity / 255);
                if (this.m_fLastOpacity === 0) {
                    if (!this.m_bMakeFadedOut) {
                        this.m_psRoot.AddChild(this.m_psShapeGlow)
                    }
                    this.m_psRoot.AddChild(this.m_psTime);
                    this.m_psRoot.AddChild(this.m_psMoves);
                    if (!this.m_bMakeFadedOut) {
                        for (var i = 0; i < this.m_apMakeBlocks.length; i += 1) {
                            this.m_psShadowRoot.AddChild(this.m_apMakeBlocks[i].m_psShadow);
                            this.m_psBonusShapeRoot.AddChild(this.m_apMakeBlocks[i].m_psSprite)
                        }
                    }
                    this.m_psObjectiveRoot.AddChild(this.m_psJoinTitle);
                    this.m_psRoot.AddChild(this.m_psMovesTitle);
                    this.m_psRoot.AddChild(this.m_psTimeTitle);
                    for (i = 0; i < 4; i += 1) {
                        this.m_psObjectiveRoot.AddChild(this.m_pasJoinLights[i])
                    }
                    this.m_psBonusRoot.AddChild(this.m_psBonusTitle);
                    if (this.m_bBonusImageActive) {
                        this.m_psBonusRoot.AddChild(this.m_psBonusImage);
                        this.m_psBonusRoot.AddChild(this.m_psBonusExtra)
                    }
                }
            } else {
                if (this.m_fLastOpacity !== 0) {
                    if (!this.m_bMakeFadedOut) {
                        this.m_psShapeGlow.RemoveFromParent();
                        this.m_psBonusTitle.RemoveFromParent();
                        for (i = 0; i < this.m_apMakeBlocks.length; i += 1) {
                            this.m_apMakeBlocks[i].m_psSprite.RemoveFromParent();
                            this.m_apMakeBlocks[i].m_psShadow.RemoveFromParent()
                        }
                        if (this.m_bBonusImageActive) {
                            this.m_psBonusImage.RemoveFromParent();
                            this.m_psBonusExtra.RemoveFromParent()
                        }
                    }
                    for (i = 0; i < 4; i += 1) {
                        this.m_pasJoinLights[i].RemoveFromParent()
                    }
                    this.m_psTime.RemoveFromParent();
                    this.m_psMoves.RemoveFromParent();
                    this.m_psJoinTitle.RemoveFromParent();
                    this.m_psMovesTitle.RemoveFromParent();
                    this.m_psTimeTitle.RemoveFromParent()
                }
            }
            this.m_fLastOpacity = fOpacity
        },
        SetMakeOpacity: function(fOpacity) {
            if (fOpacity < 0) {
                fOpacity = 0
            }
            this.m_psShapeGlow.SetOpacity(fOpacity / 255);
            this.m_psBonusTitle.SetOpacity(fOpacity / 255);
            for (var i = 0; i < this.m_apMakeBlocks.length; i += 1) {
                this.m_apMakeBlocks[i].m_psShadow.SetOpacity(fOpacity / 255);
                this.m_apMakeBlocks[i].m_psSprite.SetOpacity(fOpacity / 255)
            }
            if (this.m_bBonusImageActive) {
                this.m_psBonusImage.SetOpacity(fOpacity / 255);
                this.m_psBonusExtra.SetOpacity(fOpacity / 255)
            }
            if (fOpacity === 0) {
                this.m_bMakeFadedOut = true
            }
        },
        SetMakeShapeOpacity: function(fOpacity) {
            for (var i = 0; i < this.m_apMakeBlocks.length; i += 1) {
                this.m_apMakeBlocks[i].m_psSprite.SetOpacity(fOpacity / 255)
            }
        },
        SetMakeShapeVisible: function(bVisible) {
            this.m_bMakeShapeFadedOut = !bVisible;
            for (var i = 0; i < this.m_apMakeBlocks.length; i += 1) {
                this.m_apMakeBlocks[i].m_psShadow.SetIsVisible(bVisible);
                this.m_apMakeBlocks[i].m_psSprite.SetIsVisible(bVisible)
            }
            this.m_psBonusTitle.SetIsVisible(!this.m_bMakeShapeFadedOut)
        },
        SetObjectivePercent: function(fPercent) {
            fPercent /= 100;
            fPercent = 1 - (Math.cos(fPercent * (22 / 7)) + 1) / 2;
            var x = fPercent * -1760;
            var y = fPercent * -600;
            var fScale = 1 + fPercent * 1.5;
            this.m_psObjectiveRoot.SetPosition(x, y);
            this.m_psObjectiveRoot.SetScale(fScale, fScale);
            if (fPercent) {
                this.m_psBoardFade.SetIsVisible(true);
                this.m_psBoardFade.SetOpacity(fPercent * 128 / 255);
                this.m_psObjectiveGlow.SetIsVisible(true);
                this.m_psObjectiveGlow.SetOpacity(fPercent * 255 / 255)
            } else {
                this.m_psBoardFade.SetIsVisible(false);
                this.m_psObjectiveGlow.SetIsVisible(false)
            }
            var psScheme = LevelSelect.GetColourScheme();
            var fRed = psScheme.fRed + (255 - psScheme.fRed) * fPercent;
            var fGreen = psScheme.fGreen + (255 - psScheme.fGreen) * fPercent;
            var fBlue = psScheme.fBlue + (255 - psScheme.fBlue) * fPercent;
            this.m_psJoinTitle.SetColour([fRed / 255, fGreen / 255, fBlue / 255, this.m_psJoinTitle.GetOpacity()]);
            if (fPercent) {
                this.m_psJoinTitle.SetFont("PanelFont");
                this.m_psJoinTitle.SetScale(.45, .45)
            } else {
                this.m_psJoinTitle.SetFont("PanelFontSmall");
                this.m_psJoinTitle.SetScale(.9, .9)
            }
            this.m_psJoinTitle.SetAnchor(EA.Default)
        },
        SetBonusPercent: function(fPercent) {
            fPercent /= 100;
            fPercent = 1 - (Math.cos(fPercent * (22 / 7)) + 1) / 2;
            var x = fPercent * -1e3;
            var y = fPercent * 100;
            var fScale = 1 + fPercent * .6;
            this.m_psBonusRoot.SetPosition(x, y);
            this.m_psBonusRoot.SetScale(fScale, fScale);
            var dwShapeX, dwShapeY, dwWidth, dwHeight;
            var Object = this.m_psBoard.GetMakeShapeInfo();
            dwShapeX = Object.dwShapeX;
            dwShapeY = Object.dwShapeY;
            dwWidth = Object.dwWidth;
            dwHeight = Object.dwHeight;
            if (dwWidth & 1) {
                x = fPercent * -8 * SCREEN_SCALER
            } else {
                x = 0
            }
            if (dwHeight & 1) {
                y = fPercent * -8 * SCREEN_SCALER
            } else {
                y = 0
            }
            this.m_psBonusShapeRoot.SetPosition(x, y);
            if (fPercent) {
                this.m_psBoardFade.SetIsVisible(true);
                this.m_psBoardFade.SetOpacity(fPercent * 128 / 255);
                this.m_psBonusGlow.SetIsVisible(true);
                this.m_psBonusGlow.SetOpacity(fPercent * 255 / 255);
                if (!this.m_bBonusImageActive) {
                    this.m_psBonusImage.SetIsVisible(true);
                    this.m_psBonusImage.SetOpacity(fPercent * 255 / 255);
                    if (!this.m_bFudgeIcon) {
                        this.m_psBonusExtra.SetIsVisible(true)
                    }
                    this.m_psBonusExtra.SetOpacity(fPercent * 255 / 255)
                }
            } else {
                this.m_psBoardFade.SetIsVisible(false);
                this.m_psBonusGlow.SetIsVisible(false);
                if (!this.m_bBonusImageActive) {
                    this.m_psBonusImage.SetIsVisible(false);
                    this.m_psBonusExtra.SetIsVisible(false)
                }
            }
            var psScheme = LevelSelect.GetColourScheme();
            var fRed = psScheme.fRed + (255 - psScheme.fRed) * fPercent;
            var fGreen = psScheme.fGreen + (255 - psScheme.fGreen) * fPercent;
            var fBlue = psScheme.fBlue + (255 - psScheme.fBlue) * fPercent;
            this.m_psBonusTitle.SetColour([fRed / 255, fGreen / 255, fBlue / 255, this.m_psBonusTitle.GetOpacity()]);
            if (fPercent) {
                this.m_psBonusTitle.SetFont("PanelFont");
                this.m_psBonusTitle.SetScale(.45, .45);
                this.m_psBonusExtra.SetFont("PanelFont");
                this.m_psBonusExtra.SetScale(.45, .45)
            } else {
                this.m_psBonusTitle.SetFont("PanelFontSmall");
                this.m_psBonusTitle.SetScale(.8, .9);
                this.m_psBonusExtra.SetFont("PanelFontSmall");
                this.m_psBonusExtra.SetScale(.8, .9)
            }
            this.m_psBonusTitle.SetAnchor(EA.Default);
            this.m_psBonusExtra.SetAnchor(EA.Default)
        },
        SetBonusImage: function(dwImage) {
            this.m_psBonusImage.SetFrameByName(dwImage)
        }
    };
    EntityHud.Create = function(papsBoard, psParent) {
        var NewObject = EntityBase.Create(0, 0, "NewBlank", EA.TopLeft, psParent);
        NewObject.SetScheme = EntityHud.prototype.SetScheme;
        NewObject.AddMakeBlock = EntityHud.prototype.AddMakeBlock;
        NewObject.FinishMakeShape = EntityHud.prototype.FinishMakeShape;
        NewObject.SetBonus = EntityHud.prototype.SetBonus;
        NewObject.JoinActive = EntityHud.prototype.JoinActive;
        NewObject.JoinComplete = EntityHud.prototype.JoinComplete;
        NewObject.ShapeComplete = EntityHud.prototype.ShapeComplete;
        NewObject.EndCompleteCeremony = EntityHud.prototype.EndCompleteCeremony;
        NewObject.ObjectiveComplete = EntityHud.prototype.ObjectiveComplete;
        NewObject.UpdateIcon = EntityHud.prototype.UpdateIcon;
        NewObject.ResetObjective = EntityHud.prototype.ResetObjective;
        NewObject.SetMoves = EntityHud.prototype.SetMoves;
        NewObject.SetTime = EntityHud.prototype.SetTime;
        NewObject.SetActive = EntityHud.prototype.SetActive;
        NewObject.SetOpacity = EntityHud.prototype.SetOpacity;
        NewObject.SetMakeOpacity = EntityHud.prototype.SetMakeOpacity;
        NewObject.SetMakeShapeOpacity = EntityHud.prototype.SetMakeShapeOpacity;
        NewObject.SetMakeShapeVisible = EntityHud.prototype.SetMakeShapeVisible;
        NewObject.SetObjectivePercent = EntityHud.prototype.SetObjectivePercent;
        NewObject.SetBonusPercent = EntityHud.prototype.SetBonusPercent;
        NewObject.SetBonusImage = EntityHud.prototype.SetBonusImage;
        NewObject.Destroy = EntityHud.prototype.Destroy;
        NewObject.Update = EntityHud.prototype.Update;
        NewObject.OldSprite = NewObject.m_psSprite;
        NewObject.m_psSprite = Helpers.CreateTree(0, 0, psParent);
        NewObject.m_psBoardFade = Helpers.CreateSprite(0, 0, EA.TopLeft, "Black", NewObject.m_psSprite);
        NewObject.m_psBoardFade.SetScale(SCREEN_WIDTH, SCREEN_HEIGHT);
        NewObject.m_psBoardFade.SetIsVisible(false);
        NewObject.m_psShadowRoot = Helpers.CreateTree(0, 0, NewObject.m_psSprite);
        NewObject.m_psShapeGlow = Helpers.CreateSprite(0, 0, EA.Default, "GlowRound", NewObject.m_psSprite);
        NewObject.m_psShapeGlow.SetIsVisible(false);
        NewObject.m_psRoot = Helpers.CreateTree(0, 0, NewObject.m_psSprite);
        NewObject.m_dwType = ENTITYMANAGER_TYPE_HUD;
        NewObject.m_dwNumColoursJoined = 0;
        NewObject.m_psBoard = papsBoard;
        NewObject.m_bMakeFadedOut = false;
        NewObject.m_bMakeShapeFadedOut = false;
        NewObject.m_fLastOpacity = 1;
        NewObject.m_fLastMakeOpacity = 1;
        NewObject.m_bBonusImageActive = false;
        NewObject.m_bCompleteCeremony = false;
        NewObject.m_bFlashColour = [];
        for (var i = 0; i < 4; i += 1) {
            NewObject.m_bFlashColour[i] = false
        }
        NewObject.m_bFlashShape = false;
        NewObject.m_psScheme = null;
        NewObject.m_psObjectiveRoot = Helpers.CreateTree(0, 0, NewObject.m_psSprite);
        NewObject.m_psBonusRoot = Helpers.CreateTree(0, 0, NewObject.m_psSprite);
        NewObject.m_fJoinX = 753;
        NewObject.m_pasJoinLights = [];
        for (var i = 0; i < 4; i += 1) {
            NewObject.m_pasJoinLights[i] = Helpers.CreateSprite(i * JOIN_SPACING + 753, 392, EA.Default, EntityHud_JoinLightImages[i], NewObject.m_psObjectiveRoot);
            NewObject.m_pasJoinLights[i].SetIsVisible(false)
        }
        NewObject.m_apMakeBlocks = [];
        NewObject.m_papsBlocks = [];
        var tx = 834;
        var ty = 352;
        NewObject.m_psJoinTitle = Helpers.CreateBitmapText(JamSystem.TextManager.GetText("DATATEXT_ID_HUD_JOIN_BLOCKS"), tx, ty, EA.Default, "PanelFontSmall", NewObject.m_psObjectiveRoot);
        ty += 48;
        NewObject.m_psObjectiveGlow = Helpers.CreateSprite(tx, ty - 30, EA.Default, "GlowRound", NewObject.m_psObjectiveRoot);
        ty += 54;
        NewObject.m_psTimeTitle = Helpers.CreateBitmapText(JamSystem.TextManager.GetText("DATATEXT_ID_HUD_TIME"), tx, ty, EA.Default, "PanelFontSmall", NewObject.m_psRoot);
        ty += 32;
        NewObject.m_psTime = Helpers.CreateBitmapText("00:00.0", tx, ty, EA.Default, "PanelFontSmall", NewObject.m_psRoot);
        ty += 40;
        NewObject.m_psMovesTitle = Helpers.CreateBitmapText(JamSystem.TextManager.GetText("DATATEXT_ID_HUD_MOVES"), tx, ty, EA.Default, "PanelFontSmall", NewObject.m_psRoot);
        ty += 38;
        NewObject.m_psMoves = Helpers.CreateBitmapText("0", tx, ty, EA.Default, "PanelFontSmall", NewObject.m_psRoot);
        ty = 55;
        NewObject.m_psBonusTitle = Helpers.CreateBitmapText(JamSystem.TextManager.GetText("DATATEXT_ID_HUD_BONUS_CHALLENGE"), tx + 10, ty + 10, EA.Default, "PanelFontSmall", NewObject.m_psBonusRoot);
        ty += 102;
        NewObject.m_psBonusImage = Helpers.CreateSprite(tx, ty, EA.Default, "NewBlank", NewObject.m_psBonusRoot);
        ty += 10;
        NewObject.m_psBonusGlow = Helpers.CreateSprite(tx, ty, EA.Default, "GlowRound", NewObject.m_psBonusRoot);
        ty += 100;
        NewObject.m_psBonusExtra = Helpers.CreateBitmapText("", tx, ty, EA.Default, "PanelFontSmall", NewObject.m_psBonusRoot);
        NewObject.m_psMoves.SetScale(1, .9);
        NewObject.m_psTime.SetScale(1, .95);
        NewObject.m_psObjectiveGlow.SetScale(1.5, .75);
        NewObject.m_psObjectiveGlow.SetIsVisible(false);
        NewObject.m_psJoinTitle.SetScale(.9, .9);
        NewObject.m_psMovesTitle.SetScale(.9, .9);
        NewObject.m_psTimeTitle.SetScale(.9, .9);
        NewObject.m_psBonusGlow.SetScale(1.5, 1.5);
        NewObject.m_psBonusGlow.SetIsVisible(false);
        NewObject.m_psBonusShapeRoot = Helpers.CreateTree(0, 0, NewObject.m_psBonusRoot);
        NewObject.m_psBonusTitle.SetScale(.8, .9);
        NewObject.m_psBonusTitle.SetIsVisible(false);
        NewObject.m_psBonusImage.SetIsVisible(false);
        NewObject.m_psBonusExtra.SetScale(.8, .9);
        NewObject.m_psBonusExtra.SetIsVisible(false);
        return NewObject
    };
    var ENTITYLEVEL_STATE_NORMAL = 0;
    var ENTITYLEVEL_STATE_OPENING = 1;
    var ENTITYLEVEL_STATE_COMPLETING = 2;
    var ENTITYLEVEL_STATE_FLIP_TO_LEVEL = 3;
    var ENTITYLEVEL_STATE_FLIP_TO_REVEAL = 4;
    var ENTITYLEVEL_STATE_TOTAL = 5;
    var NORMAL_SCALE = 1;
    var HIGHLIGHT_SCALE = 1.2;
    var OVER_SCALE = 1.3;
    var UNDER_SCALE = .9;
    var NORMAL_OPEN_SCALE = 1;
    var HIGHLIGHT_OPEN_SCALE = 1.2;
    var COVER_DELAY = 30;
    var FLIP_DELAY = 6;
    var STAR_X = -22 * SCREEN_SCALER;
    var STAR_Y = -22 * SCREEN_SCALER;
    var TEXT_SCALE = .9;

    function EntityLevel() {}
    ScriptData.Flip = [SCRIPT_INSTRUCTION_WAIT, 1, SCRIPT_LOCAL_VARIABLE_3, SCRIPT_INSTRUCTION_PLAY_AUDIO, 1, "MotionRepeat", SCRIPT_INSTRUCTION_OBJECT_CREATE_SPRITE, 5, 0, SCRIPT_LOCAL_VARIABLE_1, 0, 0, EA.Default, SCRIPT_INSTRUCTION_OBJECT_SCALE_SET, 3, 0, NORMAL_OPEN_SCALE * 100, NORMAL_OPEN_SCALE * 100, SCRIPT_INSTRUCTION_OBJECT_SCALE_TO_EASE, 6, 0, NORMAL_OPEN_SCALE * 100, 0, false, true, FLIP_DELAY, SCRIPT_INSTRUCTION_WAIT, 1, FLIP_DELAY, SCRIPTEXT_INSTRUCTION_FLIP_LEVEL, 1, SCRIPT_LOCAL_VARIABLE_2, SCRIPT_INSTRUCTION_OBJECT_SCALE_TO_EASE, 6, 0, NORMAL_OPEN_SCALE * 100, NORMAL_OPEN_SCALE * 100, true, false, FLIP_DELAY, SCRIPT_INSTRUCTION_WAIT, 1, FLIP_DELAY, SCRIPT_INSTRUCTION_OBJECT_SCALE_SET, 3, 0, NORMAL_OPEN_SCALE * 100, NORMAL_OPEN_SCALE * 100, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 0, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.FlipReveal = [SCRIPT_INSTRUCTION_WAIT, 1, SCRIPT_LOCAL_VARIABLE_3, SCRIPT_INSTRUCTION_PLAY_AUDIO, 1, "PicturePiece", SCRIPT_INSTRUCTION_OBJECT_CREATE_SPRITE, 5, 0, SCRIPT_LOCAL_VARIABLE_1, 0, 0, EA.Default, SCRIPT_INSTRUCTION_OBJECT_SCALE_SET, 3, 0, NORMAL_OPEN_SCALE * 100, NORMAL_OPEN_SCALE * 100, SCRIPT_INSTRUCTION_OBJECT_SCALE_TO_EASE, 6, 0, NORMAL_OPEN_SCALE * 125, 0, false, true, FLIP_DELAY * 2, SCRIPT_INSTRUCTION_WAIT, 1, FLIP_DELAY * 2, SCRIPTEXT_INSTRUCTION_FLIP_LEVEL, 1, SCRIPT_LOCAL_VARIABLE_2, SCRIPT_INSTRUCTION_OBJECT_SCALE_TO_EASE, 6, 0, NORMAL_OPEN_SCALE * 150, NORMAL_OPEN_SCALE * 150, true, false, FLIP_DELAY * 2, SCRIPT_INSTRUCTION_WAIT, 1, FLIP_DELAY * 2, SCRIPT_INSTRUCTION_OBJECT_SCALE_SET, 3, 0, NORMAL_OPEN_SCALE * 150, NORMAL_OPEN_SCALE * 150, SCRIPT_INSTRUCTION_WAIT, 1, 30, SCRIPT_INSTRUCTION_OBJECT_SCALE_TO_EASE, 6, 0, NORMAL_OPEN_SCALE * 100, NORMAL_OPEN_SCALE * 100, true, true, FLIP_DELAY, SCRIPT_INSTRUCTION_WAIT, 1, FLIP_DELAY, SCRIPT_INSTRUCTION_OBJECT_SCALE_SET, 3, 0, NORMAL_OPEN_SCALE * 100, NORMAL_OPEN_SCALE * 150, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 0, SCRIPT_INSTRUCTION_END, 0];
    ScriptData.FlipRevealAndBack = [SCRIPT_INSTRUCTION_WAIT, 1, SCRIPT_LOCAL_VARIABLE_3, SCRIPT_INSTRUCTION_PLAY_AUDIO, 1, "PicturePiece", SCRIPT_INSTRUCTION_OBJECT_CREATE_SPRITE, 5, 0, SCRIPT_LOCAL_VARIABLE_1, 0, 0, EA.Default, SCRIPT_INSTRUCTION_OBJECT_SCALE_SET, 3, 0, NORMAL_OPEN_SCALE * 100, NORMAL_OPEN_SCALE * 100, SCRIPT_INSTRUCTION_OBJECT_SCALE_TO_EASE, 6, 0, NORMAL_OPEN_SCALE * 125, 0, false, true, FLIP_DELAY * 2, SCRIPT_INSTRUCTION_WAIT, 1, FLIP_DELAY * 2, SCRIPTEXT_INSTRUCTION_FLIP_LEVEL, 1, SCRIPT_LOCAL_VARIABLE_2, SCRIPT_INSTRUCTION_OBJECT_SCALE_TO_EASE, 6, 0, NORMAL_OPEN_SCALE * 150, NORMAL_OPEN_SCALE * 150, true, false, FLIP_DELAY * 2, SCRIPT_INSTRUCTION_WAIT, 1, FLIP_DELAY * 2, SCRIPT_INSTRUCTION_OBJECT_SCALE_SET, 3, 0, NORMAL_OPEN_SCALE * 150, NORMAL_OPEN_SCALE * 150, SCRIPT_INSTRUCTION_WAIT, 1, 30, SCRIPT_INSTRUCTION_OBJECT_SCALE_TO_EASE, 6, 0, NORMAL_OPEN_SCALE * 125, 0, false, true, FLIP_DELAY, SCRIPT_INSTRUCTION_WAIT, 1, FLIP_DELAY, SCRIPTEXT_INSTRUCTION_FLIP_TOGGLE, 1, SCRIPT_LOCAL_VARIABLE_2, SCRIPT_INSTRUCTION_OBJECT_SCALE_TO_EASE, 6, 0, NORMAL_OPEN_SCALE * 100, NORMAL_OPEN_SCALE * 100, true, false, FLIP_DELAY, SCRIPT_INSTRUCTION_WAIT, 1, FLIP_DELAY, SCRIPT_INSTRUCTION_OBJECT_SCALE_SET, 3, 0, NORMAL_OPEN_SCALE * 100, NORMAL_OPEN_SCALE * 100, SCRIPT_INSTRUCTION_OBJECT_DESTROY, 1, 0, SCRIPT_INSTRUCTION_END, 0];
    var EntityLevel_adwCompleteColour = [192, 192, 0];
    var EntityLevel_adwNormalColour = [192, 192, 192];
    var EntityLevel_adwHighCompleteColour = [255, 255, 0];
    var EntityLevel_adwHighNormalColour = [255, 255, 255];
    EntityLevel.prototype = {
        Destroy: function() {
            if (this.m_psHole) {
                Helpers.DestroySprite(this.m_psHole)
            }
            Helpers.DestroySprite(this.m_psStar);
            Helpers.DestroyBitmapText(this.m_psLevelName);
            Helpers.DestroySprite(this.m_psOutline);
            JamSystem.RenderManager.DestroySpriteAnimation(this.m_psOutlineAnimation);
            Helpers.DestroySprite(this.m_psImage);
            this.m_psScriptList = [];
            if (this.m_psScript) {
                Script.Delete(this.m_psScript)
            }
            ScriptObjects.ShutDownList(this.m_psScriptList);
            Helpers.DestroyTree(this.m_psRoot)
        },
        RetTouch: function() {
            return this.m_sArea
        },
        GetState: function() {
            return this.dwState
        },
        SetState: function(dwNewState) {
            if (this.m_psOutlineAnimation.Playing) {
                this.m_psOutlineAnimation.Playing = false
            }
            this.m_psScriptList = [];
            this.m_psScript = null;
            switch (this.dwState) {
                case ENTITYLEVEL_STATE_NORMAL:
                    break;
                case ENTITYLEVEL_STATE_OPENING:
                    break;
                case ENTITYLEVEL_STATE_COMPLETING:
                    break;
                case ENTITYLEVEL_STATE_FLIP_TO_LEVEL:
                case ENTITYLEVEL_STATE_FLIP_TO_REVEAL:
                    Helpers.DestroySprite(this.m_psHole);
                    this.m_psHole = null;
                    this.UpdateStatus();
                    break;
                default:
                    break
            }
            this.dwState = dwNewState;
            var psEffect;
            switch (this.dwState) {
                case ENTITYLEVEL_STATE_NORMAL:
                    break;
                case ENTITYLEVEL_STATE_OPENING:
                    this.SetIsPlayed(true);
                    var x, y;
                    var Object = LevelGrid.GetBoard();
                    x = Object.x;
                    y = Object.y;
                    psEffect = EntityEffect.Create(x, y, ENTITYEFFECT_TYPE_COVER_1, GadgetTree.GetLayer(LAYERS_HUD));
                    psEffect.SetFrameByName(this.m_psScheme.dwCoverBreakImage);
                    EntityManager.Add(psEffect);
                    psEffect = EntityEffect.Create(x, y, ENTITYEFFECT_TYPE_COVER_2, GadgetTree.GetLayer(LAYERS_HUD));
                    psEffect.SetFrameByName(this.m_psScheme.dwCoverBreakImage);
                    EntityManager.Add(psEffect);
                    psEffect = EntityEffect.Create(x, y, ENTITYEFFECT_TYPE_COVER_3, GadgetTree.GetLayer(LAYERS_HUD));
                    psEffect.SetFrameByName(this.m_psScheme.dwCoverBreakImage);
                    EntityManager.Add(psEffect);
                    psEffect = EntityEffect.Create(x, y, ENTITYEFFECT_TYPE_COVER_4, GadgetTree.GetLayer(LAYERS_HUD));
                    psEffect.SetFrameByName(this.m_psScheme.dwCoverBreakImage);
                    EntityManager.Add(psEffect);
                    for (var i = 0; i < 20; i += 1) {
                        var xt = Math.random() * 32 - 16 + x;
                        var yt = Math.random() * 32 - 16 + y;
                        x = x * 2 + 64;
                        y = y * 2 + 32;
                        psEffect = EntityEffect.Create(xt, yt, ENTITYEFFECT_TYPE_SPARKLE, GadgetTree.GetLayer(LAYERS_HUD));
                        psEffect.SetColour(this.m_psScheme.fRed, this.m_psScheme.fGreen, this.m_psScheme.fBlue);
                        EntityManager.Add(psEffect)
                    }
                    break;
                case ENTITYLEVEL_STATE_COMPLETING:
                    break;
                case ENTITYLEVEL_STATE_FLIP_TO_LEVEL:
                case ENTITYLEVEL_STATE_FLIP_TO_REVEAL:
                    this.m_psHole = Helpers.CreateSprite(this.m_psRoot.x, this.m_psRoot.y, EA.Default, "PuzzleRecess", LevelGrid.GetBGRoot());
                    this.UpdateFlip();
                    if (this.dwState !== ENTITYLEVEL_STATE_FLIP_TO_LEVEL) {
                        this.m_bIsFlipped = true
                    } else {
                        this.m_bIsFlipped = false
                    }
                    break;
                default:
                    break
            }
        },
        TouchAdd: function(bAdd) {
            if (bAdd) {
                Touch.Add(this.m_sArea)
            } else {
                Touch.Remove(this.m_sArea)
            }
        },
        UpdateStatus: function() {
            if (!this.m_bIsPlayed) {
                this.m_psImage.SetFrameByName(this.m_psScheme.dwCoverImage);
                this.m_psImage.SetScale(1, 1);
                if (this.m_bIsHighLighted) {
                    this.m_psRoot.SetScale(HIGHLIGHT_SCALE, HIGHLIGHT_SCALE)
                } else {
                    this.m_psRoot.SetScale(NORMAL_SCALE, NORMAL_SCALE)
                }
                this.m_psLevelName.SetColour([this.m_psScheme.fCoverRed / 255, this.m_psScheme.fCoverGreen / 255, this.m_psScheme.fCoverBlue / 255, 1]);
                this.m_psLevelName.SetPosition(1, 0);
                this.m_psLevelName.SetScale(TEXT_SCALE, TEXT_SCALE);
                this.m_psLevelName.SetIsVisible(true);
                this.m_psOutline.SetIsVisible(false);
                this.m_psStar.SetIsVisible(false)
            } else {
                if (this.m_bIsHighLighted) {
                    this.m_psRoot.SetScale(HIGHLIGHT_OPEN_SCALE, HIGHLIGHT_OPEN_SCALE)
                } else {
                    this.m_psRoot.SetScale(NORMAL_OPEN_SCALE, NORMAL_OPEN_SCALE)
                }
                if (this.m_bIsFlipped && !this.m_bIsHighLighted && this.m_bIsCompleted) {
                    this.m_psImage.SetFrameByName("NewBlank");
                    this.m_psImage.SetScale(1, 1);
                    this.m_psStar.SetIsVisible(false)
                } else {
                    this.m_psImage.SetFrameByName(LevelData_asData[this.m_dwNumber].pszFileName);
                    this.m_psImage.SetScale(1.72, 1.72);
                    if (this.m_bIsChallengeCompleted) {
                        this.m_psStar.SetIsVisible(true)
                    } else {
                        this.m_psStar.SetIsVisible(false)
                    }
                }
                this.m_psLevelName.SetPosition(0, 25);
                this.m_psLevelName.SetScale(.266, .266);
                this.m_psLevelName.SetIsVisible(false);
                this.m_psOutline.SetIsVisible(true)
            }
            if (this.m_bIsFlipped) {
                this.m_psOutline.SetFrameByName("PuzzleOutline")
            } else {
                this.m_psOutline.SetFrameByName("PuzzleRecess")
            }
        },
        UpdateFlip: function() {
            if (this.m_bIsFlipped) {
                var x, y;
                var Object = LevelGrid.CalcScreenCoord(this.m_dwNumber);
                x = Object.x;
                y = Object.y;
                var dwImage = LevelData_asData[this.m_dwNumber].pszFileName;
                var fWidth = 60 * 2;
                var fHeight = 60 * 2;
                this.m_psImage.SetFrameByName(this.m_dwLevelBackgroundImage, x - fWidth / 2, y - fHeight / 2, fWidth, fHeight);
                this.m_psImage.SetScale(1, 1);
                this.m_psOutline.SetFrameByName("PuzzleOutline");
                this.m_psStar.SetIsVisible(false)
            } else {
                this.m_psImage.SetFrameByName(LevelData_asData[this.m_dwNumber].pszFileName);
                this.m_psImage.SetScale(1.72, 1.72);
                this.m_psOutline.SetFrameByName("PuzzleRecess");
                if (this.m_bIsChallengeCompleted) {
                    this.m_psStar.SetIsVisible(true)
                } else {
                    this.m_psStar.SetIsVisible(false)
                }
            }
        },
        StartFlip: function(bFlipped, dwDelay, bOnScreen, bNewReveal) {
            if (this.m_bIsCompleted) {
                if (bOnScreen) {
                    if (this.m_bIsFlipped) {
                        this.SetState(ENTITYLEVEL_STATE_FLIP_TO_LEVEL)
                    } else {
                        this.SetState(ENTITYLEVEL_STATE_FLIP_TO_REVEAL)
                    }
                    this.m_psScriptList = [];
                    this.m_psScript = null;
                    if (bNewReveal) {
                        if (!LevelGrid.GetFlipped()) {
                            this.m_psScript = Script.New(ScriptData.FlipRevealAndBack)
                        } else {
                            this.m_psScript = Script.New(ScriptData.FlipReveal)
                        }
                    } else {
                        this.m_psScript = Script.New(ScriptData.Flip)
                    }
                    Script.SetLocalVariable(this.m_psScript, SCRIPT_LOCAL_VARIABLE_1, this.m_psRoot);
                    Script.SetLocalVariable(this.m_psScript, SCRIPT_LOCAL_VARIABLE_2, this);
                    Script.SetLocalVariable(this.m_psScript, SCRIPT_LOCAL_VARIABLE_3, dwDelay);
                    Script.SetLocalVariable(this.m_psScript, SCRIPT_LOCAL_VARIABLE_4, this.m_psRoot.x * 256);
                    Script.SetLocalVariable(this.m_psScript, SCRIPT_LOCAL_VARIABLE_5, this.m_psRoot.y * 256)
                } else {
                    this.m_bIsFlipped = bFlipped;
                    this.UpdateStatus()
                }
            }
        },
        SetIsHighlighted: function(bHighLighted, bAnimate) {
            this.m_psScriptList = [];
            this.m_psScript = null;
            if (this.m_bIsHighLighted !== bHighLighted) {
                this.m_bIsHighLighted = bHighLighted;
                if (bAnimate) {
                    this.m_psScript = Script.New(ScriptData.ScaleToBounce);
                    Script.SetLocalVariable(this.m_psScript, SCRIPT_LOCAL_VARIABLE_1, this.m_psRoot);
                    Script.SetLocalVariable(this.m_psScript, SCRIPT_LOCAL_VARIABLE_5, 0);
                    if (this.m_bIsHighLighted) {
                        Script.SetLocalVariable(this.m_psScript, SCRIPT_LOCAL_VARIABLE_2, NORMAL_SCALE * 100);
                        Script.SetLocalVariable(this.m_psScript, SCRIPT_LOCAL_VARIABLE_3, OVER_SCALE * 100);
                        Script.SetLocalVariable(this.m_psScript, SCRIPT_LOCAL_VARIABLE_4, HIGHLIGHT_SCALE * 100)
                    } else {
                        Script.SetLocalVariable(this.m_psScript, SCRIPT_LOCAL_VARIABLE_2, HIGHLIGHT_SCALE * 100);
                        Script.SetLocalVariable(this.m_psScript, SCRIPT_LOCAL_VARIABLE_3, UNDER_SCALE * 100);
                        Script.SetLocalVariable(this.m_psScript, SCRIPT_LOCAL_VARIABLE_4, NORMAL_SCALE * 100)
                    }
                }
            }
            if (this.m_bIsHighLighted) {
                this.m_psRoot.RemoveFromParent();
                this.m_psParent.AddChild(this.m_psRoot)
            }
            this.UpdateStatus()
        },
        SetIsPlayed: function(bPlayed) {
            this.m_bIsPlayed = bPlayed;
            this.UpdateStatus()
        },
        SetIsCompleted: function(bCompleted) {
            this.m_bIsCompleted = bCompleted;
            this.UpdateStatus()
        },
        SetIsChallengeCompleted: function(bChallengeCompleted) {
            this.m_bIsChallengeCompleted = bChallengeCompleted;
            this.UpdateStatus()
        },
        SetTouch: function(x, y) {
            this.m_sArea.x = x - 35 * SCREEN_SCALER;
            this.m_sArea.y = y - 35 * SCREEN_SCALER;
            this.m_sArea.x2 = x + 35 * SCREEN_SCALER;
            this.m_sArea.y2 = y + 35 * SCREEN_SCALER
        },
        SetIsVisible: function(bActive) {
            this.m_psRoot.SetIsVisible(bActive)
        },
        SetIsNameActive: function(bActive) {
            if (!bActive) {
                this.m_psLevelName.SetText("")
            } else {
                var achTemp = "" + (this.m_dwIDNumber + 1);
                this.m_psLevelName.SetText(achTemp)
            }
        },
        SetOpacity: function(dwOpacity) {
            this.m_psImage.SetOpacity(dwOpacity / 255);
            this.m_psStar.SetOpacity(dwOpacity / 255);
            this.m_psOutline.SetOpacity(dwOpacity / 255);
            if (this.m_psHole) {
                this.m_psHole.SetOpacity(dwOpacity / 255)
            }
            if (dwOpacity && this.m_dwLastOpacity === 0) {
                Touch.Remove(this.m_sArea);
                this.m_psRoot.RemoveFromParent()
            }
            if (dwOpacity === 0 && this.m_dwLastOpacity) {
                Touch.Add(this.m_sArea);
                this.m_psParent.AddChild(this.m_psRoot)
            }
            this.m_dwLastOpacity = dwOpacity
        },
        SetNameOpacity: function(dwOpacity) {
            this.m_psLevelName.SetOpacity(dwOpacity / 255);
            if (dwOpacity && this.m_dwLastNameOpacity === 0) {
                this.m_psRoot.AddChild(this.m_psLevelName)
            }
            if (dwOpacity === 0 && this.m_dwLastNameOpacity) {
                this.m_psLevelName.RemoveFromParent()
            }
            this.m_dwLastNameOpacity = dwOpacity
        },
        Update: function() {
            if (this.m_psScript) {
                if (!Script.Process(this.m_psScript, this.m_psScriptList, GadgetTree.GetLayer(LAYERS_HUD))) {
                    this.m_psScript = null
                }
            }
            switch (this.dwState) {
                case ENTITYLEVEL_STATE_NORMAL:
                    break;
                case ENTITYLEVEL_STATE_OPENING:
                    this.SetState(ENTITYLEVEL_STATE_NORMAL);
                    break;
                case ENTITYLEVEL_STATE_COMPLETING:
                    break;
                case ENTITYLEVEL_STATE_FLIP_TO_LEVEL:
                case ENTITYLEVEL_STATE_FLIP_TO_REVEAL:
                    if (this.m_psScript === null) {
                        this.SetState(ENTITYLEVEL_STATE_NORMAL)
                    }
                    break;
                default:
                    break
            }
            if (this.m_bIsChallengeCompleted && !this.m_bIsFlipped && this.m_psRoot.GetIsVisible() && Math.random() * 100 <= 1) {
                var x = STAR_X + Math.random() * 10 - 5;
                var y = STAR_Y + Math.random() * 10 - 5;
                var psEffect = EntityEffect.Create(x, y, ENTITYEFFECT_TYPE_STATIC_SPARKLE, this.m_psRoot);
                EntityManager.Add(psEffect)
            }
            if (this.m_dwSheenDelay) {
                this.m_dwSheenDelay -= 1;
                if (this.m_dwSheenDelay === 0) {
                    this.m_psOutlineAnimation.SetData(AnimationMisc_sSheen)
                }
            }
            if (this.m_psOutlineAnimation.Playing) {
                this.m_psOutlineAnimation.Update(1 / 60)
            }
        },
        ResetFlip: function() {
            this.m_bIsFlipped = false;
            this.UpdateFlip()
        },
        ScriptFlip: function() {
            this.m_bIsFlipped = !this.m_bIsFlipped;
            this.UpdateFlip()
        },
        ScriptHide: function(bHide) {
            if (bHide) {
                var x, y;
                var Object = LevelGrid.CalcLevelCoord(this.m_dwNumber);
                x = Object.x;
                y = Object.y;
                this.m_psHole = Helpers.CreateSprite(x, y, EA.Default, "PuzzleRecess", LevelGrid.GetBGRoot());
                this.m_psImage.SetIsVisible(false);
                this.m_psOutline.SetIsVisible(false);
                this.m_psStar.SetIsVisible(false);
                this.m_psLevelName.SetIsVisible(false)
            } else {
                if (this.m_psHole) {
                    Helpers.DestroySprite(this.m_psHole);
                    this.m_psHole = null
                }
                this.m_psImage.SetIsVisible(true);
                if (!this.m_bIsPlayed) {
                    this.m_psLevelName.SetIsVisible(true)
                } else {
                    if (this.m_bIsFlipped) {
                        this.m_psOutline.SetIsVisible(true)
                    } else {
                        if (this.m_bIsChallengeCompleted) {
                            this.m_psStar.SetIsVisible(true)
                        }
                    }
                }
            }
        },
        SetSheenDelay: function(dwDelay) {
            if (this.m_bIsFlipped) {
                this.m_dwSheenDelay = dwDelay
            }
        },
        GetIsCompleted: function() {
            return this.m_bIsCompleted
        }
    };
    EntityLevel.Create = function(x, y, dwNumber, dwIDNumber, psScheme, dwLevelBackgroundImage, dwBonusImage, psParent) {
        var NewObject = new EntityLevel;
        NewObject.m_dwNumber = dwNumber;
        NewObject.m_dwIDNumber = dwIDNumber;
        NewObject.m_bIsPlayed = false;
        NewObject.m_bIsCompleted = false;
        NewObject.m_bIsChallengeCompleted = false;
        NewObject.m_bIsHighLighted = false;
        NewObject.m_bIsFlipped = true;
        NewObject.m_dwLastNameOpacity = 255;
        NewObject.m_dwLastOpacity = 255;
        NewObject.m_psHole = null;
        NewObject.m_psScheme = psScheme;
        NewObject.m_dwLevelBackgroundImage = dwLevelBackgroundImage;
        NewObject.dwState = ENTITYLEVEL_STATE_NORMAL;
        NewObject.m_sArea = {};
        NewObject.m_psParent = psParent;
        NewObject.m_psRoot = Helpers.CreateTree(x, y, psParent);
        NewObject.m_psOutline = Helpers.CreateSprite(0, 0, EA.Default, "PuzzleOutline", NewObject.m_psRoot);
        NewObject.m_dwSheenDelay = 0;
        NewObject.m_psOutlineAnimation = JamSystem.RenderManager.CreateSpriteAnimation(NewObject.m_psOutline, 0);
        NewObject.m_psImage = Helpers.CreateSprite(0, 0, EA.Default, "NewBlank", NewObject.m_psRoot);
        var achTemp = "" + (dwIDNumber + 1);
        NewObject.m_psLevelName = Helpers.CreateBitmapText(achTemp, 1, 0, EA.Default, "NumberFont", NewObject.m_psRoot);
        NewObject.m_psLevelName.SetScale(TEXT_SCALE, TEXT_SCALE);
        NewObject.m_psStar = Helpers.CreateSprite(STAR_X, STAR_Y, EA.Default, dwBonusImage, NewObject.m_psRoot);
        NewObject.SetTouch(x, y);
        NewObject.UpdateStatus();
        NewObject.m_psScript = null;
        NewObject.m_psScriptList = ScriptObjects.InitList();
        return NewObject
    };
    var SCALE_UP_DELAY = 10;
    var FADE_OUT_DELAY = 10;
    var FADE_DELAY = 10;
    var LIFE_DELAY = 2 * FADE_DELAY;

    function EntityLightRays() {}
    EntityLightRays.prototype = {
        Destroy: function() {
            for (var i = 0; i < 3; i += 1) {
                Helpers.DestroySprite(this.mpcSprites[i])
            }
            EntityBase.Destroy(this)
        },
        SetPosition: function(x, y) {
            for (var i = 0; i < 3; i += 1) {
                this.mpcSprites[i].SetPosition(x, y)
            }
        },
        SetScale: function(fScale) {
            for (var i = 0; i < 3; i += 1) {
                this.mpcSprites[i].SetScale(fScale, fScale)
            }
            this.mfScale = fScale
        },
        ScaleTo: function(fTargetScale, fDelay) {
            this.mfCurrentScale = this.mfScale;
            this.mfTargetScale = fTargetScale;
            this.mfScaleDelay = fDelay;
            this.mfScaleTimer = 0;
            this.mbScaling = true;
            this.mdwTimer = 0
        },
        Rotate: function() {
            for (var i = 0; i < 3; i += 1) {
                this.mfRotationDeltas[i] = 0;
                this.mfRotationDeltaTargets[i] = Math.random() * .025 + .025
            }
        },
        FadeOut: function() {
            if (!this.mbFadeOut) {
                this.mbFadeOut = true;
                this.mdwTimer = 0
            }
        },
        Update: function() {
            this.mdwTimer += 1;
            var fGlobalsFade = 1;
            var fGlobalsScale = 1;
            if (this.mbFadeOut) {
                if (this.mdwTimer > FADE_OUT_DELAY) {
                    return
                }
                fGlobalsFade = 1 - this.mdwTimer / FADE_OUT_DELAY
            } else {
                if (this.mdwTimer < SCALE_UP_DELAY) {
                    fGlobalsScale = this.mdwTimer / SCALE_UP_DELAY
                }
            }
            for (var i = 0; i < 3; i += 1) {
                var pcSprite = this.mpcSprites[i];
                this.mfTimers[i] += 1;
                if (this.mfTimers[i] >= LIFE_DELAY) {
                    this.mfTimers[i] -= LIFE_DELAY;
                    pcSprite.Rotation = Math.random() * (44 / 7);
                    if (this.mfRotationDeltaTargets[i]) {
                        this.mfRotationDeltaTargets[i] = Math.random() * .025 + .025;
                        this.mfRotationDeltas[i] = this.mfRotationDeltaTargets[i]
                    }
                } else {
                    if (this.mfRotationDeltas[i] !== this.mfRotationDeltaTargets[i]) {
                        if (this.mfRotationDeltas[i] < this.mfRotationDeltaTargets[i]) {
                            this.mfRotationDeltas[i] += .0025;
                            if (this.mfRotationDeltas[i] > this.mfRotationDeltaTargets[i]) {
                                this.mfRotationDeltas[i] = this.mfRotationDeltaTargets[i]
                            }
                        } else {
                            this.mfRotationDeltas[i] -= .0025;
                            if (this.mfRotationDeltas[i] < this.mfRotationDeltaTargets[i]) {
                                this.mfRotationDeltas[i] = this.mfRotationDeltaTargets[i]
                            }
                        }
                    }
                    pcSprite.Rotation += this.mfRotationDeltas[i];
                    pcSprite.SetRotation(pcSprite.Rotation)
                }
                var fPercent = this.mfTimers[i] / LIFE_DELAY;
                var fOpacity;
                if (fPercent < .5) {
                    fOpacity = fPercent / .5
                } else {
                    fOpacity = 1 - (fPercent - .5) / .5
                }
                pcSprite.SetOpacity(fOpacity * fGlobalsFade * 255 / 255);
                pcSprite.ScaleX = this.mfScale * fGlobalsScale;
                pcSprite.ScaleY = this.mfScale * fGlobalsScale;
                pcSprite.SetScale(pcSprite.ScaleX, pcSprite.ScaleY)
            }
            if (this.mbScaling) {
                this.mfScaleTimer += 1;
                if (this.mfScaleTimer >= this.mfScaleDelay) {
                    this.mbScaling = false;
                    this.SetScale(this.mfTargetScale)
                } else {
                    var fScale = (this.mfTargetScale - this.mfCurrentScale) * (this.mfScaleTimer / this.mfScaleDelay) + this.mfCurrentScale;
                    this.SetScale(fScale)
                }
            }
        }
    };
    EntityLightRays.Create = function(x, y, fScale, psParent) {
        var NewObject = EntityBase.Create(x, y, "NewBlank", EA.TopLeft, psParent);
        NewObject.SetPosition = EntityLightRays.prototype.SetPosition;
        NewObject.SetScale = EntityLightRays.prototype.SetScale;
        NewObject.ScaleTo = EntityLightRays.prototype.ScaleTo;
        NewObject.Rotate = EntityLightRays.prototype.Rotate;
        NewObject.FadeOut = EntityLightRays.prototype.FadeOut;
        NewObject.Destroy = EntityLightRays.prototype.Destroy;
        NewObject.Update = EntityLightRays.prototype.Update;
        NewObject.mbScaling = false;
        NewObject.mfScale = fScale;
        NewObject.mpcSprites = [];
        NewObject.mfRotationDeltas = [];
        NewObject.mfRotationDeltaTargets = [];
        NewObject.mfTimers = [];
        for (var i = 0; i < 3; i += 1) {
            NewObject.mpcSprites[i] = Helpers.CreateSprite(x, y, EA.Default, "LightBeams", psParent);
            NewObject.mpcSprites[i].SetScale(0, 0);
            NewObject.mpcSprites[i].Rotation = Math.random() * (44 / 7);
            NewObject.mfRotationDeltas[i] = 0;
            NewObject.mfRotationDeltaTargets[i] = 0;
            NewObject.mfTimers[i] = (3 - i) * (1 / 3) * LIFE_DELAY
        }
        NewObject.mbFadeOut = false;
        NewObject.mdwTimer = 0;
        return NewObject
    };
    var ENTITYMANAGER_TYPE_NONE = 0;
    var ENTITYMANAGER_TYPE_BLOCK = 1;
    var ENTITYMANAGER_TYPE_BOARD = 2;
    var ENTITYMANAGER_TYPE_HUD = 3;
    var ENTITYMANAGER_TYPE_COUNTER = 4;
    var ENTITYMANAGER_TYPE_EFFECT = 5;
    var ENTITYMANAGER_TYPE_LEVEL = 6;
    var ENTITYMANAGER_TYPE_LIGHT_RAYS = 7;
    var ENTITYMANAGER_TYPE_TOTAL = 8;

    function EntityManager() {}
    EntityManager.apEntities = [];
    EntityManager.Init = function() {
        EntityManager.apEntities = []
    };
    EntityManager.ShutDown = function() {
        EntityManager.DeleteAll()
    };
    EntityManager.Add = function(psEntity) {
        EntityManager.apEntities[EntityManager.apEntities.length] = psEntity
    };
    EntityManager.DeleteEntity = function(psEntity) {
        psEntityBase.Destroy()
    };
    EntityManager.Update = function() {
        var i;
        for (i = 0; i < this.apEntities.length; i += 1) {
            this.apEntities[i].Update()
        }
        for (i = 0; i < this.apEntities.length; i += 1) {
            var psEntity = this.apEntities[i];
            if (psEntity.bRemove) {
                this.apEntities.splice(i, 1);
                psEntity.Destroy()
            }
        }
    };
    EntityManager.DeleteAll = function() {
        while (this.apEntities.length) {
            this.apEntities[0].Destroy();
            this.apEntities.splice(0, 1)
        }
    };
    EntityManager.Remove = function(psEntity) {
        for (var i = 0; i < this.apEntities.length; i += 1) {
            if (psEntity === this.apEntities[i]) {
                this.apEntities.splice(i, 1);
                return
            }
        }
    };
    var LAYERS_COVER = 0;
    var LAYERS_LEVEL_GRID = 1;
    var LAYERS_HUD = 2;
    var LAYERS_BG = 3;
    var LAYERS_EFFECTS = 4;
    var LAYERS_TOTAL = 5;
    var MainScaler = 1;
    var MouseScaler = 1;

    function GadgetTree() {}
    GadgetTree.m_psRootGadget = null;
    GadgetTree.psLayers = null;
    GadgetTree.Init = function() {
        GadgetTree.m_psRootGadget = Helpers.CreateTree(0, 0, JamSystem.RenderManager.GetRoot());
        GadgetTree.m_psRootGadget.SetScale(MainScaler, MainScaler);
        GadgetTree.psLayers = [];
        var i;
        for (i = 0; i < LAYERS_TOTAL; i += 1) {
            GadgetTree.psLayers[i] = Helpers.CreateTree(0, 0, GadgetTree.m_psRootGadget)
        }
    };
    GadgetTree.GetRoot = function() {
        return GadgetTree.m_psRootGadget
    };
    GadgetTree.GetLayer = function(dwLayer) {
        return GadgetTree.psLayers[dwLayer]
    };
    GadgetTree.ShutDown = function() {
        var i;
        for (i = 0; i < LAYERS_TOTAL; i += 1) {
            Helpers.DestroyTree(GadgetTree.psLayers[i])
        }
        Helpers.DestroyTree(GadgetTree.m_psRootGadget)
    };
    var BUTTON_NORMAL_SCALE = 1;
    var BUTTON_OVER_SCALE = 1.75;
    var BUTTON_BIG_SCALE = 1.5;
    var BUTTON_UNDER_SCALE = .8;
    var GAME_TILT_SENSE = .15;
    var GAME_TILT_DELAY = 5;
    var RESTART_DELAY = 20;

    function Game() {}
    Game.psBoard = 0;
    Game.sContinueButton = {};
    Game.sRestartButton = {};
    Game.sQuitButton = {};
    Game.psUndo = 0;
    Game.psPause = 0;
    Game.psContinuePanel = 0;
    Game.psContinue = 0;
    Game.psRestartPanel = 0;
    Game.psRestart = 0;
    Game.psQuitPanel = 0;
    Game.psQuit = 0;
    Game.bQuitSelected = 0;
    Game.bRestartSelected = 0;
    Game.dwSelectedTimer = 0;
    Game.dwGestureTouch = 0;
    Game.dwGestureTimer = 0;
    Game.fGestureStartX = 0;
    Game.fGestureStartY = 0;
    Game.dwCellX = 0;
    Game.dwCellY = 0;
    Game.dwLastDirection = 0;
    Game.dwLastMove = 0;
    Game.psFileName = 0;
    Game.bTouchActive = 0;
    Game.bChallengeDone = 0;
    Game.psBackground = 0;
    Game.dwButtonScript = 0;
    Game.dwResetScript = 0;
    Game.Init = function() {
        var Level = LevelSelect.GetLevelNumber();
        GlobalMain.MetricsManager.StartGame(Level);
        Game.dwGestureTouch = -1;
        var psScheme = LevelSelect.GetColourScheme();
        Game.psBackground = Helpers.CreateSprite(0, 0, EA.TopLeft, psScheme.dwGameBackgroundImage, GadgetTree.GetLayer(LAYERS_LEVEL_GRID));
        Game.psBackground.SetOpacity(0);
        Game.psBoard = EntityBoard.Create(0, 0, 18, 18, 16 * SCREEN_SCALER, 16 * SCREEN_SCALER, GadgetTree.GetLayer(LAYERS_HUD));
        var psFileName = LevelSelect.GetLevel();
        Game.psBoard.LoadLevelByName(psFileName, LevelSelect.GetColourScheme());
        var x, y;
        var Object = LevelGrid.GetBoard();
        x = Object.x;
        y = Object.y;
        Game.psBoard.SetPosition(x, y, .25, .25);
        Game.psBoard.m_psHud.SetOpacity(0);
        Game.bTouchActive = false
    };
    Game.StartTouch = function() {
        Game.bTouchActive = true;
        Game.psUndo = Helpers.CreateSprite(832 - 50, 670, EA.Default, "ButtonRewind", GadgetTree.GetLayer(LAYERS_BG));
        var dwWidth = Game.psUndo.GetWidth();
        var dwHeight = Game.psUndo.GetHeight();
        Game.sUndoButton = {};
        Game.sUndoButton.x = Game.psUndo.GetPositionX() - dwWidth * .5;
        Game.sUndoButton.y = Game.psUndo.GetPositionY() - dwHeight * .5;
        Game.sUndoButton.x2 = Game.psUndo.GetPositionX() + dwWidth * .5;
        Game.sUndoButton.y2 = Game.psUndo.GetPositionY() + dwHeight * .5;
        Game.psPause = Helpers.CreateSprite(832 + 50, 670, EA.Default, "ButtonPause", GadgetTree.GetLayer(LAYERS_BG));
        var dwWidth = Game.psPause.GetWidth();
        var dwHeight = Game.psPause.GetHeight();
        Game.sPauseButton = {};
        Game.sPauseButton.x = Game.psPause.GetPositionX() - dwWidth * .5;
        Game.sPauseButton.y = Game.psPause.GetPositionY() - dwHeight * .5;
        Game.sPauseButton.x2 = Game.psPause.GetPositionX() + dwWidth * .5;
        Game.sPauseButton.y2 = Game.psPause.GetPositionY() + dwHeight * .5;
        Game.psUndo.SetIsVisible(false);
        Game.psPause.SetIsVisible(false);
        Game.psContinuePanel = Helpers.CreateSprite(SCREEN_WIDTH / 2, 335, EA.Default, "ButtonPlay", GadgetTree.GetLayer(LAYERS_BG));
        Game.psContinue = Helpers.CreateSprite(SCREEN_WIDTH / 2, 335, EA.Default, "ButtonPlay2", GadgetTree.GetLayer(LAYERS_BG));
        Game.sContinueButton.x = Game.psContinue.x - Game.psContinue.GetWidth() / 2;
        Game.sContinueButton.x2 = Game.psContinue.x + Game.psContinue.GetWidth() / 2;
        Game.sContinueButton.y = Game.psContinue.y - Game.psContinue.GetWidth() / 2;
        Game.sContinueButton.y2 = Game.psContinue.y + Game.psContinue.GetWidth() / 2;
        Game.psContinuePanel.SetIsVisible(false);
        Game.psContinue.SetIsVisible(false);
        Game.psRestartPanel = Helpers.CreateSprite(SCREEN_WIDTH / 2, 430, EA.Default, "ButtonRestart", GadgetTree.GetLayer(LAYERS_BG));
        Game.psRestart = Helpers.CreateSprite(SCREEN_WIDTH / 2, 430, EA.Default, "ButtonReset2", GadgetTree.GetLayer(LAYERS_BG));
        Game.sRestartButton.x = Game.psRestart.x - Game.psRestart.GetWidth() / 2;
        Game.sRestartButton.x2 = Game.psRestart.x + Game.psRestart.GetWidth() / 2;
        Game.sRestartButton.y = Game.psRestart.y - Game.psRestart.GetHeight() / 2;
        Game.sRestartButton.y2 = Game.psRestart.y + Game.psRestart.GetHeight() / 2;
        Game.psRestartPanel.SetIsVisible(false);
        Game.psRestart.SetIsVisible(false);
        Game.psQuitPanel = Helpers.CreateSprite(SCREEN_WIDTH / 2, 525, EA.Default, "ButtonQuit", GadgetTree.GetLayer(LAYERS_BG));
        Game.psQuit = Helpers.CreateSprite(SCREEN_WIDTH / 2, 525, EA.Default, "ButtonQuit2", GadgetTree.GetLayer(LAYERS_BG));
        Game.sQuitButton.x = Game.psQuit.x - Game.psQuit.GetWidth() / 2;
        Game.sQuitButton.x2 = Game.psQuit.x + Game.psQuit.GetWidth() / 2;
        Game.sQuitButton.y = Game.psQuit.y - Game.psQuit.GetHeight() / 2;
        Game.sQuitButton.y2 = Game.psQuit.y + Game.psQuit.GetHeight() / 2;
        Game.psQuitPanel.SetIsVisible(false);
        Game.psQuit.SetIsVisible(false);
        Game.bQuitSelected = false;
        Game.psQuit.SetScale(1, 1);
        Game.bRestartSelected = false;
        Game.psRestart.SetScale(1, 1);
        Game.dwSelectedTimer = 0;
        Game.dwButtonScript = -1;
        Game.dwResetScript = -1;
        Game.ShowTouch(true)
    };
    Game.ShowTouch = function(bShow) {
        if (bShow) {
            Game.psUndo.SetIsVisible(true);
            Game.psPause.SetIsVisible(true);
            Touch.Add(Game.sUndoButton);
            Touch.Add(Game.sPauseButton)
        } else {
            Game.psUndo.SetIsVisible(false);
            Game.psPause.SetIsVisible(false);
            Touch.Remove(Game.sUndoButton);
            Touch.Remove(Game.sPauseButton)
        }
    };
    Game.EndTouch = function() {
        if (!Game.bTouchActive) {
            return
        }
        Game.bTouchActive = false;
        Game.ShowTouch(false);
        Helpers.DestroySprite(Game.psPause);
        Helpers.DestroySprite(Game.psUndo);
        Helpers.DestroySprite(Game.psContinuePanel);
        Helpers.DestroySprite(Game.psContinue);
        Helpers.DestroySprite(Game.psRestartPanel);
        Helpers.DestroySprite(Game.psRestart);
        Helpers.DestroySprite(Game.psQuitPanel);
        Helpers.DestroySprite(Game.psQuit)
    };
    Game.ShutDown = function() {
        Game.psBoard.Destroy();
        Game.psBoard = null;
        Helpers.DestroySprite(Game.psBackground)
    };
    Game.HideMenu = function() {
        Game.psContinuePanel.SetIsVisible(false);
        Game.psContinue.SetIsVisible(false);
        Game.psRestartPanel.SetIsVisible(false);
        Game.psRestart.SetIsVisible(false);
        Game.psQuitPanel.SetIsVisible(false);
        Game.psQuit.SetIsVisible(false);
        Touch.Remove(Game.sContinueButton);
        Touch.Remove(Game.sRestartButton);
        Touch.Remove(Game.sQuitButton)
    };
    Game.Update = function() {
        var bUp = false,
            bDown = false,
            bLeft = false,
            bRight = false,
            bUndo = false,
            bPause = false;
        var psArea = Touch.Test(JamSystem.InputManager.GetMouseButtonPressed(0));
        if (GameState.GetState() === GAMESTATE_PAUSE) {
            if (psArea === Game.sPauseButton) {
                Game.HideMenu();
                Globals.BounceImage(Game.psPause);
                Helpers.PlaySound("Pause");
                GlobalMain.MetricsManager.PauseGame();
                GameState.RequestChangeState(GAMESTATE_NORMAL)
            }
        } else {
            Game.psBoard.Update();
            if (Game.psBoard.GetColourComplete()) {
                GameState.ChangeState(GAMESTATE_COLOUR_COMPLETE);
                return
            } else if (Game.psBoard.GetComplete()) {
                GameState.ChangeState(GAMESTATE_COMPLETE);
                return
            }
            if (Application.Cheats) {
                if (GameState.GetState() === GAMESTATE_NORMAL) {
                    if (JamSystem.InputManager.GetKeyPressed(2)) {
                        GameState.RequestChangeState(GAMESTATE_COMPLETE)
                    } else if (JamSystem.InputManager.GetKeyPressed(1)) {
                        GameState.RequestChangeState(GAMESTATE_COMPLETE);
                        Game.psBoard.SetChallengeComplete()
                    }
                }
            }
            if (JamSystem.InputManager.GetKeyHeld(200) || JamSystem.InputManager.GetKeyHeld(0) || JamSystem.InputManager.GetPadButtonHeld(1)) {
                bLeft = true
            }
            if (JamSystem.InputManager.GetKeyHeld(201) || JamSystem.InputManager.GetKeyHeld(3) || JamSystem.InputManager.GetPadButtonHeld(3)) {
                bRight = true
            }
            if (JamSystem.InputManager.GetKeyHeld(202) || JamSystem.InputManager.GetKeyHeld(22) || JamSystem.InputManager.GetPadButtonHeld(0)) {
                bUp = true
            }
            if (JamSystem.InputManager.GetKeyHeld(203) || JamSystem.InputManager.GetKeyHeld(18) || JamSystem.InputManager.GetPadButtonHeld(2)) {
                bDown = true
            }
            if (psArea === Game.sUndoButton || JamSystem.InputManager.GetKeyPressed(403)) {
                bUndo = true
            }
            if (psArea === Game.sPauseButton) {
                bPause = true
            }
            if (Cover.dwTiltControls === 1) {
                if (psArea === null) {
                    if (Game.dwGestureTouch === -1 && JamSystem.InputManager.GetMouseButtonHeld(0)) {
                        Game.dwGestureTouch = 0;
                        Game.dwGestureTimer = 0;
                        Game.fGestureStartX = JamSystem.InputManager.GetMouseX() * MouseScaler;
                        Game.fGestureStartY = JamSystem.InputManager.GetMouseY() * MouseScaler;
                        Game.dwLastDirection = ENTITYBLOCK_MOVE_TOTAL;
                        Game.dwCellX = 0;
                        Game.dwCellY = 0
                    }
                    if (Game.dwGestureTouch !== -1) {
                        Game.dwGestureTimer += 1;
                        if (JamSystem.InputManager.GetMouseButtonHeld(0)) {
                            if (Game.dwGestureTimer >= 2) {
                                if (Game.psBoard.dwState === ENTITYBOARD_STATE_WAIT) {
                                    var x = JamSystem.InputManager.GetMouseX() * MouseScaler - Game.fGestureStartX;
                                    var y = JamSystem.InputManager.GetMouseY() * MouseScaler - Game.fGestureStartY;
                                    var dwDirection = ENTITYBLOCK_MOVE_TOTAL;
                                    var fDiffMin = 20;
                                    var fDiff = Math.sqrt(x * x + y * y);
                                    var dwAngle = Math.floor(Maths.RadToDeg(Math.atan2(x, y)));
                                    if (dwAngle < 0) {
                                        dwAngle += 360
                                    }
                                    dwAngle %= 90;
                                    var dwCellXDiff = Math.floor(x / fDiffMin - Game.dwCellX);
                                    var dwCellYDiff = Math.floor(y / fDiffMin - Game.dwCellY);
                                    if (dwCellXDiff || dwCellYDiff) {
                                        if (Math.abs(dwCellXDiff) > Math.abs(dwCellYDiff)) {
                                            if (dwCellXDiff < 0) {
                                                bLeft = true;
                                                dwDirection = ENTITYBLOCK_MOVE_LEFT;
                                                Game.dwCellX -= 1
                                            } else {
                                                bRight = true;
                                                dwDirection = ENTITYBLOCK_MOVE_RIGHT;
                                                Game.dwCellX += 1
                                            }
                                        } else {
                                            if (dwCellYDiff < 0) {
                                                bUp = true;
                                                dwDirection = ENTITYBLOCK_MOVE_UP;
                                                Game.dwCellY -= 1
                                            } else {
                                                bDown = true;
                                                dwDirection = ENTITYBLOCK_MOVE_DOWN;
                                                Game.dwCellY += 1
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            Game.dwGestureTouch = -1
                        }
                    }
                }
            } else {
                if (psArea === null) {
                    if (LevelSelect.dwGestureTouch === -1 && JamSystem.InputManager.GetMouseButtonHeld(0)) {
                        Game.dwGestureTouch = 0;
                        Game.dwGestureTimer = 0;
                        Game.fGestureStartX = JamSystem.InputManager.GetMouseX() * MouseScaler;
                        Game.fGestureStartY = JamSystem.InputManager.GetMouseY() * MouseScaler;
                        Game.dwLastDirection = ENTITYBLOCK_MOVE_TOTAL;
                        Game.dwLastMove = ENTITYBLOCK_MOVE_TOTAL;
                        Game.dwCellX = 0;
                        Game.dwCellY = 0
                    }
                    if (Game.dwGestureTouch !== -1) {
                        if (JamSystem.InputManager.GetMouseButtonHeld(0)) {
                            if (Game.psBoard.dwState === ENTITYBOARD_STATE_WAIT) {
                                Game.dwGestureTimer += 1;
                                var x = JamSystem.InputManager.GetMouseX() * MouseScaler - Game.fGestureStartX;
                                var y = JamSystem.InputManager.GetMouseY() * MouseScaler - Game.fGestureStartY;
                                var dwDirection = ENTITYBLOCK_MOVE_TOTAL;
                                var fDiffMin = 20;
                                var fDiff = Math.sqrt(x * x + y * y);
                                var dwAngle = Math.floor(Maths.RadToDeg(Math.atan2(x, y)));
                                if (dwAngle < 0) {
                                    dwAngle += 360
                                }
                                dwAngle %= 90;
                                var dwCellXDiff = Math.floor(x / fDiffMin);
                                var dwCellYDiff = Math.floor(y / fDiffMin);
                                if (dwCellXDiff || dwCellYDiff) {
                                    if (Math.abs(dwCellXDiff) > Math.abs(dwCellYDiff)) {
                                        if (dwCellXDiff < 0) {
                                            bLeft = true;
                                            dwDirection = ENTITYBLOCK_MOVE_LEFT;
                                            Game.dwCellX -= 1
                                        } else {
                                            bRight = true;
                                            dwDirection = ENTITYBLOCK_MOVE_RIGHT;
                                            Game.dwCellX += 1
                                        }
                                    } else {
                                        if (dwCellYDiff < 0) {
                                            bUp = true;
                                            dwDirection = ENTITYBLOCK_MOVE_UP;
                                            Game.dwCellY -= 1
                                        } else {
                                            bDown = true;
                                            dwDirection = ENTITYBLOCK_MOVE_DOWN;
                                            Game.dwCellY += 1
                                        }
                                    }
                                    Game.dwLastMove = dwDirection;
                                    Game.dwGestureTimer = 0
                                }
                            }
                        } else {
                            Game.dwGestureTouch = -1
                        }
                    }
                }
            }
            if (bUp) {
                Game.psBoard.Move(ENTITYBLOCK_MOVE_UP)
            } else if (bDown) {
                Game.psBoard.Move(ENTITYBLOCK_MOVE_DOWN)
            } else if (bLeft) {
                Game.psBoard.Move(ENTITYBLOCK_MOVE_LEFT)
            } else if (bRight) {
                Game.psBoard.Move(ENTITYBLOCK_MOVE_RIGHT)
            } else {
                Game.psBoard.Move(ENTITYBLOCK_MOVE_TOTAL)
            }
            if (bUndo) {
                Globals.BounceImage(Game.psUndo);
                Game.psBoard.Undo()
            }
            if (Game.psBoard.GetNumUndos()) {
                Game.psUndo.SetOpacity(255 / 255)
            } else {
                Game.psUndo.SetOpacity(128 / 255)
            }
            if (bPause) {
                Game.psContinue.SetIsVisible(true);
                Game.psRestart.SetIsVisible(true);
                Game.psQuit.SetIsVisible(true);
                Touch.Add(Game.sContinueButton);
                Touch.Add(Game.sRestartButton);
                Touch.Add(Game.sQuitButton);
                GlobalMain.MetricsManager.PauseGame();
                Globals.BounceImage(Game.psPause);
                GameState.RequestChangeState(GAMESTATE_PAUSE);
                Helpers.PlaySound("Pause");
                GlobalMain.MusicManager.SetVolume(.5)
            }
            Game.dwSelectedTimer += 1
        }
        if ((JamSystem.InputManager.GetKeyHeld(302) || JamSystem.InputManager.GetKeyHeld(303)) && JamSystem.InputManager.GetKeyPressed(16)) {
            Game.bQuitSelected = false;
            Game.psQuit.SetIsVisible(true);
            Game.HideMenu();
            if (!Script.GetIsFinished(Game.dwButtonScript)) {
                Script.Stop(Game.dwButtonScript, true)
            }
            Helpers.PlaySound("Quit");
            GlobalMain.MetricsManager.QuitGame();
            GameState.RequestChangeState(GAMESTATE_END)
        }
        if (Game.bQuitSelected) {
            if (psArea) {
                Game.bQuitSelected = false;
                Game.psQuit.SetIsVisible(true);
                if (psArea === Game.sQuitButton) {
                    if (Script.GetIsFinished(Game.dwButtonScript)) {
                        Game.dwButtonScript = Script.Add(ScriptData.ScaleToBounce);
                        Script.SetLocalVariableID(Game.dwButtonScript, SCRIPT_LOCAL_VARIABLE_1, Game.psQuit);
                        Script.SetLocalVariableID(Game.dwButtonScript, SCRIPT_LOCAL_VARIABLE_2, BUTTON_BIG_SCALE * 100);
                        Script.SetLocalVariableID(Game.dwButtonScript, SCRIPT_LOCAL_VARIABLE_3, BUTTON_UNDER_SCALE * 100);
                        Script.SetLocalVariableID(Game.dwButtonScript, SCRIPT_LOCAL_VARIABLE_4, BUTTON_NORMAL_SCALE * 100);
                        Script.SetLocalVariableID(Game.dwButtonScript, SCRIPT_LOCAL_VARIABLE_5, 990)
                    } else {
                        Game.psQuit.SetScale(BUTTON_NORMAL_SCALE, BUTTON_NORMAL_SCALE)
                    }
                    Game.HideMenu();
                    if (psArea === Game.sQuitButton) {
                        if (!Script.GetIsFinished(Game.dwButtonScript)) {
                            Script.Stop(Game.dwButtonScript, true)
                        }
                        GlobalMain.MetricsManager.QuitGame();
                        Helpers.PlaySound("Quit");
                        GameState.RequestChangeState(GAMESTATE_END)
                    }
                } else {
                    if (Script.GetIsFinished(Game.dwButtonScript)) {
                        Game.dwButtonScript = Script.Add(ScriptData.ScaleToBounce);
                        Script.SetLocalVariableID(Game.dwButtonScript, SCRIPT_LOCAL_VARIABLE_1, Game.psQuit);
                        Script.SetLocalVariableID(Game.dwButtonScript, SCRIPT_LOCAL_VARIABLE_2, BUTTON_BIG_SCALE * 100);
                        Script.SetLocalVariableID(Game.dwButtonScript, SCRIPT_LOCAL_VARIABLE_3, BUTTON_UNDER_SCALE * 100);
                        Script.SetLocalVariableID(Game.dwButtonScript, SCRIPT_LOCAL_VARIABLE_4, BUTTON_NORMAL_SCALE * 100);
                        Script.SetLocalVariableID(Game.dwButtonScript, SCRIPT_LOCAL_VARIABLE_5, 991)
                    } else {
                        Game.psQuit.SetScale(BUTTON_NORMAL_SCALE, BUTTON_NORMAL_SCALE)
                    }
                }
            }
        } else {
            if (psArea === Game.sQuitButton) {
                Helpers.PlaySound("OptionIndicated");
                if (Script.GetIsFinished(Game.dwButtonScript)) {
                    Game.dwButtonScript = Script.Add(ScriptData.ScaleToBounce);
                    Script.SetLocalVariableID(Game.dwButtonScript, SCRIPT_LOCAL_VARIABLE_1, Game.psQuit);
                    Script.SetLocalVariableID(Game.dwButtonScript, SCRIPT_LOCAL_VARIABLE_2, BUTTON_NORMAL_SCALE * 100);
                    Script.SetLocalVariableID(Game.dwButtonScript, SCRIPT_LOCAL_VARIABLE_3, BUTTON_OVER_SCALE * 100);
                    Script.SetLocalVariableID(Game.dwButtonScript, SCRIPT_LOCAL_VARIABLE_4, BUTTON_BIG_SCALE * 100);
                    Script.SetLocalVariableID(Game.dwButtonScript, SCRIPT_LOCAL_VARIABLE_5, 990)
                } else {
                    Game.psQuit.SetScale(BUTTON_BIG_SCALE, BUTTON_BIG_SCALE)
                }
                Game.bQuitSelected = true
            }
        }
        if ((JamSystem.InputManager.GetKeyHeld(302) || JamSystem.InputManager.GetKeyHeld(303)) && JamSystem.InputManager.GetKeyPressed(17)) {
            Game.bRestartSelected = false;
            Game.psRestart.SetIsVisible(true);
            if (!Script.GetIsFinished(Game.dwResetScript)) {
                Script.Stop(Game.dwResetScript, true)
            }
            Game.psRestart.SetScale(BUTTON_NORMAL_SCALE, BUTTON_NORMAL_SCALE);
            Game.psBoard.Reset();
            Game.HideMenu();
            Helpers.PlaySound("Reset");
            GameState.RequestChangeState(GAMESTATE_NORMAL);
            GlobalMain.MetricsManager.RestartGame();
            var psEffect = EntityEffect.Create(0, 0, ENTITYEFFECT_TYPE_SCREEN_FLASH, GadgetTree.GetLayer(LAYERS_HUD));
            EntityManager.Add(psEffect)
        }
        if (Game.bRestartSelected) {
            if (psArea) {
                Game.bRestartSelected = false;
                Game.psRestart.SetIsVisible(true);
                if (psArea === Game.sRestartButton) {
                    if (!Script.GetIsFinished(Game.dwResetScript)) {
                        Script.Stop(Game.dwResetScript, true)
                    }
                    Game.psRestart.SetScale(BUTTON_NORMAL_SCALE, BUTTON_NORMAL_SCALE);
                    Game.psBoard.Reset();
                    Game.HideMenu();
                    Helpers.PlaySound("Reset");
                    GameState.RequestChangeState(GAMESTATE_NORMAL);
                    GlobalMain.MetricsManager.RestartGame();
                    var psEffect = EntityEffect.Create(0, 0, ENTITYEFFECT_TYPE_SCREEN_FLASH, GadgetTree.GetLayer(LAYERS_HUD));
                    EntityManager.Add(psEffect)
                } else {
                    if (Script.GetIsFinished(Game.dwResetScript)) {
                        Game.dwResetScript = Script.Add(ScriptData.ScaleToBounce);
                        Script.SetLocalVariableID(Game.dwResetScript, SCRIPT_LOCAL_VARIABLE_1, Game.psRestart);
                        Script.SetLocalVariableID(Game.dwResetScript, SCRIPT_LOCAL_VARIABLE_2, BUTTON_BIG_SCALE * 100);
                        Script.SetLocalVariableID(Game.dwResetScript, SCRIPT_LOCAL_VARIABLE_3, BUTTON_UNDER_SCALE * 100);
                        Script.SetLocalVariableID(Game.dwResetScript, SCRIPT_LOCAL_VARIABLE_4, BUTTON_NORMAL_SCALE * 100);
                        Script.SetLocalVariableID(Game.dwResetScript, SCRIPT_LOCAL_VARIABLE_5, 991)
                    } else {
                        Game.psRestart.SetScale(BUTTON_NORMAL_SCALE, BUTTON_NORMAL_SCALE)
                    }
                }
            }
        } else {
            if (psArea === Game.sRestartButton) {
                Helpers.PlaySound("OptionIndicated");
                if (Script.GetIsFinished(Game.dwResetScript)) {
                    Game.dwResetScript = Script.Add(ScriptData.ScaleToBounce);
                    Script.SetLocalVariableID(Game.dwResetScript, SCRIPT_LOCAL_VARIABLE_1, Game.psRestart);
                    Script.SetLocalVariableID(Game.dwResetScript, SCRIPT_LOCAL_VARIABLE_2, BUTTON_NORMAL_SCALE * 100);
                    Script.SetLocalVariableID(Game.dwResetScript, SCRIPT_LOCAL_VARIABLE_3, BUTTON_OVER_SCALE * 100);
                    Script.SetLocalVariableID(Game.dwResetScript, SCRIPT_LOCAL_VARIABLE_4, BUTTON_BIG_SCALE * 100);
                    Script.SetLocalVariableID(Game.dwResetScript, SCRIPT_LOCAL_VARIABLE_5, 991)
                } else {
                    Game.psRestart.SetScale(BUTTON_BIG_SCALE, BUTTON_BIG_SCALE)
                }
                Game.bRestartSelected = true
            }
        }
        if (psArea === Game.sContinueButton) {
            Game.HideMenu();
            GameState.RequestChangeState(GAMESTATE_NORMAL);
            GlobalMain.MetricsManager.PauseGame();
            Helpers.PlaySound("OptionIndicated")
        }
    };
    Game.SetOpacity = function(fOpacity) {
        if (fOpacity < 0) {
            fOpacity = 0
        }
        Game.psBackground.SetOpacity(fOpacity / 255)
    };

    function GameState() {}
    var GAMESTATE_NONE = 0;
    var GAMESTATE_START = 1;
    var GAMESTATE_START_IMMEDIATE = 2;
    var GAMESTATE_GO = 3;
    var GAMESTATE_NORMAL = 4;
    var GAMESTATE_PAUSE = 5;
    var GAMESTATE_COLOUR_COMPLETE = 6;
    var GAMESTATE_COMPLETE = 7;
    var GAMESTATE_CHALLANGE_COMPLETE = 8;
    var GAMESTATE_REVIEW = 9;
    var GAMESTATE_END = 10;
    var GAMESTATE_TOTAL = 11;
    GameState.asStateUpdateWorld = [{
        bUpdateWorld: false,
        bScript: false,
        eNewState: GAMESTATE_NORMAL
    }, {
        bUpdateWorld: true,
        bScript: true,
        eNewState: GAMESTATE_GO
    }, {
        bUpdateWorld: true,
        bScript: true,
        eNewState: GAMESTATE_NORMAL
    }, {
        bUpdateWorld: true,
        bScript: true,
        eNewState: GAMESTATE_NORMAL
    }, {
        bUpdateWorld: true,
        bScript: false,
        eNewState: GAMESTATE_NORMAL
    }, {
        bUpdateWorld: true,
        bScript: false,
        eNewState: GAMESTATE_NORMAL
    }, {
        bUpdateWorld: true,
        bScript: true,
        eNewState: GAMESTATE_NORMAL
    }, {
        bUpdateWorld: true,
        bScript: true,
        eNewState: GAMESTATE_NORMAL
    }, {
        bUpdateWorld: true,
        bScript: true,
        eNewState: GAMESTATE_NORMAL
    }, {
        bUpdateWorld: true,
        bScript: false,
        eNewState: GAMESTATE_NORMAL
    }, {
        bUpdateWorld: true,
        bScript: true,
        eNewState: GAMESTATE_NORMAL
    }];
    GameState.eState = 0;
    GameState.eRequestChangeState = GAMESTATE_TOTAL;
    GameState.eRequestedState = 0;
    GameState.dwCurrentScript = 0;
    GameState.psPausedFade = 0;
    GameState.psPaused = 0;
    GameState.psPausedGlow = 0;
    GameState.bReview = 0;
    GameState.adwChallengeCompleteText = ["DATATEXT_ID_TWO_OF_A_KIND", "DATATEXT_ID_THREE_OF_A_KIND", "DATATEXT_ID_BEAT_TIME", "DATATEXT_ID_BEAT_MOVES", "DATATEXT_ID_SHAPE_MADE"];
    GameState.Init = function() {
        GameState.eRequestedState = GAMESTATE_TOTAL;
        GameState.eRequestChangeState = GAMESTATE_TOTAL;
        Globals.StopBackgroundMusic();
        Game.Init();
        if (!LevelSelect.bImmediateStart) {
            GameState.SetState(GAMESTATE_START)
        } else {
            GameState.SetState(GAMESTATE_START_IMMEDIATE)
        }
    };
    GameState.ShutDown = function() {
        GameState.EndState();
        Game.ShutDown();
        if (!Script.GetIsFinished(GameState.dwCurrentScript)) {
            Script.Stop(GameState.dwCurrentScript, true);
            Script.DestroyObjects()
        }
    };
    GameState.GetState = function() {
        return GameState.eState
    };
    GameState.EndState = function() {
        if (!Script.GetIsFinished(GameState.dwCurrentScript)) {
            Script.Stop(GameState.dwCurrentScript, true)
        }
        switch (GameState.eState) {
            case GAMESTATE_NORMAL:
                break;
            case GAMESTATE_START:
                Game.StartTouch();
                Game.psBoard.SetState(ENTITYBOARD_STATE_WAIT);
                Game.psBoard.m_psHud.SetOpacity(255);
                GameState.SetState(GAMESTATE_GO);
                break;
            case GAMESTATE_START_IMMEDIATE:
                Game.StartTouch();
                Game.psBoard.SetState(ENTITYBOARD_STATE_WAIT);
                Game.psBoard.m_psHud.SetOpacity(255);
                GameState.SetState(GAMESTATE_NORMAL);
                break;
            case GAMESTATE_GO:
                GameState.SetState(GAMESTATE_NORMAL);
                Globals.SetBackgroundMusic("PlayTheme", true);
                break;
            case GAMESTATE_PAUSE:
                Globals.SetBackgroundMusicVolume(1);
                Helpers.DestroySprite(GameState.psPaused);
                Helpers.DestroySprite(GameState.psPausedGlow);
                Helpers.DestroySprite(GameState.psPausedFade);
                Game.psUndo.SetOpacity(255 / 255);
                break;
            case GAMESTATE_COLOUR_COMPLETE:
                Game.ShowTouch(true);
                Game.psBoard.EndCompleteCeremony();
                Game.psBoard.m_psHud.EndCompleteCeremony();
                GameState.SetState(GAMESTATE_NORMAL);
                break;
            case GAMESTATE_COMPLETE:
                Game.psBoard.EndCompleteCeremony();
                Game.psBoard.m_psHud.EndCompleteCeremony();
                Game.psBoard.CalcChallengeComplete();
                if (Game.psBoard.GetChallengeComplete()) {
                    var dwLevel = LevelSelect.GetLevelNumber();
                    var achTemp;
                    if (LevelData_asData[dwLevel].dwBonusType === BONUS_TYPE_TIME) {
                        achTemp = JamSystem.TextManager.GetText(GameState.adwChallengeCompleteText[LevelData_asData[dwLevel].dwBonusType], [LevelData_asData[dwLevel].dwParTime])
                    } else if (LevelData_asData[dwLevel].dwBonusType === BONUS_TYPE_MOVES) {
                        achTemp = JamSystem.TextManager.GetText(GameState.adwChallengeCompleteText[LevelData_asData[dwLevel].dwBonusType], [LevelData_asData[dwLevel].dwParMoves])
                    } else {
                        achTemp = JamSystem.TextManager.GetText(GameState.adwChallengeCompleteText[LevelData_asData[dwLevel].dwBonusType])
                    }
                    Script.SetGlobalVariable(SCRIPT_GLOBAL_VARIABLE_4, achTemp);
                    GameState.SetState(GAMESTATE_CHALLANGE_COMPLETE)
                } else {
                    GameState.SetState(GAMESTATE_REVIEW)
                }
                break;
            case GAMESTATE_CHALLANGE_COMPLETE:
                GameState.SetState(GAMESTATE_REVIEW);
                break;
            case GAMESTATE_REVIEW:
                Review.ShutDown();
                GameState.SetState(GAMESTATE_END);
                break;
            case GAMESTATE_END:
                if (GameState.bReview) {
                    Review.ShutDownScreen()
                }
                GameState.eState = GAMESTATE_NONE;
                Globals.SetBackgroundMusic("LevelSelectTheme", true);
                GlobalMain.StateManager.RequestChangeState(StateManager.StateLevelSelect);
                break;
            default:
                break
        }
        return true
    };
    GameState.SetState = function(eState) {
        GameState.eState = eState;
        Touch.Clear();
        GameState.dwCurrentScript = -1;
        switch (GameState.eState) {
            case GAMESTATE_START:
                GameState.dwCurrentScript = Script.Add(ScriptData.Start);
                Script.SetLocalVariableID(GameState.dwCurrentScript, SCRIPT_LOCAL_VARIABLE_6, LevelGrid.GetLevel(LevelSelect.GetLevelNumber()));
                GameState.bReview = false;
                break;
            case GAMESTATE_START_IMMEDIATE:
                GameState.dwCurrentScript = Script.Add(ScriptData.StartImmediate);
                GameState.bReview = false;
                break;
            case GAMESTATE_GO:
                GameState.dwCurrentScript = Script.Add(ScriptData.Go);
                break;
            case GAMESTATE_NORMAL:
                break;
            case GAMESTATE_PAUSE:
                Globals.SetBackgroundMusicVolume(.5);
                GameState.psPausedFade = Helpers.CreateSprite(0, 0, EA.TopLeft, "Black", GadgetTree.GetLayer(LAYERS_HUD));
                GameState.psPausedFade.SetScale(SCREEN_WIDTH, SCREEN_HEIGHT);
                GameState.psPausedFade.SetOpacity(128 / 255);
                GameState.psPausedGlow = Helpers.CreateSprite(SCREEN_WIDTH / 2, 200, EA.Default, "GlowRound", GadgetTree.GetLayer(LAYERS_HUD));
                GameState.psPausedGlow.SetScale(2.3, .8);
                var psScheme = LevelSelect.GetColourScheme();
                GameState.psPausedGlow.SetColour([psScheme.fRed / 255, psScheme.fGreen / 255, psScheme.fBlue / 255, 1]);
                GameState.psPaused = Helpers.CreateBitmapText(JamSystem.TextManager.GetText("DATATEXT_ID_HUD_PAUSED"), SCREEN_WIDTH / 2, 200, EA.Default, "PanelFont", GadgetTree.GetLayer(LAYERS_HUD));
                Game.psUndo.SetOpacity(128 / 255);
                break;
            case GAMESTATE_COLOUR_COMPLETE:
                GameState.dwCurrentScript = Script.Add(ScriptData.ColourComplete);
                Game.ShowTouch(false);
                break;
            case GAMESTATE_COMPLETE:
                Globals.FadeBackgroundMusic();
                var dwLevel = LevelSelect.GetLevelNumber();
                if (Game.psBoard.GetChallengeComplete() && Records.GetScore(dwLevel) !== 0) {
                    Game.psBoard.m_psHud.ObjectiveComplete()
                }
                Game.EndTouch();
                Review.LevelComplete();
                Review.SetupScreen();
                GameState.dwCurrentScript = Script.Add(ScriptData.Complete);
                Globals.StopBackgroundMusic();
                if (Game.psBoard.GetChallengeComplete()) {
                    Script.SetLocalVariableID(GameState.dwCurrentScript, SCRIPT_LOCAL_VARIABLE_1, 1)
                } else {
                    Script.SetLocalVariableID(GameState.dwCurrentScript, SCRIPT_LOCAL_VARIABLE_1, 0)
                }
                break;
            case GAMESTATE_CHALLANGE_COMPLETE:
                var dwBonusImage1, dwBonusImage2, dwBonusImage3, dwBonusImage4;
                if (!LevelSelect.GetSecret()) {
                    dwBonusImage1 = "BonusStarBigPart01";
                    dwBonusImage2 = "BonusStarBigPart02";
                    dwBonusImage3 = "BonusStarBigPart03";
                    dwBonusImage4 = "BonusStarBigPart04"
                } else {
                    dwBonusImage1 = LevelSelect.GetColourScheme().dwSecretBonusBigImages[LevelSelect.GetPageNumber() % NUM_LOCATIONS][0];
                    dwBonusImage2 = LevelSelect.GetColourScheme().dwSecretBonusBigImages[LevelSelect.GetPageNumber() % NUM_LOCATIONS][1];
                    dwBonusImage3 = LevelSelect.GetColourScheme().dwSecretBonusBigImages[LevelSelect.GetPageNumber() % NUM_LOCATIONS][2];
                    dwBonusImage4 = LevelSelect.GetColourScheme().dwSecretBonusBigImages[LevelSelect.GetPageNumber() % NUM_LOCATIONS][3]
                }
                GameState.dwCurrentScript = Script.Add(ScriptData.ChallengeComplete);
                Script.SetLocalVariableID(GameState.dwCurrentScript, SCRIPT_LOCAL_VARIABLE_1, dwBonusImage1);
                Script.SetLocalVariableID(GameState.dwCurrentScript, SCRIPT_LOCAL_VARIABLE_2, dwBonusImage2);
                Script.SetLocalVariableID(GameState.dwCurrentScript, SCRIPT_LOCAL_VARIABLE_3, dwBonusImage3);
                Script.SetLocalVariableID(GameState.dwCurrentScript, SCRIPT_LOCAL_VARIABLE_4, dwBonusImage4);
                break;
            case GAMESTATE_REVIEW:
                GameState.bReview = true;
                Review.Init();
                break;
            case GAMESTATE_END:
                Game.EndTouch();
                GameState.dwCurrentScript = Script.Add(ScriptData.End);
                var x, y;
                var Object = LevelGrid.GetBoard();
                x = Object.x;
                y = Object.y;
                Script.SetLocalVariableID(GameState.dwCurrentScript, SCRIPT_LOCAL_VARIABLE_1, x);
                Script.SetLocalVariableID(GameState.dwCurrentScript, SCRIPT_LOCAL_VARIABLE_2, y);
                Script.SetLocalVariableID(GameState.dwCurrentScript, SCRIPT_LOCAL_VARIABLE_3, .25 * 100);
                Script.SetLocalVariableID(GameState.dwCurrentScript, SCRIPT_LOCAL_VARIABLE_4, .25 * 100);
                Script.SetLocalVariableID(GameState.dwCurrentScript, SCRIPT_LOCAL_VARIABLE_5, GameState.bReview);
                Script.SetLocalVariableID(GameState.dwCurrentScript, SCRIPT_LOCAL_VARIABLE_6, LevelGrid.GetLevel(LevelSelect.GetLevelNumber()));
                break;
            default:
                break
        }
    };
    GameState.ChangeState = function(eState) {
        GameState.EndState();
        GameState.SetState(eState)
    };
    GameState.RequestChangeState = function(eState) {
        GameState.eRequestedState = eState
    };
    GameState.UpdateLobby = function() {};
    GameState.Update = function() {
        EntityManager.Update();
        Script.Update();
        switch (GameState.eState) {
            case GAMESTATE_NORMAL:
            case GAMESTATE_GO:
                Game.Update();
                break;
            case GAMESTATE_START:
            case GAMESTATE_START_IMMEDIATE:
            case GAMESTATE_END:
                Game.psBoard.Update();
                break;
            case GAMESTATE_PAUSE:
                Game.Update();
                break;
            case GAMESTATE_REVIEW:
                Game.psBoard.Update();
                Review.Update();
                break;
            default:
                break
        }
        if (GameState.asStateUpdateWorld[GameState.eState].bScript && Script.GetIsFinished(GameState.dwCurrentScript)) {
            GameState.EndState()
        } else {
            if (GameState.eRequestedState !== GAMESTATE_TOTAL) {
                GameState.ChangeState(GameState.eRequestedState);
                GameState.eRequestedState = GAMESTATE_TOTAL
            }
        }
    };
    var NUM_HELP_PAGES = 2;
    var HELP_RETURN_X = SCREEN_WIDTH / 2 - 190 - 270;
    var HELP_RETURN_Y = SCREEN_HEIGHT - 50 - 615;
    var BUTTON_LEFT_X = SCREEN_WIDTH / 2 - 50;
    var BUTTON_LEFT_Y = SCREEN_HEIGHT - 50;
    var BUTTON_RIGHT_X = SCREEN_WIDTH / 2 + 50;
    var BUTTON_RIGHT_Y = SCREEN_HEIGHT - 50;
    var DOT_SPACING = 40;
    var HELP_STATE_START = 0;
    var HELP_STATE_WAIT = 1;
    var HELP_STATE_DRAG = 2;
    var HELP_STATE_SPRING = 3;
    var HELP_STATE_END = 4;
    var HELP_STATE_TOTAL = 5;

    function Help() {}
    Help.psReturn = 0;
    Help.psButtonLeft = 0;
    Help.sReturnArea = {};
    Help.sButtonLeftArea = {};
    Help.sButtonRightArea = {};
    Help.sDotsArea = {};
    Help.sLinkArea = {};
    Help.sDenkiArea = {};
    Help.sFaceBookArea = {};
    Help.sYoutubeArea = {};
    Help.sTwitterArea = {};
    Help.dwState = 0;
    Help.dwScript = 0;
    Help.dwPage = 0;
    Help.fOffset = 0;
    Help.dwGestureTouch = 0;
    Help.fGestureStartX = 0;
    Help.fGestureStartY = 0;
    Help.fRootStartX = 0;
    Help.dwStateTimer = 0;
    Help.psRoot = 0;
    Help.bPageClick = 0;
    Help.bGestureStarted = 0;
    Help.fLastXDiff = 0;
    Help.fSpeed = 0;
    Help.pasPageDots = [];
    Help.psBG = 0;
    var CLOUD_NORMAL_SPEED = .5;
    Help.asSprites = [{
        dwImage: "HelpPuzzle1",
        x: 200,
        y: 108,
        eAlignment: EA.TopMiddle,
        fScaleX: .75,
        fScaleY: .75,
        r: 255,
        g: 255,
        b: 255
    }, {
        dwImage: "HelpPuzzle3",
        x: 208,
        y: 388,
        eAlignment: EA.TopMiddle,
        fScaleX: .75,
        fScaleY: .75,
        r: 255,
        g: 255,
        b: 255
    }, {
        dwImage: "HelpPuzzle2",
        x: 688,
        y: 108,
        eAlignment: EA.TopMiddle,
        fScaleX: .75,
        fScaleY: .75,
        r: 255,
        g: 255,
        b: 255
    }, {
        dwImage: "Stars",
        x: 688,
        y: 444,
        eAlignment: EA.Default,
        fScaleX: .5,
        fScaleY: .5,
        r: 255,
        g: 255,
        b: 255
    }, {
        dwImage: "DenkiLogo",
        x: 1536,
        y: 160,
        eAlignment: EA.Default,
        fScaleX: 1,
        fScaleY: 1,
        r: 255,
        g: 255,
        b: 255
    }, {
        dwImage: "NewWhite",
        x: 1536,
        y: 256,
        eAlignment: EA.Default,
        fScaleX: 200,
        fScaleY: 4,
        r: 40,
        g: 121,
        b: 228
    }, {
        dwImage: "NewWhite",
        x: 1536,
        y: 304,
        eAlignment: EA.Default,
        fScaleX: 245,
        fScaleY: 4,
        r: 40,
        g: 121,
        b: 228
    }, {
        dwImage: "NewWhite",
        x: 1536,
        y: 352,
        eAlignment: EA.Default,
        fScaleX: 265,
        fScaleY: 4,
        r: 40,
        g: 121,
        b: 228
    }, {
        dwImage: "NewWhite",
        x: 1536,
        y: 400,
        eAlignment: EA.Default,
        fScaleX: 260,
        fScaleY: 4,
        r: 40,
        g: 121,
        b: 228
    }];
    Help.asTexts = [{
        dwText: "DATATEXT_ID_HELP_TITLE",
        x: SCREEN_WIDTH * 0 + SCREEN_WIDTH / 2,
        y: 64,
        eAlignment: EA.Default,
        r: 255,
        g: 255,
        b: 255,
        fScale: .9
    }, {
        dwText: "DATATEXT_ID_HELP_PAGE_1_TEXT_1",
        x: 352,
        y: 220,
        eAlignment: EA.MiddleLeft,
        r: 0,
        g: 84,
        b: 119,
        fScale: .35
    }, {
        dwText: "DATATEXT_ID_HELP_PAGE_2_TEXT_1",
        x: 352,
        y: 500,
        eAlignment: EA.MiddleLeft,
        r: 0,
        g: 84,
        b: 119,
        fScale: .35
    }, {
        dwText: "DATATEXT_ID_HELP_PAGE_1_TEXT_2",
        x: 840,
        y: 220,
        eAlignment: EA.MiddleLeft,
        r: 0,
        g: 84,
        b: 119,
        fScale: .35
    }, {
        dwText: "DATATEXT_ID_HELP_TEXT_EXTRA_1",
        x: 64,
        y: 356,
        eAlignment: EA.MiddleLeft,
        r: 0,
        g: 84,
        b: 119,
        fScale: .35
    }, {
        dwText: "DATATEXT_ID_HELP_TEXT_EXTRA_2",
        x: 552,
        y: 356,
        eAlignment: EA.MiddleLeft,
        r: 0,
        g: 84,
        b: 119,
        fScale: .35
    }, {
        dwText: "DATATEXT_ID_HELP_TITLE",
        x: SCREEN_WIDTH * 1 + SCREEN_WIDTH / 2,
        y: 64,
        eAlignment: EA.Default,
        r: 255,
        g: 255,
        b: 255,
        fScale: .9
    }, {
        dwText: "DATATEXT_ID_HELP_PAGE_3_TEXT_5",
        x: 704,
        y: 550,
        eAlignment: EA.Default,
        r: 0,
        g: 84,
        b: 119,
        fScale: .35
    }, {
        dwText: "DATATEXT_ID_HELP_PAGE_4_TEXT_1",
        x: 1536,
        y: 240,
        eAlignment: EA.Default,
        r: 22,
        g: 76,
        b: 210,
        fScale: .35
    }, {
        dwText: "DATATEXT_ID_HELP_PAGE_4_TEXT_2",
        x: 1536,
        y: 288,
        eAlignment: EA.Default,
        r: 22,
        g: 76,
        b: 210,
        fScale: .35
    }, {
        dwText: "DATATEXT_ID_HELP_PAGE_4_TEXT_3",
        x: 1536,
        y: 336,
        eAlignment: EA.Default,
        r: 22,
        g: 76,
        b: 210,
        fScale: .35
    }, {
        dwText: "DATATEXT_ID_HELP_PAGE_4_TEXT_4",
        x: 1536,
        y: 384,
        eAlignment: EA.Default,
        r: 22,
        g: 76,
        b: 210,
        fScale: .35
    }, {
        dwText: "DATATEXT_ID_HELP_PAGE_4_TEXT_5",
        x: 1536,
        y: 464,
        eAlignment: EA.Default,
        r: 0,
        g: 84,
        b: 119,
        fScale: .25
    }, {
        dwText: "DATATEXT_ID_HELP_PAGE_4_TEXT_6",
        x: 1536,
        y: 520,
        eAlignment: EA.Default,
        r: 0,
        g: 84,
        b: 119,
        fScale: .25
    }, {
        dwText: "DATATEXT_ID_HELP_PAGE_4_TEXT_7",
        x: 1536,
        y: 576,
        eAlignment: EA.Default,
        r: 0,
        g: 84,
        b: 119,
        fScale: .25
    }];
    Help.asClouds = [{
        dwImage: "CloudBackground1",
        x: SCREEN_WIDTH * 0 + 221 * SCREEN_SCALER + 64,
        y: 35 * SCREEN_SCALER + 32,
        fScale: 1,
        fSpeed: CLOUD_NORMAL_SPEED
    }, {
        dwImage: "CloudBackground1",
        x: SCREEN_WIDTH * 0 + 73 * SCREEN_SCALER + 64,
        y: 122 * SCREEN_SCALER + 32,
        fScale: 1,
        fSpeed: CLOUD_NORMAL_SPEED
    }, {
        dwImage: "CloudForeground1",
        x: SCREEN_WIDTH * 0 + 244 * SCREEN_SCALER + 64,
        y: 337 * SCREEN_SCALER + 32,
        fScale: .65,
        fSpeed: CLOUD_NORMAL_SPEED
    }, {
        dwImage: "CloudForeground2",
        x: SCREEN_WIDTH * 0 + 188 * SCREEN_SCALER + 64,
        y: 59 * SCREEN_SCALER + 32,
        fScale: .55,
        fSpeed: CLOUD_NORMAL_SPEED
    }, {
        dwImage: "CloudForeground2",
        x: SCREEN_WIDTH * 0 + 205 * SCREEN_SCALER + 64,
        y: 337 * SCREEN_SCALER + 32,
        fScale: .55,
        fSpeed: CLOUD_NORMAL_SPEED
    }, {
        dwImage: "CloudForeground2",
        x: SCREEN_WIDTH * 0 + 62 * SCREEN_SCALER + 64,
        y: 420 * SCREEN_SCALER + 32,
        fScale: .55,
        fSpeed: CLOUD_NORMAL_SPEED
    }];
    Help.papSprites = [];
    Help.papTexts = [];
    Help.papClouds = [];
    Help.CreateScene = function() {
        Help.psBG = Helpers.CreateSprite(0, 0, EA.TopLeft, "HelpBackground", Help.psRoot);
        Help.psBG.SetScale(SCREEN_WIDTH * NUM_HELP_PAGES, SCREEN_HEIGHT / 16);
        var i, j, x, y;
        var dwBaseClouds = Help.asClouds.length;
        for (i = 0; i < dwBaseClouds; i += 1) {
            for (j = 0; j < NUM_HELP_PAGES + 1; j += 1) {
                x = Help.asClouds[i].x + SCREEN_WIDTH * j;
                y = Help.asClouds[i].y;
                Help.papClouds[j * dwBaseClouds + i] = Helpers.CreateSprite(x, y, EA.BottomMiddle, Help.asClouds[i].dwImage, Help.psRoot);
                Help.papClouds[j * dwBaseClouds + i].SetScale(Help.asClouds[i].fScale, Help.asClouds[i].fScale)
            }
        }
        for (i = 0; i < Help.asSprites.length; i += 1) {
            x = Help.asSprites[i].x;
            y = Help.asSprites[i].y;
            Help.papSprites[i] = Helpers.CreateSprite(x, y, Help.asSprites[i].eAlignment, Help.asSprites[i].dwImage, Help.psRoot);
            Help.papSprites[i].SetScale(Help.asSprites[i].fScaleX, Help.asSprites[i].fScaleY);
            Help.papSprites[i].SetColour([Help.asSprites[i].r / 255, Help.asSprites[i].g / 255, Help.asSprites[i].b / 255, 1])
        }
        for (i = 0; i < Help.asTexts.length; i += 1) {
            x = Help.asTexts[i].x;
            y = Help.asTexts[i].y;
            if (Help.asTexts[i].fScale < .56) {
                Help.papTexts[i] = Helpers.CreateBitmapText(JamSystem.TextManager.GetText(Help.asTexts[i].dwText), x, y, Help.asTexts[i].eAlignment, "PanelFontSmall2", Help.psRoot);
                var fScale = Help.asTexts[i].fScale / .45;
                Help.papTexts[i].SetScale(fScale, fScale)
            } else {
                Help.papTexts[i] = Helpers.CreateBitmapText(JamSystem.TextManager.GetText(Help.asTexts[i].dwText), x, y, Help.asTexts[i].eAlignment, "PanelFont", Help.psRoot);
                Help.papTexts[i].SetScale(Help.asTexts[i].fScale, Help.asTexts[i].fScale)
            }
            Help.papTexts[i].SetColour([Help.asTexts[i].r / 255, Help.asTexts[i].g / 255, Help.asTexts[i].b / 255, 1])
        }
    };
    Help.DestroyScene = function() {
        var i;
        for (i = 0; i < Help.papClouds.length; i += 1) {
            Helpers.DestroySprite(Help.papClouds[i])
        }
        Help.papClouds = [];
        for (i = 0; i < Help.asSprites.length; i += 1) {
            Helpers.DestroySprite(Help.papSprites[i])
        }
        Help.papSprites = [];
        for (i = 0; i < Help.asTexts.length; i += 1) {
            Helpers.DestroyBitmapText(Help.papTexts[i])
        }
        Help.papTexts = [];
        Helpers.DestroySprite(Help.psBG);
        Help.psBG = null
    };
    Help.UpdateScene = function() {
        var dwBaseClouds = Help.asClouds.length;
        for (var i = 0; i < dwBaseClouds; i += 1) {
            for (var j = 0; j < NUM_HELP_PAGES + 1; j += 1) {
                Help.papClouds[j * dwBaseClouds + i].x += Help.asClouds[i].fSpeed;
                var xLeft = Help.papClouds[j * dwBaseClouds + i].x - Help.papClouds[i].GetWidth() / 2 * Help.papClouds[j * dwBaseClouds + i].ScaleX;
                if (xLeft > SCREEN_WIDTH * NUM_HELP_PAGES + 150) {
                    Help.papClouds[j * dwBaseClouds + i].x -= SCREEN_WIDTH * (NUM_HELP_PAGES + 1)
                }
                Help.papClouds[j * dwBaseClouds + i].SetPosition(Help.papClouds[j * dwBaseClouds + i].x, Help.papClouds[j * dwBaseClouds + i].y)
            }
        }
    };
    Help.Init = function() {
        Help.dwState = HELP_STATE_START;
        Help.fOffset = 0;
        Help.dwStateTimer = 0;
        Help.bPageClick = false;
        Help.fLastXDiff = 0;
        Help.fSpeed = 0;
        Help.dwPage = 0;
        Help.psRoot = Helpers.CreateTree(0, 0, GadgetTree.GetLayer(LAYERS_COVER));
        Help.psRoot.x = Help.fOffset;
        Help.psRoot.SetPosition(Help.psRoot.x, Help.psRoot.y);
        Help.CreateScene();
        Help.psReturn = Helpers.CreateSprite(HELP_RETURN_X, HELP_RETURN_Y, EA.Default, "ButtonToCover", GadgetTree.GetLayer(LAYERS_HUD));
        var dwWidth = Help.psReturn.GetWidth();
        var dwHeight = Help.psReturn.GetHeight();
        Help.sReturnArea.x = HELP_RETURN_X - dwWidth / 2;
        Help.sReturnArea.y = HELP_RETURN_Y - dwHeight / 2;
        Help.sReturnArea.x2 = HELP_RETURN_X + dwWidth / 2;
        Help.sReturnArea.y2 = HELP_RETURN_Y + dwHeight / 2;
        Touch.Add(Help.sReturnArea);
        Help.psButtonLeft = Helpers.CreateSprite(BUTTON_LEFT_X, BUTTON_LEFT_Y, EA.Default, "ButtonHelpLeft", GadgetTree.GetLayer(LAYERS_HUD));
        dwWidth = Help.psButtonLeft.GetWidth();
        dwHeight = Help.psButtonLeft.GetHeight();
        Help.sButtonLeftArea.x = BUTTON_LEFT_X - dwWidth * .5;
        Help.sButtonLeftArea.y = BUTTON_LEFT_Y - dwHeight * .5;
        Help.sButtonLeftArea.x2 = BUTTON_LEFT_X + dwWidth * .5;
        Help.sButtonLeftArea.y2 = BUTTON_LEFT_Y + dwHeight * .5;
        Touch.Add(Help.sButtonLeftArea);
        Help.psButtonRight = Helpers.CreateSprite(BUTTON_RIGHT_X, BUTTON_RIGHT_Y, EA.Default, "ButtonHelpRight", GadgetTree.GetLayer(LAYERS_HUD));
        dwWidth = Help.psButtonRight.GetWidth();
        dwHeight = Help.psButtonRight.GetHeight();
        Help.sButtonRightArea.x = BUTTON_RIGHT_X - dwWidth * .5;
        Help.sButtonRightArea.y = BUTTON_RIGHT_Y - dwHeight * .5;
        Help.sButtonRightArea.x2 = BUTTON_RIGHT_X + dwWidth * .5;
        Help.sButtonRightArea.y2 = BUTTON_RIGHT_Y + dwHeight * .5;
        Touch.Add(Help.sButtonRightArea);
        Help.dwScript = Script.Add(ScriptData.HelpStart);
        Help.SetOffset(0);
        Touch.Add(Help.sLinkArea);
        Touch.Add(Help.sDenkiArea);
        Touch.Add(Help.sFaceBookArea);
        Touch.Add(Help.sYoutubeArea);
        Touch.Add(Help.sTwitterArea);
        Help.UpdatePage()
    };
    Help.ShutDown = function() {
        Script.StopAll(true);
        Touch.Remove(Help.sLinkArea);
        Touch.Remove(Help.sDenkiArea);
        Touch.Remove(Help.sFaceBookArea);
        Touch.Remove(Help.sYoutubeArea);
        Touch.Remove(Help.sTwitterArea);
        Helpers.DestroySprite(Help.psReturn);
        Help.psReturn = null;
        Touch.Remove(Help.sReturnArea);
        Helpers.DestroySprite(Help.psButtonLeft);
        Help.psButtonLeft = null;
        Touch.Remove(Help.sButtonLeftArea);
        Helpers.DestroySprite(Help.psButtonRight);
        Help.psButtonRight = null;
        Touch.Remove(Help.sButtonRightArea);
        Help.DestroyScene();
        Helpers.DestroyTree(Help.psRoot);
        Help.psRoot = null
    };
    Help.TouchDots = function() {};
    Help.Update = function() {
        EntityManager.Update();
        Script.Update();
        Help.UpdateScene();
        if (Help.dwGestureTouch === -1 && JamSystem.InputManager.GetMouseButtonHeld(0)) {
            Help.dwGestureTouch = 0;
            Help.fGestureStartX = JamSystem.InputManager.GetMouseX() * MouseScaler;
            Help.fGestureStartY = JamSystem.InputManager.GetMouseY() * MouseScaler;
            Help.fRootStartX = Help.fOffset
        }
        var fGestureX = 0,
            fGestureY = 0;
        if (Help.dwGestureTouch !== -1 && JamSystem.InputManager.GetMouseButtonHeld(0)) {
            fGestureX = JamSystem.InputManager.GetMouseX() * MouseScaler - Help.fGestureStartX;
            fGestureY = JamSystem.InputManager.GetMouseY() * MouseScaler - Help.fGestureStartY
        }
        Help.psButtonLeft.SetIsVisible(Help.dwPage);
        Help.psButtonRight.SetIsVisible(Help.dwPage !== NUM_HELP_PAGES - 1);
        var x, xDiff;
        switch (Help.dwState) {
            case HELP_STATE_START:
                if (Script.GetIsFinished(Help.dwScript)) {
                    Help.dwState = HELP_STATE_WAIT
                }
                break;
            case HELP_STATE_WAIT:
                var psArea = Touch.Test(JamSystem.InputManager.GetMouseButtonPressed(0));
                if (psArea === Help.sReturnArea) {
                    Globals.BounceImage(Help.psReturn);
                    Helpers.PlaySound("OptionSelected");
                    Help.dwScript = Script.Add(ScriptData.HelpEnd);
                    Help.dwState = HELP_STATE_END
                } else if (psArea === Help.sButtonLeftArea && Help.psButtonLeft.GetIsVisible()) {
                    Globals.BounceImage(Help.psButtonLeft);
                    Help.dwPage -= 1;
                    Help.UpdatePage();
                    Helpers.PlaySound("OptionMotion");
                    Help.dwState = HELP_STATE_SPRING;
                    Help.bPageClick = false;
                    Help.fLastXDiff = 0;
                    Help.dwGestureTouch = -1
                } else if (psArea === Help.sButtonRightArea && Help.psButtonRight.GetIsVisible()) {
                    Globals.BounceImage(Help.psButtonRight);
                    Help.dwPage += 1;
                    Help.UpdatePage();
                    Helpers.PlaySound("OptionMotion");
                    Help.dwState = HELP_STATE_SPRING;
                    Help.bPageClick = false;
                    Help.fLastXDiff = 0;
                    Help.dwGestureTouch = -1
                } else if (psArea === Help.sLinkArea) {
                    window.location.href = "https://ok.ru/group/53079599743119";
                    Help.dwGestureTouch = -1
                } else if (psArea === Help.sDenkiArea) {
                    window.location.href = "https://ok.ru/group/53079599743119";
                    Help.dwGestureTouch = -1
                } else if (Application.TouchControls) {
                    if (Help.dwGestureTouch !== -1 && JamSystem.InputManager.GetMouseButtonHeld(0)) {
                        Help.dwStateTimer = 0;
                        Help.dwState = HELP_STATE_DRAG;
                        Help.bGestureStarted = false
                    } else {
                        Help.dwGestureTouch = -1
                    }
                }
                break;
            case HELP_STATE_DRAG:
                if (Application.TouchControls) {
                    if (!JamSystem.InputManager.GetMouseButtonHeld(0)) {
                        if (Help.dwStateTimer < 20) {
                            var bChanged = false;
                            xDiff = Help.fGestureStartX - JamSystem.InputManager.GetMouseX() * MouseScaler;
                            if (xDiff < -15) {
                                if (Help.dwPage > 0) {
                                    Help.dwPage -= 1;
                                    Help.UpdatePage();
                                    Helpers.PlaySound("OptionMotion");
                                    bChanged = true
                                }
                            } else if (xDiff > 15) {
                                if (Help.dwPage < NUM_HELP_PAGES - 1) {
                                    Help.dwPage += 1;
                                    Help.UpdatePage();
                                    Helpers.PlaySound("OptionMotion");
                                    bChanged = true
                                }
                            }
                            if (bChanged || Help.bGestureStarted) {
                                Help.dwState = HELP_STATE_SPRING;
                                Help.bPageClick = false;
                                Help.fLastXDiff = 0
                            } else {
                                Help.dwState = HELP_STATE_WAIT
                            }
                        } else {
                            if (Help.bGestureStarted) {
                                x = -Help.fOffset;
                                var dwX = Help.dwPage * SCREEN_WIDTH - x;
                                if (dwX > 160) {
                                    if (Help.dwPage > 0) {
                                        Help.dwPage -= 1;
                                        Help.UpdatePage();
                                        Helpers.PlaySound("OptionMotion")
                                    }
                                } else if (dwX < -160) {
                                    if (Help.dwPage < NUM_HELP_PAGES - 1) {
                                        Help.dwPage += 1;
                                        Help.UpdatePage();
                                        Helpers.PlaySound("OptionMotion")
                                    }
                                }
                                Help.dwState = HELP_STATE_SPRING;
                                Help.bPageClick = false;
                                Help.fLastXDiff = 0;
                                Help.fSpeed = 0
                            } else {
                                Help.dwState = HELP_STATE_WAIT
                            }
                        }
                    } else {
                        Help.dwStateTimer += 1;
                        x = Help.fRootStartX + fGestureX;
                        if (Math.abs(fGestureX) > 10) {
                            Help.bGestureStarted = true;
                            if (x > 0) {
                                x = (x - 0) / 2 + 0
                            } else if (x < -((NUM_HELP_PAGES - 1) * SCREEN_WIDTH)) {
                                x = (x - -((NUM_HELP_PAGES - 1) * SCREEN_WIDTH)) / 2 + -((NUM_HELP_PAGES - 1) * SCREEN_WIDTH)
                            }
                            Help.SetOffset(x)
                        }
                    }
                }
                break;
            case HELP_STATE_SPRING:
                {
                    xDiff = -(Help.dwPage * SCREEN_WIDTH) - Help.fOffset;Help.fSpeed += xDiff * .06;Help.fSpeed *= .7;Help.SetOffset(Help.fOffset + Help.fSpeed);
                    if ((xDiff <= 0 && Help.fLastXDiff > 0 || xDiff >= 0 && Help.fLastXDiff < 0) && !Help.bPageClick) {
                        Help.bPageClick = true;
                        Helpers.PlaySound("Impact")
                    }
                    Help.fLastXDiff = xDiff;
                    if (Math.abs(xDiff) < 1 && Math.abs(Help.fSpeed) < 1) {
                        if (!Help.bPageClick) {
                            Helpers.PlaySound("Impact")
                        }
                        Help.SetOffset(-(Help.dwPage * SCREEN_WIDTH));
                        Help.dwState = HELP_STATE_WAIT
                    }
                }
                break;
            case HELP_STATE_END:
                if (Script.GetIsFinished(Help.dwScript)) {
                    GlobalMain.StateManager.RequestChangeState(StateManager.StateLevelSelect)
                }
                break
        }
    };
    Help.SetOpacity = function(fOpacity) {
        Help.psBG.SetOpacity(fOpacity / 255);
        Help.psReturn.SetOpacity(fOpacity / 255);
        Help.psButtonLeft.SetOpacity(fOpacity / 255);
        Help.psButtonRight.SetOpacity(fOpacity / 255);
        var i;
        for (i = 0; i < Help.papSprites.length; i += 1) {
            Help.papSprites[i].SetOpacity(fOpacity / 255)
        }
        for (i = 0; i < Help.papTexts.length; i += 1) {
            Help.papTexts[i].SetOpacity(fOpacity / 255)
        }
        for (i = 0; i < Help.papClouds.length; i += 1) {
            Help.papClouds[i].SetOpacity(fOpacity / 255)
        }
    };
    Help.SetOffset = function(fOffset) {
        var bBGSet = false;
        if (fOffset > 0) {
            bBGSet = true;
            Globals.SetBGSize(0, 0, 0, SCREEN_WIDTH - fOffset)
        }
        if (fOffset < -(SCREEN_WIDTH * (NUM_HELP_PAGES - 1))) {
            bBGSet = true;
            Globals.SetBGSize(0, 0, SCREEN_WIDTH - (-fOffset - SCREEN_WIDTH * (NUM_HELP_PAGES - 1)), 0)
        }
        if (!bBGSet) {
            Globals.SetBGSize(0, 0, 0, 0)
        }
        Help.fOffset = fOffset;
        Help.psRoot.x = Help.fOffset;
        Help.psRoot.SetPosition(Help.psRoot.x, Help.psRoot.y);
        var i, k = 0;
        for (i = 0; i < Help.asSprites.length; i += 1) {
            if (Help.asSprites[i].dwImage === "NewWhite") {
                var Width = Help.asSprites[i].fScaleX;
                var Height = 30;
                var psArea;
                if (k === 0) {
                    psArea = Help.sDenkiArea
                }
                if (k === 1) {
                    psArea = Help.sFaceBookArea
                }
                if (k === 2) {
                    psArea = Help.sYoutubeArea
                }
                if (k === 3) {
                    psArea = Help.sTwitterArea
                }
                psArea.x = Help.asSprites[i].x - Width / 2 + fOffset;
                psArea.y = Help.asSprites[i].y - Height;
                psArea.x2 = Help.asSprites[i].x + Width / 2 + fOffset;
                psArea.y2 = Help.asSprites[i].y;
                k += 1
            }
        }
    };
    Help.UpdatePage = function() {};
    var BONUS_TYPE_TWO = 0;
    var BONUS_TYPE_THREE = 1;
    var BONUS_TYPE_TIME = 2;
    var BONUS_TYPE_MOVES = 3;
    var BONUS_TYPE_SHAPE = 4;
    var BONUS_TYPE_TOTAL = 5;
    var LevelData_asData = [{
        pszFileName: "L_026",
        dwParMoves: 22,
        dwParTime: 11,
        dwBonusType: BONUS_TYPE_SHAPE
    }, {
        pszFileName: "C017s",
        dwParMoves: 23,
        dwParTime: 11,
        dwBonusType: BONUS_TYPE_SHAPE
    }, {
        pszFileName: "O_034",
        dwParMoves: 20,
        dwParTime: 10,
        dwBonusType: BONUS_TYPE_TIME
    }, {
        pszFileName: "O_047",
        dwParMoves: 10,
        dwParTime: 5,
        dwBonusType: BONUS_TYPE_MOVES
    }, {
        pszFileName: "L_084",
        dwParMoves: 37,
        dwParTime: 18,
        dwBonusType: BONUS_TYPE_SHAPE
    }, {
        pszFileName: "O_004",
        dwParMoves: 25,
        dwParTime: 12,
        dwBonusType: BONUS_TYPE_SHAPE
    }, {
        pszFileName: "S_005",
        dwParMoves: 17,
        dwParTime: 8,
        dwBonusType: BONUS_TYPE_MOVES
    }, {
        pszFileName: "L_040",
        dwParMoves: 25,
        dwParTime: 12,
        dwBonusType: BONUS_TYPE_SHAPE
    }, {
        pszFileName: "L_046C",
        dwParMoves: 22,
        dwParTime: 11,
        dwBonusType: BONUS_TYPE_SHAPE
    }, {
        pszFileName: "O_905",
        dwParMoves: 29,
        dwParTime: 14,
        dwBonusType: BONUS_TYPE_MOVES
    }, {
        pszFileName: "O_322",
        dwParMoves: 36,
        dwParTime: 18,
        dwBonusType: BONUS_TYPE_SHAPE
    }, {
        pszFileName: "A_104O",
        dwParMoves: 22,
        dwParTime: 11,
        dwBonusType: BONUS_TYPE_TWO
    }, {
        pszFileName: "O_045",
        dwParMoves: 71,
        dwParTime: 35,
        dwBonusType: BONUS_TYPE_TIME
    }, {
        pszFileName: "L_378",
        dwParMoves: 56,
        dwParTime: 28,
        dwBonusType: BONUS_TYPE_SHAPE
    }, {
        pszFileName: "C017_02",
        dwParMoves: 22,
        dwParTime: 11,
        dwBonusType: BONUS_TYPE_TWO
    }, {
        pszFileName: "L_263",
        dwParMoves: 37,
        dwParTime: 18,
        dwBonusType: BONUS_TYPE_THREE
    }, {
        pszFileName: "P_005",
        dwParMoves: 22,
        dwParTime: 11,
        dwBonusType: BONUS_TYPE_SHAPE
    }, {
        pszFileName: "P_006",
        dwParMoves: 26,
        dwParTime: 13,
        dwBonusType: BONUS_TYPE_SHAPE
    }, {
        pszFileName: "P_007",
        dwParMoves: 26,
        dwParTime: 13,
        dwBonusType: BONUS_TYPE_SHAPE
    }, {
        pszFileName: "P_008",
        dwParMoves: 42,
        dwParTime: 21,
        dwBonusType: BONUS_TYPE_SHAPE
    }, {
        pszFileName: "L_003a",
        dwParMoves: 21,
        dwParTime: 21,
        dwBonusType: BONUS_TYPE_MOVES
    }, {
        pszFileName: "A_010Ob",
        dwParMoves: 36,
        dwParTime: 36,
        dwBonusType: BONUS_TYPE_SHAPE
    }, {
        pszFileName: "L_373",
        dwParMoves: 39,
        dwParTime: 39,
        dwBonusType: BONUS_TYPE_TWO
    }, {
        pszFileName: "L_271",
        dwParMoves: 30,
        dwParTime: 15,
        dwBonusType: BONUS_TYPE_TWO
    }, {
        pszFileName: "O_228",
        dwParMoves: 27,
        dwParTime: 13,
        dwBonusType: BONUS_TYPE_MOVES
    }, {
        pszFileName: "O_251",
        dwParMoves: 30,
        dwParTime: 15,
        dwBonusType: BONUS_TYPE_THREE
    }, {
        pszFileName: "L_110",
        dwParMoves: 25,
        dwParTime: 12,
        dwBonusType: BONUS_TYPE_SHAPE
    }, {
        pszFileName: "O_027",
        dwParMoves: 45,
        dwParTime: 22,
        dwBonusType: BONUS_TYPE_MOVES
    }, {
        pszFileName: "O_075",
        dwParMoves: 25,
        dwParTime: 12,
        dwBonusType: BONUS_TYPE_MOVES
    }, {
        pszFileName: "L_333s",
        dwParMoves: 75,
        dwParTime: 37,
        dwBonusType: BONUS_TYPE_SHAPE
    }, {
        pszFileName: "A_108Ob",
        dwParMoves: 27,
        dwParTime: 13,
        dwBonusType: BONUS_TYPE_SHAPE
    }, {
        pszFileName: "A_112O",
        dwParMoves: 50,
        dwParTime: 25,
        dwBonusType: BONUS_TYPE_TWO
    }, {
        pszFileName: "T_Pair",
        dwParMoves: 18,
        dwParTime: 9,
        dwBonusType: BONUS_TYPE_TWO
    }, {
        pszFileName: "L_025",
        dwParMoves: 33,
        dwParTime: 16,
        dwBonusType: BONUS_TYPE_SHAPE
    }, {
        pszFileName: "O_136s",
        dwParMoves: 26,
        dwParTime: 13,
        dwBonusType: BONUS_TYPE_SHAPE
    }, {
        pszFileName: "O_119",
        dwParMoves: 52,
        dwParTime: 26,
        dwBonusType: BONUS_TYPE_TIME
    }, {
        pszFileName: "A_028",
        dwParMoves: 26,
        dwParTime: 13,
        dwBonusType: BONUS_TYPE_MOVES
    }, {
        pszFileName: "L_102C",
        dwParMoves: 51,
        dwParTime: 25,
        dwBonusType: BONUS_TYPE_SHAPE
    }, {
        pszFileName: "L_121C",
        dwParMoves: 57,
        dwParTime: 28,
        dwBonusType: BONUS_TYPE_SHAPE
    }, {
        pszFileName: "L_002",
        dwParMoves: 28,
        dwParTime: 14,
        dwBonusType: BONUS_TYPE_SHAPE
    }, {
        pszFileName: "O_229",
        dwParMoves: 23,
        dwParTime: 12,
        dwBonusType: BONUS_TYPE_TIME
    }, {
        pszFileName: "L_069",
        dwParMoves: 18,
        dwParTime: 9,
        dwBonusType: BONUS_TYPE_THREE
    }, {
        pszFileName: "A_034",
        dwParMoves: 31,
        dwParTime: 16,
        dwBonusType: BONUS_TYPE_TIME
    }, {
        pszFileName: "L_247",
        dwParMoves: 56,
        dwParTime: 28,
        dwBonusType: BONUS_TYPE_TWO
    }, {
        pszFileName: "L_079",
        dwParMoves: 60,
        dwParTime: 30,
        dwBonusType: BONUS_TYPE_THREE
    }, {
        pszFileName: "W2C401",
        dwParMoves: 52,
        dwParTime: 26,
        dwBonusType: BONUS_TYPE_TWO
    }, {
        pszFileName: "O_235",
        dwParMoves: 51,
        dwParTime: 25,
        dwBonusType: BONUS_TYPE_TIME
    }, {
        pszFileName: "L_176",
        dwParMoves: 32,
        dwParTime: 16,
        dwBonusType: BONUS_TYPE_THREE
    }, {
        pszFileName: "O_211",
        dwParMoves: 2,
        dwParTime: 51,
        dwBonusType: BONUS_TYPE_THREE
    }, {
        pszFileName: "L_377",
        dwParMoves: 37,
        dwParTime: 18,
        dwBonusType: BONUS_TYPE_SHAPE
    }, {
        pszFileName: "O_107",
        dwParMoves: 42,
        dwParTime: 21,
        dwBonusType: BONUS_TYPE_TWO
    }, {
        pszFileName: "L_375",
        dwParMoves: 39,
        dwParTime: 39,
        dwBonusType: BONUS_TYPE_TWO
    }, {
        pszFileName: "O_244",
        dwParMoves: 41,
        dwParTime: 20,
        dwBonusType: BONUS_TYPE_THREE
    }, {
        pszFileName: "L_015",
        dwParMoves: 3,
        dwParTime: 51,
        dwBonusType: BONUS_TYPE_TIME
    }, {
        pszFileName: "O_258s",
        dwParMoves: 48,
        dwParTime: 24,
        dwBonusType: BONUS_TYPE_SHAPE
    }, {
        pszFileName: "S_010s",
        dwParMoves: 13,
        dwParTime: 6,
        dwBonusType: BONUS_TYPE_SHAPE
    }, {
        pszFileName: "A_008",
        dwParMoves: 61,
        dwParTime: 30,
        dwBonusType: BONUS_TYPE_TIME
    }, {
        pszFileName: "O_149",
        dwParMoves: 46,
        dwParTime: 23,
        dwBonusType: BONUS_TYPE_MOVES
    }, {
        pszFileName: "O_150",
        dwParMoves: 63,
        dwParTime: 31,
        dwBonusType: BONUS_TYPE_MOVES
    }, {
        pszFileName: "L_073",
        dwParMoves: 98,
        dwParTime: 49,
        dwBonusType: BONUS_TYPE_THREE
    }, {
        pszFileName: "A_024",
        dwParMoves: 30,
        dwParTime: 15,
        dwBonusType: BONUS_TYPE_MOVES
    }, {
        pszFileName: "L_092",
        dwParMoves: 72,
        dwParTime: 36,
        dwBonusType: BONUS_TYPE_SHAPE
    }, {
        pszFileName: "L_108",
        dwParMoves: 20,
        dwParTime: 10,
        dwBonusType: BONUS_TYPE_THREE
    }, {
        pszFileName: "L_070",
        dwParMoves: 85,
        dwParTime: 42,
        dwBonusType: BONUS_TYPE_THREE
    }, {
        pszFileName: "L_043",
        dwParMoves: 58,
        dwParTime: 29,
        dwBonusType: BONUS_TYPE_SHAPE
    }, {
        pszFileName: "B_001",
        dwParMoves: 65,
        dwParTime: 32,
        dwBonusType: BONUS_TYPE_TWO
    }, {
        pszFileName: "A_044O",
        dwParMoves: 27,
        dwParTime: 13,
        dwBonusType: BONUS_TYPE_MOVES
    }, {
        pszFileName: "T_Bonus",
        dwParMoves: 25,
        dwParTime: 12,
        dwBonusType: BONUS_TYPE_SHAPE
    }, {
        pszFileName: "L_053",
        dwParMoves: 96,
        dwParTime: 40,
        dwBonusType: BONUS_TYPE_TIME
    }, {
        pszFileName: "O_243",
        dwParMoves: 82,
        dwParTime: 41,
        dwBonusType: BONUS_TYPE_THREE
    }, {
        pszFileName: "T_TOAK",
        dwParMoves: 32,
        dwParTime: 16,
        dwBonusType: BONUS_TYPE_THREE
    }, {
        pszFileName: "A_025O",
        dwParMoves: 38,
        dwParTime: 19,
        dwBonusType: BONUS_TYPE_MOVES
    }, {
        pszFileName: "L_042",
        dwParMoves: 52,
        dwParTime: 26,
        dwBonusType: BONUS_TYPE_SHAPE
    }, {
        pszFileName: "L_051",
        dwParMoves: 67,
        dwParTime: 25,
        dwBonusType: BONUS_TYPE_TIME
    }, {
        pszFileName: "L_052",
        dwParMoves: 33,
        dwParTime: 16,
        dwBonusType: BONUS_TYPE_THREE
    }, {
        pszFileName: "L_063",
        dwParMoves: 28,
        dwParTime: 14,
        dwBonusType: BONUS_TYPE_MOVES
    }, {
        pszFileName: "O_031",
        dwParMoves: 20,
        dwParTime: 10,
        dwBonusType: BONUS_TYPE_MOVES
    }, {
        pszFileName: "S_003s",
        dwParMoves: 23,
        dwParTime: 11,
        dwBonusType: BONUS_TYPE_SHAPE
    }, {
        pszFileName: "S_004",
        dwParMoves: 35,
        dwParTime: 17,
        dwBonusType: BONUS_TYPE_MOVES
    }, {
        pszFileName: "S_008",
        dwParMoves: 27,
        dwParTime: 13,
        dwBonusType: BONUS_TYPE_MOVES
    }, {
        pszFileName: "L_072",
        dwParMoves: 52,
        dwParTime: 26,
        dwBonusType: BONUS_TYPE_TIME
    }, {
        pszFileName: "A_175O",
        dwParMoves: 21,
        dwParTime: 10,
        dwBonusType: BONUS_TYPE_MOVES
    }, {
        pszFileName: "L_168",
        dwParMoves: 42,
        dwParTime: 21,
        dwBonusType: BONUS_TYPE_TIME
    }, {
        pszFileName: "L_260b",
        dwParMoves: 11,
        dwParTime: 5,
        dwBonusType: BONUS_TYPE_SHAPE
    }, {
        pszFileName: "L_028",
        dwParMoves: 37,
        dwParTime: 18,
        dwBonusType: BONUS_TYPE_THREE
    }, {
        pszFileName: "L_355",
        dwParMoves: 67,
        dwParTime: 25,
        dwBonusType: BONUS_TYPE_TIME
    }, {
        pszFileName: "A_035O",
        dwParMoves: 86,
        dwParTime: 43,
        dwBonusType: BONUS_TYPE_SHAPE
    }, {
        pszFileName: "A_040",
        dwParMoves: 51,
        dwParTime: 25,
        dwBonusType: BONUS_TYPE_TIME
    }, {
        pszFileName: "O_143",
        dwParMoves: 40,
        dwParTime: 20,
        dwBonusType: BONUS_TYPE_TWO
    }, {
        pszFileName: "O_148",
        dwParMoves: 36,
        dwParTime: 18,
        dwBonusType: BONUS_TYPE_MOVES
    }, {
        pszFileName: "L_306",
        dwParMoves: 45,
        dwParTime: 22,
        dwBonusType: BONUS_TYPE_THREE
    }, {
        pszFileName: "O_203",
        dwParMoves: 38,
        dwParTime: 19,
        dwBonusType: BONUS_TYPE_MOVES
    }, {
        pszFileName: "A_098",
        dwParMoves: 23,
        dwParTime: 12,
        dwBonusType: BONUS_TYPE_MOVES
    }, {
        pszFileName: "O_207",
        dwParMoves: 43,
        dwParTime: 21,
        dwBonusType: BONUS_TYPE_THREE
    }, {
        pszFileName: "O_212",
        dwParMoves: 20,
        dwParTime: 10,
        dwBonusType: BONUS_TYPE_TIME
    }, {
        pszFileName: "A_140",
        dwParMoves: 42,
        dwParTime: 21,
        dwBonusType: BONUS_TYPE_THREE
    }, {
        pszFileName: "L_004",
        dwParMoves: 115,
        dwParTime: 57,
        dwBonusType: BONUS_TYPE_TIME
    }, {
        pszFileName: "L_014",
        dwParMoves: 62,
        dwParTime: 31,
        dwBonusType: BONUS_TYPE_TIME
    }, {
        pszFileName: "L_012",
        dwParMoves: 63,
        dwParTime: 31,
        dwBonusType: BONUS_TYPE_TIME
    }, {
        pszFileName: "L_273",
        dwParMoves: 68,
        dwParTime: 34,
        dwBonusType: BONUS_TYPE_SHAPE
    }, {
        pszFileName: "O_218",
        dwParMoves: 73,
        dwParTime: 36,
        dwBonusType: BONUS_TYPE_THREE
    }, {
        pszFileName: "L_277",
        dwParMoves: 70,
        dwParTime: 35,
        dwBonusType: BONUS_TYPE_TIME
    }, {
        pszFileName: "O_236",
        dwParMoves: 81,
        dwParTime: 40,
        dwBonusType: BONUS_TYPE_THREE
    }, {
        pszFileName: "A_101",
        dwParMoves: 25,
        dwParTime: 12,
        dwBonusType: BONUS_TYPE_MOVES
    }, {
        pszFileName: "O_151",
        dwParMoves: 31,
        dwParTime: 15,
        dwBonusType: BONUS_TYPE_TWO
    }, {
        pszFileName: "A_182O",
        dwParMoves: 26,
        dwParTime: 13,
        dwBonusType: BONUS_TYPE_MOVES
    }, {
        pszFileName: "A_148",
        dwParMoves: 53,
        dwParTime: 26,
        dwBonusType: BONUS_TYPE_SHAPE
    }, {
        pszFileName: "O_232",
        dwParMoves: 20,
        dwParTime: 10,
        dwBonusType: BONUS_TYPE_MOVES
    }, {
        pszFileName: "O_247",
        dwParMoves: 30,
        dwParTime: 15,
        dwBonusType: BONUS_TYPE_THREE
    }, {
        pszFileName: "A_237",
        dwParMoves: 38,
        dwParTime: 19,
        dwBonusType: BONUS_TYPE_TWO
    }, {
        pszFileName: "A_006O",
        dwParMoves: 21,
        dwParTime: 10,
        dwBonusType: BONUS_TYPE_MOVES
    }, {
        pszFileName: "A_174",
        dwParMoves: 38,
        dwParTime: 19,
        dwBonusType: BONUS_TYPE_THREE
    }, {
        pszFileName: "L_076",
        dwParMoves: 16,
        dwParTime: 8,
        dwBonusType: BONUS_TYPE_THREE
    }, {
        pszFileName: "O_033",
        dwParMoves: 47,
        dwParTime: 23,
        dwBonusType: BONUS_TYPE_TIME
    }, {
        pszFileName: "L_109",
        dwParMoves: 21,
        dwParTime: 10,
        dwBonusType: BONUS_TYPE_SHAPE
    }, {
        pszFileName: "O_138",
        dwParMoves: 21,
        dwParTime: 10,
        dwBonusType: BONUS_TYPE_TWO
    }, {
        pszFileName: "O_219",
        dwParMoves: 108,
        dwParTime: 54,
        dwBonusType: BONUS_TYPE_THREE
    }, {
        pszFileName: "O_241",
        dwParMoves: 20,
        dwParTime: 10,
        dwBonusType: BONUS_TYPE_MOVES
    }, {
        pszFileName: "A_032O",
        dwParMoves: 32,
        dwParTime: 16,
        dwBonusType: BONUS_TYPE_MOVES
    }, {
        pszFileName: "O_214",
        dwParMoves: 68,
        dwParTime: 34,
        dwBonusType: BONUS_TYPE_THREE
    }];
    var GRID_SPACING_X = 146;
    var GRID_SPACING_Y = 131;
    var NORMAL_LEVELS_WIDTH = 4;
    var NORMAL_LEVELS_HEIGHT = 4;
    var SECRET_LEVELS_WIDTH = 1;
    var SECRET_LEVELS_HEIGHT = 4;
    var TOTAL_NORMAL_LEVELS = NORMAL_LEVELS_WIDTH * NORMAL_LEVELS_HEIGHT;
    var TOTAL_SECRET_LEVELS = SECRET_LEVELS_WIDTH * SECRET_LEVELS_HEIGHT;
    var TOTAL_LEVELS = TOTAL_NORMAL_LEVELS + TOTAL_SECRET_LEVELS;
    var NUM_PAGES = 6;
    var NUM_LEVELS = TOTAL_LEVELS * NUM_PAGES;

    function LevelGrid() {}
    LevelGrid.psRoot = 0;
    LevelGrid.psBackgroundRoot = 0;
    LevelGrid.psLevelsRoot = 0;
    LevelGrid.fRootOffsetX = 0;
    LevelGrid.fRootOffsetY = 0;
    LevelGrid.psCursor = 0;
    LevelGrid.psCursorGlow = 0;
    LevelGrid.dwCursorFlash = 0;
    LevelGrid.apcPages = [];
    LevelGrid.dwLevel = 0;
    LevelGrid.fLastNameOpacity = 0;
    LevelGrid.bFlipped = 0;
    LevelGrid.dwFlipLevel = 0;
    LevelGrid.dwNumPages = 0;
    LevelGrid.GetPageAndLevel = function(dwLevel) {
        var Object = {};
        var dwSet = Math.floor(dwLevel / TOTAL_LEVELS);
        var dwSetLevel = dwLevel % TOTAL_LEVELS;
        if (dwSetLevel < TOTAL_NORMAL_LEVELS) {
            Object.dwPage = dwSet * 2;
            Object.dwPageLevel = dwSetLevel
        } else {
            Object.dwPage = dwSet * 2 + 1;
            Object.dwPageLevel = dwSetLevel - TOTAL_NORMAL_LEVELS
        }
        return Object
    };
    LevelGrid.CalcLevelCoord = function(dwLevel) {
        var Object = LevelGrid.GetPageAndLevel(dwLevel);
        var dwPage = Object.dwPage;
        var dwPageLevel = Object.dwPageLevel;
        var ObjectCoord = LevelGrid.apcPages[dwPage].CalcLevelCoord(dwPageLevel);
        return ObjectCoord
    };
    LevelGrid.CalcScreenCoord = function(dwLevel) {
        var Object = LevelGrid.GetPageAndLevel(dwLevel);
        var dwPage = Object.dwPage;
        var dwPageLevel = Object.dwPageLevel;
        var ObjectCoord = LevelGrid.apcPages[dwPage].CalcScreenCoord(dwPageLevel);
        return ObjectCoord
    };
    LevelGrid.CalcRecordsIndex = function(dwPage, dwLevel, bSecret) {
        var dwIndex = dwPage * (NORMAL_LEVELS_WIDTH * NORMAL_LEVELS_HEIGHT + SECRET_LEVELS_WIDTH * SECRET_LEVELS_HEIGHT);
        if (bSecret) {
            return dwIndex + dwLevel * (SECRET_LEVELS_WIDTH * SECRET_LEVELS_HEIGHT) + NORMAL_LEVELS_WIDTH * NORMAL_LEVELS_HEIGHT
        }
        return dwIndex + dwLevel
    };
    LevelGrid.Init = function() {
        LevelGrid.dwLevel = -1;
        LevelGrid.fLastNameOpacity = 1;
        LevelGrid.bFlipped = true;
        LevelGrid.psRoot = Helpers.CreateTree(LevelGrid.fRootOffsetX, LevelGrid.fRootOffsetY, GadgetTree.GetLayer(LAYERS_LEVEL_GRID));
        LevelGrid.psBackgroundRoot = Helpers.CreateTree(0, 0, LevelGrid.psRoot);
        LevelGrid.psLevelsRoot = Helpers.CreateTree(0, 0, LevelGrid.psRoot);
        LevelGrid.psCursor = Helpers.CreateSprite(0, 0, EA.Default, "PuzzleHighlight", LevelGrid.psLevelsRoot);
        LevelGrid.psCursor.SetIsVisible(false);
        LevelGrid.psCursorGlow = Helpers.CreateSprite(0, 0, EA.Default, "GlowSquare", LevelGrid.psLevelsRoot);
        LevelGrid.psCursorGlow.SetScale(1.3, 1.3);
        LevelGrid.psCursorGlow.SetIsVisible(false);
        for (var i = 0; i < NUM_PAGES; i += 1) {
            var sInfo = {};
            sInfo.m_dwFirstRecordIndex = LevelGrid.CalcRecordsIndex(i, 0, false);
            sInfo.m_dwLevelsWide = NORMAL_LEVELS_WIDTH;
            sInfo.m_dwLevelsHigh = NORMAL_LEVELS_HEIGHT;
            var fWidth = (NORMAL_LEVELS_WIDTH - 1) * GRID_SPACING_X;
            var fHeight = (NORMAL_LEVELS_HEIGHT - 1) * GRID_SPACING_Y;
            sInfo.m_fX = i * SCREEN_WIDTH;
            sInfo.m_fY = 0;
            sInfo.m_fLevelX = SCREEN_WIDTH / 2 - fWidth / 2 - 100;
            sInfo.m_fLevelY = 163 * SCREEN_SCALER - fHeight / 2 + 32;
            sInfo.m_fSpacingX = GRID_SPACING_X;
            sInfo.m_fSpacingY = GRID_SPACING_Y;
            sInfo.m_psScheme = LevelScheme_asSchemes[Math.floor(i / 2)];
            sInfo.m_dwLocation = i % NUM_LOCATIONS;
            sInfo.m_bSecret = false;
            sInfo.m_psBackgroundParent = LevelGrid.psBackgroundRoot;
            sInfo.m_psLevelsParent = LevelGrid.psLevelsRoot;
            LevelGrid.apcPages[i * 2] = LevelPage.Create(sInfo);
            sInfo = {};
            fWidth = (SECRET_LEVELS_WIDTH - 1) * GRID_SPACING_X;
            fHeight = (SECRET_LEVELS_HEIGHT - 1) * GRID_SPACING_Y;
            sInfo.m_dwFirstRecordIndex = LevelGrid.CalcRecordsIndex(i, 0, true);
            sInfo.m_dwLevelsWide = SECRET_LEVELS_WIDTH;
            sInfo.m_dwLevelsHigh = SECRET_LEVELS_HEIGHT;
            sInfo.m_fX = i * SCREEN_WIDTH;
            sInfo.m_fY = SCREEN_HEIGHT;
            sInfo.m_fLevelX = 640;
            sInfo.m_fLevelY = 163 * SCREEN_SCALER - fHeight / 2 + 32;
            sInfo.m_fSpacingX = GRID_SPACING_X;
            sInfo.m_fSpacingY = GRID_SPACING_Y;
            sInfo.m_psScheme = LevelScheme_asSchemes[Math.floor(i / 2)];
            sInfo.m_dwLocation = i % NUM_LOCATIONS;
            sInfo.m_bSecret = true;
            sInfo.m_psBackgroundParent = LevelGrid.psBackgroundRoot;
            sInfo.m_psLevelsParent = LevelGrid.psLevelsRoot;
            LevelGrid.apcPages[i * 2 + 1] = LevelPage.Create(sInfo)
        }
        LevelGrid.dwNumPages = NUM_PAGES * 2
    };
    LevelGrid.ShutDown = function() {
        for (var i = 0; i < LevelGrid.dwNumPages; i += 1) {
            LevelGrid.apcPages[i].Destroy()
        }
        Helpers.DestroySprite(LevelGrid.psCursorGlow);
        Helpers.DestroySprite(LevelGrid.psCursor);
        Helpers.DestroyTree(LevelGrid.psLevelsRoot);
        Helpers.DestroyTree(LevelGrid.psBackgroundRoot);
        Helpers.DestroyTree(LevelGrid.psRoot)
    };
    LevelGrid.TouchActive = function(bActive) {
        for (var i = 0; i < LevelGrid.dwNumPages; i += 1) {
            LevelGrid.apcPages[i].SetTouchActive(bActive)
        }
    };
    LevelGrid.Update = function() {
        if (LevelGrid.dwLevel !== -1) {
            LevelGrid.dwCursorFlash += 1;
            var fOpacity = (Math.sin(LevelGrid.dwCursorFlash % 40 / 40 * (44 / 7)) + 1) / 2 * 255;
            LevelGrid.psCursor.SetOpacity((fOpacity / 2 + 128) / 255);
            LevelGrid.psCursorGlow.SetOpacity((fOpacity / 2 + 128) / 255)
        }
        for (var i = 0; i < LevelGrid.dwNumPages; i += 1) {
            LevelGrid.apcPages[i].Update()
        }
    };
    LevelGrid.SetLevel = function(dwLevel) {
        var Object, dwPage, dwPageLevel;
        if (LevelGrid.dwLevel !== -1) {
            Object = LevelGrid.GetPageAndLevel(LevelGrid.dwLevel);
            dwPage = Object.dwPage;
            dwPageLevel = Object.dwPageLevel;
            LevelGrid.apcPages[dwPage].HighlightLevel(dwPageLevel, false)
        }
        LevelGrid.dwLevel = dwLevel;
        if (LevelGrid.dwLevel !== -1) {
            Object = LevelGrid.GetPageAndLevel(LevelGrid.dwLevel);
            dwPage = Object.dwPage;
            dwPageLevel = Object.dwPageLevel;
            var psScheme = LevelGrid.apcPages[dwPage].GetInfo().m_psScheme;
            var x, y;
            var ObjectCoords = LevelGrid.apcPages[dwPage].CalcLevelCoord(dwPageLevel);
            x = ObjectCoords.x;
            y = ObjectCoords.y;
            LevelGrid.psCursor.SetPosition(x, y);
            LevelGrid.psCursor.SetIsVisible(true);
            LevelGrid.psCursor.SetColour([psScheme.fCoverGlowRed / 255, psScheme.fCoverGlowGreen / 255, psScheme.fCoverGlowBlue / 255, LevelGrid.psCursor.GetOpacity()]);
            LevelGrid.psCursorGlow.SetPosition(x, y);
            LevelGrid.psCursorGlow.SetIsVisible(true);
            LevelGrid.psCursorGlow.SetFrameByName("GlowSquare");
            LevelGrid.psCursorGlow.SetColour([psScheme.fCoverGlowRed / 255, psScheme.fCoverGlowGreen / 255, psScheme.fCoverGlowBlue / 255, LevelGrid.psCursor.GetOpacity()]);
            LevelGrid.psCursor.RemoveFromParent();
            LevelGrid.psCursorGlow.RemoveFromParent();
            LevelGrid.psLevelsRoot.AddChild(LevelGrid.psCursorGlow);
            LevelGrid.psLevelsRoot.AddChild(LevelGrid.psCursor);
            if (!Records.GetPlayed(LevelGrid.dwLevel)) {
                LevelGrid.psCursor.SetFrameByName(LevelGrid.apcPages[dwPage].GetInfo().m_psScheme.dwCursorImage);
                LevelGrid.psCursor.SetScale(1.2, 1.2)
            } else {
                LevelGrid.psCursor.SetFrameByName("PuzzleHighlight");
                LevelGrid.psCursor.SetScale(1.3, 1.3)
            }
            LevelGrid.apcPages[dwPage].HighlightLevel(dwPageLevel, true)
        } else {
            LevelGrid.psCursor.SetFrameByName("NewBlank");
            LevelGrid.psCursorGlow.SetFrameByName("NewBlank")
        }
    };
    LevelGrid.HideCursor = function() {
        LevelGrid.psCursor.RemoveFromParent();
        LevelGrid.psCursorGlow.RemoveFromParent()
    };
    LevelGrid.SetPage = function(dwPage) {
        var padwImges = LevelGrid.apcPages[dwPage * 2].GetInfo().m_psScheme.adwBlockerImages;
        EntityBlock_SetBlockerImages(padwImges)
    };
    LevelGrid.SetOffsetX = function(fOffset) {
        LevelGrid.psRoot.x = fOffset;
        LevelGrid.psRoot.SetPosition(LevelGrid.psRoot.x, LevelGrid.psRoot.y);
        LevelGrid.fRootOffsetX = fOffset;
        for (var i = 0; i < LevelGrid.dwNumPages; i += 1) {
            LevelGrid.apcPages[i].SetOffsetX(fOffset)
        }
    };
    LevelGrid.SetOffsetY = function(fOffset) {
        LevelGrid.psRoot.y = fOffset;
        LevelGrid.psRoot.SetPosition(LevelGrid.psRoot.x, LevelGrid.psRoot.y);
        LevelGrid.fRootOffsetY = fOffset;
        for (var i = 0; i < LevelGrid.dwNumPages; i += 1) {
            LevelGrid.apcPages[i].SetOffsetY(fOffset)
        }
    };
    LevelGrid.GetOffsetX = function() {
        return LevelGrid.psRoot.x
    };
    LevelGrid.GetOffsetY = function() {
        return LevelGrid.psRoot.y
    };
    LevelGrid.OpenLevel = function(dwLevel) {
        var Object = LevelGrid.GetPageAndLevel(dwLevel);
        var dwPage = Object.dwPage;
        var dwPageLevel = Object.dwPageLevel;
        LevelGrid.apcPages[dwPage].OpenLevel(dwPageLevel)
    };
    LevelGrid.CloseLevel = function(dwLevel) {
        var Object = LevelGrid.GetPageAndLevel(dwLevel);
        var dwPage = Object.dwPage;
        var dwPageLevel = Object.dwPageLevel;
        LevelGrid.apcPages[dwPage].CloseLevel(dwPageLevel)
    };
    LevelGrid.CompleteLevel = function(dwLevel, bSparkles) {
        var Object = LevelGrid.GetPageAndLevel(dwLevel);
        var dwPage = Object.dwPage;
        var dwPageLevel = Object.dwPageLevel;
        LevelGrid.apcPages[dwPage].CompleteLevel(dwPageLevel, bSparkles)
    };
    LevelGrid.HideLevel = function(dwLevel, bHide) {
        var Object = LevelGrid.GetPageAndLevel(dwLevel);
        var dwPage = Object.dwPage;
        var dwPageLevel = Object.dwPageLevel;
        LevelGrid.apcPages[dwPage].HideLevel(dwPageLevel, bHide)
    };
    LevelGrid.GetTouchedLevel = function(psArea) {
        for (var i = 0; i < LevelGrid.dwNumPages; i += 1) {
            var iLevel = LevelGrid.apcPages[i].GetTouchedLevel(psArea);
            if (iLevel !== -1) {
                var j = i & 1;
                if ((i & 1) === 0) {
                    return iLevel + Math.floor(i / 2) * TOTAL_LEVELS
                } else {
                    return iLevel + Math.floor(i / 2) * TOTAL_LEVELS + TOTAL_NORMAL_LEVELS
                }
            }
        }
        return -1
    };
    LevelGrid.SetCursorActive = function(bActive) {
        LevelGrid.psCursor.SetIsVisible(bActive);
        LevelGrid.psCursorGlow.SetIsVisible(bActive)
    };
    LevelGrid.SetOpacity = function(fOpacity) {
        Cover.SetOpacity(fOpacity);
        LevelGrid.psRoot.RemoveFromParent();
        if (fOpacity !== 0) {
            for (var i = 0; i < LevelGrid.dwNumPages; i += 1) {
                LevelGrid.apcPages[i].SetOpacity(fOpacity)
            }
            GadgetTree.GetLayer(LAYERS_LEVEL_GRID).AddChild(LevelGrid.psRoot)
        }
    };
    LevelGrid.SetNameOpacity = function(fOpacity) {
        if (fOpacity < 0) {
            fOpacity = 0
        }
        for (var i = 0; i < LevelGrid.dwNumPages; i += 1) {
            LevelGrid.apcPages[i].SetNameOpacity(fOpacity)
        }
    };
    LevelGrid.GetBoard = function() {
        var Object = LevelGrid.CalcLevelCoord(LevelGrid.dwLevel);
        Object.x += LevelGrid.fRootOffsetX;
        Object.y += LevelGrid.fRootOffsetY;
        return Object
    };
    LevelGrid.Flip = function(dwCurrentPage) {
        LevelGrid.bFlipped = !LevelGrid.bFlipped;
        for (var i = 0; i < LevelGrid.dwNumPages; i += 1) {
            if (i === dwCurrentPage) {
                LevelGrid.apcPages[i].Flip(LevelGrid.bFlipped, true)
            } else {
                LevelGrid.apcPages[i].Flip(LevelGrid.bFlipped, false)
            }
        }
    };
    LevelGrid.ResetFlip = function(dwLevel) {
        var Object = LevelGrid.GetPageAndLevel(dwLevel);
        var dwPage = Object.dwPage;
        var dwPageLevel = Object.dwPageLevel;
        LevelGrid.apcPages[dwPage].ResetFlipLevel(dwPageLevel)
    };
    LevelGrid.FlipLevel = function(dwLevel, dwCurrentPage) {
        LevelGrid.dwFlipLevel = dwLevel;
        var Object = LevelGrid.GetPageAndLevel(dwLevel);
        var dwPage = Object.dwPage;
        var dwPageLevel = Object.dwPageLevel;
        var bOnScreen = false;
        if (dwPage === dwCurrentPage) {
            bOnScreen = true
        }
        LevelGrid.apcPages[dwPage].FlipLevel(dwPageLevel, LevelGrid.bFlipped, bOnScreen)
    };
    LevelGrid.IsLevelFlipped = function() {
        var Object = LevelGrid.GetPageAndLevel(LevelSelect.dwLevel);
        var dwPage = Object.dwPage;
        var dwPageLevel = Object.dwPageLevel;
        return LevelGrid.apcPages[dwPage].IsLevelFlipped(dwPageLevel)
    };
    LevelGrid.GetLevel = function(dwLevel) {
        var Object = LevelGrid.GetPageAndLevel(dwLevel);
        var dwPage = Object.dwPage;
        var dwPageLevel = Object.dwPageLevel;
        return LevelGrid.apcPages[dwPage].GetLevel(dwPageLevel)
    };
    LevelGrid.SetPageAvailable = function(dwPage, bAvailable) {
        LevelGrid.apcPages[dwPage].SetIsAvailable(bAvailable)
    };
    LevelGrid.GetBGRoot = function() {
        return LevelGrid.psBackgroundRoot
    };
    LevelGrid.GetFlipped = function() {
        return LevelGrid.bFlipped
    };
    LevelGrid.GetColourScheme = function(dwLevel) {
        var Object = LevelGrid.GetPageAndLevel(dwLevel);
        var dwPage = Object.dwPage;
        var dwPageLevel = Object.dwPageLevel;
        return LevelGrid.apcPages[dwPage].GetInfo().m_psScheme
    };
    LevelGrid.SetPageBonusPart = function(dwPage, dwPart) {
        LevelGrid.apcPages[dwPage].EnableBonusPart(dwPart)
    };

    function LevelPage() {}
    LevelPage.prototype = {
        Destroy: function() {
            var i;
            for (i = 0; i < this.m_sInfo.m_dwLevelsHigh * this.m_sInfo.m_dwLevelsWide; i += 1) {
                if (this.m_bTouchActive) {
                    this.m_papEntityLevels[i].TouchAdd(false)
                }
                this.m_papEntityLevels[i].Destroy()
            }
            this.m_papEntityLevels = [];
            for (i = 0; i < 4; i += 1) {
                if (this.m_psGemParts[i]) {
                    Helpers.DestroySprite(this.m_psGemParts[i])
                }
            }
            Helpers.DestroySprite(this.m_psBackground)
        },
        SetIsAvailable: function(bAvailable) {
            if (this.m_bAvailable !== bAvailable) {
                this.m_bAvailable = bAvailable;
                for (var i = 0; i < this.m_sInfo.m_dwLevelsHigh * this.m_sInfo.m_dwLevelsWide; i += 1) {
                    if (!bAvailable || !this.m_papEntityLevels[i].GetIsCompleted()) {
                        this.m_papEntityLevels[i].SetIsNameActive(this.m_bAvailable)
                    }
                }
            }
        },
        CalcLevelCoord: function(dwLevel) {
            var sx = dwLevel % this.m_sInfo.m_dwLevelsWide;
            var sy = Math.floor(dwLevel / this.m_sInfo.m_dwLevelsWide);
            var Object = {};
            Object.x = this.m_sInfo.m_fX + this.m_sInfo.m_fLevelX + sx * this.m_sInfo.m_fSpacingX;
            Object.y = this.m_sInfo.m_fY + this.m_sInfo.m_fLevelY + sy * this.m_sInfo.m_fSpacingY;
            return Object
        },
        CalcScreenCoord: function(dwLevel) {
            var sx = dwLevel % this.m_sInfo.m_dwLevelsWide;
            var sy = Math.floor(dwLevel / this.m_sInfo.m_dwLevelsWide);
            var Object = {};
            Object.x = this.m_sInfo.m_fLevelX + sx * this.m_sInfo.m_fSpacingX;
            Object.y = this.m_sInfo.m_fLevelY + sy * this.m_sInfo.m_fSpacingY;
            return Object
        },
        UpdateOffset: function() {
            var bOnScreen = false;
            if (-this.m_fOffsetX >= this.m_sInfo.m_fX && -this.m_fOffsetX < this.m_sInfo.m_fX + SCREEN_WIDTH || -this.m_fOffsetX + SCREEN_WIDTH > this.m_sInfo.m_fX && -this.m_fOffsetX + SCREEN_WIDTH < this.m_sInfo.m_fX + SCREEN_WIDTH) {
                if (-this.m_fOffsetY >= this.m_sInfo.m_fY && -this.m_fOffsetY < this.m_sInfo.m_fY + SCREEN_HEIGHT || -this.m_fOffsetY + SCREEN_HEIGHT > this.m_sInfo.m_fY && -this.m_fOffsetY + SCREEN_HEIGHT < this.m_sInfo.m_fY + SCREEN_HEIGHT) {
                    bOnScreen = true
                }
            }
            var i;
            if (this.m_bLastOnScreen !== bOnScreen) {
                this.m_bLastOnScreen = bOnScreen;
                for (i = 0; i < this.m_sInfo.m_dwLevelsHigh * this.m_sInfo.m_dwLevelsWide; i += 1) {
                    this.m_papEntityLevels[i].SetIsVisible(this.m_bLastOnScreen)
                }
                this.m_psBackground.SetIsVisible(this.m_bLastOnScreen)
            }
            for (i = 0; i < this.m_sInfo.m_dwLevelsHigh * this.m_sInfo.m_dwLevelsWide; i += 1) {
                var x, y;
                var Object = this.CalcLevelCoord(i);
                x = Object.x;
                y = Object.y;
                this.m_papEntityLevels[i].SetTouch(x + this.m_fOffsetX, y + this.m_fOffsetY)
            }
        },
        SetOffsetX: function(fOffsetX) {
            this.m_fOffsetX = fOffsetX;
            this.UpdateOffset()
        },
        SetOffsetY: function(fOffsetY) {
            this.m_fOffsetY = fOffsetY;
            this.UpdateOffset()
        },
        SetOpacity: function(fOpacity) {
            for (var i = 0; i < this.m_sInfo.m_dwLevelsHigh * this.m_sInfo.m_dwLevelsWide; i += 1) {
                this.m_papEntityLevels[i].SetOpacity(fOpacity)
            }
            this.m_psBackground.SetOpacity(fOpacity / 255)
        },
        SetNameOpacity: function(fOpacity) {
            for (var i = 0; i < this.m_sInfo.m_dwLevelsHigh * this.m_sInfo.m_dwLevelsWide; i += 1) {
                this.m_papEntityLevels[i].SetNameOpacity(fOpacity)
            }
        },
        GetLevelsWaiting: function() {
            for (var i = 0; i < this.m_sInfo.m_dwLevelsHigh * this.m_sInfo.m_dwLevelsWide; i += 1) {
                if (this.m_papEntityLevels[i].GetState() !== ENTITYLEVEL_STATE_NORMAL) {
                    return false
                }
            }
            return true
        },
        SetTouchActive: function(bActive) {
            if (this.m_bTouchActive !== bActive) {
                for (var i = 0; i < this.m_sInfo.m_dwLevelsHigh * this.m_sInfo.m_dwLevelsWide; i += 1) {
                    this.m_papEntityLevels[i].TouchAdd(bActive)
                }
                this.m_bTouchActive = bActive
            }
        },
        Flip: function(bFlipped, bOnScreen) {
            for (var i = 0; i < this.m_sInfo.m_dwLevelsHigh * this.m_sInfo.m_dwLevelsWide; i += 1) {
                var dwDelay = Math.random() * 14;
                this.m_papEntityLevels[i].StartFlip(bFlipped, dwDelay, bOnScreen, false)
            }
        },
        GetLevel: function(dwLevel) {
            return this.m_papEntityLevels[dwLevel]
        },
        OpenLevel: function(dwLevel) {
            this.m_papEntityLevels[dwLevel].SetState(ENTITYLEVEL_STATE_OPENING)
        },
        CloseLevel: function(dwLevel) {
            this.m_papEntityLevels[dwLevel].SetIsPlayed(false)
        },
        CompleteLevel: function(dwLevel, bSparkles) {
            this.m_papEntityLevels[dwLevel].SetIsPlayed(true);
            this.m_papEntityLevels[dwLevel].SetIsCompleted(Records.GetCompleted(this.m_sInfo.m_dwFirstRecordIndex + dwLevel));
            this.m_papEntityLevels[dwLevel].SetIsChallengeCompleted(Records.GetChallengeDone(this.m_sInfo.m_dwFirstRecordIndex + dwLevel));
            if (bSparkles) {
                var x, y;
                var Object = this.CalcScreenCoord(dwLevel);
                x = Object.x;
                y = Object.y;
                for (var i = 0; i < 20; i += 1) {
                    var xt = Math.random() * 32 - 16 + x;
                    var yt = Math.random() * 32 - 16 + y;
                    var psEffect = EntityEffect.Create(xt, yt, ENTITYEFFECT_TYPE_SPARKLE, GadgetTree.GetLayer(LAYERS_HUD));
                    psEffect.SetColour(this.m_sInfo.m_psScheme.fRed, this.m_sInfo.m_psScheme.fGreen, this.m_sInfo.m_psScheme.fBlue);
                    EntityManager.Add(psEffect)
                }
            }
        },
        HideLevel: function(dwLevel, bHide) {
            this.m_papEntityLevels[dwLevel].SetIsVisible(!bHide)
        },
        ResetFlipLevel: function(dwLevel) {
            this.m_papEntityLevels[dwLevel].ResetFlip()
        },
        FlipLevel: function(dwLevel, bFlipped, bOnScreen) {
            this.m_papEntityLevels[dwLevel].SetIsHighlighted(false, false);
            this.m_papEntityLevels[dwLevel].StartFlip(bFlipped, 0, bOnScreen, true)
        },
        IsLevelFlipped: function(dwLevel) {
            if (this.m_papEntityLevels[dwLevel].GetState() === ENTITYLEVEL_STATE_NORMAL) {
                return true
            }
            return false
        },
        HighlightLevel: function(dwLevel, bHighlight) {
            this.m_papEntityLevels[dwLevel].SetIsHighlighted(bHighlight, true)
        },
        GetTouchedLevel: function(psArea) {
            if (!this.GetLevelsWaiting()) {
                return -1
            }
            for (var i = 0; i < this.m_sInfo.m_dwLevelsHigh * this.m_sInfo.m_dwLevelsWide; i += 1) {
                if (psArea === this.m_papEntityLevels[i].RetTouch()) {
                    return i
                }
            }
            return -1
        },
        Update: function() {
            var i;
            for (i = 0; i < this.m_sInfo.m_dwLevelsHigh * this.m_sInfo.m_dwLevelsWide; i += 1) {
                this.m_papEntityLevels[i].Update()
            }
            if (Math.random() * 100 <= 5) {
                var dwNumComplete = 0;
                for (i = 0; i < 4; i += 1) {
                    if (this.m_psGemParts[i] && this.m_psGemParts[i].GetIsVisible()) {
                        dwNumComplete += 1
                    }
                }
                if (dwNumComplete === 4) {
                    var x = this.m_sInfo.m_fX + this.m_sInfo.m_psScheme.adwSecretBonusPosition[this.m_sInfo.m_dwLocation][0];
                    var y = this.m_sInfo.m_fY + this.m_sInfo.m_psScheme.adwSecretBonusPosition[this.m_sInfo.m_dwLocation][1];
                    x += Math.random() * 80 - 40;
                    y += Math.random() * 80 - 40;
                    var psEffect = EntityEffect.Create(x, y, ENTITYEFFECT_TYPE_STATIC_SPARKLE, this.m_sInfo.m_psBackgroundParent);
                    EntityManager.Add(psEffect)
                }
            }
            this.m_dwSheenTimer -= 1;
            if (this.m_dwSheenTimer === 0) {
                this.m_dwSheenTimer = Math.floor(Math.random() * 30 + 30);
                i = Math.floor(Math.random() * this.m_sInfo.m_dwLevelsHigh * this.m_sInfo.m_dwLevelsWide);
                this.m_papEntityLevels[i].SetSheenDelay(1)
            }
        },
        EnableBonusPart: function(dwPart) {
            this.m_psGemParts[dwPart].SetIsVisible(true);
            for (var i = 0; i < 20; i += 1) {
                var xt = Math.random() * 80 - 40 + this.m_psGemParts[dwPart].x;
                var yt = Math.random() * 80 - 40 + this.m_psGemParts[dwPart].y;
                var psEffect = EntityEffect.Create(xt, yt, ENTITYEFFECT_TYPE_SPARKLE, this.m_sInfo.m_psBackgroundParent);
                psEffect.SetColour(this.m_sInfo.m_psScheme.fRed, this.m_sInfo.m_psScheme.fGreen, this.m_sInfo.m_psScheme.fBlue);
                EntityManager.Add(psEffect)
            }
        },
        GetInfo: function() {
            return this.m_sInfo
        }
    };
    LevelPage.Create = function(psInfo) {
        var NewObject = new LevelPage;
        NewObject.m_sInfo = psInfo;
        NewObject.m_fOffsetX = 0;
        NewObject.m_fOffsetY = 0;
        var dwBackgroundImage, dwBonusImage;
        if (!NewObject.m_sInfo.m_bSecret) {
            dwBackgroundImage = NewObject.m_sInfo.m_psScheme.dwLevelBackgroundImages[NewObject.m_sInfo.m_dwLocation];
            dwBonusImage = "BonusStarSmall"
        } else {
            dwBackgroundImage = NewObject.m_sInfo.m_psScheme.dwSecretBackgroundImages[NewObject.m_sInfo.m_dwLocation];
            dwBonusImage = NewObject.m_sInfo.m_psScheme.dwSecretBonusSmallImages[NewObject.m_sInfo.m_dwLocation]
        }
        NewObject.m_psBackground = Helpers.CreateSprite(NewObject.m_sInfo.m_fX, NewObject.m_sInfo.m_fY, EA.TopLeft, dwBackgroundImage, NewObject.m_sInfo.m_psBackgroundParent);
        NewObject.m_psBackground.SetIsVisible(false);
        NewObject.m_papEntityLevels = [];
        var i, j;
        var x, y;
        for (j = 0; j < NewObject.m_sInfo.m_dwLevelsHigh; j += 1) {
            for (i = 0; i < NewObject.m_sInfo.m_dwLevelsWide; i += 1) {
                var l = j * NewObject.m_sInfo.m_dwLevelsWide + i;
                var Object = NewObject.CalcLevelCoord(l);
                x = Object.x;
                y = Object.y;
                NewObject.m_papEntityLevels[l] = EntityLevel.Create(x, y, NewObject.m_sInfo.m_dwFirstRecordIndex + l, l, NewObject.m_sInfo.m_psScheme, dwBackgroundImage, dwBonusImage, NewObject.m_sInfo.m_psLevelsParent);
                if (Records.GetCompleted(NewObject.m_sInfo.m_dwFirstRecordIndex + l)) {
                    NewObject.m_papEntityLevels[l].SetIsPlayed(Records.GetPlayed(NewObject.m_sInfo.m_dwFirstRecordIndex + l))
                }
                NewObject.m_papEntityLevels[l].SetIsCompleted(Records.GetCompleted(NewObject.m_sInfo.m_dwFirstRecordIndex + l));
                NewObject.m_papEntityLevels[l].SetIsChallengeCompleted(Records.GetChallengeDone(NewObject.m_sInfo.m_dwFirstRecordIndex + l));
                NewObject.m_papEntityLevels[l].SetIsVisible(false)
            }
        }
        var aeAligns = [EA.BottomRight, EA.BottomLeft, EA.TopRight, EA.TopLeft];
        NewObject.m_psGemParts = [];
        for (i = 0; i < 4; i += 1) {
            if (!NewObject.m_sInfo.m_bSecret) {
                NewObject.m_psGemParts[i] = null
            } else {
                x = NewObject.m_sInfo.m_fX + NewObject.m_sInfo.m_psScheme.adwSecretBonusPosition[NewObject.m_sInfo.m_dwLocation][0];
                y = NewObject.m_sInfo.m_fY + NewObject.m_sInfo.m_psScheme.adwSecretBonusPosition[NewObject.m_sInfo.m_dwLocation][1];
                var dwImage = NewObject.m_sInfo.m_psScheme.dwSecretBonusBigImages[NewObject.m_sInfo.m_dwLocation][i];
                NewObject.m_psGemParts[i] = Helpers.CreateSprite(x, y, aeAligns[i], dwImage, NewObject.m_sInfo.m_psBackgroundParent);
                if (!Records.GetChallengeDone(NewObject.m_sInfo.m_dwFirstRecordIndex + i)) {
                    NewObject.m_psGemParts[i].SetIsVisible(false)
                }
            }
        }
        NewObject.m_bTouchActive = false;
        NewObject.m_bLastOnScreen = false;
        NewObject.m_bAvailable = true;
        NewObject.SetIsAvailable(false);
        NewObject.m_dwSheenTimer = Math.floor(Math.random() * 15 + 20);
        return NewObject
    };
    var LevelScheme_asSchemes = [{
        dwBaseColour: 0,
        fRed: 255,
        fGreen: 255,
        fBlue: 0,
        fCoverRed: 76,
        fCoverGreen: 255,
        fCoverBlue: 17,
        fCoverGlowRed: 169,
        fCoverGlowGreen: 255,
        fCoverGlowBlue: 180,
        dwCoverImage: "LevelCover01",
        dwCoverBreakImage: "LevelCoverParticle01",
        dwCursorImage: "CoverHighlight01",
        dwGameBackgroundImage: "PuzzleSet01",
        dwGameBoardImage: "Board01",
        adwBlockerImages: ["BlockWhite01None", "BlockWhite01Up", "BlockWhite01Down", "BlockWhite01UpDown", "BlockWhite01Left", "BlockWhite01UpLeft", "BlockWhite01DownLeft", "BlockWhite01UpDownLeft", "BlockWhite01Right", "BlockWhite01UpRight", "BlockWhite01DownRight", "BlockWhite01UpDownRight", "BlockWhite01LeftRight", "BlockWhite01UpLeftRight", "BlockWhite01DownLeftRight", "BlockWhite01UpDownLeftRight"],
        dwLevelBackgroundImages: ["Location01Background01", "Location02Background01"],
        dwSecretBackgroundImages: ["Location01BackgroundSecret01", "Location02BackgroundSecret01"],
        dwSecretBonusSmallImages: ["Location01Gem01Small", "Location02Gem01Small"],
        dwSecretBonusBigImages: [
            ["Location01Gem01Part01", "Location01Gem01Part02", "Location01Gem01Part03", "Location01Gem01Part04"],
            ["Location02Gem01Part01", "Location02Gem01Part02", "Location02Gem01Part03", "Location02Gem01Part04"]
        ],
        adwSecretBonusPosition: [
            [341, 299],
            [259, 329]
        ],
        adwLocationName: ["DATATEXT_ID_PAGE_01_NAME", "DATATEXT_ID_PAGE_01_SECRET_NAME", "DATATEXT_ID_PAGE_02_NAME", "DATATEXT_ID_PAGE_02_SECRET_NAME"]
    }, {
        dwBaseColour: 1,
        fRed: 255,
        fGreen: 167,
        fBlue: 1,
        fCoverRed: 255,
        fCoverGreen: 167,
        fCoverBlue: 1,
        fCoverGlowRed: 255,
        fCoverGlowGreen: 168,
        fCoverGlowBlue: 0,
        dwCoverImage: "LevelCover02",
        dwCoverBreakImage: "LevelCoverParticle02",
        dwCursorImage: "CoverHighlight02",
        dwGameBackgroundImage: "PuzzleSet02",
        dwGameBoardImage: "Board02",
        adwBlockerImages: ["BlockWhite02None", "BlockWhite02Up", "BlockWhite02Down", "BlockWhite02UpDown", "BlockWhite02Left", "BlockWhite02UpLeft", "BlockWhite02DownLeft", "BlockWhite02UpDownLeft", "BlockWhite02Right", "BlockWhite02UpRight", "BlockWhite02DownRight", "BlockWhite02UpDownRight", "BlockWhite02LeftRight", "BlockWhite02UpLeftRight", "BlockWhite02DownLeftRight", "BlockWhite02UpDownLeftRight"],
        dwLevelBackgroundImages: ["Location01Background02", "Location02Background02"],
        dwSecretBackgroundImages: ["Location01BackgroundSecret02", "Location02BackgroundSecret02"],
        dwSecretBonusSmallImages: ["Location01Gem02Small", "Location02Gem02Small"],
        dwSecretBonusBigImages: [
            ["Location01Gem02Part01", "Location01Gem02Part02", "Location01Gem02Part03", "Location01Gem02Part04"],
            ["Location02Gem02Part01", "Location02Gem02Part02", "Location02Gem02Part03", "Location02Gem02Part04"]
        ],
        adwSecretBonusPosition: [
            [402, 395],
            [427, 397]
        ],
        adwLocationName: ["DATATEXT_ID_PAGE_03_NAME", "DATATEXT_ID_PAGE_03_SECRET_NAME", "DATATEXT_ID_PAGE_04_NAME", "DATATEXT_ID_PAGE_04_SECRET_NAME"]
    }, {
        dwBaseColour: 2,
        fRed: 255,
        fGreen: 174,
        fBlue: 0,
        fCoverRed: 255,
        fCoverGreen: 174,
        fCoverBlue: 0,
        fCoverGlowRed: 255,
        fCoverGlowGreen: 174,
        fCoverGlowBlue: 0,
        dwCoverImage: "LevelCover03",
        dwCoverBreakImage: "LevelCoverParticle03",
        dwCursorImage: "CoverHighlight03",
        dwGameBackgroundImage: "PuzzleSet03",
        dwGameBoardImage: "Board03",
        adwBlockerImages: ["BlockWhite03None", "BlockWhite03Up", "BlockWhite03Down", "BlockWhite03UpDown", "BlockWhite03Left", "BlockWhite03UpLeft", "BlockWhite03DownLeft", "BlockWhite03UpDownLeft", "BlockWhite03Right", "BlockWhite03UpRight", "BlockWhite03DownRight", "BlockWhite03UpDownRight", "BlockWhite03LeftRight", "BlockWhite03UpLeftRight", "BlockWhite03DownLeftRight", "BlockWhite03UpDownLeftRight"],
        dwLevelBackgroundImages: ["Location01Background03", "Location02Background03"],
        dwSecretBackgroundImages: ["Location01BackgroundSecret03", "Location02BackgroundSecret03"],
        dwSecretBonusSmallImages: ["Location01Gem03Small", "Location02Gem03Small"],
        dwSecretBonusBigImages: [
            ["Location01Gem03Part01", "Location01Gem03Part02", "Location01Gem03Part03", "Location01Gem03Part04"],
            ["Location02Gem03Part01", "Location02Gem03Part02", "Location02Gem03Part03", "Location02Gem03Part04"]
        ],
        adwSecretBonusPosition: [
            [383, 322],
            [387, 317]
        ],
        adwLocationName: ["DATATEXT_ID_PAGE_05_NAME", "DATATEXT_ID_PAGE_05_SECRET_NAME", "DATATEXT_ID_PAGE_06_NAME", "DATATEXT_ID_PAGE_06_SECRET_NAME"]
    }];
    var EntityEffect_adwColours = [
        [169, 255, 180],
        [255, 168, 0],
        [0, 255, 246],
        [255, 255, 192],
        [255, 255, 255]
    ];
    var NUM_LOCATIONS = 2;
    var LEVELSELECT_FLICK_DELAY = 20;
    var LEVELSELECT_FLIP_X = 845;
    var LEVELSELECT_FLIP_Y = 160;
    var LEVELSELECT_SCALE_DELAY = 8;
    var LEVELSELECT_PULSE_DELAY = 30;
    var STARS_PER_PAGE = 10;
    var STARS_PER_SECRET = 10;
    var MOVE_PAGE_DELAY = 30;
    var LEVELSELECT_MODE_WAIT = 0;
    var LEVELSELECT_MODE_WAIT_END = 1;
    var LEVELSELECT_MODE_DRAG = 2;
    var LEVELSELECT_MODE_SPRING = 3;
    var LEVELSELECT_MODE_OPEN = 4;
    var LEVELSELECT_MODE_LEVEL_COMPLETE = 5;
    var LEVELSELECT_MODE_CHALLENGE_COMPLETE = 6;
    var LEVELSELECT_MODE_PAGE_UNLOCKED = 7;
    var LEVELSELECT_MODE_SECRET_UNLOCKED = 8;
    var LEVELSELECT_MODE_SET_COMPLETE = 9;
    var LEVELSELECT_MODE_NORMAL_COMPLETE = 10;
    var LEVELSELECT_MODE_NORMAL_BONUS_COMPLETE = 11;
    var LEVELSELECT_MODE_SECRET_COMPLETE = 12;
    var LEVELSELECT_MODE_ALL_CHALLENGE_COMPLETE = 13;
    var LEVELSELECT_MODE_BOUGHT_ALL = 14;
    var LEVELSELECT_MODE_TOTAL = 15;
    var BUTTON_X = SCREEN_WIDTH / 2 - 190;
    var BUTTON_Y = SCREEN_HEIGHT - 50;
    var BUTTONAMOUNT = 6;

    function LevelSelect() {}
    LevelSelect.eMode = 0;
    LevelSelect.dwGestureTouch = 0;
    LevelSelect.fGestureStartX = 0;
    LevelSelect.fGestureStartY = 0;
    LevelSelect.fRootStartX = 0;
    LevelSelect.fRootStartY = 0;
    LevelSelect.psPanel = 0;
    LevelSelect.psPuzzleGlow = 0;
    LevelSelect.psPuzzleNumber = 0;
    LevelSelect.psBestScore = 0;
    LevelSelect.psTotalScore = 0;
    LevelSelect.psStars = 0;
    LevelSelect.psStarsIcon = 0;
    LevelSelect.psTempArea = {};
    LevelSelect.psLevelButtons = [];
    LevelSelect.psLevelWrapping = [];
    LevelSelect.sLevelButtonsArea = [];
    LevelSelect.psButtonUpDown = [];
    LevelSelect.sButtonUpDown = {};
    LevelSelect.psButtonToCover = [];
    LevelSelect.sButtonToCover = {};
    LevelSelect.psButtonToEnd = [];
    LevelSelect.sButtonToEnd = {};
    LevelSelect.psButtonPanel = 0;
    LevelSelect.psFlip = 0;
    LevelSelect.sFlipArea = {};
    LevelSelect.bPulseFlip = 0;
    LevelSelect.dwFlipPulseTimer = 0;
    LevelSelect.dwFlipScaleTimer = 0;
    LevelSelect.dwSecretPulseTimer = 0;
    LevelSelect.dwSecretScaleTimer = 0;
    LevelSelect.dwLevel = 0;
    LevelSelect.dwPage = -1;
    LevelSelect.dwSecret = 0;
    LevelSelect.dwMaxPage = 0;
    LevelSelect.fSpeedX = 0;
    LevelSelect.fSpeedY = 0;
    LevelSelect.dwStateTimer = 0;
    LevelSelect.bPageClick = 0;
    LevelSelect.fLastXDiff = 0;
    LevelSelect.fLastYDiff = 0;
    LevelSelect.dwScript = 0;
    LevelSelect.dwTimer = 0;
    LevelSelect.fLastInfoOpacity = 0;
    LevelSelect.bWaitForRelease = 0;
    LevelSelect.bComplete = 0;
    LevelSelect.bChallengeComplete = 0;
    LevelSelect.bPageUnlocked = 0;
    LevelSelect.bMovingPage = 0;
    LevelSelect.bMovingPageX = 0;
    LevelSelect.fStartOffset = 0;
    LevelSelect.fMoveOffset = 0;
    LevelSelect.dwMoveDelay = 0;
    LevelSelect.dwTotalDelay = 0;
    LevelSelect.bInfoOn = 0;
    LevelSelect.bPlayingIntro = 0;
    LevelSelect.dwIntroTimer = 0;
    LevelSelect.bGestureStarted = 0;
    LevelSelect.bGestureX = 0;
    LevelSelect.bImmediateStart = false;
    LevelSelect.bCoverThemePlayed = false;
    LevelSelect.bTempFlip = false;
    LevelSelect.bStatusCheck = true;
    LevelSelect.GetPage = function() {
        return LevelSelect.dwPage * 2 + LevelSelect.dwSecret
    };
    LevelSelect.SetOffsetX = function(fOffset) {
        var bBGSet = false;
        if (LevelSelect.dwSecret === 0) {
            if (fOffset > SCREEN_WIDTH) {
                bBGSet = true;
                Globals.SetBGSize(0, 0, 0, SCREEN_WIDTH - (fOffset - SCREEN_WIDTH))
            } else if (LevelSelect.dwMaxPage === NUM_PAGES && fOffset < -(SCREEN_WIDTH * (NUM_PAGES + 0))) {
                bBGSet = true;
                Globals.SetBGSize(0, 0, SCREEN_WIDTH - (-fOffset - SCREEN_WIDTH * (NUM_PAGES + 0)), 0)
            } else if (LevelSelect.dwMaxPage !== NUM_PAGES && fOffset < -(SCREEN_WIDTH * (NUM_PAGES - 1))) {
                bBGSet = true;
                Globals.SetBGSize(0, 0, SCREEN_WIDTH - (-fOffset - SCREEN_WIDTH * (NUM_PAGES - 1)), 0)
            }
        } else {
            if (fOffset > 0) {
                bBGSet = true;
                Globals.SetBGSize(0, 0, 0, SCREEN_WIDTH - fOffset)
            }
            if (fOffset < -(SCREEN_WIDTH * (NUM_PAGES - 1))) {
                bBGSet = true;
                Globals.SetBGSize(0, 0, SCREEN_WIDTH - (-fOffset - SCREEN_WIDTH * (NUM_PAGES - 1)), 0)
            }
        }
        if (!bBGSet) {
            Globals.SetBGSize(0, 0, 0, 0)
        }
        Cover.SetOffsetX(fOffset);
        EndScreen.SetOffsetX(fOffset);
        LevelGrid.SetOffsetX(fOffset)
    };
    LevelSelect.SetOffsetY = function(fOffset) {
        var bBGSet = false;
        if (LevelSelect.dwPage >= 0 && LevelSelect.dwPage < NUM_PAGES) {
            if (fOffset > 0) {
                bBGSet = true;
                Globals.SetBGSize(0, SCREEN_HEIGHT - fOffset, 0, 0)
            }
            if (fOffset < -SCREEN_HEIGHT) {
                bBGSet = true;
                Globals.SetBGSize(SCREEN_HEIGHT - (-fOffset - SCREEN_HEIGHT), 0, 0, 0)
            }
        } else {
            if (fOffset > 0) {
                bBGSet = true;
                Globals.SetBGSize(0, SCREEN_HEIGHT - fOffset, 0, 0)
            }
            if (fOffset < 0) {
                bBGSet = true;
                Globals.SetBGSize(SCREEN_HEIGHT + fOffset, 0, 0, 0)
            }
        }
        if (!bBGSet) {
            Globals.SetBGSize(0, 0, 0, 0)
        }
        Cover.SetOffsetY(fOffset);
        EndScreen.SetOffsetY(fOffset);
        LevelGrid.SetOffsetY(fOffset)
    };
    LevelSelect.Create = function() {
        Cover.Create();
        EndScreen.Create();
        LevelSelect.psPanel = Helpers.CreateSprite(SCREEN_WIDTH - 300, 204, EA.TopLeft, "DB_InfoPanel", GadgetTree.GetLayer(LAYERS_HUD));
        LevelSelect.psPanel.SetColour([0, 0, 0, .5]);
        LevelSelect.fLastInfoOpacity = 1;
        LevelSelect.psPuzzleGlow = Helpers.CreateSprite(SCREEN_WIDTH - 175, 280, EA.Default, "GlowRound", GadgetTree.GetLayer(LAYERS_HUD));
        LevelSelect.psPuzzleGlow.SetScale(1.5, .75);
        var psScheme = LevelSelect.GetColourScheme();
        LevelSelect.psPuzzleGlow.SetColour([psScheme.fRed / 255, psScheme.fGreen / 255, psScheme.fBlue / 255, 1]);
        LevelSelect.psPuzzleNumber = Helpers.CreateBitmapText("", SCREEN_WIDTH - 175, 280, EA.Default, "PanelFontSmall", GadgetTree.GetLayer(LAYERS_HUD));
        LevelSelect.psBestScore = Helpers.CreateBitmapText("", SCREEN_WIDTH - 175, 320, EA.Default, "PanelFontSmall", GadgetTree.GetLayer(LAYERS_HUD));
        LevelSelect.psFlip = Helpers.CreateSprite(LEVELSELECT_FLIP_X, LEVELSELECT_FLIP_Y, EA.Default, "ButtonFlip", GadgetTree.GetLayer(LAYERS_HUD));
        var dwWidth = LevelSelect.psFlip.GetWidth();
        var dwHeight = LevelSelect.psFlip.GetHeight();
        LevelSelect.sFlipArea.x = LEVELSELECT_FLIP_X - dwWidth / 2;
        LevelSelect.sFlipArea.y = LEVELSELECT_FLIP_Y - dwHeight / 2;
        LevelSelect.sFlipArea.x2 = LEVELSELECT_FLIP_X + dwWidth / 2;
        LevelSelect.sFlipArea.y2 = LEVELSELECT_FLIP_Y + dwHeight / 2;
        LevelSelect.psButtonPanel = Helpers.CreateSprite(SCREEN_WIDTH / 2 - 95, 680, EA.Default, "ButtonBacking", GadgetTree.GetLayer(LAYERS_HUD));
        LevelSelect.psGlowPageButtons = Helpers.CreateSprite(BUTTON_X - 1040, BUTTON_Y + 5, EA.Default, "GlowSquare", GadgetTree.GetLayer(LAYERS_HUD));
        LevelSelect.psGlowPageButtons.SetScale(.6, .6);
        var i = 0;
        for (i = 0; i < BUTTONAMOUNT; i += 1) {
            var YAdd = i > 5 ? 75 : 0;
            var XAdd = YAdd ? (i - 6) * 80 : i * 95;
            var Image = "ButtonMagicWoods1";
            if (i === 1) {
                Image = "ButtonMagicWoods2"
            }
            if (i === 2) {
                Image = "ButtonUnderground1"
            }
            if (i === 3) {
                Image = "ButtonUnderground2"
            }
            if (i === 4) {
                Image = "ButtonDragonDen1"
            }
            if (i === 5) {
                Image = "ButtonDragonDen2"
            }
            LevelSelect.psLevelButtons[i] = Helpers.CreateSprite(BUTTON_X + XAdd - 150, BUTTON_Y + YAdd + 5, EA.Default, Image, GadgetTree.GetLayer(LAYERS_HUD));
            LevelSelect.psLevelButtons[i].SetScale(.7, .7);
            LevelSelect.sLevelButtonsArea[i] = {};
            dwWidth = LevelSelect.psLevelButtons[i].GetWidth();
            dwHeight = LevelSelect.psLevelButtons[i].GetHeight();
            LevelSelect.sLevelButtonsArea[i].x = LevelSelect.psLevelButtons[i].GetPositionX() - dwWidth * .5;
            LevelSelect.sLevelButtonsArea[i].y = LevelSelect.psLevelButtons[i].GetPositionY() - dwHeight * .5;
            LevelSelect.sLevelButtonsArea[i].x2 = LevelSelect.psLevelButtons[i].GetPositionX() + dwWidth * .5;
            LevelSelect.sLevelButtonsArea[i].y2 = LevelSelect.psLevelButtons[i].GetPositionY() + dwHeight * .5;
            Touch.Add(LevelSelect.sLevelButtonsArea[i]);
            LevelSelect.psLevelWrapping[i] = Helpers.CreateSprite(BUTTON_X + XAdd - 150, BUTTON_Y + YAdd + 5, EA.Default, "LevelPackWrap", GadgetTree.GetLayer(LAYERS_HUD));
            LevelSelect.psLevelWrapping[i].SetScale(.8, .8)
        }
        LevelSelect.psButtonUpDown = Helpers.CreateSprite(BUTTON_X + 525, BUTTON_Y - 120, EA.Default, "ButtonSecretDownWoods", GadgetTree.GetLayer(LAYERS_HUD));
        dwWidth = LevelSelect.psButtonUpDown.GetWidth();
        dwHeight = LevelSelect.psButtonUpDown.GetHeight();
        LevelSelect.sButtonUpDown.x = LevelSelect.psButtonUpDown.GetPositionX() - dwWidth * .5;
        LevelSelect.sButtonUpDown.y = LevelSelect.psButtonUpDown.GetPositionY() - dwHeight * .5;
        LevelSelect.sButtonUpDown.x2 = LevelSelect.psButtonUpDown.GetPositionX() + dwWidth * .5;
        LevelSelect.sButtonUpDown.y2 = LevelSelect.psButtonUpDown.GetPositionY() + dwHeight * .5;
        Touch.Add(LevelSelect.sButtonUpDown);
        LevelSelect.psButtonToCover = Helpers.CreateSprite(BUTTON_X - 270, BUTTON_Y - 615, EA.Default, "ButtonToCover", GadgetTree.GetLayer(LAYERS_HUD));
        dwWidth = LevelSelect.psButtonToCover.GetWidth();
        dwHeight = LevelSelect.psButtonToCover.GetHeight();
        LevelSelect.sButtonToCover.x = LevelSelect.psButtonToCover.GetPositionX() - dwWidth * .5;
        LevelSelect.sButtonToCover.y = LevelSelect.psButtonToCover.GetPositionY() - dwHeight * .5;
        LevelSelect.sButtonToCover.x2 = LevelSelect.psButtonToCover.GetPositionX() + dwWidth * .5;
        LevelSelect.sButtonToCover.y2 = LevelSelect.psButtonToCover.GetPositionY() + dwHeight * .5;
        Touch.Add(LevelSelect.sButtonToCover);
        LevelSelect.AllowHomeButton = true;
        LevelSelect.psButtonToEnd = Helpers.CreateSprite(BUTTON_X + 650, BUTTON_Y - 615, EA.Default, "ButtonToEnd", GadgetTree.GetLayer(LAYERS_HUD));
        dwWidth = LevelSelect.psButtonToEnd.GetWidth();
        dwHeight = LevelSelect.psButtonToEnd.GetHeight();
        LevelSelect.sButtonToEnd.x = LevelSelect.psButtonToEnd.GetPositionX() - dwWidth * .5;
        LevelSelect.sButtonToEnd.y = LevelSelect.psButtonToEnd.GetPositionY() - dwHeight * .5;
        LevelSelect.sButtonToEnd.x2 = LevelSelect.psButtonToEnd.GetPositionX() + dwWidth * .5;
        LevelSelect.sButtonToEnd.y2 = LevelSelect.psButtonToEnd.GetPositionY() + dwHeight * .5;
        Touch.Add(LevelSelect.sButtonToEnd);
        var achTemp, achTemp2;
        achTemp2 = "" + Records.GetTotalScore();
        achTemp2 = Misc.InsertCommasIntoNumberString(achTemp2);
        achTemp = "" + JamSystem.TextManager.GetText("DATATEXT_ID_HUD_TOTAL_SCORE") + " " + achTemp2;
        LevelSelect.psTotalScore = Helpers.CreateBitmapText(achTemp, SCREEN_WIDTH / 2, 20 * SCREEN_SCALER, EA.Default, "PanelFont", GadgetTree.GetLayer(LAYERS_HUD));
        LevelSelect.psTotalScore.SetScale(.65, .65);
        LevelSelect.psStarsIcon = Helpers.CreateSprite(SCREEN_WIDTH - 175, 405, EA.Default, "BonusStarSmall", GadgetTree.GetLayer(LAYERS_HUD));
        LevelSelect.psStars = Helpers.CreateBitmapText("", SCREEN_WIDTH - 175, 465, EA.Default, "PanelFontSmall", GadgetTree.GetLayer(LAYERS_HUD));
        LevelSelect.UpdatePage();
        LevelSelect.bWaitForRelease = false;
        LevelSelect.bComplete = false;
        LevelSelect.bChallengeComplete = false;
        LevelSelect.bPageUnlocked = false;
        LevelSelect.bInfoOn = false;
        LevelSelect.SetOffsetX(LevelSelect.dwPage * -SCREEN_WIDTH);
        LevelSelect.SetCursor(-1);
        LevelSelect.psFlip.SetIsVisible(false);
        LevelSelect.psButtonPanel.SetIsVisible(false);
        LevelSelect.psGlowPageButtons.SetIsVisible(false);
        var i = 0;
        for (i = 0; i < BUTTONAMOUNT; i += 1) {
            LevelSelect.psLevelButtons[i].SetIsVisible(false);
            LevelSelect.psLevelWrapping[i].SetIsVisible(false)
        }
        LevelSelect.psButtonUpDown.SetIsVisible(false);
        LevelSelect.psButtonToCover.SetIsVisible(false);
        LevelSelect.psButtonToEnd.SetIsVisible(false);
        LevelSelect.psBestScore.SetIsVisible(false);
        LevelSelect.psPuzzleNumber.SetIsVisible(false);
        LevelSelect.psPuzzleGlow.SetIsVisible(false);
        LevelSelect.psTotalScore.SetIsVisible(false);
        LevelSelect.psStars.SetIsVisible(false);
        LevelSelect.psStarsIcon.SetIsVisible(false);
        LevelSelect.bPlayingIntro = true;
        LevelSelect.dwIntroTimer = 110
    };
    LevelSelect.Destroy = function() {
        Cover.Destroy();
        EndScreen.Destroy();
        if (LevelSelect.bInfoOn) {
            Touch.Remove(LevelSelect.sFlipArea);
            Touch.Remove(LevelSelect.sButtonLeftArea);
            Touch.Remove(LevelSelect.sButtonRightArea)
        }
        Helpers.DestroySprite(LevelSelect.psFlip);
        Helpers.DestroySprite(LevelSelect.psButtonPanel);
        Helpers.DestroySprite(LevelSelect.psButtonUpDown);
        var i = 0;
        for (i = 0; i < BUTTONAMOUNT; i += 1) {
            Helpers.DestroySprite(LevelSelect.psLevelButtons[i]);
            Helpers.DestroySprite(LevelSelect.psLevelWrapping[i])
        }
        Helpers.DestroySprite(LevelSelect.psGlowPageButtons);
        Helpers.DestroySprite(LevelSelect.psButtonToCover);
        Helpers.DestroySprite(LevelSelect.psButtonToEnd);
        Helpers.DestroySprite(LevelSelect.psStars);
        Helpers.DestroySprite(LevelSelect.psStarsIcon);
        Helpers.DestroySprite(LevelSelect.psTotalScore);
        Helpers.DestroySprite(LevelSelect.psBestScore);
        Helpers.DestroySprite(LevelSelect.psPuzzleNumber);
        Helpers.DestroySprite(LevelSelect.psPuzzleGlow);
        Helpers.DestroySprite(LevelSelect.psPanel)
    };
    LevelSelect.CalcMaxPage = function() {
        if (Records.GetAllChallenge()) {
            return NUM_PAGES
        }
        return NUM_PAGES - 1
    };
    LevelSelect.Init = function() {
        Cover.Init();
        EndScreen.Init();
        if (LevelSelect.bChallengeComplete) {
            LevelSelect.bComplete = false;
            LevelSelect.eMode = LEVELSELECT_MODE_CHALLENGE_COMPLETE;
            LevelSelect.dwScript = Script.Add(ScriptData.ChallengeLevelComplete);
            LevelGrid.HideCursor()
        } else if (LevelSelect.bComplete) {
            LevelSelect.bComplete = false;
            LevelSelect.eMode = LEVELSELECT_MODE_LEVEL_COMPLETE;
            LevelSelect.dwScript = Script.Add(ScriptData.LevelComplete);
            LevelGrid.HideCursor()
        } else {
            LevelSelect.eMode = LEVELSELECT_MODE_WAIT;
            if (LevelSelect.dwLevel !== -1) {
                if (!Records.GetCompleted(LevelSelect.dwLevel)) {
                    LevelGrid.CloseLevel(LevelSelect.dwLevel)
                }
            }
        }
        LevelSelect.dwGestureTouch = -1;
        LevelSelect.dwStateTimer = 0;
        LevelSelect.bWaitForRelease = false;
        LevelSelect.bMovingPage = false;
        LevelGrid.SetOpacity(255);
        LevelGrid.SetNameOpacity(255);
        LevelGrid.SetCursorActive(true);
        LevelSelect.dwFlipPulseTimer = 0;
        LevelSelect.dwFlipScaleTimer = 0;
        if (Records.GetTotalCompleted() && !Records.GetFlipSeen()) {
            LevelSelect.bPulseFlip = true
        } else {
            LevelSelect.bPulseFlip = false
        }
        if (LevelSelect.dwLevel !== -1) {
            LevelGrid.HideLevel(LevelSelect.dwLevel, false)
        }
        LevelSelect.UpdatePage();
        LevelSelect.Reset();
        LevelSelect.bImmediateStart = false;
        if (LevelSelect.bStatusCheck) {
            LevelSelect.bStatusCheck = false;
            LevelSelect.bPlayingIntro = true;
            LevelSelect.dwIntroTimer = 110;
            Globals.SetBackgroundMusic("CoverTheme", false);
            Globals.SetBackgroundMusicVolume(0)
        }
    };
    LevelSelect.ShutDown = function() {
        LevelSelect.bCoverThemePlayed = true;
        LevelGrid.SetNameOpacity(0);
        Cover.ShutDown();
        EndScreen.ShutDown();
        if (LevelSelect.dwPage !== -1 && LevelSelect.bInfoOn) {
            LevelSelect.bInfoOn = false;
            LevelGrid.TouchActive(false);
            Touch.Remove(LevelSelect.sFlipArea);
            Touch.Remove(LevelSelect.sButtonLeftArea);
            Touch.Remove(LevelSelect.sButtonRightArea)
        }
        LevelSelect.bPlayingIntro = false
    };
    LevelSelect.Reset = function() {
        var achTemp = "";
        var dwImage = "Blank";
        if (LevelSelect.dwPage !== -1) {
            if (LevelSelect.dwSecret === 0) {
                achTemp = "" + Records.GetChallengesCompleted(LevelSelect.dwPage, LevelSelect.dwSecret) + " of 16";
                dwImage = "BonusStarSmall"
            } else {
                achTemp = "" + Records.GetChallengesCompleted(LevelSelect.dwPage, LevelSelect.dwSecret) + " of 4";
                var dwLocation = LevelSelect.dwPage % NUM_LOCATIONS;
                var dwScheme = Math.floor(LevelSelect.dwPage / NUM_LOCATIONS);
                dwImage = LevelScheme_asSchemes[dwScheme].dwSecretBonusSmallImages[dwLocation]
            }
        }
        LevelSelect.psStars.SetText(achTemp);
        LevelSelect.psStarsIcon.SetFrameByName(dwImage);
        LevelSelect.dwMaxPage = LevelSelect.CalcMaxPage();
        LevelSelect.UpdateMaxPage()
    };
    LevelSelect.UpdateInfoSimple = function() {
        var psScheme = LevelSelect.GetColourScheme();
        var fRed = psScheme.fRed;
        var fGreen = psScheme.fGreen;
        var fBlue = psScheme.fBlue;
        var achTemp = "",
            achTemp2;
        var Object = LevelGrid.GetPageAndLevel(LevelSelect.dwLevel);
        var dwPage = Object.dwPage;
        var dwPageLevel = Object.dwPageLevel;
        if (LevelSelect.dwLevel !== -1) {
            achTemp = "" + JamSystem.TextManager.GetText("DATATEXT_ID_HUD_PUZZLE") + " " + (dwPageLevel + 1);
            LevelSelect.psPuzzleNumber.SetPosition(LevelSelect.psPuzzleNumber.x, 250)
        } else {
            if (LevelSelect.dwPage !== -1 && LevelSelect.dwPage !== 6) {
                var dwLocation = LevelSelect.dwPage % NUM_LOCATIONS;
                var dwScheme = Math.floor(LevelSelect.dwPage / NUM_LOCATIONS);
                achTemp = JamSystem.TextManager.GetText(LevelScheme_asSchemes[dwScheme].adwLocationName[dwLocation * 2 + LevelSelect.dwSecret]);
                LevelSelect.psPuzzleNumber.SetPosition(LevelSelect.psPuzzleNumber.x, 280)
            }
        }
        LevelSelect.psPuzzleNumber.SetText(achTemp);
        var dwScore = Records.GetScore(LevelSelect.dwLevel);
        if (dwScore && LevelSelect.dwLevel !== -1 && LevelSelect.dwPage !== 6) {
            achTemp2 = "" + dwScore;
            achTemp2 = Misc.InsertCommasIntoNumberString(achTemp2);
            achTemp = "" + JamSystem.TextManager.GetText("DATATEXT_ID_HUD_BEST_SCORE") + "\n" + achTemp2
        } else {
            achTemp = ""
        }
        LevelSelect.psBestScore.SetText(achTemp);
        LevelSelect.psPuzzleGlow.SetColour([fRed / 255, fGreen / 255, fBlue / 255, LevelSelect.psPuzzleGlow.GetOpacity()]);
        achTemp2 = "" + Records.GetTotalScore();
        achTemp2 = Misc.InsertCommasIntoNumberString(achTemp2);
        achTemp = "" + JamSystem.TextManager.GetText("DATATEXT_ID_HUD_TOTAL_SCORE") + " " + achTemp2;
        LevelSelect.psTotalScore.SetText(achTemp);
        Script.SetGlobalVariable(SCRIPT_GLOBAL_VARIABLE_1, fRed);
        Script.SetGlobalVariable(SCRIPT_GLOBAL_VARIABLE_2, fGreen);
        Script.SetGlobalVariable(SCRIPT_GLOBAL_VARIABLE_3, fBlue)
    };
    LevelSelect.SetCursor = function(dwLevel) {
        LevelSelect.dwLevel = dwLevel;
        LevelGrid.SetLevel(dwLevel);
        LevelSelect.UpdateInfoSimple()
    };
    LevelSelect.UpdateInfo = function(bInfoOn) {
        var i;
        if (LevelSelect.bInfoOn !== bInfoOn) {
            LevelSelect.bInfoOn = bInfoOn;
            if (!LevelSelect.bInfoOn) {
                LevelGrid.TouchActive(false);
                Touch.Remove(LevelSelect.sFlipArea);
                LevelSelect.psFlip.SetIsVisible(false);
                LevelSelect.psButtonPanel.SetIsVisible(false);
                LevelSelect.psBestScore.SetIsVisible(false);
                LevelSelect.psPuzzleNumber.SetIsVisible(false);
                LevelSelect.psPanel.SetIsVisible(false);
                LevelSelect.psPuzzleGlow.SetIsVisible(false);
                LevelSelect.psTotalScore.SetIsVisible(false);
                LevelSelect.psStars.SetIsVisible(false);
                LevelSelect.psStarsIcon.SetIsVisible(false);
                LevelSelect.psButtonUpDown.SetIsVisible(false);
                for (i = 0; i < BUTTONAMOUNT; i += 1) {
                    LevelSelect.psLevelButtons[i].SetIsVisible(false);
                    LevelSelect.psLevelWrapping[i].SetIsVisible(false)
                }
                LevelSelect.psGlowPageButtons.SetIsVisible(false);
                LevelSelect.psButtonToCover.SetIsVisible(false);
                LevelSelect.psButtonToEnd.SetIsVisible(false)
            } else {
                LevelGrid.TouchActive(true);
                Touch.Add(LevelSelect.sFlipArea);
                LevelSelect.psFlip.SetIsVisible(true);
                LevelSelect.psButtonPanel.SetIsVisible(true);
                LevelSelect.psBestScore.SetIsVisible(true);
                LevelSelect.psPuzzleNumber.SetIsVisible(true);
                LevelSelect.psPanel.SetIsVisible(true);
                LevelSelect.psPuzzleGlow.SetIsVisible(true);
                LevelSelect.psTotalScore.SetIsVisible(true);
                LevelSelect.psStars.SetIsVisible(true);
                LevelSelect.psStarsIcon.SetIsVisible(true);
                for (i = 0; i < BUTTONAMOUNT; i += 1) {
                    LevelSelect.psLevelButtons[i].SetIsVisible(true);
                    LevelSelect.psLevelWrapping[i].SetIsVisible(!GlobalMain.ShopManager.IsPackPurchased(i));
                    LevelSelect.psLevelButtons[i].SetScale(i === LevelSelect.dwPage ? 1 : .7, i === LevelSelect.dwPage ? 1 : .7)
                }
                LevelSelect.psGlowPageButtons.SetIsVisible(true)
            }
        }
    };
    LevelSelect.UpdatePage = function() {
        if (LevelSelect.dwPage !== -1 && !LevelSelect.bCoverThemePlayed && !LevelSelect.bPlayingIntro) {
            LevelSelect.bCoverThemePlayed = true;
            Globals.SetBackgroundMusic("LevelSelectTheme", true)
        }
        if (LevelSelect.dwPage >= 0 && LevelSelect.dwPage < NUM_PAGES) {
            LevelSelect.UpdateInfo(true);
            LevelGrid.SetPage(LevelSelect.dwPage)
        } else {
            LevelSelect.UpdateInfo(false)
        }
        LevelSelect.Reset();
        LevelSelect.UpdateInfoSimple()
    };
    LevelSelect.UpdateMaxPage = function() {
        var i;
        for (i = 0; i < NUM_PAGES; i += 1) {
            if (i <= LevelSelect.dwMaxPage) {
                LevelGrid.SetPageAvailable(i * 2, true);
                if (Records.GetChallengesCompleted(i, 0) >= STARS_PER_SECRET) {
                    LevelGrid.SetPageAvailable(i * 2 + 1, true)
                }
            } else {
                LevelGrid.SetPageAvailable(i * 2, false);
                LevelGrid.SetPageAvailable(i * 2 + 1, false)
            }
        }
    };
    LevelSelect.GetPageAvailable = function(dwPage, dwSecret) {
        if (dwSecret === 0) {
            if (dwPage >= -1 && dwPage <= LevelSelect.dwMaxPage) {
                return true
            }
        } else {
            var dwMaxPage = LevelSelect.dwMaxPage;
            if (dwMaxPage >= NUM_PAGES) {
                dwMaxPage = NUM_PAGES - 1
            }
            if (dwPage >= 0 && dwPage <= dwMaxPage && Records.GetChallengesCompleted(dwPage, 0) >= STARS_PER_SECRET) {
                return true
            }
        }
        return false
    };
    LevelSelect.HandleCheats = function() {
        var l;
        if (JamSystem.InputManager.GetKeyPressed(18)) {
            Globals.SetBackgroundMusicVolume(0);
            EndScreen.SetActive(true);
            LevelSelect.dwScript = Script.Add(ScriptData.AllChallenge);
            LevelSelect.AllowHomeButton = false;
            LevelSelect.eMode = LEVELSELECT_MODE_ALL_CHALLENGE_COMPLETE
        }
        if (JamSystem.InputManager.GetKeyPressed(101)) {
            Globals.SetBackgroundMusicVolume(0);
            LevelSelect.UpdateInfo(false);
            LevelSelect.dwScript = Script.Add(ScriptData.AllNormalComplete);
            LevelSelect.eMode = LEVELSELECT_MODE_NORMAL_COMPLETE
        }
        if (JamSystem.InputManager.GetKeyPressed(102)) {
            Globals.SetBackgroundMusicVolume(0);
            LevelSelect.UpdateInfo(false);
            LevelSelect.dwScript = Script.Add(ScriptData.AllNormalBonusComplete);
            LevelSelect.eMode = LEVELSELECT_MODE_NORMAL_BONUS_COMPLETE
        }
        if (JamSystem.InputManager.GetKeyPressed(103)) {
            Globals.SetBackgroundMusicVolume(0);
            LevelSelect.UpdateInfo(false);
            LevelSelect.dwScript = Script.Add(ScriptData.AllSecretComplete);
            LevelSelect.eMode = LEVELSELECT_MODE_SECRET_COMPLETE
        }
        if (JamSystem.InputManager.GetKeyPressed(15)) {
            if (LevelSelect.dwPage >= 0) {
                var dwNumLevels, dwStart;
                if (LevelSelect.dwSecret) {
                    dwStart = LevelSelect.dwPage * TOTAL_LEVELS + TOTAL_NORMAL_LEVELS;
                    dwNumLevels = TOTAL_SECRET_LEVELS
                } else {
                    dwStart = LevelSelect.dwPage * TOTAL_LEVELS;
                    dwNumLevels = TOTAL_NORMAL_LEVELS
                }
                for (l = 0; l < dwNumLevels; l += 1) {
                    Records.SetPlayed(dwStart + l);
                    Records.LevelFinished(dwStart + l, 0, 0, 1, true);
                    LevelGrid.CompleteLevel(dwStart + l, false)
                }
                Records.SetPageCompletedSeen(LevelSelect.dwPage);
                LevelSelect.dwMaxPage = LevelSelect.CalcMaxPage();
                LevelSelect.UpdateMaxPage()
            }
        }
    };
    LevelSelect.Update = function() {
        if (LevelSelect.bPlayingIntro) {
            Globals.SetBackgroundMusicVolume(0);
            LevelSelect.dwIntroTimer -= 1;
            if (LevelSelect.dwIntroTimer <= 0) {
                LevelSelect.bPlayingIntro = false;
                if (LevelSelect.dwPage === -1) {
                    Globals.SetBackgroundMusic("CoverTheme", false)
                } else {
                    LevelSelect.bCoverThemePlayed = true;
                    Globals.SetBackgroundMusic("LevelSelectTheme", false)
                }
            } else {
                if (LevelSelect.dwIntroTimer === 95) {
                    Helpers.PlaySound("CoverFanfare")
                }
            }
        }
        EntityManager.Update();
        Script.Update();
        if (LevelSelect.eMode === LEVELSELECT_MODE_WAIT && LevelSelect.dwPage === LevelSelect.BuyingPage) {
            if (this.WaitForPurchase) {
                this.WaitForPurchase = !GlobalMain.ShopManager.CanIProgress();
                if (!this.WaitForPurchase) {
                    if (GlobalMain.ShopManager.IsPackPurchased(LevelSelect.dwPage)) {
                        LevelSelect.ForceToPage = false
                    }
                }
                return
            }
        }
        if (LevelSelect.bPulseFlip) {
            LevelSelect.dwFlipPulseTimer += 1;
            if (LevelSelect.dwFlipScaleTimer) {
                LevelSelect.dwFlipScaleTimer -= 1;
                if (LevelSelect.dwFlipScaleTimer === 0) {
                    LevelSelect.psFlip.SetScale(1, 1)
                } else {
                    var fScale = LevelSelect.dwFlipScaleTimer / LEVELSELECT_SCALE_DELAY * .2 + 1;
                    LevelSelect.psFlip.SetScale(fScale, fScale)
                }
            } else {
                if (LevelSelect.dwFlipPulseTimer % LEVELSELECT_PULSE_DELAY === 0) {
                    LevelSelect.dwFlipScaleTimer = LEVELSELECT_SCALE_DELAY
                }
            }
        }
        if (Application.Cheats) {
            LevelSelect.HandleCheats()
        }
        if (LevelSelect.bMovingPage) {
            LevelSelect.dwMoveDelay -= 1;
            var fOffset;
            if (LevelSelect.dwMoveDelay === 0) {
                LevelSelect.bMovingPage = false;
                fOffset = LevelSelect.fMoveOffset
            } else {
                var fPercent = LevelSelect.dwMoveDelay / LevelSelect.dwTotalDelay;
                fPercent = Math.cos(fPercent * (22 / 7)) * .5 + .5;
                fOffset = (LevelSelect.fMoveOffset - LevelSelect.fStartOffset) * fPercent + LevelSelect.fStartOffset
            }
            if (LevelSelect.bMovingPageX) {
                LevelSelect.SetOffsetX(fOffset)
            } else {
                LevelSelect.SetOffsetY(fOffset)
            }
        }
        LevelSelect.psButtonUpDown.SetIsVisible(false);
        if (LevelSelect.eMode === LEVELSELECT_MODE_WAIT) {
            if (Script.GetIsFinished(LevelSelect.dwScript)) {
                LevelSelect.psButtonUpDown.SetIsVisible(LevelSelect.dwPage !== -1 && LevelSelect.dwPage !== 6 && Records.GetChallengesCompleted(LevelSelect.dwPage, 0) >= STARS_PER_SECRET);
                LevelSelect.psButtonToCover.SetIsVisible(LevelSelect.dwPage !== -1 && LevelSelect.AllowHomeButton);
                LevelSelect.psButtonToEnd.SetIsVisible(LevelSelect.dwPage !== -1 && Records.GetAllChallenge() && LevelSelect.dwPage !== 6)
            }
        }
        var Button = JamSystem.InputManager.GetMouseButtonPressed(0);
        var psArea = Touch.Test(Button);
        Cover.Update();
        EndScreen.Update();
        if (JamSystem.InputManager.GetKeyPressed(402)) {
            if (LevelSelect.bPulseFlip && !Records.GetFlipSeen()) {
                Records.SetFlipSeen();
                LevelSelect.bPulseFlip = false;
                LevelSelect.psFlip.SetScale(1, 1)
            }
            Globals.BounceImage(LevelSelect.psFlip);
            LevelGrid.Flip(LevelSelect.GetPage());
            LevelSelect.bWaitForRelease = true
        }
        if (LevelSelect.eMode === LEVELSELECT_MODE_WAIT && LevelSelect.ForceToPage) {
            LevelSelect.ForceToPage = false;
            LevelSelect.bGestureX = true;
            LevelSelect.dwPage = LevelSelect.ForcedPage;
            LevelSelect.dwSecret = 0;
            Helpers.PlaySound("OptionMotion");
            LevelSelect.eMode = LEVELSELECT_MODE_SPRING;
            LevelSelect.bPageClick = false;
            LevelSelect.fLastXDiff = 0;
            LevelSelect.fLastYDiff = 0;
            LevelSelect.fSpeedX = 0;
            LevelSelect.fSpeedY = 0;
            if (GlobalMain.ShopManager.IsPackPurchased(i) && LevelSelect.dwPage !== -1 && LevelSelect.dwPage !== 6) {
                LevelSelect.dwLevel = LevelSelect.dwPage * TOTAL_NORMAL_LEVELS + LevelSelect.dwPage * TOTAL_SECRET_LEVELS;
                LevelSelect.SetCursor(LevelSelect.dwLevel);
                LevelGrid.SetCursorActive(true)
            }
            var Image = "ButtonSecretDownWoods";
            if (LevelSelect.dwPage === 2 || LevelSelect.dwPage === 3) {
                Image = "ButtonSecretDownUnderground"
            }
            if (LevelSelect.dwPage === 4 || LevelSelect.dwPage === 5) {
                Image = "ButtonSecretDownDragon"
            }
            var TextureInfo = Helpers.GetTextureInfoFromImageName(Image);
            LevelSelect.psButtonUpDown.SetTexture(TextureInfo.Texture, TextureInfo.Frame);
            LevelSelect.UpdatePage()
        }
        if (Button) {
            LevelSelect.fGestureStartX = JamSystem.InputManager.GetMouseX();
            LevelSelect.fGestureStartY = JamSystem.InputManager.GetMouseY();
            LevelSelect.bGestureStarted = false;
            LevelSelect.fRootStartX = LevelGrid.GetOffsetX();
            LevelSelect.fRootStartY = LevelGrid.GetOffsetY();
            Debug.Log("Get " + LevelSelect.fRootStartX)
        }
        var fGestureX = 0,
            fGestureY = 0;
        if (JamSystem.InputManager.GetMouseButtonHeld(0)) {
            fGestureX = JamSystem.InputManager.GetMouseX() - LevelSelect.fGestureStartX;
            fGestureY = JamSystem.InputManager.GetMouseY() - LevelSelect.fGestureStartY;
            Debug.Log("fGestureX " + fGestureX)
        }
        var i = 0;
        if (Script.GetIsFinished(LevelSelect.dwScript) && LevelSelect.dwPage !== -1 && LevelSelect.dwPage !== 6) {
            if (LevelSelect.eMode === LEVELSELECT_MODE_WAIT) {
                if (!GlobalMain.ShopManager.IsPackPurchased(LevelSelect.dwPage)) {
                    GlobalMain.ShopManager.DisplayBuyGame(LevelSelect.dwPage);
                    this.WaitForPurchase = true;
                    LevelSelect.ForceToPage = true;
                    LevelSelect.ForcedPage = 0;
                    LevelSelect.BuyingPage = LevelSelect.dwPage;
                    LevelSelect.psGlowPageButtons.SetPositionX(-100, -100)
                }
            }
            for (i = 0; i < BUTTONAMOUNT; i += 1) {
                LevelSelect.psLevelWrapping[i].SetIsVisible(!GlobalMain.ShopManager.IsPackPurchased(i));
                LevelSelect.psLevelButtons[i].SetScale(i === LevelSelect.dwPage ? 1 : .7, i === LevelSelect.dwPage ? 1 : .7)
            }
            if (Records.GetChallengesCompleted(LevelSelect.dwPage, 1) === 0 && !LevelSelect.dwSecret) {
                LevelSelect.dwSecretPulseTimer += 1;
                if (LevelSelect.dwSecretScaleTimer) {
                    LevelSelect.dwSecretScaleTimer -= 1;
                    if (LevelSelect.dwSecretScaleTimer === 0) {
                        LevelSelect.psButtonUpDown.SetScale(1, 1)
                    } else {
                        var fScale = LevelSelect.dwSecretScaleTimer / HELP_SCALE_DELAY * .2 + 1;
                        LevelSelect.psButtonUpDown.SetScale(fScale, fScale)
                    }
                } else {
                    if (LevelSelect.dwSecretPulseTimer % HELP_PULSE_DELAY === 0) {
                        LevelSelect.dwSecretScaleTimer = HELP_SCALE_DELAY
                    }
                }
            }
        }
        if (LevelSelect.dwPage !== -1 & LevelSelect.dwPage !== 6) {
            if (GlobalMain.ShopManager.IsPackPurchased(LevelSelect.dwPage)) {
                LevelSelect.psGlowPageButtons.SetPositionX(LevelSelect.psLevelButtons[LevelSelect.dwPage].GetPositionX())
            }
        }
        if (LevelSelect.eMode === LEVELSELECT_MODE_WAIT || LevelSelect.eMode === LEVELSELECT_MODE_SPRING && !LevelSelect.ForceToPage) {
            if (psArea) {
                for (i = 0; i < BUTTONAMOUNT; i += 1) {
                    if (psArea === LevelSelect.sLevelButtonsArea[i]) {
                        if (!GlobalMain.ShopManager.IsPackPurchased(i) && !LevelSelect.dwSecret) {
                            GlobalMain.ShopManager.DisplayBuyGame(i);
                            this.WaitForPurchase = true;
                            LevelSelect.ForceToPage = true;
                            LevelSelect.ForcedPage = 0;
                            LevelSelect.BuyingPage = i;
                            LevelSelect.psGlowPageButtons.SetPositionX(-100, -100)
                        }
                        Globals.BounceImage(LevelSelect.psLevelButtons[i]);
                        if (LevelSelect.dwSecret && Records.GetChallengesCompleted(i, 0) < STARS_PER_SECRET) {
                            LevelSelect.ForceToPage = true;
                            LevelSelect.ForcedPage = i;
                            var Image = "ButtonSecretDownWoods";
                            if (LevelSelect.dwPage === 2 || LevelSelect.dwPage === 3) {
                                Image = "ButtonSecretDownUnderground"
                            }
                            if (LevelSelect.dwPage === 4 || LevelSelect.dwPage === 5) {
                                Image = "ButtonSecretDownDragon"
                            }
                            var TextureInfo = Helpers.GetTextureInfoFromImageName(Image);
                            LevelSelect.psButtonUpDown.SetTexture(TextureInfo.Texture, TextureInfo.Frame);
                            LevelSelect.dwLevel = -1;
                            LevelSelect.bGestureX = false;
                            LevelSelect.dwSecret = 0;
                            Helpers.PlaySound("OptionMotion");
                            LevelSelect.eMode = LEVELSELECT_MODE_SPRING;
                            LevelSelect.bPageClick = false;
                            LevelSelect.fLastXDiff = 0;
                            LevelSelect.fLastYDiff = 0;
                            LevelSelect.fSpeedX = 0;
                            LevelSelect.fSpeedY = 0;
                            LevelSelect.UpdatePage()
                        } else {
                            LevelSelect.bGestureX = true;
                            LevelSelect.dwPage = i;
                            Helpers.PlaySound("OptionMotion");
                            LevelSelect.eMode = LEVELSELECT_MODE_SPRING;
                            LevelSelect.bPageClick = false;
                            LevelSelect.fLastXDiff = 0;
                            LevelSelect.fLastYDiff = 0;
                            LevelSelect.fSpeedX = 0;
                            LevelSelect.fSpeedY = 0;
                            var Image = LevelSelect.dwSecret ? "ButtonSecretUpWoods" : "ButtonSecretDownWoods";
                            if (LevelSelect.dwPage === 2 || LevelSelect.dwPage === 3) {
                                Image = LevelSelect.dwSecret ? "ButtonSecretUpUnderground" : "ButtonSecretDownUnderground"
                            }
                            if (LevelSelect.dwPage === 4 || LevelSelect.dwPage === 5) {
                                Image = LevelSelect.dwSecret ? "ButtonSecretUpDragon" : "ButtonSecretDownDragon"
                            }
                            var TextureInfo = Helpers.GetTextureInfoFromImageName(Image);
                            LevelSelect.psButtonUpDown.SetTexture(TextureInfo.Texture, TextureInfo.Frame);
                            if (GlobalMain.ShopManager.IsPackPurchased(i)) {
                                LevelSelect.dwLevel = LevelSelect.dwPage * TOTAL_NORMAL_LEVELS + LevelSelect.dwPage * TOTAL_SECRET_LEVELS;
                                LevelSelect.SetCursor(LevelSelect.dwLevel);
                                LevelGrid.SetCursorActive(true)
                            }
                            LevelSelect.UpdatePage()
                        }
                    }
                }
            }
        }
        var dwLevel;
        switch (LevelSelect.eMode) {
            case LEVELSELECT_MODE_WAIT_END:
                if (!JamSystem.InputManager.GetMouseButtonHeld(0)) {
                    var bStart = false;
                    var dwLevel = LevelGrid.GetTouchedLevel(LevelSelect.psTempArea);
                    if (dwLevel != -1) {
                        LevelSelect.bWaitForRelease = true;
                        if (LevelSelect.dwLevel != dwLevel) {
                            Helpers.PlaySound("OptionIndicated");
                            LevelSelect.SetCursor(dwLevel)
                        } else {
                            bStart = true
                        }
                    } else {
                        if (psArea === LevelSelect.sFlipArea) {
                            if (LevelSelect.bPulseFlip && !Records.GetFlipSeen()) {
                                Records.SetFlipSeen();
                                LevelSelect.bPulseFlip = false;
                                LevelSelect.psFlip.SetScale(1, 1)
                            }
                            Globals_BounceImage(LevelSelect.psFlip);
                            LevelGrid.Flip(LevelSelect.GetPage());
                            LevelSelect.bWaitForRelease = true
                        }
                        LevelSelect.SetCursor(-1)
                    }
                    if (bStart) {
                        LevelGrid.SetCursorActive(false);
                        if (!Records.GetPlayed(LevelSelect.dwLevel)) {
                            Helpers.PlaySound("LevelUnwrapped");
                            Cover_ActivateErase();
                            LevelGrid.OpenLevel(LevelSelect.dwLevel);
                            LevelSelect.eMode = LEVELSELECT_MODE_OPEN;
                            LevelSelect.dwStateTimer = 0
                        } else {
                            Helpers.PlaySound("OptionSelected");
                            Globals_FadeBackgroundMusic();
                            LevelGrid.HideLevel(LevelSelect.dwLevel, true);
                            LevelSelect.bComplete = false;
                            LevelSelect.bChallengeComplete = false;
                            LevelSelect.bPageUnlocked = false;
                            Mode_Change(MODE_GAME)
                        }
                        return
                    } else {
                        LevelSelect.eMode = LEVELSELECT_MODE_WAIT
                    }
                } else {
                    if (Math.abs(fGestureX) > 15 || Math.abs(fGestureY) > 15) {
                        LevelSelect.SetCursor(-1);
                        LevelSelect.fGestureStartX = JamSystem.InputManager.GetMouseX();
                        LevelSelect.fGestureStartY = JamSystem.InputManager.GetMouseY();
                        LevelSelect.eMode = LEVELSELECT_MODE_DRAG;
                        LevelSelect.dwStateTimer = 0
                    }
                }
                break;
            case LEVELSELECT_MODE_WAIT:
                if (Application.TouchControls) {
                    if (psArea) {
                        LevelSelect.eMode = LEVELSELECT_MODE_WAIT_END;
                        LevelSelect.psTempArea = psArea;
                        var dwLevel = LevelGrid.GetTouchedLevel(LevelSelect.psTempArea);
                        if (LevelSelect.dwLevel != dwLevel) {
                            LevelSelect.SetCursor(-1);
                            break
                        }
                    } else {
                        if (JamSystem.InputManager.GetMouseButtonHeld(0)) {
                            if (LevelSelect.bWaitForRelease) {
                                if (Math.abs(fGestureX) > 15) {
                                    LevelSelect.bWaitForRelease = false;
                                    LevelSelect.SetCursor(-1);
                                    LevelSelect.dwLevel = -1;
                                    LevelSelect.fGestureStartX = JamSystem.InputManager.GetMouseX();
                                    LevelSelect.eMode = LEVELSELECT_MODE_DRAG;
                                    LevelSelect.dwStateTimer = 0
                                }
                            } else {
                                LevelSelect.eMode = LEVELSELECT_MODE_DRAG;
                                LevelSelect.SetCursor(-1);
                                LevelSelect.dwStateTimer = 0
                            }
                            break
                        }
                    }
                } {
                    Cover.Touch(psArea);
                    EndScreen.Touch(psArea);
                    if (psArea) {
                        if (psArea === LevelSelect.sButtonUpDown && LevelSelect.psButtonUpDown.GetIsVisible()) {
                            if (Records.GetChallengesCompleted(LevelSelect.dwPage, 0) >= STARS_PER_SECRET) {
                                Globals.BounceImage(LevelSelect.psButtonUpDown);
                                var Image = !LevelSelect.dwSecret ? "ButtonSecretUpWoods" : "ButtonSecretDownWoods";
                                if (LevelSelect.dwPage === 2 || LevelSelect.dwPage === 3) {
                                    Image = !LevelSelect.dwSecret ? "ButtonSecretUpUnderground" : "ButtonSecretDownUnderground"
                                }
                                if (LevelSelect.dwPage === 4 || LevelSelect.dwPage === 5) {
                                    Image = !LevelSelect.dwSecret ? "ButtonSecretUpDragon" : "ButtonSecretDownDragon"
                                }
                                var TextureInfo = Helpers.GetTextureInfoFromImageName(Image);
                                LevelSelect.psButtonUpDown.SetTexture(TextureInfo.Texture, TextureInfo.Frame);
                                LevelSelect.bGestureX = false;
                                LevelSelect.dwSecret = LevelSelect.dwSecret ? 0 : 1;
                                Helpers.PlaySound("OptionMotion");
                                LevelSelect.eMode = LEVELSELECT_MODE_SPRING;
                                LevelSelect.bPageClick = false;
                                LevelSelect.fLastXDiff = 0;
                                LevelSelect.fLastYDiff = 0;
                                LevelSelect.fSpeedX = 0;
                                LevelSelect.fSpeedY = 0;
                                LevelSelect.dwLevel = LevelSelect.dwPage * TOTAL_NORMAL_LEVELS + LevelSelect.dwPage * TOTAL_SECRET_LEVELS;
                                LevelSelect.dwLevel += LevelSelect.dwSecret ? TOTAL_NORMAL_LEVELS : 0;
                                LevelSelect.SetCursor(LevelSelect.dwLevel);
                                LevelGrid.SetCursorActive(true);
                                LevelSelect.UpdatePage()
                            }
                        }
                    }
                    if (psArea) {
                        if (psArea === Cover.sButtonPlayGame && Cover.psButtonPlayGame.GetIsVisible()) {
                            Globals.BounceImage(Cover.psButtonPlayGame);
                            LevelSelect.bGestureX = true;
                            LevelSelect.dwPage = 0;
                            LevelSelect.dwSecret = 0;
                            Helpers.PlaySound("OptionMotion");
                            LevelSelect.eMode = LEVELSELECT_MODE_SPRING;
                            LevelSelect.bPageClick = false;
                            LevelSelect.fLastXDiff = 0;
                            LevelSelect.fLastYDiff = 0;
                            LevelSelect.fSpeedX = 0;
                            LevelSelect.fSpeedY = 0;
                            LevelSelect.dwLevel = LevelSelect.dwPage * TOTAL_NORMAL_LEVELS + LevelSelect.dwPage * TOTAL_SECRET_LEVELS;
                            LevelSelect.SetCursor(LevelSelect.dwLevel);
                            LevelGrid.SetCursorActive(true);
                            LevelSelect.UpdatePage()
                        }
                    }
                    if (psArea) {
                        if (psArea === LevelSelect.sButtonToEnd && LevelSelect.psButtonToEnd.GetIsVisible()) {
                            Globals.BounceImage(LevelSelect.psButtonToEnd);
                            if (LevelSelect.dwSecret) {
                                LevelSelect.ForceToPage = true;
                                LevelSelect.ForcedPage = 6;
                                LevelSelect.dwLevel = -1;
                                LevelSelect.bGestureX = false;
                                LevelSelect.dwSecret = 0;
                                Helpers.PlaySound("OptionMotion");
                                LevelSelect.eMode = LEVELSELECT_MODE_SPRING;
                                LevelSelect.bPageClick = false;
                                LevelSelect.fLastXDiff = 0;
                                LevelSelect.fLastYDiff = 0;
                                LevelSelect.fSpeedX = 0;
                                LevelSelect.fSpeedY = 0;
                                LevelSelect.UpdatePage()
                            } else {
                                LevelSelect.dwLevel = -1;
                                LevelSelect.bGestureX = true;
                                LevelSelect.dwPage = 6;
                                LevelSelect.dwSecret = 0;
                                Helpers.PlaySound("OptionMotion");
                                LevelSelect.eMode = LEVELSELECT_MODE_SPRING;
                                LevelSelect.bPageClick = false;
                                LevelSelect.fLastXDiff = 0;
                                LevelSelect.fLastYDiff = 0;
                                LevelSelect.fSpeedX = 0;
                                LevelSelect.fSpeedY = 0;
                                LevelSelect.UpdatePage()
                            }
                        }
                    }
                    if (psArea) {
                        if (psArea === LevelSelect.sButtonToCover && LevelSelect.psButtonToCover.GetIsVisible()) {
                            Globals.BounceImage(LevelSelect.psButtonToCover);
                            if (LevelSelect.dwPage === 6) {
                                LevelSelect.bGestureX = true;
                                LevelSelect.dwPage -= 1;
                                Helpers.PlaySound("OptionMotion");
                                LevelSelect.eMode = LEVELSELECT_MODE_SPRING;
                                LevelSelect.bPageClick = false;
                                LevelSelect.fLastXDiff = 0;
                                LevelSelect.fLastYDiff = 0;
                                LevelSelect.fSpeedX = 0;
                                LevelSelect.fSpeedY = 0;
                                LevelSelect.UpdatePage();
                                break
                            }
                            if (LevelSelect.dwSecret) {
                                LevelSelect.ForceToPage = true;
                                LevelSelect.ForcedPage = -1;
                                LevelSelect.bGestureX = false;
                                LevelSelect.dwSecret = 0;
                                Helpers.PlaySound("OptionMotion");
                                LevelSelect.eMode = LEVELSELECT_MODE_SPRING;
                                LevelSelect.bPageClick = false;
                                LevelSelect.fLastXDiff = 0;
                                LevelSelect.fLastYDiff = 0;
                                LevelSelect.fSpeedX = 0;
                                LevelSelect.fSpeedY = 0;
                                LevelSelect.UpdatePage()
                            } else {
                                LevelSelect.bGestureX = true;
                                LevelSelect.dwPage = -1;
                                LevelSelect.dwSecret = 0;
                                Helpers.PlaySound("OptionMotion");
                                LevelSelect.eMode = LEVELSELECT_MODE_SPRING;
                                LevelSelect.bPageClick = false;
                                LevelSelect.fLastXDiff = 0;
                                LevelSelect.fLastYDiff = 0;
                                LevelSelect.fSpeedX = 0;
                                LevelSelect.fSpeedY = 0;
                                LevelSelect.UpdatePage()
                            }
                        }
                    }
                    if (psArea) {
                        var bStart = false;
                        dwLevel = LevelGrid.GetTouchedLevel(psArea);
                        if (dwLevel !== -1) {
                            LevelSelect.bWaitForRelease = true;
                            if (LevelSelect.dwLevel !== dwLevel) {
                                Helpers.PlaySound("OptionIndicated");
                                LevelSelect.SetCursor(dwLevel)
                            } else {
                                bStart = true
                            }
                        }
                    }
                    if (LevelSelect.dwPage === -1) {
                        if (JamSystem.InputManager.GetKeyPressed(404) || JamSystem.InputManager.GetKeyPressed(622)) {
                            Globals.BounceImage(Cover.psButtonPlayGame);
                            LevelSelect.bGestureX = true;
                            LevelSelect.dwPage = 0;
                            LevelSelect.dwSecret = 0;
                            Helpers.PlaySound("OptionMotion");
                            LevelSelect.eMode = LEVELSELECT_MODE_SPRING;
                            LevelSelect.bPageClick = false;
                            LevelSelect.fLastXDiff = 0;
                            LevelSelect.fLastYDiff = 0;
                            LevelSelect.fSpeedX = 0;
                            LevelSelect.fSpeedY = 0;
                            LevelSelect.dwLevel = LevelSelect.dwPage * TOTAL_NORMAL_LEVELS + LevelSelect.dwPage * TOTAL_SECRET_LEVELS;
                            LevelSelect.SetCursor(LevelSelect.dwLevel);
                            LevelGrid.SetCursorActive(true);
                            LevelSelect.UpdatePage()
                        }
                    } else if (LevelSelect.dwPage !== 6) {
                        if ((JamSystem.InputManager.GetKeyPressed(404) || JamSystem.InputManager.GetKeyPressed(622)) && LevelSelect.dwLevel !== -1) {
                            bStart = true
                        }
                        if (JamSystem.InputManager.GetKeyPressed(202)) {
                            if (LevelSelect.dwLevel === -1) {
                                LevelSelect.dwLevel = LevelSelect.dwPage * TOTAL_NORMAL_LEVELS + LevelSelect.dwPage * TOTAL_SECRET_LEVELS;
                                LevelSelect.dwLevel += LevelSelect.dwSecret ? TOTAL_NORMAL_LEVELS : 0
                            } else {
                                LevelSelect.dwLevel -= LevelSelect.dwSecret ? 1 : 4;
                                var Max = LevelSelect.dwPage * TOTAL_NORMAL_LEVELS + LevelSelect.dwPage * TOTAL_SECRET_LEVELS;
                                var PageMin = LevelSelect.dwSecret ? Max + TOTAL_NORMAL_LEVELS : Max;
                                Max += LevelSelect.dwSecret ? TOTAL_SECRET_LEVELS + TOTAL_NORMAL_LEVELS : TOTAL_NORMAL_LEVELS;
                                if (LevelSelect.dwLevel < PageMin) {
                                    LevelSelect.dwLevel = Max + (LevelSelect.dwLevel - PageMin)
                                }
                            }
                            Helpers.PlaySound("OptionIndicated");
                            LevelSelect.SetCursor(LevelSelect.dwLevel)
                        }
                        if (JamSystem.InputManager.GetKeyPressed(203)) {
                            if (LevelSelect.dwLevel === -1) {
                                LevelSelect.dwLevel = LevelSelect.dwPage * TOTAL_NORMAL_LEVELS + LevelSelect.dwPage * TOTAL_SECRET_LEVELS;
                                LevelSelect.dwLevel += LevelSelect.dwSecret ? TOTAL_NORMAL_LEVELS : 0
                            } else {
                                LevelSelect.dwLevel += LevelSelect.dwSecret ? 1 : 4;
                                var Max = LevelSelect.dwPage * TOTAL_NORMAL_LEVELS + LevelSelect.dwPage * TOTAL_SECRET_LEVELS;
                                var PageMin = LevelSelect.dwSecret ? Max + TOTAL_NORMAL_LEVELS : Max;
                                Max += LevelSelect.dwSecret ? TOTAL_SECRET_LEVELS + TOTAL_NORMAL_LEVELS : TOTAL_NORMAL_LEVELS;
                                if (LevelSelect.dwLevel >= Max) {
                                    LevelSelect.dwLevel = LevelSelect.dwLevel - Max + PageMin
                                }
                            }
                            Helpers.PlaySound("OptionIndicated");
                            LevelSelect.SetCursor(LevelSelect.dwLevel)
                        }
                        if (JamSystem.InputManager.GetKeyPressed(200) && !LevelSelect.dwSecret) {
                            if (LevelSelect.dwLevel === -1) {
                                LevelSelect.dwLevel = LevelSelect.dwPage * TOTAL_NORMAL_LEVELS + LevelSelect.dwPage * TOTAL_SECRET_LEVELS
                            } else {
                                if (LevelSelect.dwLevel % 4 === 0) {
                                    LevelSelect.dwLevel = 3 + LevelSelect.dwLevel
                                } else {
                                    LevelSelect.dwLevel -= 1
                                }
                            }
                            Helpers.PlaySound("OptionIndicated");
                            LevelSelect.SetCursor(LevelSelect.dwLevel)
                        }
                        if (JamSystem.InputManager.GetKeyPressed(201) && !LevelSelect.dwSecret) {
                            if (LevelSelect.dwLevel === -1) {
                                LevelSelect.dwLevel = LevelSelect.dwPage * TOTAL_NORMAL_LEVELS + LevelSelect.dwPage * TOTAL_SECRET_LEVELS
                            } else {
                                if (LevelSelect.dwLevel % 4 === 3) {
                                    LevelSelect.dwLevel = LevelSelect.dwLevel - 3
                                } else {
                                    LevelSelect.dwLevel += 1
                                }
                            }
                            Helpers.PlaySound("OptionIndicated");
                            LevelSelect.SetCursor(LevelSelect.dwLevel)
                        }
                    }
                    if (psArea) {
                        if (psArea === LevelSelect.sFlipArea) {
                            if (LevelSelect.bPulseFlip && !Records.GetFlipSeen()) {
                                Records.SetFlipSeen();
                                LevelSelect.bPulseFlip = false;
                                LevelSelect.psFlip.SetScale(1, 1)
                            }
                            Globals.BounceImage(LevelSelect.psFlip);
                            LevelGrid.Flip(LevelSelect.GetPage());
                            LevelSelect.bWaitForRelease = true
                        }
                    }
                    if (bStart) {
                        LevelGrid.SetCursorActive(false);
                        if (!Records.GetPlayed(LevelSelect.dwLevel)) {
                            Helpers.PlaySound("LevelUnwrapped");
                            Cover.ActivateErase();
                            LevelGrid.OpenLevel(LevelSelect.dwLevel);
                            LevelSelect.eMode = LEVELSELECT_MODE_OPEN;
                            LevelSelect.dwStateTimer = 0
                        } else {
                            Helpers.PlaySound("OptionSelected");
                            Globals.FadeBackgroundMusic();
                            LevelGrid.HideLevel(LevelSelect.dwLevel, true);
                            LevelSelect.bComplete = false;
                            LevelSelect.bChallengeComplete = false;
                            LevelSelect.bPageUnlocked = false;
                            GlobalMain.StateManager.RequestChangeState(StateManager.StateGame)
                        }
                        return
                    }
                }
                break;
            case LEVELSELECT_MODE_DRAG:
                if (!JamSystem.InputManager.GetMouseButtonHeld(0)) {
                    if (LevelSelect.dwStateTimer < 20 && LevelSelect.bGestureStarted) {
                        if (LevelSelect.bGestureX) {
                            {
                                var xDiff = LevelSelect.fGestureStartX - JamSystem.InputManager.GetMouseX();
                                if (xDiff < -15) {
                                    if (LevelSelect.GetPageAvailable(LevelSelect.dwPage - 1, LevelSelect.dwSecret)) {
                                        LevelSelect.dwPage--;
                                        Helpers.PlaySound("OptionMotion")
                                    }
                                } else if (xDiff > 15) {
                                    if (LevelSelect.GetPageAvailable(LevelSelect.dwPage + 1, LevelSelect.dwSecret)) {
                                        LevelSelect.dwPage++;
                                        Helpers.PlaySound("OptionMotion")
                                    }
                                }
                            }
                        } else {
                            if (LevelSelect.dwPage != -1 && LevelSelect.dwPage != NUM_PAGES && Records.GetChallengesCompleted(LevelSelect.dwPage, 0) >= STARS_PER_SECRET) {
                                var yDiff = LevelSelect.fGestureStartY - JamSystem.InputManager.GetMouseY();
                                if (yDiff > 15) {
                                    if (LevelSelect.dwSecret == 0) {
                                        LevelSelect.dwSecret++;
                                        Helpers.PlaySound("OptionMotion")
                                    }
                                } else if (yDiff < -15) {
                                    if (LevelSelect.dwSecret) {
                                        LevelSelect.dwSecret--;
                                        Helpers.PlaySound("OptionMotion")
                                    }
                                }
                            }
                        }
                        LevelSelect.eMode = LEVELSELECT_MODE_SPRING;
                        LevelSelect.bPageClick = false;
                        LevelSelect.fLastXDiff = 0;
                        LevelSelect.fLastYDiff = 0;
                        LevelSelect.UpdatePage()
                    } else {
                        if (LevelSelect.bGestureStarted) {
                            if (LevelSelect.bGestureX) {
                                var x = -LevelGrid.GetOffsetX();
                                var dwX = LevelSelect.dwPage * SCREEN_WIDTH - x;
                                if (dwX > SCREEN_WIDTH / 2) {
                                    if (LevelSelect.dwPage >= 0) {
                                        LevelSelect.dwPage--;
                                        Helpers.PlaySound("OptionMotion")
                                    }
                                } else if (dwX < -(SCREEN_WIDTH / 2)) {
                                    if (LevelSelect.dwPage < LevelSelect.dwMaxPage) {
                                        LevelSelect.dwPage++;
                                        Helpers.PlaySound("OptionMotion")
                                    }
                                }
                            } else {
                                if (Records.GetChallengesCompleted(LevelSelect.dwPage, 0) >= STARS_PER_SECRET) {
                                    var y = -LevelGrid.GetOffsetY();
                                    var dwY = LevelSelect.dwSecret * SCREEN_HEIGHT - y;
                                    if (dwY > SCREEN_HEIGHT / 2) {
                                        if (LevelSelect.dwSecret) {
                                            LevelSelect.dwSecret--;
                                            Helpers.PlaySound("OptionMotion")
                                        }
                                    } else if (dwY < -(SCREEN_HEIGHT / 2)) {
                                        if (LevelSelect.dwSecret == 0) {
                                            LevelSelect.dwSecret++;
                                            Helpers.PlaySound("OptionMotion")
                                        }
                                    }
                                }
                            }
                            LevelSelect.eMode = LEVELSELECT_MODE_SPRING;
                            LevelSelect.bPageClick = false;
                            LevelSelect.fLastXDiff = 0;
                            LevelSelect.fLastYDiff = 0;
                            LevelSelect.fSpeedX = 0;
                            LevelSelect.fSpeedY = 0
                        } else {
                            LevelSelect.eMode = LEVELSELECT_MODE_WAIT
                        }
                    }
                    LevelSelect.UpdatePage()
                } else {
                    LevelSelect.dwStateTimer++;
                    var x = LevelSelect.fRootStartX + fGestureX;
                    var y = LevelSelect.fRootStartY + fGestureY;
                    if (!LevelSelect.bGestureStarted) {
                        {
                            if (Math.abs(fGestureX) > 10 || Math.abs(fGestureY) > 10) {
                                LevelSelect.bGestureStarted = true;
                                if (Math.abs(fGestureX) > Math.abs(fGestureY)) {
                                    LevelSelect.bGestureX = true
                                } else {
                                    LevelSelect.bGestureX = false
                                }
                            }
                        }
                    } else {
                        var bInfo = true;
                        if (LevelSelect.bGestureX) {
                            var fOffsetMin = SCREEN_WIDTH;
                            var fOffsetMax = -LevelSelect.dwMaxPage * SCREEN_WIDTH;
                            if (LevelSelect.dwSecret) {
                                fOffsetMin = -LevelSelect.dwPage * SCREEN_WIDTH;
                                fOffsetMax = fOffsetMin;
                                if (LevelSelect.dwPage > 0 && Records.GetChallengesCompleted(LevelSelect.dwPage - 1, 0) >= STARS_PER_SECRET) {
                                    fOffsetMin += SCREEN_WIDTH
                                }
                                if (LevelSelect.dwPage < NUM_PAGES - 1 && Records.GetChallengesCompleted(LevelSelect.dwPage + 1, 0) >= STARS_PER_SECRET) {
                                    fOffsetMax -= SCREEN_WIDTH
                                }
                            }
                            if (x > fOffsetMin) {
                                x = (x - fOffsetMin) / 4 + fOffsetMin
                            } else if (x < fOffsetMax) {
                                x = (x - fOffsetMax) / 4 + fOffsetMax
                            }
                            LevelSelect.SetOffsetX(x);
                            if (x > 0 || x < -(NUM_PAGES - 1) * SCREEN_WIDTH) {
                                bInfo = false
                            }
                        } else {
                            var fOffsetMin = 0;
                            var fOffsetMax = 0;
                            if (LevelSelect.dwPage != -1 && LevelSelect.dwPage != NUM_PAGES && Records.GetChallengesCompleted(LevelSelect.dwPage, 0) >= STARS_PER_SECRET) {
                                fOffsetMax = -(1 * SCREEN_HEIGHT)
                            }
                            if (y > fOffsetMin) {
                                y = (y - fOffsetMin) / 6 + fOffsetMin
                            } else if (y < fOffsetMax) {
                                y = (y - fOffsetMax) / 6 + fOffsetMax
                            }
                            LevelSelect.SetOffsetY(y);
                            if (LevelSelect.dwPage == -1 || LevelSelect.dwPage == NUM_PAGES) {
                                bInfo = false
                            }
                            if (y < -SCREEN_HEIGHT || y > 0) {
                                bInfo = false
                            }
                        }
                        LevelSelect.UpdateInfo(bInfo)
                    }
                }
                break;
            case LEVELSELECT_MODE_SPRING:
                var fTarget;
                if (LevelSelect.bGestureX) {
                    fTarget = LevelSelect.dwPage * SCREEN_WIDTH;
                    xDiff = -fTarget - LevelGrid.GetOffsetX();
                    LevelSelect.fSpeedX += xDiff * .06;
                    LevelSelect.fSpeedX *= .7;
                    LevelSelect.SetOffsetX(LevelGrid.GetOffsetX() + LevelSelect.fSpeedX);
                    if ((xDiff <= 0 && LevelSelect.fLastXDiff > 0 || xDiff >= 0 && LevelSelect.fLastXDiff < 0) && !LevelSelect.bPageClick) {
                        LevelSelect.bPageClick = true;
                        Helpers.PlaySound("Impact")
                    }
                    LevelSelect.fLastXDiff = xDiff;
                    if (Math.abs(xDiff) < 1 && Math.abs(LevelSelect.fSpeedX) < 1) {
                        if (!LevelSelect.bPageClick) {
                            Helpers.PlaySound("Impact")
                        }
                        LevelSelect.SetOffsetX(-fTarget);
                        LevelSelect.eMode = LEVELSELECT_MODE_WAIT
                    }
                } else {
                    fTarget = LevelSelect.dwSecret * SCREEN_HEIGHT;
                    yDiff = -fTarget - LevelGrid.GetOffsetY();
                    LevelSelect.fSpeedY += yDiff * .06;
                    LevelSelect.fSpeedY *= .7;
                    LevelSelect.SetOffsetY(LevelGrid.GetOffsetY() + LevelSelect.fSpeedY);
                    if ((yDiff <= 0 && LevelSelect.fLastYDiff > 0 || yDiff >= 0 && LevelSelect.fLastYDiff < 0) && !LevelSelect.bPageClick) {
                        LevelSelect.bPageClick = true;
                        Helpers.PlaySound("Impact")
                    }
                    LevelSelect.fLastYDiff = yDiff;
                    if (Math.abs(yDiff) < 1 && Math.abs(LevelSelect.fSpeedY) < 1) {
                        if (!LevelSelect.bPageClick) {
                            Helpers.PlaySound("Impact")
                        }
                        LevelSelect.SetOffsetY(-fTarget);
                        LevelSelect.eMode = LEVELSELECT_MODE_WAIT
                    }
                }
                break;
            case LEVELSELECT_MODE_OPEN:
                LevelSelect.dwTimer += 1;
                if (LevelSelect.dwTimer === 32) {
                    LevelSelect.dwTimer = 0;
                    LevelSelect.eMode = LEVELSELECT_MODE_WAIT;
                    Helpers.PlaySound("OptionSelected");
                    Globals.FadeBackgroundMusic();
                    LevelGrid.HideLevel(LevelSelect.dwLevel, true);
                    LevelSelect.bComplete = false;
                    LevelSelect.bChallengeComplete = false;
                    LevelSelect.bPageUnlocked = false;
                    GlobalMain.StateManager.RequestChangeState(StateManager.StateGame)
                }
                break;
            case LEVELSELECT_MODE_LEVEL_COMPLETE:
                if (Script.GetIsFinished(LevelSelect.dwScript)) {
                    if (LevelSelect.dwSecret === 0 && LevelSelect.dwPage === 0 && Records.GetLevelsCompleted(0, false) === TOTAL_NORMAL_LEVELS && !Records.GetFirstPageCeremonySeen()) {
                        Records.SetFirstPageCeremonySeen();
                        Globals.SetBackgroundMusicVolume(0);
                        LevelSelect.UpdateInfo(false);
                        LevelSelect.dwScript = Script.Add(ScriptData.FirstPageComplete);
                        LevelSelect.eMode = LEVELSELECT_MODE_NORMAL_COMPLETE
                    } else if (LevelSelect.bPageUnlocked) {
                        LevelGrid.SetPageAvailable(LevelSelect.GetPage() + 2, true);
                        LevelSelect.dwScript = Script.Add(ScriptData.PageUnlocked);
                        Globals.SetBackgroundMusicVolume(0);
                        LevelSelect.eMode = LEVELSELECT_MODE_PAGE_UNLOCKED
                    } else if (LevelSelect.dwSecret === 0 && !Records.GetAllNormalCompletedSeen() && Records.GetAllNormalCompleted()) {
                        Records.SetAllNormalCompletedSeen();
                        Globals.SetBackgroundMusicVolume(0);
                        LevelSelect.UpdateInfo(false);
                        LevelSelect.dwScript = Script.Add(ScriptData.AllNormalComplete);
                        LevelSelect.eMode = LEVELSELECT_MODE_NORMAL_COMPLETE
                    } else if (LevelSelect.dwSecret === 1 && !Records.GetAllSecretCompletedSeen() && Records.GetAllSecretCompleted()) {
                        Records.SetAllSecretCompletedSeen();
                        Globals.SetBackgroundMusicVolume(0);
                        LevelSelect.UpdateInfo(false);
                        LevelSelect.dwScript = Script.Add(ScriptData.AllSecretComplete);
                        LevelSelect.eMode = LEVELSELECT_MODE_SECRET_COMPLETE
                    } else if (!Records.GetPageCompletedSeen(LevelSelect.GetPage()) && LevelSelect.dwSecret === 0 && Records.GetLevelsCompleted(LevelSelect.dwPage, 0) >= TOTAL_NORMAL_LEVELS) {
                        if (!LevelGrid.GetFlipped()) {
                            LevelGrid.Flip(LevelSelect.GetPage());
                            LevelSelect.bTempFlip = true
                        } else {
                            LevelSelect.bTempFlip = false
                        }
                        Records.SetPageCompletedSeen(LevelSelect.GetPage());
                        Globals.SetBackgroundMusicVolume(0);
                        LevelSelect.dwScript = Script.Add(ScriptData.SetComplete);
                        LevelSelect.eMode = LEVELSELECT_MODE_SET_COMPLETE
                    } else {
                        LevelSelect.eMode = LEVELSELECT_MODE_WAIT;
                        LevelSelect.SetCursor(LevelSelect.dwLevel);
                        LevelGrid.SetCursorActive(true)
                    }
                }
                break;
            case LEVELSELECT_MODE_CHALLENGE_COMPLETE:
                if (Script.GetIsFinished(LevelSelect.dwScript)) {
                    LevelSelect.bChallengeComplete = false;
                    if (!Records.GetAllChallengeSeen() && Records.GetAllChallenge()) {
                        Records.SetAllChallengeSeen();
                        EndScreen.SetActive(true);
                        LevelSelect.dwScript = Script.Add(ScriptData.AllChallenge);
                        LevelSelect.AllowHomeButton = false;
                        LevelSelect.eMode = LEVELSELECT_MODE_ALL_CHALLENGE_COMPLETE
                    } else if (LevelSelect.dwSecret === 0 && LevelSelect.dwPage === 0 && Records.GetLevelsCompleted(0, false) === TOTAL_NORMAL_LEVELS && !Records.GetFirstPageCeremonySeen()) {
                        Records.SetFirstPageCeremonySeen();
                        Globals.SetBackgroundMusicVolume(0);
                        LevelSelect.UpdateInfo(false);
                        LevelSelect.dwScript = Script.Add(ScriptData.FirstPageComplete);
                        LevelSelect.eMode = LEVELSELECT_MODE_NORMAL_COMPLETE
                    } else if (LevelSelect.dwSecret === 0 && !Records.GetAllNormalBonusCompletedSeen() && Records.GetAllNormalBonusCompleted()) {
                        Records.SetAllNormalBonusCompletedSeen();
                        Records.SetAllNormalCompletedSeen();
                        Globals.SetBackgroundMusicVolume(0);
                        LevelSelect.UpdateInfo(false);
                        LevelSelect.dwScript = Script.Add(ScriptData.AllNormalBonusComplete);
                        LevelSelect.eMode = LEVELSELECT_MODE_NORMAL_BONUS_COMPLETE
                    } else if (!Records.GetSetCompletedSeen(LevelSelect.dwPage) && LevelSelect.dwSecret === 0 && Records.GetChallengesCompleted(LevelSelect.dwPage, 0) >= TOTAL_NORMAL_LEVELS) {
                        Records.SetSetCompletedSeen(LevelSelect.dwPage);
                        Globals.SetBackgroundMusicVolume(0);
                        LevelSelect.dwScript = Script.Add(ScriptData.SetBonusComplete);
                        LevelSelect.eMode = LEVELSELECT_MODE_SET_COMPLETE
                    } else if (!Records.GetSecretUnlockedSeen(LevelSelect.dwPage) && LevelSelect.dwSecret === 0 && Records.GetChallengesCompleted(LevelSelect.dwPage, 0) >= STARS_PER_SECRET) {
                        Records.SetSecretUnlockedSeen(LevelSelect.dwPage);
                        Globals.SetBackgroundMusicVolume(0);
                        LevelSelect.dwScript = Script.Add(ScriptData.SecretUnlocked);
                        LevelSelect.eMode = LEVELSELECT_MODE_SECRET_UNLOCKED
                    } else if (!Records.GetPageCompletedSeen(LevelSelect.GetPage()) && LevelSelect.dwSecret === 1 && Records.GetChallengesCompleted(LevelSelect.dwPage, 1) >= TOTAL_SECRET_LEVELS) {
                        Records.SetPageCompletedSeen(LevelSelect.GetPage());
                        Globals.SetBackgroundMusicVolume(0);
                        LevelSelect.dwScript = Script.Add(ScriptData.SecretComplete);
                        LevelSelect.eMode = LEVELSELECT_MODE_SET_COMPLETE
                    } else if (LevelSelect.bPageUnlocked) {
                        LevelGrid.SetPageAvailable(LevelSelect.GetPage() + 2, true);
                        LevelSelect.dwScript = Script.Add(ScriptData.PageUnlocked);
                        Globals.SetBackgroundMusicVolume(0);
                        LevelSelect.eMode = LEVELSELECT_MODE_PAGE_UNLOCKED
                    } else if (LevelSelect.dwSecret === 0 && !Records.GetAllNormalCompletedSeen() && Records.GetAllNormalCompleted()) {
                        Records.SetAllNormalCompletedSeen();
                        Globals.SetBackgroundMusicVolume(0);
                        LevelSelect.UpdateInfo(false);
                        LevelSelect.dwScript = Script.Add(ScriptData.AllNormalComplete);
                        LevelSelect.eMode = LEVELSELECT_MODE_NORMAL_COMPLETE
                    } else if (LevelSelect.dwSecret === 1 && !Records.GetAllSecretCompletedSeen() && Records.GetAllSecretCompleted()) {
                        Records.SetAllSecretCompletedSeen();
                        Globals.SetBackgroundMusicVolume(0);
                        LevelSelect.UpdateInfo(false);
                        LevelSelect.dwScript = Script.Add(ScriptData.AllSecretComplete);
                        LevelSelect.eMode = LEVELSELECT_MODE_SECRET_COMPLETE
                    } else if (!Records.GetPageCompletedSeen(LevelSelect.GetPage()) && LevelSelect.dwSecret === 0 && Records.GetLevelsCompleted(LevelSelect.dwPage, 0) >= TOTAL_NORMAL_LEVELS) {
                        if (!LevelGrid.GetFlipped()) {
                            LevelGrid.Flip(LevelSelect.GetPage());
                            LevelSelect.bTempFlip = true
                        } else {
                            LevelSelect.bTempFlip = false
                        }
                        Records.SetPageCompletedSeen(LevelSelect.GetPage());
                        Globals.SetBackgroundMusicVolume(0);
                        LevelSelect.dwScript = Script.Add(ScriptData.SetComplete);
                        LevelSelect.eMode = LEVELSELECT_MODE_SET_COMPLETE
                    } else {
                        LevelSelect.eMode = LEVELSELECT_MODE_WAIT;
                        LevelSelect.SetCursor(LevelSelect.dwLevel);
                        LevelGrid.SetCursorActive(true)
                    }
                }
                break;
            case LEVELSELECT_MODE_PAGE_UNLOCKED:
                if (Script.GetIsFinished(LevelSelect.dwScript)) {
                    Globals.SetBackgroundMusic("LevelSelectTheme", true);
                    LevelSelect.eMode = LEVELSELECT_MODE_WAIT
                }
                break;
            case LEVELSELECT_MODE_SECRET_UNLOCKED:
                if (Script.GetIsFinished(LevelSelect.dwScript)) {
                    Globals.SetBackgroundMusicVolume(1);
                    LevelSelect.eMode = LEVELSELECT_MODE_WAIT
                }
                break;
            case LEVELSELECT_MODE_SET_COMPLETE:
                if (Script.GetIsFinished(LevelSelect.dwScript)) {
                    if (LevelSelect.bTempFlip) {
                        LevelGrid.Flip(LevelSelect.GetPage());
                        LevelSelect.bTempFlip = false
                    }
                    Globals.SetBackgroundMusic("LevelSelectTheme", true);
                    LevelSelect.eMode = LEVELSELECT_MODE_WAIT;
                    LevelSelect.UpdateInfo(true)
                }
                break;
            case LEVELSELECT_MODE_NORMAL_COMPLETE:
                if (Script.GetIsFinished(LevelSelect.dwScript)) {
                    Globals.SetBackgroundMusic("LevelSelectTheme", true);
                    LevelSelect.UpdateInfo(true);
                    LevelSelect.eMode = LEVELSELECT_MODE_WAIT
                }
                break;
            case LEVELSELECT_MODE_NORMAL_BONUS_COMPLETE:
                if (Script.GetIsFinished(LevelSelect.dwScript)) {
                    Globals.SetBackgroundMusic("LevelSelectTheme", true);
                    LevelSelect.UpdateInfo(true);
                    LevelSelect.eMode = LEVELSELECT_MODE_WAIT
                }
                break;
            case LEVELSELECT_MODE_SECRET_COMPLETE:
                if (Script.GetIsFinished(LevelSelect.dwScript)) {
                    Globals.SetBackgroundMusic("LevelSelectTheme", true);
                    LevelSelect.UpdateInfo(true);
                    LevelSelect.eMode = LEVELSELECT_MODE_WAIT
                }
                break;
            case LEVELSELECT_MODE_ALL_CHALLENGE_COMPLETE:
                if (Script.GetIsFinished(LevelSelect.dwScript)) {
                    Globals.SetBackgroundMusicVolume(1);
                    LevelSelect.AllowHomeButton = true;
                    LevelSelect.eMode = LEVELSELECT_MODE_WAIT
                }
                break;
            case LEVELSELECT_MODE_BOUGHT_ALL:
                if (Script.GetIsFinished(LevelSelect.dwScript)) {
                    LevelSelect.eMode = LEVELSELECT_MODE_WAIT
                }
                break
        }
    };
    LevelSelect.SetLevelNumber = function(dwLevel) {
        LevelSelect.dwLevel = dwLevel;
        if (LevelSelect.dwLevel === -1) {
            LevelSelect.dwPage = -1;
            LevelSelect.dwSecret = 0
        } else {
            LevelSelect.dwPage = Math.floor(LevelSelect.dwLevel / TOTAL_LEVELS);
            if (LevelSelect.dwLevel % TOTAL_LEVELS < TOTAL_NORMAL_LEVELS) {
                LevelSelect.dwSecret = 0
            } else {
                LevelSelect.dwSecret = 1
            }
        }
        LevelSelect.UpdatePage();
        LevelSelect.SetOffsetX(LevelSelect.dwPage * -SCREEN_WIDTH);
        LevelSelect.SetOffsetY(LevelSelect.dwSecret * -SCREEN_HEIGHT);
        LevelSelect.dwLevel = dwLevel;
        LevelGrid.SetLevel(dwLevel)
    };
    LevelSelect.GetLevelNumber = function() {
        return LevelSelect.dwLevel
    };
    LevelSelect.GetPageNumber = function() {
        return LevelSelect.dwPage
    };
    LevelSelect.GetSecret = function() {
        return LevelSelect.dwSecret
    };
    LevelSelect.GetLevel = function() {
        return LevelData_asData[LevelSelect.dwLevel].pszFileName
    };
    LevelSelect.GetColourScheme = function() {
        if (LevelSelect.dwPage < 0 || LevelSelect.dwPage >= NUM_PAGES) {
            return LevelGrid.GetColourScheme(0)
        }
        if (LevelSelect.dwLevel === -1) {
            return LevelGrid.GetColourScheme(LevelSelect.dwPage * TOTAL_LEVELS)
        }
        return LevelGrid.GetColourScheme(LevelSelect.dwLevel)
    };
    LevelSelect.GetLevelShort = function() {
        return LevelData_asData[LevelSelect.dwLevel].pszFileName
    };
    LevelSelect.SetInfoOpacity = function(fOpacity) {
        if (fOpacity < 0) {
            fOpacity = 0
        }
        var i;
        if (fOpacity !== 0) {
            LevelSelect.psPanel.SetOpacity(fOpacity / 255 * .5);
            LevelSelect.psPuzzleGlow.SetOpacity(fOpacity / 255);
            LevelSelect.psPuzzleNumber.SetOpacity(fOpacity / 255);
            LevelSelect.psBestScore.SetOpacity(fOpacity / 255);
            LevelSelect.psTotalScore.SetOpacity(fOpacity / 255);
            LevelSelect.psFlip.SetOpacity(fOpacity / 255);
            LevelSelect.psButtonPanel.SetOpacity(fOpacity / 255);
            LevelSelect.psGlowPageButtons.SetOpacity(fOpacity / 255);
            var i = 0;
            for (i = 0; i < BUTTONAMOUNT; i += 1) {
                LevelSelect.psLevelButtons[i].SetOpacity(fOpacity / 255);
                LevelSelect.psLevelWrapping[i].SetOpacity(fOpacity / 255)
            }
            LevelSelect.psButtonUpDown.SetOpacity(fOpacity / 255);
            LevelSelect.psButtonToCover.SetOpacity(fOpacity / 255);
            LevelSelect.psButtonToEnd.SetOpacity(fOpacity / 255);
            LevelSelect.psStars.SetOpacity(fOpacity / 255);
            LevelSelect.psStarsIcon.SetOpacity(fOpacity / 255);
            if (LevelSelect.fLastInfoOpacity === 0) {
                GadgetTree.GetLayer(LAYERS_HUD).AddChild(LevelSelect.psPanel);
                GadgetTree.GetLayer(LAYERS_HUD).AddChild(LevelSelect.psPuzzleGlow);
                GadgetTree.GetLayer(LAYERS_HUD).AddChild(LevelSelect.psPuzzleNumber);
                GadgetTree.GetLayer(LAYERS_HUD).AddChild(LevelSelect.psBestScore);
                GadgetTree.GetLayer(LAYERS_HUD).AddChild(LevelSelect.psTotalScore);
                GadgetTree.GetLayer(LAYERS_HUD).AddChild(LevelSelect.psFlip);
                GadgetTree.GetLayer(LAYERS_HUD).AddChild(LevelSelect.psButtonPanel);
                GadgetTree.GetLayer(LAYERS_HUD).AddChild(LevelSelect.psButtonUpDown);
                GadgetTree.GetLayer(LAYERS_HUD).AddChild(LevelSelect.psGlowPageButtons);
                for (i = 0; i < BUTTONAMOUNT; i += 1) {
                    GadgetTree.GetLayer(LAYERS_HUD).AddChild(LevelSelect.psLevelButtons[i]);
                    GadgetTree.GetLayer(LAYERS_HUD).AddChild(LevelSelect.psLevelWrapping[i])
                }
                GadgetTree.GetLayer(LAYERS_HUD).AddChild(LevelSelect.psButtonToCover);
                GadgetTree.GetLayer(LAYERS_HUD).AddChild(LevelSelect.psButtonToEnd);
                GadgetTree.GetLayer(LAYERS_HUD).AddChild(LevelSelect.psStars);
                GadgetTree.GetLayer(LAYERS_HUD).AddChild(LevelSelect.psStarsIcon)
            }
        } else {
            if (LevelSelect.fLastInfoOpacity !== 0) {
                LevelSelect.psPanel.RemoveFromParent();
                LevelSelect.psPuzzleGlow.RemoveFromParent();
                LevelSelect.psPuzzleNumber.RemoveFromParent();
                LevelSelect.psBestScore.RemoveFromParent();
                LevelSelect.psTotalScore.RemoveFromParent();
                LevelSelect.psFlip.RemoveFromParent();
                LevelSelect.psButtonPanel.RemoveFromParent();
                LevelSelect.psGlowPageButtons.RemoveFromParent();
                for (i = 0; i < BUTTONAMOUNT; i += 1) {
                    LevelSelect.psLevelButtons[i].RemoveFromParent();
                    LevelSelect.psLevelWrapping[i].RemoveFromParent()
                }
                LevelSelect.psButtonUpDown.RemoveFromParent();
                LevelSelect.psButtonToCover.RemoveFromParent();
                LevelSelect.psButtonToEnd.RemoveFromParent();
                LevelSelect.psStars.RemoveFromParent();
                LevelSelect.psStarsIcon.RemoveFromParent()
            }
        }
        LevelSelect.fLastInfoOpacity = fOpacity
    };
    LevelSelect.SetLevelComplete = function(bChallengeComplete, dwMoves, dwTime, dwScore) {
        if (!Records.GetCompleted(LevelSelect.GetLevelNumber())) {
            LevelSelect.bComplete = true
        }
        if (bChallengeComplete && !Records.GetChallengeDone(LevelSelect.GetLevelNumber())) {
            LevelSelect.bChallengeComplete = true
        }
        Records.SetPlayed(LevelSelect.GetLevelNumber());
        Records.LevelFinished(LevelSelect.GetLevelNumber(), dwMoves, dwTime, dwScore, bChallengeComplete);
        if (LevelSelect.dwMaxPage < NUM_PAGES - 1 && LevelSelect.CalcMaxPage() > LevelSelect.dwMaxPage) {
            LevelSelect.bPageUnlocked = true;
            LevelSelect.dwMaxPage += 1;
            LevelSelect.UpdateMaxPage()
        }
    };
    LevelSelect.ScriptCompleteLevel = function() {
        LevelGrid.CompleteLevel(LevelSelect.GetLevelNumber(), true);
        LevelGrid.ResetFlip(LevelSelect.GetLevelNumber());
        LevelGrid.FlipLevel(LevelSelect.GetLevelNumber(), LevelSelect.GetPage());
        if (LevelSelect.dwSecret && LevelSelect.bChallengeComplete) {
            var dwPart = LevelSelect.dwLevel % TOTAL_LEVELS - TOTAL_NORMAL_LEVELS;
            LevelGrid.SetPageBonusPart(LevelSelect.GetPage(), dwPart)
        }
    };
    LevelSelect.ScriptNewPage = function() {
        LevelSelect.bMovingPage = true;
        LevelSelect.bMovingPageX = true;
        LevelSelect.fStartOffset = -(LevelSelect.dwPage * SCREEN_WIDTH);
        LevelSelect.fMoveOffset = -(LevelSelect.dwMaxPage * SCREEN_WIDTH);
        LevelSelect.dwTotalDelay = LevelSelect.dwMoveDelay = MOVE_PAGE_DELAY
    };
    LevelSelect.ScriptSecretPage = function() {
        LevelSelect.bMovingPage = true;
        LevelSelect.bMovingPageX = false;
        LevelSelect.fStartOffset = 0;
        LevelSelect.fMoveOffset = -SCREEN_HEIGHT;
        LevelSelect.dwTotalDelay = LevelSelect.dwMoveDelay = MOVE_PAGE_DELAY
    };
    LevelSelect.ScriptReturnPage = function() {
        LevelSelect.bMovingPage = true;
        if (LevelSelect.bMovingPageX) {
            LevelSelect.fStartOffset = -(LevelSelect.dwMaxPage * SCREEN_WIDTH);
            LevelSelect.fMoveOffset = -(LevelSelect.dwPage * SCREEN_WIDTH)
        } else {
            LevelSelect.fStartOffset = -SCREEN_HEIGHT;
            LevelSelect.fMoveOffset = 0
        }
        LevelSelect.dwTotalDelay = LevelSelect.dwMoveDelay = MOVE_PAGE_DELAY
    };
    LevelSelect.ScriptNoSecretPage = function() {
        LevelSelect.UpdateInfo(false);
        if (LevelSelect.dwSecret) {
            LevelSelect.bMovingPage = true;
            LevelSelect.bMovingPageX = false;
            LevelSelect.fStartOffset = -SCREEN_HEIGHT;
            LevelSelect.fMoveOffset = 0;
            LevelSelect.dwMoveDelay = MOVE_PAGE_DELAY;
            LevelSelect.dwTotalDelay = MOVE_PAGE_DELAY;
            LevelSelect.dwSecret = 0
        }
    };
    LevelSelect.ScriptEndPage = function() {
        LevelSelect.bMovingPage = true;
        LevelSelect.bMovingPageX = true;
        LevelSelect.fStartOffset = -(LevelSelect.dwPage * SCREEN_WIDTH);
        LevelSelect.fMoveOffset = -(NUM_PAGES * SCREEN_WIDTH);
        LevelSelect.dwMoveDelay = MOVE_PAGE_DELAY;
        LevelSelect.dwTotalDelay = MOVE_PAGE_DELAY;
        LevelSelect.dwPage = NUM_PAGES;
        LevelSelect.dwMaxPage = NUM_PAGES;
        LevelSelect.UpdateMaxPage()
    };
    LevelSelect.ScriptFirstPage = function() {
        LevelSelect.bMovingPage = true;
        LevelSelect.bMovingPageX = true;
        LevelSelect.fStartOffset = -(LevelSelect.dwPage * SCREEN_WIDTH);
        LevelSelect.fMoveOffset = -(0 * SCREEN_WIDTH);
        LevelSelect.dwMoveDelay = MOVE_PAGE_DELAY;
        LevelSelect.dwTotalDelay = MOVE_PAGE_DELAY
    };
    LevelSelect.ScriptCoverPage = function() {
        LevelSelect.bMovingPage = true;
        LevelSelect.bMovingPageX = true;
        LevelSelect.fStartOffset = -(LevelSelect.dwPage * SCREEN_WIDTH);
        LevelSelect.fMoveOffset = -(0 * SCREEN_WIDTH);
        LevelSelect.dwMoveDelay = MOVE_PAGE_DELAY;
        LevelSelect.dwTotalDelay = MOVE_PAGE_DELAY
    };
    LevelSelect.ScriptStartPan = function() {
        LevelSelect.bMovingPage = true;
        LevelSelect.bMovingPageX = true;
        LevelSelect.fStartOffset = -(0 * SCREEN_WIDTH);
        LevelSelect.fMoveOffset = -((NUM_PAGES - 1) * SCREEN_WIDTH);
        LevelSelect.dwMoveDelay = 210;
        LevelSelect.dwTotalDelay = 210
    };
    LevelSelect.ScriptIsPageEnded = function() {
        return !LevelSelect.bMovingPage
    };
    LevelSelect.CheckMusic = function() {
        if (!LevelSelect.bCoverThemePlayed) {
            LevelSelect.bCoverThemePlayed = true;
            Globals.SetBackgroundMusic("LevelSelectTheme", true)
        }
    };

    function Records() {}
    Records.Init = function() {};
    Records.Save = function() {
        GlobalMain.LifetimeStatManager.SaveAnyData()
    };
    Records.ShutDown = function() {};
    Records.Erase = function() {
        GlobalMain.LifetimeStatManager.Clear()
    };
    Records.Exists = function() {
        return GlobalMain.LifetimeStatManager.LoadedData
    };
    Records.LevelFinished = function(dwLevel, dwMoves, dwTime, dwScore, bChallengeDone) {
        GlobalMain.LifetimeStatManager.SetLevelFinished(dwLevel, dwMoves, dwTime, dwScore, bChallengeDone)
    };
    Records.SetPlayed = function(dwLevel) {
        GlobalMain.LifetimeStatManager.SetPlayed(dwLevel)
    };
    Records.GetPlayed = function(dwLevel) {
        return GlobalMain.LifetimeStatManager.GetPlayed(dwLevel)
    };
    Records.GetCompleted = function(dwLevel) {
        return GlobalMain.LifetimeStatManager.GetCompleted(dwLevel)
    };
    Records.GetMoves = function(dwLevel) {
        return GlobalMain.LifetimeStatManager.GetMoves(dwLevel)
    };
    Records.GetTime = function(dwLevel) {
        GlobalMain.LifetimeStatManager.GetTime(dwLevel)
    };
    Records.GetScore = function(dwLevel) {
        if (dwLevel === -1) {
            return 0
        }
        return GlobalMain.LifetimeStatManager.GetScore(dwLevel)
    };
    Records.GetChallengeDone = function(dwLevel) {
        if (dwLevel === -1) {
            return false
        }
        return GlobalMain.LifetimeStatManager.GetChallengeDone(dwLevel)
    };
    Records.GetTotalScore = function() {
        return GlobalMain.LifetimeStatManager.GetTotalScore()
    };
    Records.GetTotalCompleted = function() {
        return GlobalMain.LifetimeStatManager.GetTotalCompleted()
    };
    Records.SetPageCompletedSeen = function(dwPage) {
        GlobalMain.LifetimeStatManager.SetPageCompletedSeen(dwPage)
    };
    Records.GetPageCompletedSeen = function(dwPage) {
        return GlobalMain.LifetimeStatManager.GetMoves(dwPage)
    };
    Records.SetSecretUnlockedSeen = function(dwPage) {
        GlobalMain.LifetimeStatManager.SetSecretUnlockedSeen(dwPage)
    };
    Records.GetSecretUnlockedSeen = function(dwPage) {
        if (dwPage < 0) {
            return false
        }
        return GlobalMain.LifetimeStatManager.GetSecretUnlockedSeen(dwPage)
    };
    Records.SetSetCompletedSeen = function(dwPage) {
        GlobalMain.LifetimeStatManager.SetSetCompletedSeen(dwPage)
    };
    Records.GetSetCompletedSeen = function(dwPage) {
        return GlobalMain.LifetimeStatManager.GetSetCompletedSeen(dwPage)
    };
    Records.GetPageCompleted = function(dwPage) {
        return GlobalMain.LifetimeStatManager.GetPageCompleted(dwPage)
    };
    Records.GetLevelsCompleted = function(dwPage, dwSecret) {
        return GlobalMain.LifetimeStatManager.GetLevelsCompleted(dwPage, dwSecret)
    };
    Records.GetChallengesCompleted = function(dwPage, dwSecret) {
        if (dwPage === -1 || dwPage === 6) {
            return false
        }
        return GlobalMain.LifetimeStatManager.GetChallengesCompleted(dwPage, dwSecret)
    };
    Records.GetAllNormalCompleted = function() {
        return GlobalMain.LifetimeStatManager.GetAllNormalCompleted()
    };
    Records.SetAllNormalCompletedSeen = function() {
        GlobalMain.LifetimeStatManager.SetAllNormalCompletedSeen()
    };
    Records.GetAllNormalCompletedSeen = function() {
        return GlobalMain.LifetimeStatManager.GetAllNormalCompletedSeen()
    };
    Records.GetAllNormalBonusCompleted = function() {
        return GlobalMain.LifetimeStatManager.GetAllNormalBonusCompleted()
    };
    Records.SetAllNormalBonusCompletedSeen = function() {
        GlobalMain.LifetimeStatManager.SetAllNormalBonusCompletedSeen()
    };
    Records.GetAllNormalBonusCompletedSeen = function() {
        return GlobalMain.LifetimeStatManager.GetAllNormalBonusCompletedSeen()
    };
    Records.GetAllSecretCompleted = function() {
        return GlobalMain.LifetimeStatManager.GetAllSecretCompleted()
    };
    Records.SetAllSecretCompletedSeen = function() {
        GlobalMain.LifetimeStatManager.SetAllSecretCompletedSeen()
    };
    Records.GetAllSecretCompletedSeen = function() {
        return GlobalMain.LifetimeStatManager.GetAllSecretCompletedSeen()
    };
    Records.GetAllCompleted = function() {
        return GlobalMain.LifetimeStatManager.GetAllCompleted()
    };
    Records.SetAllCompletedSeen = function() {
        GlobalMain.LifetimeStatManager.SetAllCompletedSeen()
    };
    Records.GetAllCompletedSeen = function() {
        return GlobalMain.LifetimeStatManager.GetAllCompletedSeen()
    };
    Records.GetAllChallenge = function() {
        return GlobalMain.LifetimeStatManager.GetAllChallenge()
    };
    Records.SetAllChallengeSeen = function() {
        GlobalMain.LifetimeStatManager.SetAllChallengeSeen()
    };
    Records.GetAllChallengeSeen = function() {
        return GlobalMain.LifetimeStatManager.GetAllChallengeSeen()
    };
    Records.SetFirstPlaySeen = function() {
        if (Records.GetFirstPlaySeen()) {
            return
        }
        GlobalMain.LifetimeStatManager.SetFirstPlaySeen()
    };
    Records.GetFirstPlaySeen = function() {
        return GlobalMain.LifetimeStatManager.GetFirstPlaySeen()
    };
    Records.SetHelpSeen = function() {
        if (Records.GetHelpSeen()) {
            return
        }
        GlobalMain.LifetimeStatManager.SetHelpSeen()
    };
    Records.GetHelpSeen = function() {
        return GlobalMain.LifetimeStatManager.GetHelpSeen()
    };
    Records.SetFlipSeen = function() {
        GlobalMain.LifetimeStatManager.SetFlipSeen()
    };
    Records.GetFlipSeen = function() {
        return GlobalMain.LifetimeStatManager.GetFlipSeen()
    };
    Records.SetFirstPageCeremonySeen = function() {
        GlobalMain.LifetimeStatManager.SetFirstPageCeremonySeen()
    };
    Records.GetFirstPageCeremonySeen = function() {
        return GlobalMain.LifetimeStatManager.GetFirstPageCeremonySeen()
    };
    var COMPLETE_BONUS = 1e3;
    var CHALLENGE_BONUS = 5e3;
    var TIME_BONUS = 1;
    var MOVES_BONUS = 100;
    var BONUS_SCALER_TIME = 400;
    var BONUS_SCALER_MOVES = 200;
    var REVIEW_X = 115 * SCREEN_SCALER;
    var REVIEW_Y = 50 * SCREEN_SCALER;

    function Review() {}
    Review.sContinueButton = {
        x: 0,
        y: 0,
        x2: SCREEN_WIDTH,
        y2: SCREEN_HEIGHT
    };
    Review.psFade = 0;
    Review.psTitle = 0;
    Review.psTitleGlow = 0;
    Review.psCompletion = 0;
    Review.psChallenge = 0;
    Review.psTime = 0;
    Review.psMoves = 0;
    Review.psTotal = 0;
    Review.psComment = 0;
    Review.psCommentGlow = 0;
    Review.psContinue = 0;
    Review.psCompletionBonus = 0;
    Review.psChallengeBonus = 0;
    Review.psTimeBonus = 0;
    Review.psMovesBonus = 0;
    Review.psTotalScore = 0;
    Review.dwCompletionBonus = 0;
    Review.dwChallengeBonus = 0;
    Review.dwTimeBonus = 0;
    Review.dwMovesBonus = 0;
    Review.dwTotalScore = 0;
    Review.bChallengeDone = 0;
    Review.bChallengeAvailable = 0;
    Review.dwScript = 0;
    Review.achComment = "";
    Review.bNewHiScore = 0;
    Review.bShowChallenge = 0;
    Review.dwOldScore = 0;
    Review.fLastOpacity = 0;
    Review.dwPromptTimer = 0;
    Review.LevelComplete = function() {
        var dwLevel = LevelSelect.GetLevelNumber();
        if (LevelData_asData[dwLevel].dwBonusType !== BONUS_TYPE_TOTAL) {
            Review.bChallengeAvailable = true;
            Review.bChallengeDone = false;
            if (LevelData_asData[dwLevel].dwBonusType === BONUS_TYPE_TWO && Game.psBoard.GetNumSameShapes() === 2 || LevelData_asData[dwLevel].dwBonusType === BONUS_TYPE_THREE && Game.psBoard.GetNumSameShapes() === 3 || LevelData_asData[dwLevel].dwBonusType === BONUS_TYPE_TIME && Game.psBoard.GetTime() / 60 <= LevelData_asData[dwLevel].dwParTime || LevelData_asData[dwLevel].dwBonusType === BONUS_TYPE_MOVES && Game.psBoard.GetMoves() <= LevelData_asData[dwLevel].dwParMoves || Game.psBoard.m_bMakeShape && Game.psBoard.m_bShapeMade) {
                Review.bChallengeDone = true
            }
        } else {
            Review.bChallengeAvailable = false
        }
        Review.dwCompletionBonus = COMPLETE_BONUS;
        if (Review.bChallengeDone) {
            Review.dwChallengeBonus = CHALLENGE_BONUS
        } else {
            Review.dwChallengeBonus = 0
        }
        var dwParTime = Math.floor(LevelData_asData[dwLevel].dwParTime * BONUS_SCALER_TIME / 100);
        Review.dwTimeBonus = Math.floor((dwParTime * 10 - Game.psBoard.m_dwTime / 6) * TIME_BONUS);
        if (Review.dwTimeBonus < 0) {
            Review.dwTimeBonus = 0
        }
        var dwParMoves = Math.floor(LevelData_asData[dwLevel].dwParMoves * BONUS_SCALER_MOVES / 100);
        Review.dwMovesBonus = (dwParMoves - Game.psBoard.m_dwMoves) * MOVES_BONUS;
        if (Review.dwMovesBonus < 0) {
            Review.dwMovesBonus = 0
        }
        Review.dwTotalScore = Review.dwCompletionBonus + Review.dwTimeBonus + Review.dwMovesBonus + Review.dwChallengeBonus;
        if (Review.dwTotalScore > Records.GetScore(LevelSelect.GetLevelNumber())) {
            Review.bNewHiScore = true
        } else {
            Review.bNewHiScore = false
        }
        Review.dwOldScore = Records.GetScore(dwLevel);
        LevelSelect.SetLevelComplete(Review.bChallengeDone, Game.psBoard.m_dwMoves, Game.psBoard.m_dwTime, Review.dwTotalScore);
        GlobalMain.MetricsManager.EndGame(Review.dwTotalScore, Game.psBoard.m_dwMoves, Game.psBoard.m_dwTime, Review.bChallengeDone)
    };
    Review.Init = function() {
        Review.bShowChallenge = false;
        var dwLevel = LevelSelect.GetLevelNumber();
        Review.achComment = JamSystem.TextManager.GetText("DATATEXT_ID_REVIEW_OK");
        Review.psComment.SetScale(.75, .75);
        Review.psCommentGlow.SetScale(2 * .75, .8 * .75);
        if (Review.dwTimeBonus || Review.dwMovesBonus) {
            Review.achComment = JamSystem.TextManager.GetText("DATATEXT_ID_REVIEW_NICE");
            Review.psComment.SetScale(1, 1);
            Review.psCommentGlow.SetScale(2 * 1, .8 * 1);
            if (Review.dwTimeBonus && Review.dwMovesBonus) {
                Review.achComment = JamSystem.TextManager.GetText("DATATEXT_ID_REVIEW_GREAT");
                Review.psComment.SetScale(1.35, 1.35);
                Review.psCommentGlow.SetScale(2 * 1.25, .8 * 1.25)
            }
        }
        Review.psComment.SetText(Review.achComment);
        Review.dwScript = Script.Add(ScriptData.Review);
        Script.SetLocalVariableID(Review.dwScript, SCRIPT_LOCAL_VARIABLE_1, Review.psCompletionBonus);
        Script.SetLocalVariableID(Review.dwScript, SCRIPT_LOCAL_VARIABLE_2, Review.dwCompletionBonus);
        Script.SetLocalVariableID(Review.dwScript, SCRIPT_LOCAL_VARIABLE_3, Review.psTimeBonus);
        Script.SetLocalVariableID(Review.dwScript, SCRIPT_LOCAL_VARIABLE_4, Review.dwTimeBonus);
        Script.SetLocalVariableID(Review.dwScript, SCRIPT_LOCAL_VARIABLE_5, Review.psMovesBonus);
        Script.SetLocalVariableID(Review.dwScript, SCRIPT_LOCAL_VARIABLE_6, Review.dwMovesBonus);
        Script.SetLocalVariableID(Review.dwScript, SCRIPT_LOCAL_VARIABLE_7, Review.psTotalScore);
        Script.SetLocalVariableID(Review.dwScript, SCRIPT_LOCAL_VARIABLE_8, Review.dwTotalScore);
        Script.SetLocalVariableID(Review.dwScript, SCRIPT_LOCAL_VARIABLE_9, Review.psChallengeBonus);
        Script.SetLocalVariableID(Review.dwScript, SCRIPT_LOCAL_VARIABLE_10, Review.dwChallengeBonus);
        Script.SetLocalVariableID(Review.dwScript, SCRIPT_LOCAL_VARIABLE_11, Review.bChallengeAvailable);
        Touch.Add(Review.sContinueButton);
        Globals.SetBackgroundMusic("ReviewTheme", true)
    };
    Review.ShutDown = function() {
        Touch.Remove(Review.sContinueButton)
    };
    Review.SetupScreen = function() {
        Review.fLastOpacity = 1;
        var psScheme = LevelSelect.GetColourScheme();
        var fRed = psScheme.fRed;
        var fGreen = psScheme.fGreen;
        var fBlue = psScheme.fBlue;
        var dwLevel;
        if (!LevelSelect.GetSecret()) {
            dwLevel = LevelSelect.GetLevelNumber() % TOTAL_LEVELS
        } else {
            dwLevel = LevelSelect.GetLevelNumber() % TOTAL_LEVELS - TOTAL_NORMAL_LEVELS
        }
        var tx = 328;
        var achTemp = JamSystem.TextManager.GetText("DATATEXT_ID_REVIEW_TITLE", [dwLevel + 1]);
        Review.psTitle = Helpers.CreateBitmapText(achTemp, tx, REVIEW_Y - 25 * SCREEN_SCALER + 40, EA.Default, "PanelFont", GadgetTree.GetLayer(LAYERS_HUD));
        Review.psTitle.SetScale(.75, .75);
        var fCompletionY = REVIEW_Y * SCREEN_SCALER;
        var fChallengeY = REVIEW_Y * SCREEN_SCALER;
        var fTimeY = REVIEW_Y + 30 * SCREEN_SCALER;
        var fMovesY = REVIEW_Y + 60 * SCREEN_SCALER;
        var fTotalY = REVIEW_Y + 90 * SCREEN_SCALER;
        if (Review.bChallengeAvailable) {
            fCompletionY = REVIEW_Y + 30 * SCREEN_SCALER;
            fChallengeY = REVIEW_Y + 60 * SCREEN_SCALER;
            fTimeY = REVIEW_Y + 90 * SCREEN_SCALER;
            fMovesY = REVIEW_Y + 120 * SCREEN_SCALER;
            fTotalY = REVIEW_Y + 160 * SCREEN_SCALER
        }
        Review.psCompletion = Helpers.CreateBitmapText(JamSystem.TextManager.GetText("DATATEXT_ID_REVIEW_COMPLETION_BONUS"), REVIEW_X + 60 * SCREEN_SCALER + 64, fCompletionY, EA.MiddleRight, "PanelFontSmall", GadgetTree.GetLayer(LAYERS_HUD));
        if (Review.bChallengeAvailable) {
            Review.psChallenge = Helpers.CreateBitmapText(JamSystem.TextManager.GetText("DATATEXT_ID_REVIEW_CHALLENGE_BONUS"), REVIEW_X + 60 * SCREEN_SCALER + 64, fChallengeY, EA.MiddleRight, "PanelFontSmall", GadgetTree.GetLayer(LAYERS_HUD))
        }
        Review.psTime = Helpers.CreateBitmapText(JamSystem.TextManager.GetText("DATATEXT_ID_REVIEW_TIME_BONUS"), REVIEW_X + 60 * SCREEN_SCALER + 64, fTimeY, EA.MiddleRight, "PanelFontSmall", GadgetTree.GetLayer(LAYERS_HUD));
        Review.psMoves = Helpers.CreateBitmapText(JamSystem.TextManager.GetText("DATATEXT_ID_REVIEW_MOVES_BONUS"), REVIEW_X + 60 * SCREEN_SCALER + 64, fMovesY, EA.MiddleRight, "PanelFontSmall", GadgetTree.GetLayer(LAYERS_HUD));
        Review.psTotal = Helpers.CreateBitmapText(JamSystem.TextManager.GetText("DATATEXT_ID_REVIEW_TOTAL_SCORE"), REVIEW_X + 50 * SCREEN_SCALER + 64, fTotalY, EA.MiddleRight, "PanelFont", GadgetTree.GetLayer(LAYERS_HUD));
        var Colour = [fRed / 255, fGreen / 255, fBlue / 255, 1];
        Review.psCompletion.SetColour(Colour);
        if (Review.bChallengeAvailable) {
            Review.psChallenge.SetColour(Colour)
        }
        Review.psTime.SetColour(Colour);
        Review.psMoves.SetColour(Colour);
        Review.psTotal.SetColour(Colour);
        Review.psTotal.SetScale(.75, .75);
        Review.psCompletionBonus = EntityCounter.Create(REVIEW_X + 80 * SCREEN_SCALER + 64, fCompletionY, 0, GadgetTree.GetLayer(LAYERS_HUD));
        if (Review.bChallengeAvailable) {
            Review.psChallengeBonus = EntityCounter.Create(REVIEW_X + 80 * SCREEN_SCALER + 64, fChallengeY, 0, GadgetTree.GetLayer(LAYERS_HUD))
        }
        Review.psTimeBonus = EntityCounter.Create(REVIEW_X + 80 * SCREEN_SCALER + 64, fTimeY, 0, GadgetTree.GetLayer(LAYERS_HUD));
        Review.psMovesBonus = EntityCounter.Create(REVIEW_X + 80 * SCREEN_SCALER + 64, fMovesY, 0, GadgetTree.GetLayer(LAYERS_HUD));
        Review.psTotalScore = EntityCounter.Create(REVIEW_X + 70 * SCREEN_SCALER + 64, fTotalY, 0, GadgetTree.GetLayer(LAYERS_HUD));
        Review.psCompletionBonus.m_psText.SetScale(.5, .5);
        EntityManager.Add(Review.psCompletionBonus);
        if (Review.bChallengeAvailable) {
            Review.psChallengeBonus.m_psText.SetScale(.5, .5);
            EntityManager.Add(Review.psChallengeBonus)
        }
        Review.psTimeBonus.m_psText.SetScale(.5, .5);
        EntityManager.Add(Review.psTimeBonus);
        Review.psMovesBonus.m_psText.SetScale(.5, .5);
        EntityManager.Add(Review.psMovesBonus);
        Review.psTotalScore.m_psText.SetFont("PanelFont");
        Review.psTotalScore.m_psText.SetScale(.75, .75);
        EntityManager.Add(Review.psTotalScore);
        if (Review.dwTotalScore > 1e4) {
            Review.psTotalScore.m_psText.SetPosition(REVIEW_X + (80 - 21) * SCREEN_SCALER + 64, fTotalY)
        }
        Review.psComment = Helpers.CreateBitmapText(Review.achComment, tx, REVIEW_Y + 210 * SCREEN_SCALER + 30, EA.Default, "PanelFont", GadgetTree.GetLayer(LAYERS_HUD));
        Review.psComment.SetScale(1, 1);
        Review.psComment.SetIsVisible(false);
        Review.psCommentGlow = Helpers.CreateSprite(tx + 25, REVIEW_Y + 210 * SCREEN_SCALER + 30, EA.Default, "GlowRound", GadgetTree.GetLayer(LAYERS_HUD));
        Review.psCommentGlow.SetScale(2, .8);
        Review.psCommentGlow.SetColour(Colour);
        Review.psCommentGlow.SetIsVisible(false);
        var achTemp = "DATATEXT_ID_REVIEW_ANY_KEY";
        if (Math.random() < .5) {
            achTemp = "DATATEXT_ID_REVIEW_ANY_KEY02"
        }
        Review.psContinue = Helpers.CreateBitmapText(JamSystem.TextManager.GetText(achTemp), tx, SCREEN_HEIGHT - 40, EA.Default, "PanelFont", GadgetTree.GetLayer(LAYERS_HUD));
        Review.psContinue.SetScale(.6, .6);
        Review.psContinue.SetIsVisible(false);
        Review.SetOpacity(0)
    };
    Review.ShutDownScreen = function() {
        Helpers.DestroyBitmapText(Review.psContinue);
        Review.psContinue = null;
        Helpers.DestroySprite(Review.psCommentGlow);
        Review.psCommentGlow = null;
        Helpers.DestroyBitmapText(Review.psComment);
        Review.psComment = null;
        EntityManager.Remove(Review.psTotalScore);
        Review.psTotalScore.Destroy();
        Review.psTotalScore = null;
        EntityManager.Remove(Review.psMovesBonus);
        Review.psMovesBonus.Destroy();
        Review.psMovesBonus = null;
        EntityManager.Remove(Review.psTimeBonus);
        Review.psTimeBonus.Destroy();
        Review.psTimeBonus = null;
        if (Review.bChallengeAvailable) {
            EntityManager.Remove(Review.psChallengeBonus);
            Review.psChallengeBonus.Destroy();
            Review.psChallengeBonus = null
        }
        EntityManager.Remove(Review.psCompletionBonus);
        Review.psCompletionBonus.Destroy();
        Review.psCompletionBonus = null;
        Helpers.DestroyBitmapText(Review.psTotal);
        Review.psTotal = null;
        Helpers.DestroyBitmapText(Review.psMoves);
        Review.psMoves = null;
        Helpers.DestroyBitmapText(Review.psTime);
        Review.psTime = null;
        if (Review.bChallengeAvailable) {
            Helpers.DestroyBitmapText(Review.psChallenge);
            Review.psChallenge = null
        }
        Helpers.DestroyBitmapText(Review.psCompletion);
        Review.psCompletion = null;
        Helpers.DestroyBitmapText(Review.psTitle);
        Review.psTitle = null
    };
    Review.Update = function() {
        if (!Review.bShowChallenge) {
            if (Script.GetIsFinished(Review.dwScript)) {
                if (Review.psComment.GetIsVisible() === false) {
                    if (Review.bNewHiScore) {
                        Helpers.PlaySound("BestScore")
                    }
                    Review.psComment.SetIsVisible(true);
                    Review.psCommentGlow.SetIsVisible(true);
                    Review.psContinue.SetIsVisible(true);
                    for (var i = 0; i < 30; i += 1) {
                        var x = (Math.random() * 80 - 40) * 2 + 322;
                        var y = (Math.random() * 20 - 10) * 2 + REVIEW_Y + 210 * 2;
                        var psEffect = EntityEffect.Create(x, y, ENTITYEFFECT_TYPE_SPARKLE, GadgetTree.GetLayer(LAYERS_HUD));
                        var psScheme = LevelSelect.GetColourScheme();
                        psEffect.SetColour(psScheme.fRed, psScheme.fGreen, psScheme.fBlue);
                        EntityManager.Add(psEffect)
                    }
                }
            }
            Review.dwPromptTimer += 1;
            if (Review.dwPromptTimer % 15 === 0) {
                Review.psContinue.SetOpacity(0)
            }
            if (Review.dwPromptTimer % 15 === 5) {
                Review.psContinue.SetOpacity(255 / 255)
            }
            var psArea = Touch.Test(JamSystem.InputManager.GetMouseButtonPressed(0));
            if (psArea === Review.sContinueButton || JamSystem.InputManager.GetAnyKey()) {
                if (!Script.GetIsFinished(Review.dwScript)) {
                    Script.Stop(Review.dwScript, true);
                    Game.psBoard.m_psHud.UpdateIcon();
                    Review.SetOpacity(255);
                    Game.psBoard.m_psHud.SetMakeOpacity(0);
                    Game.psBoard.m_psHud.SetMakeShapeOpacity(0);
                    Game.psBoard.m_psHud.m_psBonusImage.SetOpacity(0);
                    Game.psBoard.m_psHud.m_psBonusExtra.SetOpacity(0);
                    Review.psCompletionBonus.SetValue(Review.dwCompletionBonus, true, true);
                    if (Review.bChallengeAvailable) {
                        Review.psChallengeBonus.SetValue(Review.dwChallengeBonus, true, true)
                    }
                    Review.psTimeBonus.SetValue(Review.dwTimeBonus, true, true);
                    Review.psMovesBonus.SetValue(Review.dwMovesBonus, true, true);
                    Review.psTotalScore.SetValue(Review.dwTotalScore, true, true)
                } else {
                    Review.psContinue.SetIsVisible(false);
                    var dwLevel = LevelSelect.GetLevelNumber();
                    var achTemp;
                    if (Review.bChallengeAvailable && !Review.bChallengeDone && Review.dwOldScore === 0) {
                        Game.psBoard.m_psHud.m_bBonusImageActive = false;
                        Review.bShowChallenge = true;
                        Review.dwScript = Script.Add(ScriptData.ReviewChallenge);
                        switch (LevelData_asData[dwLevel].dwBonusType) {
                            case BONUS_TYPE_TWO:
                                Script.SetLocalVariableID(Review.dwScript, SCRIPT_LOCAL_VARIABLE_1, "DATATEXT_ID_CHALLENGE_TWO_OF_A_KIND");
                                Game.psBoard.m_psHud.SetBonusImage("TwoOfAKind");
                                break;
                            case BONUS_TYPE_THREE:
                                Script.SetLocalVariableID(Review.dwScript, SCRIPT_LOCAL_VARIABLE_1, "DATATEXT_ID_CHALLENGE_THREE_OF_A_KIND");
                                Game.psBoard.m_psHud.SetBonusImage("ThreeOfAKind");
                                break;
                            case BONUS_TYPE_TIME:
                                achTemp = JamSystem.TextManager.GetText("DATATEXT_ID_CHALLENGE_BEAT_TIME", [LevelData_asData[dwLevel].dwParTime]);
                                Script.SetLocalVariableID(Review.dwScript, SCRIPT_LOCAL_VARIABLE_1, achTemp);
                                Game.psBoard.m_psHud.SetBonusImage("BeatTime");
                                break;
                            case BONUS_TYPE_MOVES:
                                achTemp = JamSystem.TextManager.GetText("DATATEXT_ID_CHALLENGE_BEAT_MOVES", [LevelData_asData[dwLevel].dwParMoves]);
                                Script.SetLocalVariableID(Review.dwScript, SCRIPT_LOCAL_VARIABLE_1, achTemp);
                                Game.psBoard.m_psHud.SetBonusImage("BeatMoves");
                                break;
                            case BONUS_TYPE_SHAPE:
                                Script.SetLocalVariableID(Review.dwScript, SCRIPT_LOCAL_VARIABLE_1, "DATATEXT_ID_CHALLENGE_SHAPE_MADE");
                                Game.psBoard.m_psHud.SetBonusImage("NewBlank");
                                break
                        }
                    } else {
                        GameState.EndState()
                    }
                }
            }
        } else {
            if (Script.GetIsFinished(Review.dwScript)) {
                GameState.EndState()
            }
        }
    };
    Review.SetOpacity = function(fOpacity) {
        if (fOpacity < 0) {
            fOpacity = 0
        }
        if (fOpacity !== 0) {
            Review.psTitle.SetOpacity(fOpacity / 255);
            Review.psCompletion.SetOpacity(fOpacity / 255);
            Review.psChallenge.SetOpacity(fOpacity / 255);
            Review.psTime.SetOpacity(fOpacity / 255);
            Review.psMoves.SetOpacity(fOpacity / 255);
            Review.psTotal.SetOpacity(fOpacity / 255);
            Review.psCompletionBonus.m_psText.SetOpacity(fOpacity / 255);
            Review.psChallengeBonus.m_psText.SetOpacity(fOpacity / 255);
            Review.psTimeBonus.m_psText.SetOpacity(fOpacity / 255);
            Review.psMovesBonus.m_psText.SetOpacity(fOpacity / 255);
            Review.psTotalScore.m_psText.SetOpacity(fOpacity / 255);
            Review.psCommentGlow.SetOpacity(fOpacity / 255);
            Review.psComment.SetOpacity(fOpacity / 255);
            Review.psContinue.SetOpacity(fOpacity / 255);
            if (Review.fLastOpacity === 0) {
                GadgetTree.GetLayer(LAYERS_HUD).AddChild(Review.psTitle);
                GadgetTree.GetLayer(LAYERS_HUD).AddChild(Review.psCompletion);
                GadgetTree.GetLayer(LAYERS_HUD).AddChild(Review.psChallenge);
                GadgetTree.GetLayer(LAYERS_HUD).AddChild(Review.psTime);
                GadgetTree.GetLayer(LAYERS_HUD).AddChild(Review.psMoves);
                GadgetTree.GetLayer(LAYERS_HUD).AddChild(Review.psTotal);
                GadgetTree.GetLayer(LAYERS_HUD).AddChild(Review.psCompletionBonus.m_psText);
                GadgetTree.GetLayer(LAYERS_HUD).AddChild(Review.psChallengeBonus.m_psText);
                GadgetTree.GetLayer(LAYERS_HUD).AddChild(Review.psTimeBonus.m_psText);
                GadgetTree.GetLayer(LAYERS_HUD).AddChild(Review.psMovesBonus.m_psText);
                GadgetTree.GetLayer(LAYERS_HUD).AddChild(Review.psTotalScore.m_psText);
                GadgetTree.GetLayer(LAYERS_HUD).AddChild(Review.psCommentGlow);
                GadgetTree.GetLayer(LAYERS_HUD).AddChild(Review.psComment);
                GadgetTree.GetLayer(LAYERS_HUD).AddChild(Review.psContinue)
            }
        } else {
            if (Review.fLastOpacity !== 0) {
                Review.psTitle.RemoveFromParent();
                Review.psCompletion.RemoveFromParent();
                Review.psChallenge.RemoveFromParent();
                Review.psTime.RemoveFromParent();
                Review.psMoves.RemoveFromParent();
                Review.psTotal.RemoveFromParent();
                Review.psCompletionBonus.m_psText.RemoveFromParent();
                Review.psChallengeBonus.m_psText.RemoveFromParent();
                Review.psTimeBonus.m_psText.RemoveFromParent();
                Review.psMovesBonus.m_psText.RemoveFromParent();
                Review.psTotalScore.m_psText.RemoveFromParent();
                Review.psComment.RemoveFromParent();
                Review.psCommentGlow.RemoveFromParent();
                Review.psContinue.RemoveFromParent()
            }
        }
        Review.fLastOpacity = fOpacity
    };
    Review.IsShowChallenge = function() {
        if (Review.bChallengeAvailable && !Review.bChallengeDone && Review.dwOldScore === 0) {
            return true
        }
        return false
    };

    function Touch() {}
    Touch.psAreaList = 0;
    Touch.dwLastTouch = 0;
    Touch.psLastTouch = 0;
    Touch.Init = function() {
        Touch.psAreaList = [];
        Touch.dwLastTouch = -1;
        Touch.psLastTouch = null
    };
    Touch.Add = function(pasAreas) {
        Touch.psAreaList[Touch.psAreaList.length] = pasAreas
    };
    Touch.Remove = function(pasAreas) {
        var Index = Touch.psAreaList.indexOf(pasAreas);
        if (Index !== -1) {
            Touch.psAreaList.splice(Index, 1)
        }
    };
    Touch.ShutDown = function() {};
    Touch.Test = function(Button) {
        var psTouch = null;
        var i;
        if (Button) {
            var x = JamSystem.InputManager.GetMouseX() * MouseScaler;
            var y = JamSystem.InputManager.GetMouseY() * MouseScaler;
            var Found = false;
            for (i = Touch.psAreaList.length - 1; i >= 0; i -= 1) {
                var psArea = Touch.psAreaList[i];
                if (x >= psArea.x && x < psArea.x2 && y >= psArea.y && y < psArea.y2) {
                    if (Touch.psLastTouch === null) {
                        psTouch = psArea;
                        Touch.psLastTouch = psTouch;
                        Found = true
                    }
                    break
                }
            }
            if (Found === false) {
                psTouch = -1
            }
        } else {
            Touch.psLastTouch = null
        }
        return psTouch
    };
    Touch.Clear = function() {
        Touch.dwLastTouch = -1;
        Touch.psLastTouch = null
    };
    TurbulenzEngine.onload = function onloadFn() {
        var application = Application.create();
        TurbulenzEngine.onunload = function onUnloadFn() {
            application.shutdown()
        };
        application.init()
    };
    window.TurbulenzEngine = TurbulenzEngine
})();